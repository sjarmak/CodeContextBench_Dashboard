```csharp
// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="module_61.cs"
//            project="PulseOps Warehouse — Serverless Productivity Intelligence Fabric">
//   © 2023–2024 Contoso Corporation. All rights reserved.
// </copyright>
// <summary>
//   KPI transformation strategies & engine (Strategy-Pattern + Parallel_Processing).
//   This module is loaded by multiple Lambda functions to transform raw event
//   streams into higher-level productivity KPIs.
// </summary>
// ---------------------------------------------------------------------------------------------------------------------

#nullable enable
#pragma warning disable CA1031 // Do not catch general exception types

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Amazon.SQS;
using Amazon.SQS.Model;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region Domain contracts

    /// <summary>
    /// Raw event emitted by upstream ingestion Lambdas.
    /// </summary>
    public sealed record RawEvent(
        string EventId,
        string Source,
        DateTimeOffset Timestamp,
        IReadOnlyDictionary<string, JsonElement> Payload);

    /// <summary>
    /// Canonical productivity KPI record.
    /// </summary>
    public sealed record KpiRecord(
        string KpiName,
        DateTimeOffset CalculatedAt,
        double? NumericValue,
        IReadOnlyDictionary<string, string>? Dimensions,
        string? AdditionalContext);

    /// <summary>
    /// Contract for a KPI transformation strategy.
    /// </summary>
    public interface IKpiTransformationStrategy
    {
        /// <summary>Machine-readable strategy identifier.</summary>
        string Name { get; }

        /// <summary>
        /// Transforms a stream of raw events into KPI records.
        /// </summary>
        /// <param name="input">Asynchronous sequence of raw events.</param>
        /// <param name="token">Cancellation token.</param>
        /// <returns>Sequence of transformed KPI records.</returns>
        IAsyncEnumerable<KpiRecord> TransformAsync(
            IAsyncEnumerable<RawEvent> input,
            CancellationToken token = default);
    }

    #endregion

    #region Concrete strategies

    /// <summary>
    /// Calculates Focus-Time Ratio KPI based on calendar and IDE activity events.
    /// </summary>
    public sealed class FocusTimeRatioStrategy : IKpiTransformationStrategy
    {
        private readonly ILogger<FocusTimeRatioStrategy> _logger;

        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger) => _logger = logger;

        public string Name => "focus_time_ratio";

        public async IAsyncEnumerable<KpiRecord> TransformAsync(
            IAsyncEnumerable<RawEvent> input,
            [EnumeratorCancellation] CancellationToken token = default)
        {
            const string CalendarSource = "ms_calendar";
            const string IdeSource      = "vscode_activity";

            TimeSpan totalCalendar = TimeSpan.Zero;
            TimeSpan totalCoding   = TimeSpan.Zero;

            await foreach (var evt in input.WithCancellation(token))
            {
                if (evt.Source == CalendarSource &&
                    evt.Payload.TryGetValue("durationMinutes", out var calJson) &&
                    calJson.TryGetInt32(out var calMinutes))
                {
                    totalCalendar += TimeSpan.FromMinutes(calMinutes);
                }

                if (evt.Source == IdeSource &&
                    evt.Payload.TryGetValue("activeSeconds", out var codingJson) &&
                    codingJson.TryGetInt32(out var codingSeconds))
                {
                    totalCoding += TimeSpan.FromSeconds(codingSeconds);
                }
            }

            var ratio = totalCalendar.TotalMinutes + totalCoding.TotalMinutes == 0
                ? (double?)null
                : totalCoding.TotalMinutes / (totalCalendar.TotalMinutes + totalCoding.TotalMinutes);

            _logger.LogInformation("Computed Focus-Time Ratio: {Ratio:P2}", ratio);

            yield return new KpiRecord(
                KpiName: "focus_time_ratio",
                CalculatedAt: DateTimeOffset.UtcNow,
                NumericValue: ratio,
                Dimensions: new Dictionary<string, string>
                {
                    ["unit"] = "percentage"
                },
                AdditionalContext: null);
        }
    }

    /// <summary>
    /// Calculates an estimated Meeting Cost Index KPI.
    /// </summary>
    public sealed class MeetingCostIndexStrategy : IKpiTransformationStrategy
    {
        private readonly ILogger<MeetingCostIndexStrategy> _logger;

        public MeetingCostIndexStrategy(ILogger<MeetingCostIndexStrategy> logger) => _logger = logger;

        public string Name => "meeting_cost_index";

        public async IAsyncEnumerable<KpiRecord> TransformAsync(
            IAsyncEnumerable<RawEvent> input,
            [EnumeratorCancellation] CancellationToken token = default)
        {
            var meetingDurations = new List<int>(); // minutes

            await foreach (var evt in input.WithCancellation(token))
            {
                if (evt.Source != "ms_calendar") continue;

                if (!evt.Payload.TryGetValue("durationMinutes", out var durationJson) ||
                    !durationJson.TryGetInt32(out var duration)) continue;

                meetingDurations.Add(duration);
            }

            if (meetingDurations.Count == 0)
            {
                _logger.LogWarning("No meeting events found while calculating Meeting Cost Index.");
                yield break;
            }

            var avgDuration = meetingDurations.Average();
            var index       = avgDuration switch
            {
                <= 15 => 1,
                <= 30 => 2,
                <= 60 => 3,
                _      => 4
            };

            yield return new KpiRecord(
                KpiName: "meeting_cost_index",
                CalculatedAt: DateTimeOffset.UtcNow,
                NumericValue: index,
                Dimensions: new Dictionary<string, string>
                {
                    ["average_meeting_duration_minutes"] = avgDuration.ToString("F1")
                },
                AdditionalContext: "Lower is better. Thresholds: ≤15=1, ≤30=2, ≤60=3, >60=4");
        }
    }

    #endregion

    #region Strategy registry

    /// <summary>
    /// Thread-safe registry for discovery and retrieval of KPI transformation strategies.
    /// Enables hot-swap of business logic without redeployment (Strategy_Pattern).
    /// </summary>
    public sealed class KpiTransformationRegistry
    {
        private readonly ConcurrentDictionary<string, Func<IServiceProvider, IKpiTransformationStrategy>> _factories =
            new(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// Registers a strategy factory under the given name.
        /// </summary>
        public void Register(
            string name,
            Func<IServiceProvider, IKpiTransformationStrategy> factory)
        {
            if (!_factories.TryAdd(name, factory))
            {
                throw new InvalidOperationException(
                    $"Strategy with name '{name}' was already registered.");
            }
        }

        /// <summary>
        /// Resolves a strategy instance using the supplied <see cref="IServiceProvider"/>.
        /// </summary>
        /// <exception cref="KeyNotFoundException">Thrown if name not found.</exception>
        public IKpiTransformationStrategy Resolve(
            string name,
            IServiceProvider sp)
        {
            if (!_factories.TryGetValue(name, out var factory))
            {
                throw new KeyNotFoundException(
                    $"No transformation strategy registered under the name '{name}'.");
            }

            return factory(sp);
        }
    }

    #endregion

    #region Engine

    /// <summary>
    /// Orchestrates execution of transformation strategies with bounded parallelism.
    /// </summary>
    public sealed class KpiTransformationEngine
    {
        private readonly KpiTransformationRegistry _registry;
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogger<KpiTransformationEngine> _logger;
        private readonly IAmazonSQS? _sqs; // Optional DLQ sink.
        private readonly string? _deadLetterQueueUrl;
        private readonly int _degreeOfParallelism;

        public KpiTransformationEngine(
            KpiTransformationRegistry registry,
            IServiceProvider serviceProvider,
            ILogger<KpiTransformationEngine> logger,
            int degreeOfParallelism = 4,
            IAmazonSQS? sqs = null,
            string? deadLetterQueueUrl = null)
        {
            _registry              = registry;
            _serviceProvider       = serviceProvider;
            _logger                = logger;
            _degreeOfParallelism   = Math.Max(1, degreeOfParallelism);
            _sqs                   = sqs;
            _deadLetterQueueUrl    = deadLetterQueueUrl;
        }

        /// <summary>
        /// Executes the requested transformation strategy.
        /// </summary>
        /// <param name="strategyName">Name of the registered strategy.</param>
        /// <param name="input">Raw event stream.</param>
        /// <param name="token">Cancellation token.</param>
        /// <returns>All KPI records yielded by the strategy.</returns>
        /// <exception cref="KeyNotFoundException"></exception>
        public async Task<IReadOnlyCollection<KpiRecord>> ExecuteAsync(
            string strategyName,
            IAsyncEnumerable<RawEvent> input,
            CancellationToken token = default)
        {
            var strategy = _registry.Resolve(strategyName, _serviceProvider);

            _logger.LogInformation(
                "Executing KPI transformation using strategy '{StrategyName}'.",
                strategyName);

            var outputBag = new ConcurrentBag<KpiRecord>();

            // Because strategies internally may iterate multiple times,
            // we buffer events first (bounded) then process in parallel partitions.
            var buffer = await input.ToListAsync(token).ConfigureAwait(false);

            // Partition input for parallel processing if strategy supports multi-threading.
            var partitions = Partitioner.Create(buffer, EnumerablePartitionerOptions.NoBuffering)
                                        .GetPartitions(_degreeOfParallelism);

            var tasks = partitions.Select(async partition =>
            {
                await using (partition)
                {
                    // Re-hydrate enumerator for each partition.
                    var partitionEvents = Enumerate(partition);

                    try
                    {
                        await foreach (var record in strategy.TransformAsync(
                                           partitionEvents, token)
                                           .WithCancellation(token))
                        {
                            outputBag.Add(record);
                        }
                    }
                    catch (OperationCanceledException) { throw; }
                    catch (Exception ex)
                    {
                        _logger.LogError(
                            ex,
                            "Transformation failed in strategy '{StrategyName}'.",
                            strategyName);

                        // Fire-and-forget DLQ publish.
                        _ = SendToDeadLetterQueueAsync(buffer, ex, token);

                        // Swallow to allow other partitions to continue.
                    }
                }
            }).ToArray();

            await Task.WhenAll(tasks).ConfigureAwait(false);

            return outputBag.ToArray();
        }

        #endregion

        #region Helpers

        private static async IAsyncEnumerable<RawEvent> Enumerate(
            IEnumerator<RawEvent> enumerator,
            [EnumeratorCancellation] CancellationToken token = default)
        {
            while (!token.IsCancellationRequested && enumerator.MoveNext())
            {
                yield return enumerator.Current;
                await Task.Yield(); // Yield to avoid hogging thread in CPU-bound loops.
            }
        }

        private async Task SendToDeadLetterQueueAsync(
            IEnumerable<RawEvent> events,
            Exception ex,
            CancellationToken token)
        {
            if (_sqs is null || string.IsNullOrWhiteSpace(_deadLetterQueueUrl)) return;

            try
            {
                var payload = new
                {
                    Error   = ex.Message,
                    Stack   = ex.StackTrace,
                    Events  = events.Take(10) // Limit to avoid payload bloat.
                };

                var request = new SendMessageRequest
                {
                    QueueUrl    = _deadLetterQueueUrl,
                    MessageBody = JsonSerializer.Serialize(payload)
                };

                await _sqs.SendMessageAsync(request, token).ConfigureAwait(false);

                _logger.LogWarning(
                    "Published failed batch to DLQ '{QueueUrl}'.",
                    _deadLetterQueueUrl);
            }
            catch (Exception sqsEx)
            {
                _logger.LogCritical(
                    sqsEx,
                    "Failed to publish to DLQ. Message loss may have occurred.");
            }
        }

        #endregion
    }

    #endregion
}

#pragma warning restore CA1031
```