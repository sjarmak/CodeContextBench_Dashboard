```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace PulseOps.Warehouse.Transformations
{
    #region Domain Models

    /// <summary>
    /// Represents a raw payload pulled from the Data-Lake ingestion layer.
    /// </summary>
    public sealed record RawRecord(
        Guid Id,
        string SourceSystem,
        DateTimeOffset IngestedAt,
        string JsonPayload);

    /// <summary>
    /// Represents a successfully transformed, canonical record.
    /// </summary>
    public sealed record TransformedRecord(
        Guid Id,
        string CanonicalType,
        DateTimeOffset ProcessedAt,
        IReadOnlyDictionary<string, object?> Data);

    /// <summary>
    /// Notification event published by <see cref="TransformationEngine"/> to its observers.
    /// </summary>
    public sealed class TransformationEvent
    {
        public TransformationEvent(RawRecord raw, TransformedRecord? transformed, Exception? exception)
        {
            Raw = raw;
            Transformed = transformed;
            Exception = exception;
            Timestamp = DateTimeOffset.UtcNow;
        }

        public RawRecord Raw { get; }
        public TransformedRecord? Transformed { get; }
        public Exception? Exception { get; }
        public DateTimeOffset Timestamp { get; }
        public bool Success => Exception is null;
    }

    #endregion

    #region Strategy Interfaces & Attribute

    /// <summary>
    /// Marker attribute used for auto-registration of transformation strategies.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public sealed class TransformationStrategyAttribute : Attribute
    {
        public TransformationStrategyAttribute(string sourceSystem) =>
            SourceSystem = sourceSystem ?? throw new ArgumentNullException(nameof(sourceSystem));

        public string SourceSystem { get; }
    }

    /// <summary>
    /// Defines a pluggable transformation strategy.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>
        /// The <see cref="RawRecord.SourceSystem"/> this strategy handles.
        /// </summary>
        string SourceSystem { get; }

        /// <summary>
        /// Executes the transformation.
        /// </summary>
        Task<TransformedRecord> TransformAsync(RawRecord raw, CancellationToken token = default);
    }

    #endregion

    #region Strategy Implementations

    [TransformationStrategy("calendar")]
    public sealed class CalendarEventStrategy : ITransformationStrategy
    {
        public string SourceSystem => "calendar";

        public Task<TransformedRecord> TransformAsync(RawRecord raw, CancellationToken token = default)
        {
            // Simulated schema: { "subject": "...", "durationMinutes": 45, "participants": [ ... ] }
            var doc = JsonSerializer.Deserialize<Dictionary<string, object?>>(raw.JsonPayload)!;

            var transformed = new TransformedRecord(
                raw.Id,
                CanonicalType: "meeting_activity",
                ProcessedAt: DateTimeOffset.UtcNow,
                Data: doc);

            return Task.FromResult(transformed);
        }
    }

    [TransformationStrategy("ci_cd")]
    public sealed class CiCdLogStrategy : ITransformationStrategy
    {
        public string SourceSystem => "ci_cd";

        public Task<TransformedRecord> TransformAsync(RawRecord raw, CancellationToken token = default)
        {
            // Simulated schema: { "pipelineId": "...", "durationSeconds": 123, "status": "Succeeded" }
            var doc = JsonSerializer.Deserialize<Dictionary<string, object?>>(raw.JsonPayload)!;

            var transformed = new TransformedRecord(
                raw.Id,
                CanonicalType: "deployment_activity",
                ProcessedAt: DateTimeOffset.UtcNow,
                Data: doc);

            return Task.FromResult(transformed);
        }
    }

    #endregion

    #region Observer Implementations

    /// <summary>
    /// Simple observer that aggregates failure counts and writes to structured logs.
    /// </summary>
    public sealed class DataQualityObserver : IObserver<TransformationEvent>, IDisposable
    {
        private int _success;
        private int _failure;

        public void OnCompleted()
        {
            Console.WriteLine($"[DQ] Completed â€” Successes={_success}, Failures={_failure}");
        }

        public void OnError(Exception error)
        {
            Console.WriteLine($"[DQ] Stream aborted: {error}");
        }

        public void OnNext(TransformationEvent evt)
        {
            if (evt.Success)
            {
                Interlocked.Increment(ref _success);
            }
            else
            {
                Interlocked.Increment(ref _failure);
                Console.WriteLine($"[DQ] Transformation failed for record {evt.Raw.Id}: {evt.Exception}");
            }
        }

        public void Dispose()
        {
            // nothing to dispose currently
        }
    }

    #endregion

    #region Transformation Engine

    /// <summary>
    /// Executes transformations using a pluggable strategy model. Implements the <see cref="IObservable{T}"/>
    /// contract so monitoring dashboards or DLQ publishers can subscribe to transformation outcomes.
    /// </summary>
    public sealed class TransformationEngine : IObservable<TransformationEvent>
    {
        private static readonly Lazy<IReadOnlyDictionary<string, ITransformationStrategy>> _strategies
            = new(DiscoverStrategies);

        private readonly ConcurrentBag<IObserver<TransformationEvent>> _observers = new();

        /// <summary>
        /// Transforms all supplied records using the matching registered strategy. 
        /// Results (success or failure) are pushed to the observer set.
        /// </summary>
        /// <param name="records">Batch of raw records to process.</param>
        /// <param name="parallelism">Maximum degree of parallelism.</param>
        /// <param name="token">Cancellation token.</param>
        public async Task ExecuteAsync(
            IEnumerable<RawRecord> records,
            int parallelism = 8,
            CancellationToken token = default)
        {
            ArgumentNullException.ThrowIfNull(records);

            await Parallel.ForEachAsync(records, new ParallelOptions
            {
                CancellationToken = token,
                MaxDegreeOfParallelism = parallelism
            }, async (raw, ct) =>
            {
                try
                {
                    var strategy = ResolveStrategy(raw.SourceSystem);
                    if (strategy is null)
                    {
                        throw new InvalidOperationException(
                            $"No transformation strategy registered for source '{raw.SourceSystem}'.");
                    }

                    var transformed = await strategy.TransformAsync(raw, ct).ConfigureAwait(false);
                    Publish(new TransformationEvent(raw, transformed, exception: null));
                }
                catch (Exception ex) when (IsRecoverable(ex))
                {
                    Publish(new TransformationEvent(raw, transformed: null, exception: ex));
                }
            }).ConfigureAwait(false);

            // signal completion
            foreach (var obs in _observers)
            {
                obs.OnCompleted();
            }
        }

        #region Strategy Registry Helpers

        private static IReadOnlyDictionary<string, ITransformationStrategy> DiscoverStrategies()
        {
            var dict = new Dictionary<string, ITransformationStrategy>(StringComparer.OrdinalIgnoreCase);
            var strategies = AppDomain.CurrentDomain
                                      .GetAssemblies()
                                      .SelectMany(a =>
                                      {
                                          try { return a.DefinedTypes; }
                                          catch (ReflectionTypeLoadException e) { return e.Types.Where(t => t != null)!; }
                                      })
                                      .Where(t => t.IsClass &&
                                                  !t.IsAbstract &&
                                                  typeof(ITransformationStrategy).IsAssignableFrom(t));

            foreach (var type in strategies)
            {
                var attr = type.GetCustomAttribute<TransformationStrategyAttribute>();
                if (attr is null) continue;

                if (Activator.CreateInstance(type) is ITransformationStrategy instance)
                {
                    dict[attr.SourceSystem] = instance; // last in wins
                }
            }

            return dict;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ITransformationStrategy? ResolveStrategy(string sourceSystem)
        {
            _strategies.Value.TryGetValue(sourceSystem, out var strat);
            return strat;
        }

        private static bool IsRecoverable(Exception ex)
        {
            // Pretend we have some transient determination logic.
            return true;
        }

        #endregion

        #region Observer Pattern

        public IDisposable Subscribe(IObserver<TransformationEvent> observer)
        {
            if (observer is null) throw new ArgumentNullException(nameof(observer));
            _observers.Add(observer);

            return new Unsubscriber(_observers, observer);
        }

        private void Publish(TransformationEvent evt)
        {
            foreach (var obs in _observers)
            {
                try
                {
                    obs.OnNext(evt);
                }
                catch
                {
                    // Never let a subscriber fail the pipeline.
                }
            }
        }

        private sealed class Unsubscriber : IDisposable
        {
            private readonly ConcurrentBag<IObserver<TransformationEvent>> _observers;
            private readonly IObserver<TransformationEvent> _observer;
            private bool _disposed;

            public Unsubscriber(ConcurrentBag<IObserver<TransformationEvent>> observers, IObserver<TransformationEvent> observer)
            {
                _observers = observers;
                _observer = observer;
            }

            public void Dispose()
            {
                if (_disposed) return;
                _disposed = true;

                _observers.TryTake(out _);
            }
        }

        #endregion
    }

    #endregion
}
```