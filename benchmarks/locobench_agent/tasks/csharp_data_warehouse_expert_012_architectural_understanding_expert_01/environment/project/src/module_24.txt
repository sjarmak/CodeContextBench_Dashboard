```csharp
// -----------------------------------------------------------------------------
//  File:        src/module_24.txt   (logical name: MeetingCostIndexTransformer)
//  Project:     PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//  Language:    C# 10
//  Description: Core transformation strategy that converts raw calendar events
//               into Meeting-Cost Index (MCI) KPI records.
// -----------------------------------------------------------------------------
//  Copyright ©
//  Licensed under the Apache 2.0 License.
// -----------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Amazon.Lambda.Core;
using Amazon.Lambda.KinesisEvents;
using Microsoft.Extensions.Logging;
using PulseOps.Warehouse.Common;
using PulseOps.Warehouse.Domain.Calendar;
using PulseOps.Warehouse.Domain.Exceptions;
using PulseOps.Warehouse.Domain.Kpis;
using PulseOps.Warehouse.Transformations.Contracts;

// Lambda serialization directive — required by AWS Lambda runtime.
[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace PulseOps.Warehouse.Transformations.MeetingCost
{
    /// <summary>
    /// Lambda entry-point responsible for computing Meeting-Cost Index (MCI) KPI
    /// from calendar events streamed via Kinesis.
    /// </summary>
    public sealed class MeetingCostIndexTransformerLambda
    {
        private static readonly ILogger<MeetingCostIndexTransformerLambda> _logger =
            LambdaLoggerFactory.CreateLogger<MeetingCostIndexTransformerLambda>();

        private readonly ITransformationStrategy<IEnumerable<CalendarEvent>, IEnumerable<MeetingCostIndexRecord>> _strategy;

        public MeetingCostIndexTransformerLambda()
        {
            _strategy = new MeetingCostIndexTransformer(_logger);
        }

        /// <summary>
        /// AWS Lambda handler. Triggered for a batch of Kinesis records.
        /// </summary>
        /// <param name="kinesisEvent">Kinesis event containing raw calendar events.</param>
        /// <param name="context">AWS Lambda execution context.</param>
        /// <returns>Total number of KPI records emitted.</returns>
        public async Task<int> HandlerAsync(KinesisEvent kinesisEvent, ILambdaContext context)
        {
            try
            {
                _logger.LogInformation("Received {RecordCount} Kinesis records (RequestId={RequestId}).",
                                        kinesisEvent.Records.Count, context.AwsRequestId);

                var calendarEvents = FromKinesisEvent(kinesisEvent);
                var output = await _strategy.ExecuteAsync(calendarEvents, context.CancellationToken);
                
                // In real code we'd push KPI downstream (Kinesis, S3, Glue, etc.).
                // For demo we simply return count.
                int emitted = output.Count;
                _logger.LogInformation("Successfully generated {Emitted} MCI records.", emitted);
                return emitted;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "MeetingCostIndexTransformer failed. Batching to DLQ.");
                // The Lambda will automatically retry/invoke DLQ based on configuration.
                throw;
            }
        }

        /// <summary>
        /// Deserialize Kinesis payloads into <see cref="CalendarEvent"/> objects.
        /// </summary>
        private static IReadOnlyCollection<CalendarEvent> FromKinesisEvent(KinesisEvent kinesisEvent)
        {
            var events = new List<CalendarEvent>(kinesisEvent.Records.Count);
            foreach (var record in kinesisEvent.Records)
            {
                try
                {
                    var json = record.Kinesis.Data.Span;             // Already Base64-decoded.
                    var evt  = JsonSerializer.Deserialize<CalendarEvent>(json);
                    if (evt is null)
                        throw new JsonException("Deserialization yielded null CalendarEvent.");

                    events.Add(evt);
                }
                catch (Exception ex)
                {
                    // Swallow single-event errors but continue processing others.
                    _logger.LogWarning(ex, "Dropping malformed calendar event (SequenceNumber={Seq}).",
                                       record.Kinesis.SequenceNumber);
                }
            }
            return events;
        }
    }

    /// <summary>
    /// Transformation strategy that computes Meeting-Cost Index KPI per meeting.
    /// </summary>
    internal sealed class MeetingCostIndexTransformer :
        ITransformationStrategy<IEnumerable<CalendarEvent>, IEnumerable<MeetingCostIndexRecord>>
    {
        private const string CurrencyCode = "USD";
        private readonly ILogger _logger;

        public MeetingCostIndexTransformer(ILogger logger) => _logger = logger;

        public async Task<IEnumerable<MeetingCostIndexRecord>> ExecuteAsync(
            IEnumerable<CalendarEvent> input, CancellationToken ct = default)
        {
            if (input is null) throw new ArgumentNullException(nameof(input));

            // Use thread-safe collection for parallel aggregation.
            var output = new ConcurrentBag<MeetingCostIndexRecord>();

            // Process events in parallel; suitable for high-volume Kinesis shards.
            await Parallel.ForEachAsync(input, ct, async (calendarEvent, token) =>
            {
                var record = await TransformAsync(calendarEvent, token);
                if (record is not null)
                {
                    output.Add(record);
                }
            });

            return output.ToImmutableArray();
        }

        /// <summary>
        /// Transform a single calendar event into its KPI record.
        /// </summary>
        private async ValueTask<MeetingCostIndexRecord?> TransformAsync(
            CalendarEvent calendarEvent, CancellationToken ct)
        {
            try
            {
                // Simulate async lookup (e.g., from DynamoDB People table).
                var profiles = await ResolveParticipantProfilesAsync(calendarEvent.ParticipantEmails, ct);

                if (!profiles.Any())
                {
                    _logger.LogWarning("No employee profiles resolved for meeting {Id}. Skipping.", calendarEvent.Id);
                    return null;
                }

                decimal totalHourlyRate = profiles.Sum(p => p.HourlyRate);
                var meetingDurationHours = (decimal)calendarEvent.Duration.TotalHours;

                decimal cost = Math.Round(meetingDurationHours * totalHourlyRate, 2, MidpointRounding.AwayFromZero);

                var record = new MeetingCostIndexRecord(
                    id: Guid.NewGuid().ToString("N", CultureInfo.InvariantCulture),
                    sourceMeetingId: calendarEvent.Id,
                    timestampUtc: calendarEvent.StartTimeUtc,
                    meetingTitle: calendarEvent.Title,
                    participantCount: profiles.Count,
                    meetingDurationHours: meetingDurationHours,
                    cost: cost,
                    currencyCode: CurrencyCode);

                _logger.LogDebug("Computed MCI={Cost} for meeting {MeetingId}.", cost, calendarEvent.Id);
                return record;
            }
            catch (DataValidationException dvx)
            {
                _logger.LogWarning(dvx, "Validation failed for meeting {Id}. Skipping.", calendarEvent.Id);
                return null;
            }
            catch (Exception ex)
            {
                // Bubble up to trigger overall batch failure -> DLQ.
                _logger.LogError(ex, "Fatal error while processing meeting {Id}.", calendarEvent.Id);
                throw;
            }
        }

        /// <summary>
        /// Fake async profile resolution. In production this would issue a batched
        /// query against a People micro-service or Glue table.
        /// </summary>
        private static Task<IReadOnlyCollection<EmployeeProfile>> ResolveParticipantProfilesAsync(
            IReadOnlyCollection<string> participantEmails, CancellationToken ct)
        {
            // Demo stub uses deterministic hourly rate based on hash code.
            var profiles = participantEmails
                .Select(email => new EmployeeProfile(
                    email: email,
                    hourlyRate: 20 + Math.Abs(email.GetHashCode()) % 100)) // $20–$119/h
                .ToImmutableArray();

            return Task.FromResult<IReadOnlyCollection<EmployeeProfile>>(profiles);
        }
    }

    #region Domain – Calendar / People / KPI

    /// <summary>
    /// Calendar event domain model.
    /// </summary>
    public sealed record CalendarEvent(
        string Id,
        string Title,
        DateTime StartTimeUtc,
        TimeSpan Duration,
        IReadOnlyCollection<string> ParticipantEmails);

    /// <summary>
    /// Employee profile (subset).
    /// </summary>
    public sealed record EmployeeProfile(
        string Email,
        decimal HourlyRate);

    /// <summary>
    /// Meeting-Cost Index KPI record.
    /// </summary>
    public sealed record MeetingCostIndexRecord(
        string Id,
        string SourceMeetingId,
        DateTime TimestampUtc,
        string MeetingTitle,
        int ParticipantCount,
        decimal MeetingDurationHours,
        decimal Cost,
        string CurrencyCode);

    #endregion

    #region Common – Exceptions / Logging / Strategy Contract

    /// <summary>
    /// Exception thrown when domain validation fails.
    /// </summary>
    public sealed class DataValidationException : Exception
    {
        public DataValidationException(string message) : base(message) { }
        public DataValidationException(string message, Exception inner) : base(message, inner) { }
    }

    /// <summary>
    /// Transforms input of type <typeparamref name="TInput"/> into
    /// <typeparamref name="TOutput"/>.
    /// </summary>
    public interface ITransformationStrategy<in TInput, TOutput>
    {
        Task<TOutput> ExecuteAsync(TInput input, CancellationToken ct = default);
    }

    /// <summary>
    /// Simple Lambda-compatible logger factory backed by <see cref="ILambdaLogger"/>.
    /// </summary>
    internal static class LambdaLoggerFactory
    {
        public static ILogger<T> CreateLogger<T>() => new LambdaLoggerAdapter<T>(LambdaLogger.Log);

        private sealed class LambdaLoggerAdapter<T> : ILogger<T>, IDisposable
        {
            private readonly Action<string> _sink;

            public LambdaLoggerAdapter(Action<string> sink) => _sink = sink;
            public void Dispose() { /* nothing to dispose */ }

            public IDisposable? BeginScope<TState>(TState state) => this;

            public bool IsEnabled(LogLevel logLevel) => true;

            public void Log<TState>(LogLevel logLevel, EventId eventId,
                TState state, Exception? exception, Func<TState, Exception?, string> formatter)
            {
                var level = logLevel.ToString().ToUpperInvariant();
                _sink?.Invoke($"[{level}] {formatter(state, exception)} {exception}");
            }
        }
    }

    #endregion
}
```