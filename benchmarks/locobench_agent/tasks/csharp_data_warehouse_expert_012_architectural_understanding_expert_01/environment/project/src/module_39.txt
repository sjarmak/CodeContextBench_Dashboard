```csharp
// -----------------------------------------------------------------------------
//  File:        module_39.txt
//  Project:     PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//  Description: Transformation-layer infrastructure leveraging the Strategy &
//               Observer patterns to dynamically resolve, execute, and monitor
//               KPI-calculation strategies for heterogeneous raw event streams.
// -----------------------------------------------------------------------------
//
//  Copyright © 2024 PulseOps
//  Licensed under the Apache License, Version 2.0
// -----------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Polly;
using Polly.Retry;

namespace PulseOps.Warehouse.Transformations
{
    #region Public Contracts ───────────────────────────────────────────────────

    /// <summary>
    /// Canonical raw event representation flowing in the transformation layer.
    /// </summary>
    public sealed record RawEvent(
        string EventType,
        IReadOnlyDictionary<string, object> Payload,
        DateTimeOffset ReceivedAt,
        string SourceSystem);

    /// <summary>
    /// Resulting KPI/metric emitted by a transformation strategy.
    /// </summary>
    public sealed record KpiRecord(
        string Name,
        double Value,
        DateTimeOffset Timestamp,
        IReadOnlyDictionary<string, string> Dimensions);

    /// <summary>
    /// Contract for a transformation strategy operating on a single <see cref="RawEvent"/>.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>Unique identifier for strategy (duplicated from attribute for fast access).</summary>
        string StrategyKey { get; }

        /// <summary>
        /// Executes domain-specific transformation logic.
        /// </summary>
        /// <param name="raw">Incoming raw event.</param>
        /// <param name="token">Cancellation token.</param>
        /// <returns>Zero or more KPI records computed from <paramref name="raw"/>.</returns>
        Task<IReadOnlyCollection<KpiRecord>> TransformAsync(RawEvent raw, CancellationToken token);
    }

    #endregion

    #region Strategy Registration & Resolution ────────────────────────────────

    /// <summary>
    /// Attribute used by reflection-based discovery of transformation strategies.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited = false)]
    public sealed class StrategyAttribute : Attribute
    {
        public StrategyAttribute(string key) => Key = key ?? throw new ArgumentNullException(nameof(key));

        public string Key { get; }
    }

    /// <summary>
    /// Thread-safe registry that caches concrete strategy instances keyed by event type.
    /// </summary>
    public sealed class TransformationStrategyRegistry
    {
        private readonly ILogger<TransformationStrategyRegistry> _logger;
        private readonly ConcurrentDictionary<string, ITransformationStrategy> _cache = new(StringComparer.OrdinalIgnoreCase);

        public TransformationStrategyRegistry(ILogger<TransformationStrategyRegistry> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            LoadFromAssemblies(AppDomain.CurrentDomain.GetAssemblies());
        }

        /// <summary>
        /// Attempts to resolve a strategy for <paramref name="eventType"/>.
        /// </summary>
        /// <exception cref="KeyNotFoundException">Thrown when no strategy exists.</exception>
        public ITransformationStrategy GetOrThrow(string eventType)
        {
            if (eventType is null) throw new ArgumentNullException(nameof(eventType));

            if (_cache.TryGetValue(eventType, out var strategy)) return strategy;

            throw new KeyNotFoundException($"No transformation strategy registered for event type '{eventType}'.");
        }

        /// <summary>
        /// Registers an already-constructed strategy instance (permits runtime overrides).
        /// </summary>
        public void Register(ITransformationStrategy strategy)
        {
            if (strategy is null) throw new ArgumentNullException(nameof(strategy));

            if (!_cache.TryAdd(strategy.StrategyKey, strategy))
            {
                _logger.LogWarning("Strategy {Key} already registered – overriding instance.", strategy.StrategyKey);
                _cache[strategy.StrategyKey] = strategy;
            }
        }

        private void LoadFromAssemblies(IEnumerable<Assembly> assemblies)
        {
            foreach (Assembly asm in assemblies.Where(a => !a.IsDynamic))
            {
                foreach (var type in asm.GetTypes())
                {
                    if (type.IsAbstract || type.IsInterface) continue;
                    if (!typeof(ITransformationStrategy).IsAssignableFrom(type)) continue;

                    var attr = type.GetCustomAttribute<StrategyAttribute>();
                    if (attr is null) continue; // skip unannotated types

                    try
                    {
                        // Prefer parameterless ctor – strategies are stateless by design.
                        var instance = (ITransformationStrategy)Activator.CreateInstance(type)!;
                        Register(instance);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Failed to instantiate strategy {Type}.", type.FullName);
                    }
                }
            }

            _logger.LogInformation("Loaded {Count} transformation strategies.", _cache.Count);
        }
    }

    #endregion

    #region Transformation Engine ─────────────────────────────────────────────

    /// <summary>
    /// High-level orchestrator that fans-out raw events to the relevant strategy,
    /// executes them in parallel with retry semantics, and fans-in KPI records.
    /// </summary>
    public sealed class TransformationEngine
    {
        private static readonly AsyncRetryPolicy RetryPolicy = Policy
            .Handle<Exception>(ex => ex is not OperationCanceledException)
            .WaitAndRetryAsync(
                retryCount: 3,
                sleepDurationProvider: attempt => TimeSpan.FromMilliseconds(100 * Math.Pow(2, attempt)), // 100ms, 200ms, 400ms
                onRetry: (ex, ts, attempt, ctx) =>
                {
                    if (ctx.TryGetValue("Logger", out var obj) && obj is ILogger logger)
                    {
                        logger.LogWarning(ex,
                            "Transient failure executing strategy (attempt {Attempt}/3). Retrying after {Delay}ms…",
                            attempt, ts.TotalMilliseconds);
                    }
                });

        private readonly TransformationStrategyRegistry _registry;
        private readonly ILogger<TransformationEngine> _logger;

        public TransformationEngine(
            TransformationStrategyRegistry registry,
            ILogger<TransformationEngine> logger)
        {
            _registry = registry ?? throw new ArgumentNullException(nameof(registry));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Orchestrates transformation of a batch of raw events.
        /// </summary>
        public async Task<IReadOnlyCollection<KpiRecord>> ExecuteBatchAsync(
            IReadOnlyCollection<RawEvent> events,
            CancellationToken token = default)
        {
            if (events is null) throw new ArgumentNullException(nameof(events));

            var kpiBag = new ConcurrentBag<KpiRecord>();
            var stopwatch = Stopwatch.StartNew();

            // Run transformations concurrently but keep within sane parallelism to protect lambda memory
            await Parallel.ForEachAsync(events, new ParallelOptions
            {
                CancellationToken = token,
                MaxDegreeOfParallelism = Environment.ProcessorCount // auto-scale based on memory
            }, async (ev, ct) =>
            {
                // Strategy resolution (fast dictionary lookup)
                ITransformationStrategy strategy;
                try
                {
                    strategy = _registry.GetOrThrow(ev.EventType);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Unable to find strategy for event type '{EventType}'. Dropping event.", ev.EventType);
                    return; // swallow – DLQ routing handled upstream
                }

                // Execute with retry & jitter
                var context = new Context().With("Logger", _logger);
                var results = await RetryPolicy.ExecuteAsync(
                    (_, _) => strategy.TransformAsync(ev, ct),
                    context, ct);

                foreach (var kpi in results)
                {
                    kpiBag.Add(kpi);
                }
            });

            stopwatch.Stop();
            _logger.LogInformation(
                "Processed {EventCount} event(s) into {KpiCount} KPI record(s) in {ElapsedMs} ms.",
                events.Count, kpiBag.Count, stopwatch.ElapsedMilliseconds);

            return kpiBag.ToArray();
        }
    }

    #endregion

    #region Sample Strategies ─────────────────────────────────────────────────

    /// <summary>
    /// Calculates focus-time ratio from calendar events.
    /// EventType = "calendar_event"
    ///
    /// Expects payload form:
    /// {
    ///     "start": "2024-04-01T09:00:00Z",
    ///     "end":   "2024-04-01T10:00:00Z",
    ///     "isRecurring": false,
    ///     "organizer": "jane@example.com",
    ///     "attendees": 9
    /// }
    /// </summary>
    [Strategy("calendar_event")]
    public sealed class FocusTimeRatioStrategy : ITransformationStrategy
    {
        private const string KpiName = "focus_time_ratio";

        public string StrategyKey => "calendar_event";

        public Task<IReadOnlyCollection<KpiRecord>> TransformAsync(RawEvent raw, CancellationToken token)
        {
            // Basic validation
            if (!raw.Payload.TryGetValue("start", out var startObj) ||
                !raw.Payload.TryGetValue("end", out var endObj))
            {
                throw new InvalidOperationException("Invalid calendar event payload – missing start/end.");
            }

            var start = DateTimeOffset.Parse(startObj.ToString()!);
            var end   = DateTimeOffset.Parse(endObj.ToString()!);
            var durationMinutes = (end - start).TotalMinutes;

            // Example heuristic: meetings with <= 2 attendees are considered 'focus'
            var attendees = raw.Payload.TryGetValue("attendees", out var attendeeObj)
                ? Convert.ToInt32(attendeeObj)
                : 0;
            var isFocusTime = attendees <= 2;

            var value = isFocusTime ? durationMinutes : 0; // minutes of focus time
            var kpi = new KpiRecord(
                Name: KpiName,
                Value: value,
                Timestamp: raw.ReceivedAt,
                Dimensions: new Dictionary<string, string>
                {
                    ["source"] = raw.SourceSystem,
                    ["isRecurring"] = raw.Payload.TryGetValue("isRecurring", out var r) && (bool)r
                        ? "true"
                        : "false"
                });

            return Task.FromResult<IReadOnlyCollection<KpiRecord>>(new[] { kpi });
        }
    }

    /// <summary>
    /// Calculates deployment lead-time from CI/CD pipeline events.
    /// EventType = "deployment_pipeline"
    /// </summary>
    [Strategy("deployment_pipeline")]
    public sealed class DeploymentLeadTimeStrategy : ITransformationStrategy
    {
        private const string KpiName = "deployment_lead_time_hours";

        public string StrategyKey => "deployment_pipeline";

        public Task<IReadOnlyCollection<KpiRecord>> TransformAsync(RawEvent raw, CancellationToken token)
        {
            if (!raw.Payload.TryGetValue("commit_timestamp", out var commitTsObj) ||
                !raw.Payload.TryGetValue("production_timestamp", out var prodTsObj))
            {
                throw new InvalidOperationException("Invalid deployment payload – missing timestamps.");
            }

            var commitTs = DateTimeOffset.Parse(commitTsObj.ToString()!);
            var prodTs   = DateTimeOffset.Parse(prodTsObj.ToString()!);
            var leadTimeHours = (prodTs - commitTs).TotalHours;

            var kpi = new KpiRecord(
                Name: KpiName,
                Value: leadTimeHours,
                Timestamp: prodTs,
                Dimensions: new Dictionary<string, string>
                {
                    ["source"] = raw.SourceSystem,
                    ["repository"] = raw.Payload.TryGetValue("repo", out var repoObj)
                        ? repoObj.ToString()!
                        : "unknown"
                });

            return Task.FromResult<IReadOnlyCollection<KpiRecord>>(new[] { kpi });
        }
    }

    #endregion

    #region Debug Harness (excluded from production build) ────────────────────

#if DEBUG
    internal static class Program
    {
        private static async Task Main()
        {
            using var loggerFactory = LoggerFactory.Create(b => b.AddSimpleConsole(opt =>
            {
                opt.SingleLine = true;
                opt.TimestampFormat = "HH:mm:ss ";
            }).SetMinimumLevel(LogLevel.Information));

            var logger = loggerFactory.CreateLogger<Program>();
            var registry = new TransformationStrategyRegistry(loggerFactory.CreateLogger<TransformationStrategyRegistry>());
            var engine = new TransformationEngine(registry, loggerFactory.CreateLogger<TransformationEngine>());

            // Simulate a mixed batch
            var rawBatch = new[]
            {
                new RawEvent(
                    EventType: "calendar_event",
                    Payload: JsonSerializer.Deserialize<Dictionary<string, object>>(@"{
                        ""start"":""2024-04-01T09:00:00Z"",
                        ""end"":""2024-04-01T10:00:00Z"",
                        ""isRecurring"":false,
                        ""attendees"":2
                    }")!,
                    ReceivedAt: DateTimeOffset.UtcNow,
                    SourceSystem: "gcal"),

                new RawEvent(
                    EventType: "deployment_pipeline",
                    Payload: JsonSerializer.Deserialize<Dictionary<string, object>>(@"{
                        ""commit_timestamp"":""2024-04-01T07:15:10Z"",
                        ""production_timestamp"":""2024-04-03T12:47:33Z"",
                        ""repo"":""pulseops/warehouse""
                    }")!,
                    ReceivedAt: DateTimeOffset.UtcNow,
                    SourceSystem: "github-actions")
            };

            var kpis = await engine.ExecuteBatchAsync(rawBatch);
            foreach (var kpi in kpis)
            {
                logger.LogInformation("KPI => {Name} = {Value} [{Dimensions}]",
                    kpi.Name, kpi.Value, string.Join(", ", kpi.Dimensions.Select(d => $"{d.Key}:{d.Value}")));
            }
        }
    }
#endif

    #endregion
}
```