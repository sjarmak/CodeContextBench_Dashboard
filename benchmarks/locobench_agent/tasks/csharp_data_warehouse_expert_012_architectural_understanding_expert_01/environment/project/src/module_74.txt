```csharp
// ---------------------------------------------------------------------------------------------------------------------
// <copyright>
//     PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//     © 2024 PulseOps Engineering.  All rights reserved.
// </copyright>
// <author>AI Auto-Generated (module_74)</author>
// <summary>
//     Infrastructure for run-time discovery, registration and hot-swapping of data
//     transformation strategies (Strategy Pattern) used by the ETL pipeline.
// </summary>
// ---------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Amazon.Lambda.Core;
using Microsoft.Extensions.Logging;

// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable UnusedType.Global
// ReSharper disable UnusedMember.Global

[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace PulseOps.Warehouse.Transformation
{
    #region Contracts

    /// <summary>
    ///     Raw, unshaped record emitted by upstream ingestion Lambdas.
    ///     Immutable value-object.
    /// </summary>
    public readonly record struct RawRecord(
        string SourceSystemId,
        string Payload,                    // JSON or CSV line, etc.
        DateTimeOffset IngestionTimestamp);

    /// <summary>
    ///     Canonical, strongly-typed record consumed by downstream pipeline stages.
    ///     Immutable value-object.
    /// </summary>
    public readonly record struct TransformedRecord(
        Guid Id,
        string SourceSystemId,
        JsonElement CanonicalPayload,
        DateTimeOffset TransformationTimestamp);

    /// <summary>
    ///     Strategy contract for transforming an arbitrary <see cref="RawRecord" /> into
    ///     a <see cref="TransformedRecord" />.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>
        ///     Uniquely identifies the external system this strategy knows how to transform.
        /// </summary>
        string SourceSystemId { get; }

        /// <summary>
        ///     Returns <c>true</c> if this strategy can transform the supplied record.
        ///     Implementations may inspect <paramref name="record" /> contents to decide.
        /// </summary>
        bool CanHandle(in RawRecord record);

        /// <summary>
        ///     Performs the conversion asynchronously.
        /// </summary>
        Task<TransformedRecord> TransformAsync(
            RawRecord record,
            CancellationToken ct = default);
    }

    /// <summary>
    ///     Attribute used to flag types as <see cref="ITransformationStrategy" /> components
    ///     that should be auto-discovered via reflection scanning.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class TransformationStrategyAttribute : Attribute
    {
        public TransformationStrategyAttribute(string sourceSystemId)
            => SourceSystemId = sourceSystemId;

        public string SourceSystemId { get; }
    }

    /// <summary>
    ///     Registry responsible for locating and providing the correct
    ///     <see cref="ITransformationStrategy" /> implementation at runtime.
    /// </summary>
    public interface ITransformationStrategyRegistry
    {
        /// <summary>
        ///     Retrieves the transformation strategy capable of handling the
        ///     supplied <paramref name="record" />.
        ///     Throws <see cref="StrategyNotFoundException" /> if none exists.
        /// </summary>
        ITransformationStrategy ResolveStrategy(in RawRecord record);

        /// <summary>
        ///     Adds the supplied strategy instance to the registry.  By default, an
        ///     attempt to register an already existing SourceSystemId results in an
        ///     exception.  Pass <paramref name="replaceIfExists" /> = true to override.
        /// </summary>
        void RegisterStrategy(
            ITransformationStrategy strategy,
            bool replaceIfExists = false);
    }

    /// <summary>
    ///     Application-level exception emitted when no suitable strategy exists.
    /// </summary>
    [SuppressMessage("Design", "CA1032:Implement standard exception constructors")]
    public sealed class StrategyNotFoundException : Exception
    {
        public StrategyNotFoundException(string sourceSystemId)
            : base($"No transformation strategy registered for SourceSystemId='{sourceSystemId}'.")
        {
            SourceSystemId = sourceSystemId;
        }

        public string SourceSystemId { get; }
    }

    #endregion

    #region Registry implementation

    /// <inheritdoc />
    public sealed class TransformationStrategyRegistry : ITransformationStrategyRegistry
    {
        private readonly ConcurrentDictionary<
            string /* SourceSystemId */,
            ITransformationStrategy>
            _cache = new(StringComparer.OrdinalIgnoreCase);

        private readonly ILogger<TransformationStrategyRegistry> _logger;

        /// <summary>
        ///     Creates a new registry instance and bulk-loads strategies from the
        ///     provided <paramref name="assembliesToScan" />.
        /// </summary>
        public TransformationStrategyRegistry(
            IEnumerable<Assembly> assembliesToScan,
            ILogger<TransformationStrategyRegistry> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            if (assembliesToScan == null) throw new ArgumentNullException(nameof(assembliesToScan));

            LoadStrategiesFromAssemblies(assembliesToScan.Distinct().ToArray());
        }

        /// <inheritdoc />
        public ITransformationStrategy ResolveStrategy(in RawRecord record)
        {
            if (_cache.TryGetValue(record.SourceSystemId, out var handler))
                return handler;

            _logger.LogError(
                "No transformation strategy found for SourceSystemId={SourceSystemId}.",
                record.SourceSystemId);

            throw new StrategyNotFoundException(record.SourceSystemId);
        }

        /// <inheritdoc />
        public void RegisterStrategy(ITransformationStrategy strategy, bool replaceIfExists = false)
        {
            if (strategy == null) throw new ArgumentNullException(nameof(strategy));

            var added = _cache.TryAdd(strategy.SourceSystemId, strategy);
            if (added)
            {
                _logger.LogInformation(
                    "Registered transformation strategy for SourceSystemId={SourceSystemId} ({StrategyType}).",
                    strategy.SourceSystemId,
                    strategy.GetType().Name);

                return;
            }

            if (!replaceIfExists)
            {
                throw new InvalidOperationException(
                    $"Strategy for SourceSystemId='{strategy.SourceSystemId}' already registered.");
            }

            _cache[strategy.SourceSystemId] = strategy;

            _logger.LogWarning(
                "Replaced existing transformation strategy for SourceSystemId={SourceSystemId} ({StrategyType}).",
                strategy.SourceSystemId,
                strategy.GetType().Name);
        }

        /// <summary>
        ///     Scans provided <paramref name="assemblies" /> for concrete types
        ///     implementing <see cref="ITransformationStrategy" /> AND decorated with
        ///     <see cref="TransformationStrategyAttribute" />, then registers them.
        /// </summary>
        private void LoadStrategiesFromAssemblies(params Assembly[] assemblies)
        {
            foreach (var assembly in assemblies)
            {
                var strategyTypes = assembly
                    .GetTypes()
                    .Where(t =>
                        !t.IsAbstract &&
                        typeof(ITransformationStrategy).IsAssignableFrom(t) &&
                        t.GetCustomAttribute<TransformationStrategyAttribute>() != null);

                foreach (var type in strategyTypes)
                {
                    try
                    {
                        if (Activator.CreateInstance(type) is not ITransformationStrategy instance)
                            continue;

                        RegisterStrategy(instance);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(
                            ex,
                            "Failed to instantiate transformation strategy {StrategyType}.",
                            type.FullName);
                    }
                }
            }

            _logger.LogInformation(
                "Transformation strategy registry initialized with {Count} strategies.",
                _cache.Count);
        }
    }

    #endregion

    #region Example concrete strategy

    /// <summary>
    ///     Example transformation strategy for Microsoft 365 calendars.
    /// </summary>
    [TransformationStrategy("m365_calendar")]
    public sealed class CalendarEventTransformationStrategy : ITransformationStrategy
    {
        public string SourceSystemId => "m365_calendar";

        public bool CanHandle(in RawRecord record)
            => string.Equals(record.SourceSystemId, SourceSystemId, StringComparison.OrdinalIgnoreCase);

        public async Task<TransformedRecord> TransformAsync(
            RawRecord record,
            CancellationToken ct = default)
        {
            if (!CanHandle(record))
                throw new ArgumentException(
                    $"Invalid SourceSystemId. Expected '{SourceSystemId}'.",
                    nameof(record));

            // Simulate I/O-bound enrichment (e.g., call Graph API, fetch user timezone, etc.)
            await Task.Delay(TimeSpan.FromMilliseconds(10), ct).ConfigureAwait(false);

            // Here we merely copy the payload; real implementation would map to
            // PulseOps canonical model (e.g., MeetingScheduled, MeetingCancelled).
            using var doc = JsonDocument.Parse(record.Payload);

            var output = new TransformedRecord(
                Id: Guid.NewGuid(),
                SourceSystemId: SourceSystemId,
                CanonicalPayload: doc.RootElement.Clone(),
                TransformationTimestamp: DateTimeOffset.UtcNow);

            return output;
        }
    }

    #endregion
}
```