```csharp
// File: src/module_82.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//
// Purpose:
//   Implements the “Meeting Cost Index” KPI calculation using the Strategy
//   pattern.  This KPI estimates the direct cost of meetings per-day by
//   multiplying each attendee’s hourly cost rate by the meeting duration.
//
//   The code demonstrates the following production-grade concerns:
//     • Async/await & cancellation support
//     • Dependency-injected collaborators (directory client, cache, logging)
//     • Memory-cache with sliding expiration
//     • Graceful degradation & structured error logging
//     • Immutable record types & LINQ for expressiveness
//
// NOTE:  This file is compiled as part of the shared library and is consumed
//        by a dedicated Lambda function that materialises KPI results into
//        the warehouse’s fact tables.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.KpiStrategies
{
    #region Domain Contracts ──────────────────────────────────────────────────

    /// <summary>
    /// Generic KPI calculation contract.
    /// </summary>
    public interface IKpiStrategy
    {
        /// <summary>
        /// Calculates KPI values for the supplied event stream.
        /// </summary>
        /// <param name="events">Domain events to aggregate.</param>
        /// <param name="context">Execution context metadata.</param>
        /// <param name="token">A cancellation token.</param>
        /// <returns>Zero or more KPI results.</returns>
        Task<IEnumerable<KpiResult>> CalculateAsync(
            IEnumerable<EventEnvelope> events,
            CalculationContext           context,
            CancellationToken            token = default);
    }

    /// <summary>
    /// Provider for hourly cost-rates used in meeting-cost calculations.
    /// </summary>
    public interface ICostRateProvider
    {
        Task<decimal> GetHourlyRateAsync(string email, CancellationToken token = default);
    }

    /// <summary>
    /// External employee directory abstraction.
    /// </summary>
    public interface IEmployeeDirectoryClient
    {
        Task<EmployeeInfo?> GetEmployeeByEmailAsync(string email, CancellationToken token = default);
    }

    #endregion

    #region Domain Models ─────────────────────────────────────────────────────

    /// <summary>
    /// Supported raw event types in the warehouse.
    /// </summary>
    public enum EventType
    {
        CalendarMeeting,
        // … other event kinds (PullRequest, Deployment, Build, etc.)
    }

    /// <summary>
    /// Canonical event envelope used across the data-lake.
    /// </summary>
    public sealed record EventEnvelope(
        Guid                        EventId,
        EventType                   Type,
        DateTimeOffset              StartTime,
        DateTimeOffset              EndTime,
        IReadOnlyDictionary<string, object?> Metadata);

    /// <summary>
    /// Ambient context for a KPI calculation run.
    /// </summary>
    /// <param name="TenantId">Enterprise identifier (multi-tenant support).</param>
    /// <param name="CorrelationId">Correlation id for tracing purposes.</param>
    public sealed record CalculationContext(
        string TenantId,
        Guid   CorrelationId);

    /// <summary>
    /// Immutable KPI result model.
    /// </summary>
    /// <param name="KpiName">Name of the KPI (e.g., “MeetingCostIndex”).</param>
    /// <param name="TimeWindowStart">Start of the aggregation window (inclusive).</param>
    /// <param name="TimeWindowEnd">End of the aggregation window (inclusive).</param>
    /// <param name="Value">Calculated numeric value.</param>
    /// <param name="Unit">Unit of measurement (e.g., “USD”).</param>
    public sealed record KpiResult(
        string        KpiName,
        DateTimeOffset TimeWindowStart,
        DateTimeOffset TimeWindowEnd,
        decimal        Value,
        string         Unit);

    /// <summary>
    /// Basic employee information used for cost-rate derivation.
    /// </summary>
    public sealed record EmployeeInfo(
        string  EmployeeId,
        string  Email,
        decimal AnnualSalaryUsd);

    #endregion

    #region Strategy Implementation ───────────────────────────────────────────

    /// <summary>
    /// KPI strategy that computes the “Meeting Cost Index” for a single day.
    /// </summary>
    public sealed class MeetingCostIndexStrategy : IKpiStrategy
    {
        private const string ParticipantsKey = "participants";

        private readonly ICostRateProvider                     _costRateProvider;
        private readonly ILogger<MeetingCostIndexStrategy>     _logger;

        public MeetingCostIndexStrategy(
            ICostRateProvider                 costRateProvider,
            ILogger<MeetingCostIndexStrategy> logger)
        {
            _costRateProvider = costRateProvider
                ?? throw new ArgumentNullException(nameof(costRateProvider));
            _logger = logger
                ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task<IEnumerable<KpiResult>> CalculateAsync(
            IEnumerable<EventEnvelope> events,
            CalculationContext         context,
            CancellationToken          token = default)
        {
            if (events  is null) throw new ArgumentNullException(nameof(events));
            if (context is null) throw new ArgumentNullException(nameof(context));

            // Filter and group calendar meeting events by calendar day.
            var groupedMeetings = events
                .Where(e => e.Type == EventType.CalendarMeeting)
                .GroupBy(e => e.StartTime.Date);

            var results = new List<KpiResult>();

            foreach (var dayGroup in groupedMeetings)
            {
                token.ThrowIfCancellationRequested();

                decimal dayTotal = 0m;

                foreach (var meeting in dayGroup)
                {
                    try
                    {
                        dayTotal += await CalculateMeetingCostAsync(meeting, token)
                            .ConfigureAwait(false);
                    }
                    catch (Exception ex) // swallow per-meeting failure, continue aggregation
                    {
                        _logger.LogWarning(
                            ex,
                            "Failed to calculate meeting cost for event {EventId} (Tenant={TenantId}, Correlation={CorrelationId})",
                            meeting.EventId,
                            context.TenantId,
                            context.CorrelationId);
                    }
                }

                results.Add(new KpiResult(
                    KpiName:         "MeetingCostIndex",
                    TimeWindowStart: dayGroup.Key,                  // 00:00 local
                    TimeWindowEnd:   dayGroup.Key.AddDays(1).AddTicks(-1), // 23:59:59.999
                    Value:           decimal.Round(dayTotal, 2),
                    Unit:            "USD"));
            }

            return results;
        }

        /// <summary>
        /// Calculates the cost of a single meeting event.
        /// </summary>
        private async Task<decimal> CalculateMeetingCostAsync(
            EventEnvelope   meeting,
            CancellationToken token)
        {
            // Pull participants out of the metadata bag.
            var participants = meeting.Metadata.TryGetValue(ParticipantsKey, out var value) &&
                               value is IEnumerable<string> emails
                               ? emails
                               : Enumerable.Empty<string>();

            if (!participants.Any()) return 0m;

            var durationHours =
                (decimal)(meeting.EndTime - meeting.StartTime).TotalHours;
            if (durationHours <= 0) return 0m;

            var costTasks = participants.Select(async email =>
            {
                try
                {
                    var rate = await _costRateProvider
                        .GetHourlyRateAsync(email, token)
                        .ConfigureAwait(false);

                    return rate * durationHours;
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex,
                        "Could not resolve cost-rate for {Email}. Using fallback.",
                        email);
                    return FallbackHourlyRateUsd * durationHours;
                }
            });

            var costs = await Task.WhenAll(costTasks).ConfigureAwait(false);

            return costs.Sum();
        }

        // Company-wide fallback hourly rate (in USD) when directory lookup fails.
        private const decimal FallbackHourlyRateUsd = 75m;
    }

    #endregion

    #region Infrastructure ────────────────────────────────────────────────────

    /// <summary>
    /// Caching decorator around <see cref="IEmployeeDirectoryClient"/> that
    /// exposes an <see cref="ICostRateProvider"/> abstraction.
    /// </summary>
    public sealed class MemoryCacheCostRateProvider : ICostRateProvider
    {
        private readonly IMemoryCache                      _cache;
        private readonly IEmployeeDirectoryClient          _directory;
        private readonly ILogger<MemoryCacheCostRateProvider> _logger;
        private readonly MemoryCacheEntryOptions           _cacheOptions;

        public MemoryCacheCostRateProvider(
            IMemoryCache                       cache,
            IEmployeeDirectoryClient           directory,
            ILogger<MemoryCacheCostRateProvider> logger)
        {
            _cache   = cache     ?? throw new ArgumentNullException(nameof(cache));
            _directory = directory ?? throw new ArgumentNullException(nameof(directory));
            _logger  = logger    ?? throw new ArgumentNullException(nameof(logger));

            _cacheOptions = new MemoryCacheEntryOptions
            {
                SlidingExpiration = TimeSpan.FromHours(6),
                Size              = 1 // each entry counts as 1 unit towards CacheSizeLimit
            };
        }

        /// <inheritdoc />
        public async Task<decimal> GetHourlyRateAsync(
            string email,
            CancellationToken token = default)
        {
            if (string.IsNullOrWhiteSpace(email))
                throw new ArgumentException("Value cannot be null or whitespace.", nameof(email));

            if (_cache.TryGetValue(email, out decimal cachedRate))
            {
                return cachedRate;
            }

            decimal rate;
            try
            {
                var employee = await _directory
                    .GetEmployeeByEmailAsync(email, token)
                    .ConfigureAwait(false);

                rate = employee is null
                    ? MeetingCostIndexStrategy.FallbackHourlyRateUsd
                    : ConvertAnnualSalaryToHourly(employee.AnnualSalaryUsd);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Directory lookup failed for {Email}", email);
                rate = MeetingCostIndexStrategy.FallbackHourlyRateUsd;
            }

            _cache.Set(email, rate, _cacheOptions);
            return rate;
        }

        private static decimal ConvertAnnualSalaryToHourly(decimal annualSalaryUsd)
            => decimal.Round(annualSalaryUsd / StandardWorkHoursPerYear, 2);

        // 2080 hours = 40h/week * 52 weeks
        private const decimal StandardWorkHoursPerYear = 2080m;
    }

    #endregion
}
```