```csharp
// File: src/module_4.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric (data_warehouse)
// Purpose: Transformation Strategy Registry & built-in strategies.
// --------------------------------------------------------------------------------------
// © 2024 PulseOps Inc.  All rights reserved.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region Model Contracts

    /// <summary>
    /// Metadata describing the origin, schema and contextual tags of a raw event stream.
    /// </summary>
    public sealed record StreamMetadata(
        string SourceSystem,
        string SchemaVersion,
        string EventType,
        IReadOnlyDictionary<string, string> Tags);

    /// <summary>
    /// Raw event record as ingested from the Data Lake landing zone.
    /// </summary>
    public sealed record RawRecord(StreamMetadata Metadata, string Payload, DateTimeOffset ReceivedAt);

    /// <summary>
    /// Normalized record after applying business KPIs transformation.
    /// </summary>
    public sealed record TransformedRecord(
        StreamMetadata Metadata,
        string NormalizedPayload,
        DateTimeOffset TransformedAt);

    #endregion


    #region Strategy Contracts

    /// <summary>
    /// Core abstraction for a transformation strategy that converts <see cref="RawRecord"/> instances
    /// into <see cref="TransformedRecord"/> representations.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>
        /// Stable unique identifier for this strategy (e.g. "calendar/v1").
        /// </summary>
        string StrategyName { get; }

        /// <summary>
        /// Determines whether this strategy understands and can safely handle the supplied metadata.
        /// Implementations should rely only on metadata and avoid parsing the payload for performance.
        /// </summary>
        /// <param name="metadata">The incoming event’s metadata.</param>
        /// <returns>True if the strategy can transform the event; otherwise, false.</returns>
        bool CanHandle(StreamMetadata metadata);

        /// <summary>
        /// Transforms the incoming raw record into its normalized representation.
        /// </summary>
        /// <param name="record">The raw event record to transform.</param>
        /// <param name="ct">Cancellation signal.</param>
        /// <returns>A <see cref="TransformedRecord"/> instance.</returns>
        Task<TransformedRecord> TransformAsync(RawRecord record, CancellationToken ct = default);
    }

    #endregion


    #region Registry & Resolver

    /// <summary>
    /// Thread-safe registry that discovers available <see cref="ITransformationStrategy"/> implementations
    /// via reflection (or DI registration) and resolves the most appropriate strategy at runtime.
    /// </summary>
    public sealed class TransformationStrategyRegistry
    {
        private readonly ILogger<TransformationStrategyRegistry> _logger;
        private readonly IReadOnlyList<ITransformationStrategy> _strategies;
        private readonly ConcurrentDictionary<string, ITransformationStrategy> _cache = new();

        /// <summary>
        /// Constructs a registry given an explicit list of strategies (e.g. from DI).
        /// </summary>
        public TransformationStrategyRegistry(
            IEnumerable<ITransformationStrategy> strategies,
            ILogger<TransformationStrategyRegistry> logger)
        {
            _strategies = strategies?.ToList()
                          ?? throw new ArgumentNullException(nameof(strategies));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            if (!_strategies.Any())
            {
                _logger.LogWarning("No transformation strategies registered. Fallback will apply.");
            }
        }

        /// <summary>
        /// Convenience factory that discovers strategies via reflection scanning.
        /// Uses a whitelist filter to mitigate assembly-loading hazards in Lambda environments.
        /// </summary>
        public static TransformationStrategyRegistry DiscoverFromCurrentDomain(
            ILogger<TransformationStrategyRegistry> logger,
            params string[] assemblyNamePrefixes)
        {
            assemblyNamePrefixes ??= Array.Empty<string>();

            var strategies = AppDomain.CurrentDomain
                                      .GetAssemblies()
                                      .Where(a => assemblyNamePrefixes.Length == 0
                                                || assemblyNamePrefixes.Any(p => a.GetName().Name!.StartsWith(p, StringComparison.OrdinalIgnoreCase)))
                                      .SelectMany(FindStrategies)
                                      .Distinct()
                                      .ToList();

            return new TransformationStrategyRegistry(strategies, logger);
        }

        /// <summary>
        /// Transforms the supplied <see cref="RawRecord"/> using the most suitable strategy.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if no strategy can handle the record.</exception>
        public async Task<TransformedRecord> TransformAsync(RawRecord record, CancellationToken ct = default)
        {
            if (record == null) throw new ArgumentNullException(nameof(record));

            // Fast path: attempt cached resolution first.
            if (_cache.TryGetValue(record.Metadata.EventType, out var cached))
            {
                _logger.LogTrace("Using cached strategy [{Strategy}] for event-type [{EventType}]",
                    cached.StrategyName, record.Metadata.EventType);

                return await cached.TransformAsync(record, ct).ConfigureAwait(false);
            }

            // Resolve best candidate.
            var strategy = _strategies.FirstOrDefault(s => s.CanHandle(record.Metadata));

            if (strategy == null)
            {
                _logger.LogError("No transformation strategy found for event-type {EventType} from {SourceSystem}",
                    record.Metadata.EventType, record.Metadata.SourceSystem);

                throw new InvalidOperationException(
                    $"Unable to find transformation strategy for event-type '{record.Metadata.EventType}'.");
            }

            // Cache for future lookups (strategy resolution is deterministic per event-type).
            _cache.TryAdd(record.Metadata.EventType, strategy);

            _logger.LogDebug("Resolved strategy [{Strategy}] for event-type [{EventType}]",
                strategy.StrategyName, record.Metadata.EventType);

            return await strategy.TransformAsync(record, ct).ConfigureAwait(false);
        }

        #region Reflection Helper

        private static IEnumerable<ITransformationStrategy> FindStrategies(Assembly assembly)
        {
            var strategyType = typeof(ITransformationStrategy);

            return assembly.DefinedTypes
                           .Where(t => !t.IsAbstract
                                    && !t.IsInterface
                                    && strategyType.IsAssignableFrom(t))
                           .Select(CreateInstanceSafe)
                           .OfType<ITransformationStrategy>();
        }

        private static ITransformationStrategy? CreateInstanceSafe(TypeInfo typeInfo)
        {
            try
            {
                // Only attempt parameterless constructor instantiation for auto-discovery.
                return Activator.CreateInstance(typeInfo.AsType()) as ITransformationStrategy;
            }
            catch
            {
                // Swallow exceptions—constructor may require DI; that's okay.
                return null;
            }
        }

        #endregion
    }

    #endregion


    #region Built-in Strategies

    /// <summary>
    /// Example implementation that transforms Outlook/Google calendar events into
    /// a normalized payload used for "Meeting Cost Index" KPI calculations.
    /// </summary>
    public sealed class CalendarEventStrategy : ITransformationStrategy
    {
        public string StrategyName => "calendar/v1";

        public bool CanHandle(StreamMetadata metadata)
            => metadata.SourceSystem.Equals("calendar", StringComparison.OrdinalIgnoreCase)
               && metadata.EventType.Equals("calendar.event", StringComparison.OrdinalIgnoreCase);

        public Task<TransformedRecord> TransformAsync(RawRecord record, CancellationToken ct = default)
        {
            // Sample pseudo-transformation (production code would parse iCal / JSON)
            var normalized = new
            {
                Title           = ExtractProperty(record.Payload, "subject"),
                AttendeeCount   = int.Parse(ExtractProperty(record.Payload, "attendees")),
                DurationMinutes = int.Parse(ExtractProperty(record.Payload, "duration")),
                Organizer       = ExtractProperty(record.Payload, "organizer")
            };

            var normalizedPayload = System.Text.Json.JsonSerializer.Serialize(normalized);

            return Task.FromResult(new TransformedRecord(
                record.Metadata,
                normalizedPayload,
                DateTimeOffset.UtcNow));
        }

        private static string ExtractProperty(string payload, string key)
        {
            // Very naive placeholder. Real implementation would properly parse JSON/ICS.
            var start = payload.IndexOf($"{key}:", StringComparison.OrdinalIgnoreCase);
            if (start < 0) return string.Empty;

            start += key.Length + 1;
            var end = payload.IndexOf('\n', start);
            end = end < 0 ? payload.Length : end;

            return payload[start..end].Trim();
        }
    }

    /// <summary>
    /// Transforms deployment pipeline log events into normalized form in support of the
    /// "Deployment Lead-Time" KPI.
    /// </summary>
    public sealed class DeploymentLogStrategy : ITransformationStrategy
    {
        public string StrategyName => "deployment-log/v2";

        public bool CanHandle(StreamMetadata metadata)
            => metadata.SourceSystem.Equals("ci-cd", StringComparison.OrdinalIgnoreCase)
               && metadata.EventType.Equals("deployment.log", StringComparison.OrdinalIgnoreCase)
               && metadata.SchemaVersion.StartsWith("2.", StringComparison.OrdinalIgnoreCase);

        public async Task<TransformedRecord> TransformAsync(RawRecord record, CancellationToken ct = default)
        {
            await Task.Yield(); // Simulate async I/O (e.g. external enrichment).

            // Simplistic transformation: scrub secrets + normalize timestamps
            var scrubbed = record.Payload.Replace("token=", "token=***", StringComparison.OrdinalIgnoreCase);

            var normalized = new
            {
                Log         = scrubbed,
                ReceivedAt  = record.ReceivedAt.UtcDateTime,
                ParsedAt    = DateTimeOffset.UtcNow.UtcDateTime
            };

            var normalizedPayload = System.Text.Json.JsonSerializer.Serialize(normalized);

            return new TransformedRecord(
                record.Metadata,
                normalizedPayload,
                DateTimeOffset.UtcNow);
        }
    }

    /// <summary>
    /// Null-object pattern implementation that accepts any record and leaves the payload untouched.
    /// Use when transformation is optional or still under construction.
    /// </summary>
    public sealed class PassThroughStrategy : ITransformationStrategy
    {
        public string StrategyName => "passthrough";

        public bool CanHandle(StreamMetadata metadata) => true;

        public Task<TransformedRecord> TransformAsync(RawRecord record, CancellationToken ct = default)
        {
            return Task.FromResult(new TransformedRecord(
                record.Metadata,
                record.Payload,
                DateTimeOffset.UtcNow));
        }
    }

    #endregion
}
```