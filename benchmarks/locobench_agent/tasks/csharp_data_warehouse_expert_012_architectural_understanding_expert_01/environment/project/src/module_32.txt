```csharp
// File: src/module_32.txt
// Project: PulseOps Warehouse â€” Serverless Productivity Intelligence Fabric
// Language: C# 10
// Description:
//     Strategy-Pattern implementation that converts raw calendar events
//     into Focus-Time KPI records.  The transformer is designed to run in a
//     serverless Lambda context, but is infrastructure-agnostic and therefore
//     testable in isolation.
//
// ---------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.Calendar
{
    #region Public Contracts

    /// <summary>
    ///     Generic Strategy-Pattern contract for stream transformations.
    /// </summary>
    /// <typeparam name="TIn">Incoming domain model.</typeparam>
    /// <typeparam name="TOut">Resulting domain model.</typeparam>
    public interface ITransformationStrategy<in TIn, TOut>
    {
        /// <summary>
        ///     Transforms an async stream of <typeparamref name="TIn"/> into
        ///     an async stream of <typeparamref name="TOut"/>.
        /// </summary>
        /// <param name="source">Source stream.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>Result stream.</returns>
        IAsyncEnumerable<TOut> TransformAsync(IAsyncEnumerable<TIn> source, CancellationToken ct = default);
    }

    /// <summary>
    ///     Raw calendar event ingested from SaaS provider (e.g., Google Workspace, O365).
    /// </summary>
    public sealed record CalendarEvent(
        string EventId,
        string OrganizerEmail,
        string[] AttendeesEmails,
        DateTimeOffset StartUtc,
        DateTimeOffset EndUtc,
        bool IsCancelled,
        bool IsAllDay,
        string? Subject);

    /// <summary>
    ///     KPI record representing a user's daily focus-time ratio.
    /// </summary>
    public sealed record FocusTimeKpiRecord(
        string UserEmail,
        DateOnly Date,
        TimeSpan MeetingDuration,
        TimeSpan FocusDuration,
        double FocusRatio)
    {
        public string PartitionKey => UserEmail;
        public string SortKey      => Date.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
    }

    #endregion

    /// <summary>
    ///     Calculates daily focus-time KPI from raw calendar events.
    ///     The algorithm assumes:
    ///         * Overlapping meetings are floored at actual overlapping durations
    ///           (no double-counting).
    ///         * All-day events are considered non-focused time.
    ///         * Cancelled events are ignored.
    /// </summary>
    public sealed class CalendarFocusTimeTransformer : ITransformationStrategy<CalendarEvent, FocusTimeKpiRecord>
    {
        private readonly ILogger<CalendarFocusTimeTransformer> _logger;
        private readonly TimeSpan _workdayLength;

        public CalendarFocusTimeTransformer(
            ILogger<CalendarFocusTimeTransformer> logger,
            TimeSpan? workdayLength = null)
        {
            _logger        = logger  ?? throw new ArgumentNullException(nameof(logger));
            _workdayLength = workdayLength ?? TimeSpan.FromHours(8);
        }

        public async IAsyncEnumerable<FocusTimeKpiRecord> TransformAsync(
            IAsyncEnumerable<CalendarEvent> source,
            [EnumeratorCancellation] CancellationToken ct = default)
        {
            // 1. Materialize to list grouped by user + date.
            var eventsByUserDate = new Dictionary<(string User, DateOnly Date), List<CalendarEvent>>();

            await foreach (var evt in source.WithCancellation(ct))
            {
                if (!ShouldInclude(evt))
                {
                    _logger.LogDebug("Ignoring event {EventId} (IsCancelled={IsCancelled}, IsAllDay={IsAllDay})",
                                     evt.EventId, evt.IsCancelled, evt.IsAllDay);
                    continue;
                }

                foreach (var participant in evt.AttendeesEmails.Append(evt.OrganizerEmail))
                {
                    var key = (User: participant.ToLowerInvariant(), Date: DateOnly.FromDateTime(evt.StartUtc.UtcDateTime));
                    if (!eventsByUserDate.TryGetValue(key, out var bucket))
                    {
                        bucket = new List<CalendarEvent>(capacity: 4);
                        eventsByUserDate[key] = bucket;
                    }

                    bucket.Add(evt);
                }
            }

            // 2. Walk each user+date and compute meeting duration, focus ratio.
            foreach (var ((user, date), eventList) in eventsByUserDate)
            {
                ct.ThrowIfCancellationRequested();

                var mergedMeetingDuration = MergeAndSum(eventList);
                var focusDuration         = _workdayLength > mergedMeetingDuration
                    ? _workdayLength - mergedMeetingDuration
                    : TimeSpan.Zero;

                var record = new FocusTimeKpiRecord(
                    UserEmail:      user,
                    Date:           date,
                    MeetingDuration: mergedMeetingDuration,
                    FocusDuration:   focusDuration,
                    FocusRatio:      _workdayLength == TimeSpan.Zero
                        ? 0
                        : focusDuration.TotalMinutes / _workdayLength.TotalMinutes
                );

                _logger.LogDebug("Produced FocusTime KPI {@Record}", record);
                yield return record;
            }
        }

        #region Helpers

        private static bool ShouldInclude(CalendarEvent evt) =>
            !evt.IsCancelled && !evt.IsAllDay && evt.EndUtc > evt.StartUtc;

        /// <summary>
        ///     Merges overlapping events and computes total meeting duration.
        /// </summary>
        private static TimeSpan MergeAndSum(IReadOnlyList<CalendarEvent> events)
        {
            if (events.Count == 0)
                return TimeSpan.Zero;

            var ordered = events
                .OrderBy(e => e.StartUtc)
                .Select(e => (e.StartUtc, e.EndUtc))
                .ToImmutableArray();

            var total = TimeSpan.Zero;
            var currentStart = ordered[0].StartUtc;
            var currentEnd   = ordered[0].EndUtc;

            for (var i = 1; i < ordered.Length; i++)
            {
                var (start, end) = ordered[i];

                if (start <= currentEnd) // overlap
                {
                    currentEnd = end > currentEnd ? end : currentEnd;
                }
                else
                {
                    total += currentEnd - currentStart;
                    currentStart = start;
                    currentEnd   = end;
                }
            }

            total += currentEnd - currentStart;
            return total;
        }

        #endregion
    }
}
```