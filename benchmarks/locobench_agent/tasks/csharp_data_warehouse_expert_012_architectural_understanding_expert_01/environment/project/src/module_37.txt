```csharp
// File: src/module_37.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
// Purpose: Implements a transformation-strategy that calculates “Focus-Time Ratio” KPI.
// Language: C# 10 (.NET 6)
// -----------------------------------------------------------------------------------

using System;
using System.Buffers;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.FocusTime
{
    #region Contracts / DTOs

    /// <summary>
    ///     Canonical stream event consumed by transformation strategies.
    ///     Every event must resolve to one of the <see cref="WorkActivityKind"/> values.
    /// </summary>
    public sealed record StreamEvent(
        Guid Id,
        DateTimeOffset StartUtc,
        DateTimeOffset EndUtc,
        WorkActivityKind ActivityKind,
        string SourceSystem,
        IReadOnlyDictionary<string, string> Metadata);

    /// <summary>
    ///     Supported work activities recognized across streams.
    /// </summary>
    public enum WorkActivityKind
    {
        Unknown = 0,
        Coding,          // IDE foreground activity, Git events, etc.
        Meeting,         // Calendar meeting
        Email,           // Reading or writing e-mail
        Break,           // Lunch, coffee, away-from-keyboard
        Admin            // Tickets, paperwork, etc.
    }

    /// <summary>
    ///     Result-envelope returned by all transformation strategies.
    /// </summary>
    public sealed record TransformationResult(
        string Strategy,
        IReadOnlyDictionary<string, object> Metrics,
        DateTimeOffset GeneratedAtUtc);

    /// <summary>
    ///     Strategy contract.  Implementations transform an input stream into a KPI set.
    /// </summary>
    public interface ITransformationStrategy
    {
        string Name { get; }

        /// <summary>
        ///     Executes the transformation against an asynchronous event stream.
        /// </summary>
        /// <param name="events">Input event stream (can be unbounded).</param>
        /// <param name="token">Cancellation token.</param>
        /// <returns>KPI payload wrapped in <see cref="TransformationResult"/>.</returns>
        Task<TransformationResult> ExecuteAsync(
            IAsyncEnumerable<StreamEvent> events,
            CancellationToken token = default);
    }

    #endregion

    #region Strategy Implementation

    /// <summary>
    ///     Calculates Focus-Time Ratio KPI:
    ///     FocusTime (%) = (Sum of Coding minutes) / (Sum of All tracked work minutes) * 100
    /// </summary>
    public sealed class FocusTimeRatioStrategy : ITransformationStrategy
    {
        private readonly ILogger<FocusTimeRatioStrategy> _logger;

        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public string Name => "focus-time-ratio-v1";

        public async Task<TransformationResult> ExecuteAsync(
            IAsyncEnumerable<StreamEvent> events,
            CancellationToken token = default)
        {
            if (events == null) throw new ArgumentNullException(nameof(events));

            _logger.LogDebug("[{Strategy}] Starting execution.", Name);

            // Buffers for aggregations
            double totalMinutes = 0d;
            double focusMinutes = 0d;

            await foreach (var e in events.WithCancellation(token).ConfigureAwait(false))
            {
                // Validate
                if (e == null)
                    continue;

                var duration = (e.EndUtc - e.StartUtc).TotalMinutes;

                if (duration < 0)
                {
                    _logger.LogWarning(
                        "Event {EventId} has negative duration: {Duration} minutes. Skipping.",
                        e.Id, duration);
                    continue;
                }

                totalMinutes += duration;

                if (e.ActivityKind == WorkActivityKind.Coding)
                    focusMinutes += duration;
            }

            if (totalMinutes == 0)
            {
                _logger.LogInformation(
                    "[{Strategy}] No qualifying work minutes found. Returning empty KPI.",
                    Name);

                return new TransformationResult(
                    Strategy: Name,
                    Metrics: new Dictionary<string, object>
                    {
                        ["FocusTimePercentage"] = double.NaN,
                        ["SampleSizeMinutes"]   = 0d
                    },
                    GeneratedAtUtc: DateTimeOffset.UtcNow);
            }

            var focusRatio = Math.Round(focusMinutes / totalMinutes * 100d, 2,
                MidpointRounding.AwayFromZero);

            _logger.LogInformation(
                "[{Strategy}] Computed Focus-Time ratio {Ratio}% (Focus: {Focus}m, Total: {Total}m).",
                Name, focusRatio.ToString(CultureInfo.InvariantCulture), focusMinutes, totalMinutes);

            return new TransformationResult(
                Strategy: Name,
                Metrics: new Dictionary<string, object>
                {
                    ["FocusTimePercentage"] = focusRatio,
                    ["FocusMinutes"]        = focusMinutes,
                    ["TotalTrackedMinutes"] = totalMinutes
                },
                GeneratedAtUtc: DateTimeOffset.UtcNow);
        }
    }

    #endregion

    #region Strategy Loader / Registry

    /// <summary>
    ///     Simple in-memory registry that resolves strategies by name.
    ///     In production this may be backed by dependency-injection, reflection, or a plug-in loader.
    /// </summary>
    public sealed class TransformationStrategyRegistry
    {
        private readonly IReadOnlyDictionary<string, ITransformationStrategy> _strategies;

        public TransformationStrategyRegistry(IEnumerable<ITransformationStrategy> strategies)
        {
            if (strategies == null) throw new ArgumentNullException(nameof(strategies));

            // Deduplicate by latest registration wins
            var map = new Dictionary<string, ITransformationStrategy>(
                StringComparer.OrdinalIgnoreCase);

            foreach (var strat in strategies)
            {
                if (string.IsNullOrWhiteSpace(strat?.Name))
                    continue;

                map[strat.Name] = strat;
            }

            _strategies = map;
        }

        /// <summary>
        ///     Returns the requested strategy or throws <see cref="KeyNotFoundException"/>.
        /// </summary>
        public ITransformationStrategy Resolve(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Strategy name must be provided.", nameof(name));

            if (_strategies.TryGetValue(name, out var strat))
                return strat;

            throw new KeyNotFoundException(
                $"Transformation strategy '{name}' is not registered.");
        }
    }

    #endregion

    #region Async Helpers

    /// <summary>
    ///     Utility extensions providing high-throughput buffering for async enumerables.
    /// </summary>
    internal static class AsyncEnumerableExtensions
    {
        /// <summary>
        ///     Splits a source stream into fixed-size batches.
        /// </summary>
        public static async IAsyncEnumerable<IReadOnlyList<T>> Buffer<T>(
            this IAsyncEnumerable<T> source,
            int batchSize,
            [EnumeratorCancellation] CancellationToken token = default)
        {
            if (batchSize <= 0)
                throw new ArgumentOutOfRangeException(nameof(batchSize));

            var pool = ArrayPool<T>.Shared;
            T[] bucket = pool.Rent(batchSize);
            var index = 0;

            await foreach (var item in source.WithCancellation(token).ConfigureAwait(false))
            {
                bucket[index++] = item;

                if (index == batchSize)
                {
                    yield return new ArraySegment<T>(bucket, 0, index);
                    index = 0;
                    bucket = pool.Rent(batchSize);
                }
            }

            if (index > 0)
                yield return new ArraySegment<T>(bucket, 0, index);

            pool.Return(bucket);
        }
    }

    #endregion
}
```