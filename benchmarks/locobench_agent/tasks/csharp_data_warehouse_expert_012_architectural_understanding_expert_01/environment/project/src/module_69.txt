```csharp
// -----------------------------------------------------------------------------
//  File:        module_69.txt   (treated as .cs by the build pipeline)
//  Project:     PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//  Purpose:     Implements a pluggable, strategy-based transformation engine
//               that converts raw productivity events into KPI projections
//               (focus-time ratios, meeting-cost index, etc.).  The code here
//               showcases the Strategy Pattern, fault-tolerant execution, and
//               observability hooks expected in production workloads.
// -----------------------------------------------------------------------------
//
//  Copyright © 2024 PulseOps
//  Licensed under the Apache License, Version 2.0
// -----------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Amazon.Lambda.Core;                            // For ILambdaContext in Lambda runtimes
using Microsoft.Extensions.Logging;                  // Structured logging
using Newtonsoft.Json;                               // Payload (de)serialization
using PulseOps.Warehouse.Abstractions;               // Shared domain contracts
using PulseOps.Warehouse.Shared;                     // Guard clauses, error types, etc.

// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global

namespace PulseOps.Warehouse.Transformations
{
    /// <summary>
    /// Domain record emitted by upstream ingestion Lambdas.  A <see cref="ProductivityEvent"/> abstracts
    /// away raw provider signals (Google Calendar, GitHub, etc.) into a normalized, lake-friendly shape.
    /// </summary>
    public sealed record ProductivityEvent
    {
        public required string  EmployeeId      { get; init; }
        public required string  TenantId        { get; init; }
        public required DateTimeOffset StartUtc { get; init; }
        public required DateTimeOffset EndUtc   { get; init; }
        public required EventCategory Category  { get; init; }
        public string?            Source        { get; init; }
        public IDictionary<string, string>? Metadata { get; init; }

        [JsonIgnore]
        public TimeSpan Duration => EndUtc - StartUtc;
    }

    public enum EventCategory
    {
        Focus,          // Deep work, coding, design
        Meeting,        // Calendar meeting
        Communication,  // Slack, E-mail
        Idle            // No activity detected
    }

    /// <summary>
    /// KPI projection returned by the <see cref="FocusTimeRatioStrategy"/>.
    /// Partition-keyed on (Tenant, Employee, Date) to support efficient lake partitioning.
    /// </summary>
    public sealed record FocusTimeMetric
    {
        public required string  TenantId     { get; init; }
        public required string  EmployeeId   { get; init; }
        public required DateOnly Date        { get; init; }
        public required double  Ratio        { get; init; }  // 0-1
        public required TimeSpan FocusTime   { get; init; }
        public required TimeSpan TotalTime   { get; init; }
        public required DateTimeOffset IngestedUtc { get; init; }
    }

    /// <summary>
    /// Generic Strategy contract responsible for morphing <typeparamref name="TInput"/> signals into
    /// <typeparamref name="TOutput"/> projections.
    /// </summary>
    public interface IEventTransformationStrategy<in TInput, TOutput>
    {
        string Name { get; } // Human-friendly identifier (used for DI / reflection loading)

        Task<IReadOnlyCollection<TOutput>> TransformAsync(
            IEnumerable<TInput> input,
            CancellationToken   cancellationToken = default);
    }

    /// <summary>
    /// Concrete strategy that produces <see cref="FocusTimeMetric"/> KPIs from the raw
    /// <see cref="ProductivityEvent"/> stream.
    /// </summary>
    public sealed class FocusTimeRatioStrategy : IEventTransformationStrategy<ProductivityEvent, FocusTimeMetric>
    {
        public const string StrategyName = "focus-time-ratio";

        public string Name => StrategyName;

        private readonly ILogger<FocusTimeRatioStrategy> _logger;

        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<IReadOnlyCollection<FocusTimeMetric>> TransformAsync(
            IEnumerable<ProductivityEvent> input,
            CancellationToken cancellationToken = default)
        {
            Guard.AgainstNull(input);

            var sw = Stopwatch.StartNew();

            // Materialize early to avoid side-effects from multiple enumeration
            var events = input.ToArray();
            if (events.Length == 0) return Array.Empty<FocusTimeMetric>();

            // Group by Tenant + Employee + Day for efficient parallelization
            var grouped = events
                .GroupBy(e => new
                {
                    e.TenantId,
                    e.EmployeeId,
                    Date = DateOnly.FromDateTime(e.StartUtc.UtcDateTime)
                });

            var outputBag = new ConcurrentBag<FocusTimeMetric>();

            await Parallel.ForEachAsync(grouped, cancellationToken, (group, token) =>
            {
                token.ThrowIfCancellationRequested();

                var focusTime = group
                    .Where(e => e.Category == EventCategory.Focus)
                    .Aggregate(TimeSpan.Zero, (acc, e) => acc + e.Duration);

                var totalTime = group
                    .Aggregate(TimeSpan.Zero, (acc, e) => acc + e.Duration);

                // Defensive: guard against divide-by-zero (e.g. zero-duration events ingested)
                var ratio = totalTime.TotalMinutes <= 0
                    ? 0
                    : focusTime.TotalMinutes / totalTime.TotalMinutes;

                outputBag.Add(new FocusTimeMetric
                {
                    TenantId     = group.Key.TenantId,
                    EmployeeId   = group.Key.EmployeeId,
                    Date         = group.Key.Date,
                    Ratio        = Math.Round(ratio, 4),
                    FocusTime    = focusTime,
                    TotalTime    = totalTime,
                    IngestedUtc  = DateTimeOffset.UtcNow
                });

                return ValueTask.CompletedTask;
            });

            sw.Stop();
            _logger.LogInformation("Calculated {Count} FocusTimeRatio metrics in {ElapsedMs} ms",
                outputBag.Count, sw.ElapsedMilliseconds);

            return outputBag.ToArray();
        }
    }

    /// <summary>
    /// Provides a DI-friendly façade for resolving transformation strategies at runtime.
    /// </summary>
    public interface ITransformationStrategyFactory
    {
        IEventTransformationStrategy<TIn, TOut> Resolve<TIn, TOut>(string name);
    }

    /// <summary>
    /// Reflection-based implementation that scans the current AppDomain for classes implementing
    /// <see cref="IEventTransformationStrategy{TInput,TOutput}"/>.  This enables plug-and-play
    /// deployment of new strategies without recompiling the factory itself.
    /// </summary>
    public sealed class ReflectionStrategyFactory : ITransformationStrategyFactory
    {
        private readonly IServiceProvider _provider;
        private readonly ILogger<ReflectionStrategyFactory> _logger;
        private readonly ConcurrentDictionary<string, Type> _cache = new(StringComparer.OrdinalIgnoreCase);

        public ReflectionStrategyFactory(IServiceProvider provider, ILogger<ReflectionStrategyFactory> logger)
        {
            _provider = provider ?? throw new ArgumentNullException(nameof(provider));
            _logger   = logger   ?? throw new ArgumentNullException(nameof(logger));

            IndexStrategies();
        }

        private void IndexStrategies()
        {
            var strategyTypes = AppDomain.CurrentDomain
                .GetAssemblies()
                .SelectMany(a => a.GetTypes())
                .Where(t => !t.IsAbstract && !t.IsInterface)
                .Select(t => (Type: t, Interface: t.GetInterfaces()
                    .FirstOrDefault(i => i.IsGenericType &&
                                         i.GetGenericTypeDefinition() == typeof(IEventTransformationStrategy<,>))))
                .Where(tuple => tuple.Interface != null)
                .ToArray();

            foreach (var (type, _) in strategyTypes)
            {
                var instance = (IEventTransformationStrategy<object, object>?)Activator.CreateInstance(type);
                if (instance == null) continue;

                var key = instance.Name;

                if (!_cache.TryAdd(key, type))
                {
                    _logger.LogWarning("Duplicate strategy name '{StrategyName}' detected. Using first discovered type.", key);
                }
            }

            _logger.LogInformation("Indexed {Count} transformation strategies.", _cache.Count);
        }

        public IEventTransformationStrategy<TIn, TOut> Resolve<TIn, TOut>(string name)
        {
            Guard.AgainstNullOrWhiteSpace(name);

            if (!_cache.TryGetValue(name, out var type))
            {
                throw new StrategyNotFoundException(
                    $"No transformation strategy registered with name '{name}'.");
            }

            // Use DI provider when available to honor constructor injections
            var strategy = _provider.GetService(type) ?? Activator.CreateInstance(type);
            if (strategy is not IEventTransformationStrategy<TIn, TOut> typed)
            {
                throw new InvalidCastException(
                    $"Strategy '{name}' does not implement the expected generic contract.");
            }

            return typed;
        }
    }

    /// <summary>
    /// Orchestrates transformation end-to-end.  Intended to be called by Lambda handlers or
    /// Step-Functions activities.
    /// </summary>
    public sealed class TransformationEngine
    {
        private readonly ITransformationStrategyFactory _factory;
        private readonly ILogger<TransformationEngine>  _logger;

        public TransformationEngine(
            ITransformationStrategyFactory factory,
            ILogger<TransformationEngine> logger)
        {
            _factory = factory ?? throw new ArgumentNullException(nameof(factory));
            _logger  = logger  ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Executes a single strategy by name.
        /// </summary>
        /// <typeparam name="TIn">Input event type</typeparam>
        /// <typeparam name="TOut">Output KPI projection type</typeparam>
        /// <param name="strategyName">Unique identifier for the strategy (case-insensitive)</param>
        /// <param name="payload">Raw input events</param>
        /// <param name="lambdaContext">AWS Lambda context (optional, for enriched logging)</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Collection of derived KPI documents</returns>
        public async Task<IReadOnlyCollection<TOut>> ExecuteAsync<TIn, TOut>(
            string strategyName,
            IEnumerable<TIn> payload,
            ILambdaContext? lambdaContext          = null,
            CancellationToken cancellationToken    = default)
        {
            Guard.AgainstNull(payload);

            var invocationId = lambdaContext?.AwsRequestId ?? Guid.NewGuid().ToString("N");
            using var scope = _logger.BeginScope(new Dictionary<string, object?>
            {
                ["strategy"]    = strategyName,
                ["invocationId"] = invocationId
            });

            _logger.LogInformation("Transformation started with {EventCount} events.", payload.Count());

            IEventTransformationStrategy<TIn, TOut> strategy;
            try
            {
                strategy = _factory.Resolve<TIn, TOut>(strategyName);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to resolve strategy '{StrategyName}'.", strategyName);
                throw;
            }

            try
            {
                var result = await strategy.TransformAsync(payload, cancellationToken);

                _logger.LogInformation("Transformation completed with {KpiCount} output documents.",
                    result.Count);

                return result;
            }
            catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
            {
                _logger.LogWarning("Transformation aborted by caller request (cancellation).");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unhandled error during transformation execution.");
                throw;
            }
        }
    }

    // -------------------------------------------------------------------------
    // Below:   Custom exceptions + guard utilities
    // -------------------------------------------------------------------------

    public sealed class StrategyNotFoundException : Exception
    {
        public StrategyNotFoundException(string message)
            : base(message)
        {
        }
    }

    internal static class Guard
    {
        public static void AgainstNull(object? obj, string? paramName = null)
        {
            if (obj is null)
            {
                throw new ArgumentNullException(paramName ?? "value");
            }
        }

        public static void AgainstNullOrWhiteSpace(string? str, string? paramName = null)
        {
            if (string.IsNullOrWhiteSpace(str))
            {
                throw new ArgumentException("Value cannot be null or whitespace.",
                    paramName ?? "value");
            }
        }
    }
}
```