```csharp
// -------------------------------------------------------------------------------------------------
//  PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//  File:        src/module_30.txt
//  Project:     PulseOps Warehouse (data_warehouse)
//  Description: Strategy implementation that calculates the "Focus-Time Ratio" KPI from
//               raw calendar telemetry.  Demonstrates Strategy-Pattern, parallel processing,
//               structured logging, and robust error handling.
//  Author:      <auto-generated by GPT-4>
//  Copyright:   (c) 2024 PulseOps
// -------------------------------------------------------------------------------------------------

#nullable enable

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.FocusTime
{
    /// <summary>
    /// Calculates the <c>Focus-Time Ratio</c> KPI for knowledge-workers.
    /// 
    ///   Focus-Time Ratio = Σ(Duration of focus events) / Σ(Total working-hours)
    ///   
    /// A <strong>focus event</strong> is any calendar block that:
    ///   • Is labeled with one of the configured focus keywords (e.g., "Focus", "Deep Work")
    ///   • OR has zero participants (solo time-blocks)
    /// </summary>
    public sealed class FocusTimeRatioStrategy
        : ITransformationStrategy<IEnumerable<CalendarEvent>, ProductivityMetrics>
    {
        private readonly ILogger<FocusTimeRatioStrategy> _logger;
        private readonly FocusTimeOptions _options;

        public string Name => nameof(FocusTimeRatioStrategy);

        public FocusTimeRatioStrategy(
            ILogger<FocusTimeRatioStrategy> logger,
            FocusTimeOptions options)
        {
            _logger  = logger  ?? throw new ArgumentNullException(nameof(logger));
            _options = options ?? throw new ArgumentNullException(nameof(options));
        }

        /// <inheritdoc/>
        public async Task<ProductivityMetrics> TransformAsync(
            IEnumerable<CalendarEvent> source,
            CancellationToken cancellationToken = default)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));

            var sw = Stopwatch.StartNew();
            _logger.LogInformation("FocusTimeRatioStrategy started with {EventCount} raw events",
                source switch { ICollection<CalendarEvent> c => c.Count, _ => source.Count() });

            try
            {
                var normalizedEvents = NormalizeAndFilter(source, cancellationToken);
                var dailyGroups      = GroupByWorkday(normalizedEvents, cancellationToken);
                var dailyMetrics     = new ConcurrentBag<DailyFocusRatio>();

                // CPU-bound aggregation -> Parallel.ForEach
                Parallel.ForEach(
                    dailyGroups,
                    new ParallelOptions { CancellationToken = cancellationToken },
                    kvp =>
                    {
                        var (workday, events) = (kvp.Key, kvp.Value);

                        // Merge overlapping slots to avoid double-counting
                        var mergedFocusMinutes = MergeAndSum(events.FocusEvents);
                        var mergedWorkMinutes  = MergeAndSum(events.WorkEvents);

                        var ratio = mergedWorkMinutes > 0
                            ? mergedFocusMinutes / mergedWorkMinutes
                            : 0d;

                        dailyMetrics.Add(new DailyFocusRatio(workday, ratio));
                    });

                var overallRatio = dailyMetrics.Any()
                    ? dailyMetrics.Average(m => m.Ratio)
                    : 0d;

                var result = new ProductivityMetrics
                {
                    CreatedUtc          = DateTime.UtcNow,
                    MetricName          = "FocusTimeRatio",
                    MetricValue         = Math.Round(overallRatio, 4),
                    Samples             = dailyMetrics.Count,
                    Metadata            = new Dictionary<string, string>
                    {
                        ["Window"]       = _options.ReportingWindow.ToString(),
                        ["FocusKeywords"] = string.Join(',', _options.FocusKeywords)
                    }
                };

                sw.Stop();
                _logger.LogInformation(
                    "FocusTimeRatio computed: {Ratio:P2} in {ElapsedMs} ms (days={Days})",
                    result.MetricValue,
                    sw.ElapsedMilliseconds,
                    dailyMetrics.Count);

                return await Task.FromResult(result);
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("FocusTimeRatioStrategy was canceled");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to compute FocusTimeRatio");
                throw;
            }
        }

        #region Private Helpers

        /// <summary>
        /// Normalizes incoming events, filters out those outside the reporting window,
        /// and classifies them into focus or generic working events.
        /// </summary>
        private IEnumerable<NormalizedEvent> NormalizeAndFilter(
            IEnumerable<CalendarEvent> source,
            CancellationToken ct)
        {
            var utcNow        = DateTimeOffset.UtcNow;
            var earliestStart = utcNow.Add(_options.ReportingWindow);

            foreach (var e in source)
            {
                ct.ThrowIfCancellationRequested();

                if (e.Start >= earliestStart && e.End <= utcNow)
                {
                    bool isFocus = IsFocusEvent(e);
                    yield return new NormalizedEvent(e.Start, e.End, isFocus);
                }
            }
        }

        /// <summary>
        /// Groups events by their local workday to support business time-zone reporting.
        /// </summary>
        private IDictionary<DateOnly, DailyEventAggregate> GroupByWorkday(
            IEnumerable<NormalizedEvent> events,
            CancellationToken ct)
        {
            var map = new ConcurrentDictionary<DateOnly, DailyEventAggregate>();

            Parallel.ForEach(
                events,
                new ParallelOptions { CancellationToken = ct },
                normalized =>
                {
                    var localDate = DateOnly.FromDateTime(
                        normalized.StartLocal.Date);

                    var aggregate = map.GetOrAdd(
                        localDate,
                        _ => new DailyEventAggregate());

                    if (normalized.IsFocus)
                        aggregate.FocusEvents.Add(normalized);
                    aggregate.WorkEvents.Add(normalized);
                });

            return map;
        }

        /// <summary>
        /// Merges overlapping events and returns total minutes.
        /// </summary>
        private static double MergeAndSum(ICollection<NormalizedEvent> events)
        {
            if (events.Count == 0) return 0d;

            var ordered = events
                .OrderBy(e => e.StartLocal)
                .ToArray();

            var totalMinutes     = 0d;
            var currentStart     = ordered[0].StartLocal;
            var currentEnd       = ordered[0].EndLocal;

            for (int i = 1; i < ordered.Length; i++)
            {
                var e = ordered[i];

                if (e.StartLocal <= currentEnd) // Overlap
                {
                    currentEnd = Max(currentEnd, e.EndLocal);
                }
                else
                {
                    totalMinutes += (currentEnd - currentStart).TotalMinutes;
                    currentStart  = e.StartLocal;
                    currentEnd    = e.EndLocal;
                }
            }

            totalMinutes += (currentEnd - currentStart).TotalMinutes;
            return totalMinutes;
        }

        private static DateTime Max(DateTime a, DateTime b) => a > b ? a : b;

        private bool IsFocusEvent(CalendarEvent e)
        {
            if (e.ParticipantCount == 0) return true;

            return _options.FocusKeywords
                           .Any(k => e.Subject.Contains(k, StringComparison.OrdinalIgnoreCase));
        }

        #endregion
    }

    #region Support Types

    /// <summary>
    /// Options that tune the focus time computation logic.
    /// </summary>
    public sealed record FocusTimeOptions
    {
        /// <summary>
        /// Keywords considered as focus events (case-insensitive).
        /// </summary>
        public IReadOnlyCollection<string> FocusKeywords { get; init; } =
            new[] { "Focus", "Deep Work", "Coding" };

        /// <summary>
        /// Reporting window relative to <c>DateTimeOffset.UtcNow</c>.
        /// Default: last 30 days.
        /// </summary>
        public TimeSpan ReportingWindow { get; init; } = TimeSpan.FromDays(-30);
    }

    /// <summary>
    /// Basic contract for a transformation strategy in PulseOps Warehouse.
    /// </summary>
    /// <typeparam name="TSource">Incoming raw data type</typeparam>
    /// <typeparam name="TResult">Outgoing KPI/metric</typeparam>
    public interface ITransformationStrategy<in TSource, TResult>
    {
        string Name { get; }

        Task<TResult> TransformAsync(TSource source, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Simplified calendar event DTO coming from upstream Lambda ingestion.
    /// </summary>
    public sealed record CalendarEvent
    {
        public Guid Id                 { get; init; }
        public DateTimeOffset Start    { get; init; }
        public DateTimeOffset End      { get; init; }
        public string Subject          { get; init; } = string.Empty;
        public int ParticipantCount    { get; init; }
        public string OrganizerEmail   { get; init; } = string.Empty;
        public IDictionary<string,string> Metadata { get; init; } = new Dictionary<string,string>();
    }

    /// <summary>
    /// Output DTO holding a computed productivity metric.
    /// </summary>
    public sealed record ProductivityMetrics
    {
        public string MetricName                 { get; init; } = string.Empty;
        public double MetricValue                { get; init; }
        public int Samples                       { get; init; }
        public DateTime CreatedUtc               { get; init; }
        public IDictionary<string,string> Metadata { get; init; } = new Dictionary<string,string>();
    }

    private sealed class NormalizedEvent
    {
        public NormalizedEvent(DateTimeOffset startUtc, DateTimeOffset endUtc, bool isFocus)
        {
            if (endUtc <= startUtc)
                throw new ArgumentException("Event end time must be after start time.");

            StartUtc   = startUtc;
            EndUtc     = endUtc;
            IsFocus    = isFocus;

            // Convert to local time once to avoid repeated conversions
            StartLocal = startUtc.ToLocalTime().DateTime;
            EndLocal   = endUtc.ToLocalTime().DateTime;
        }

        public DateTimeOffset StartUtc { get; }
        public DateTimeOffset EndUtc   { get; }
        public bool IsFocus            { get; }

        public DateTime StartLocal { get; }
        public DateTime EndLocal   { get; }
    }

    private sealed class DailyEventAggregate
    {
        public List<NormalizedEvent> FocusEvents { get; } = new();
        public List<NormalizedEvent> WorkEvents  { get; } = new();
    }

    private sealed record DailyFocusRatio(DateOnly Workday, double Ratio);

    #endregion
}
```