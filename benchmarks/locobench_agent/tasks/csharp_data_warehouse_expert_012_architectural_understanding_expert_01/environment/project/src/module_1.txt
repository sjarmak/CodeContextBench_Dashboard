```csharp
// -------------------------------------------------------------------------------------------------
//  Project : PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//  File    : src/module_1.txt  (compiled as C# source)
//  Purpose : Core transformation engine implementing the Strategy pattern for converting raw,
//            domain-specific events (calendar, CI/CD, e-mail, SaaS telemetry …) into KPI records
//            used further downstream by the analytics pipeline.
// -------------------------------------------------------------------------------------------------

#nullable enable
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    /// <summary>
    /// Enumeration of first-class event types supported by the PulseOps Warehouse.
    /// </summary>
    public enum EventType
    {
        CalendarEvent,
        CiCdLog,
        EmailMetadata,
        SaaSProductTelemetry,
        Unknown
    }

    /// <summary>
    /// Raw event contract used at the ingestion boundary.  Payload is opaque JSON whose schema
    /// will be interpreted by the downstream transformation strategy.
    /// </summary>
    /// <param name="EventId">Globally unique identifier supplied by upstream producer.</param>
    /// <param name="Type">High-level event classification.</param>
    /// <param name="Payload">Opaque JSON document.</param>
    /// <param name="Timestamp">Producer-supplied event timestamp.</param>
    public record RawEvent(
        string          EventId,
        EventType       Type,
        string          Payload,
        DateTimeOffset  Timestamp);

    /// <summary>
    /// Normalised KPI record produced by a transformation strategy.  Stored in the data lake and
    /// later surfaced to BI/ML tools.
    /// </summary>
    /// <param name="EventId">Source event identifier for lineage tracking.</param>
    /// <param name="KpiName">Canonical KPI name (slug-style).</param>
    /// <param name="Value">Numeric KPI value.</param>
    /// <param name="GeneratedAt">UTC timestamp when KPI was generated.</param>
    public record KpiRecord(
        string         EventId,
        string         KpiName,
        double         Value,
        DateTimeOffset GeneratedAt);

    /// <summary>
    /// Base abstraction for a transformation strategy.
    /// </summary>
    internal interface ITransformationStrategy
    {
        ValueTask<IEnumerable<KpiRecord>> TransformAsync(RawEvent rawEvent, CancellationToken token);
    }

    #region Concrete Strategies --------------------------------------------------------------------

    /// <summary>
    /// Calculates meeting-cost related KPIs from raw calendar events.
    /// </summary>
    internal sealed class CalendarEventStrategy : ITransformationStrategy
    {
        private readonly ILogger _logger;

        public CalendarEventStrategy(ILogger logger) => _logger = logger;

        public async ValueTask<IEnumerable<KpiRecord>> TransformAsync(RawEvent rawEvent, CancellationToken token)
        {
            await Task.Yield();           // Ensures true async.

            using var doc = JsonDocument.Parse(rawEvent.Payload);
            var root = doc.RootElement;

            // Field presence validation
            if (!root.TryGetProperty("durationMinutes", out var durationProp) ||
                !root.TryGetProperty("attendeeCount",   out var attendeesProp))
            {
                _logger.LogWarning("Calendar event {EventId} missing expected properties.", rawEvent.EventId);
                return Array.Empty<KpiRecord>();
            }

            var duration   = durationProp.GetInt32();   // minutes
            var attendees  = attendeesProp.GetInt32();
            var hourlyRate = root.GetProperty("averageCostPerHour").GetDouble(); // USD

            // Meeting cost = attendees * time(hours) * hourlyRate
            var cost = attendees * (duration / 60d) * hourlyRate;

            return new[]
            {
                new KpiRecord(
                    rawEvent.EventId,
                    KpiName: "meeting_cost_usd",
                    Value:   Math.Round(cost, 2),
                    GeneratedAt: DateTimeOffset.UtcNow)
            };
        }
    }

    /// <summary>
    /// Computes deployment lead-time KPI from CI/CD pipeline events.
    /// </summary>
    internal sealed class CiCdLogStrategy : ITransformationStrategy
    {
        private readonly ILogger _logger;

        public CiCdLogStrategy(ILogger logger) => _logger = logger;

        public async ValueTask<IEnumerable<KpiRecord>> TransformAsync(RawEvent rawEvent, CancellationToken token)
        {
            await Task.Yield();

            using var doc = JsonDocument.Parse(rawEvent.Payload);

            var start = doc.RootElement.GetProperty("pipelineStartUtc").GetDateTimeOffset();
            var end   = doc.RootElement.GetProperty("pipelineEndUtc").GetDateTimeOffset();

            var leadTimeMinutes = (end - start).TotalMinutes;

            return new[]
            {
                new KpiRecord(
                    rawEvent.EventId,
                    "deployment_lead_time_minutes",
                    leadTimeMinutes,
                    DateTimeOffset.UtcNow)
            };
        }
    }

    /// <summary>
    /// Fallback strategy that intentionally produces no KPI records for unrecognized events.
    /// </summary>
    internal sealed class NullStrategy : ITransformationStrategy
    {
        public static readonly NullStrategy Instance = new();

        private NullStrategy() { }

        public ValueTask<IEnumerable<KpiRecord>> TransformAsync(RawEvent rawEvent, CancellationToken token) =>
            ValueTask.FromResult<IEnumerable<KpiRecord>>(Array.Empty<KpiRecord>());
    }

    #endregion

    #region Factory & Registry ---------------------------------------------------------------------

    /// <summary>
    /// Thread-safe factory/registry responsible for returning strategy singletons based on event
    /// type.  Uses a <see cref="ConcurrentDictionary{TKey,TValue}"/> for minimal allocation
    /// overhead while remaining Lambda-cold-start friendly.
    /// </summary>
    internal sealed class TransformationStrategyFactory
    {
        private readonly ILoggerFactory _loggerFactory;
        private readonly ConcurrentDictionary<EventType, ITransformationStrategy> _cache = new();

        public TransformationStrategyFactory(ILoggerFactory loggerFactory) =>
            _loggerFactory = loggerFactory ?? throw new ArgumentNullException(nameof(loggerFactory));

        public ITransformationStrategy Resolve(EventType eventType) =>
            _cache.GetOrAdd(eventType, Create);

        private ITransformationStrategy Create(EventType eventType) =>
            eventType switch
            {
                EventType.CalendarEvent        => new CalendarEventStrategy(_loggerFactory.CreateLogger<CalendarEventStrategy>()),
                EventType.CiCdLog              => new CiCdLogStrategy(_loggerFactory.CreateLogger<CiCdLogStrategy>()),
                _                              => NullStrategy.Instance
            };
    }

    #endregion

    /// <summary>
    /// Public façade orchestrating the transformation workflow.  Designed to be DI-friendly and
    /// Lambda-safe (stateless, thread-safe).
    /// </summary>
    public sealed class TransformationEngine
    {
        private readonly TransformationStrategyFactory _factory;
        private readonly ILogger<TransformationEngine> _logger;

        public TransformationEngine(ILoggerFactory loggerFactory)
        {
            if (loggerFactory is null) throw new ArgumentNullException(nameof(loggerFactory));

            _factory = new TransformationStrategyFactory(loggerFactory);
            _logger  = loggerFactory.CreateLogger<TransformationEngine>();
        }

        /// <summary>
        /// Entry point invoked by the Lambda handler or Step-Functions task.
        /// </summary>
        /// <exception cref="OperationCanceledException">If the operation is externally cancelled.</exception>
        public async Task<IEnumerable<KpiRecord>> ExecuteAsync(RawEvent rawEvent, CancellationToken ct = default)
        {
            if (rawEvent is null) throw new ArgumentNullException(nameof(rawEvent));

            ct.ThrowIfCancellationRequested();

            var strategy = _factory.Resolve(rawEvent.Type);

            if (strategy is NullStrategy)
            {
                _logger.LogInformation("No transformation strategy registered for event type '{EventType}'. EventId: {EventId}",
                    rawEvent.Type, rawEvent.EventId);
                return Array.Empty<KpiRecord>();
            }

            try
            {
                var kpis = await strategy.TransformAsync(rawEvent, ct);
                _logger.LogDebug("Generated {KpiCount} KPI record(s) from event {EventId}.", kpis switch { null => 0, var c => c is ICollection<KpiRecord> col ? col.Count : 1 }, rawEvent.EventId);
                return kpis;
            }
            catch (JsonException jex)
            {
                _logger.LogWarning(jex, "Malformed JSON payload for event {EventId}.", rawEvent.EventId);
                // Down-stream components treat empty KPI set as transient parse error; event will be shunted to DLQ by caller.
                return Array.Empty<KpiRecord>();
            }
            catch (Exception ex) when (!ex.IsFatal())
            {
                _logger.LogError(ex, "Unhandled error while transforming event {EventId}.", rawEvent.EventId);
                throw; // Escalate to calling Lambda for DLQ routing.
            }
        }
    }

    #region Helper Extensions ----------------------------------------------------------------------

    internal static class ExceptionExtensions
    {
        /// <summary>
        /// Indicates whether the exception is considered fatal and therefore should not be caught.
        /// </summary>
        public static bool IsFatal(this Exception ex) =>
            ex is OutOfMemoryException or StackOverflowException or AccessViolationException;
    }

    #endregion
}
```