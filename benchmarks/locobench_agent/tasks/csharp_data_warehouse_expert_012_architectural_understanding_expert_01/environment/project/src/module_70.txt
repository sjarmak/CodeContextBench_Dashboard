```csharp
// File: src/module_70.txt  (intentionally kept .txt as required by legacy build tooling)
//
// Description:
//     This module wires up the KPI–Transformation Strategy pipeline used by downstream
//     Lambda functions.  It exposes a registry that can discover, cache and execute
//     all IKpiStrategy implementations registered with the IoC container.  The code
//     honours SOLID principles, includes structured logging, and is thread-safe.
//
// NOTE:
//     The rest of the code-base will reference this file via <Compile Include="src\module_70.txt" />
//     so do not rename it to *.cs unless you also update the project file.
//

#pragma warning disable CA1031 // We log-and-swallow by design inside StrategyRegistry to prevent KPI fan-out failures from cascading.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.KpiEngine
{
    #region Public Contracts ─────────────────────────────────────────────────────────────

    /// <summary>
    ///     Represents a single, calculated KPI value along with contextual metadata.
    /// </summary>
    public sealed record KpiResult(
        string            KpiName,
        double            Value,
        string            Dimension, // e.g. "Team", "Repository", "Employee"
        DateTimeOffset    TimestampUtc,
        IReadOnlyDictionary<string, string> Tags);

    /// <summary>
    ///     Enumeration of the supported KPI categories.  The enum acts as a stable, type-safe
    ///     contract across Lambda micro-components.
    /// </summary>
    public enum KpiType
    {
        FocusTimeRatio,
        DeploymentLeadTime,
        MeetingCostIndex
    }

    /// <summary>
    ///     A raw input record coming out of the staging S3 bucket after validation.
    ///     Only the fields required for KPI computation are retained.
    /// </summary>
    public sealed record ProductivityFact(
        string         EmployeeId,
        DateTimeOffset StartTimeUtc,
        DateTimeOffset EndTimeUtc,
        string         ActivityType,  // CalendarEvent, CodingSession, CIJob, etc.
        IReadOnlyDictionary<string, string> Attributes);

    /// <summary>
    ///     Common strategy contract; each KPI has one dedicated implementation.
    /// </summary>
    public interface IKpiStrategy
    {
        /// <summary>Which KPI does this strategy compute?</summary>
        KpiType Kpi { get; }

        /// <summary>
        ///     Computes a KPI value from a batch of productivity facts.  The method is expected
        ///     to be pure (side-effect free) and thread-safe.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        ///     Thrown when the incoming facts violate a pre-condition required by the algorithm.
        /// </exception>
        KpiResult Compute(IReadOnlyCollection<ProductivityFact> facts);
    }

    #endregion

    #region Strategy Implementations ─────────────────────────────────────────────────────

    /// <summary>
    ///     Computes the ratio between "focus" (maker) time and total working time for an
    ///     employee on the granularity of a single day.
    /// </summary>
    internal sealed class FocusTimeRatioStrategy : IKpiStrategy
    {
        private readonly ILogger<FocusTimeRatioStrategy> _logger;
        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger) => _logger = logger;
        public KpiType Kpi => KpiType.FocusTimeRatio;

        public KpiResult Compute(IReadOnlyCollection<ProductivityFact> facts)
        {
            if (facts.Count == 0)
            {
                _logger.LogWarning("Focus-time computation received an empty fact set.");
                throw new InvalidOperationException("Cannot compute FocusTimeRatio on empty fact set.");
            }

            var focusMinutes = facts
                .Where(f => IsFocusActivity(f.ActivityType))
                .Sum(f => (f.EndTimeUtc - f.StartTimeUtc).TotalMinutes);

            var totalMinutes = facts
                .Where(f => f.ActivityType != "OffDuty")
                .Sum(f => (f.EndTimeUtc - f.StartTimeUtc).TotalMinutes);

            if (totalMinutes <= 0)
            {
                _logger.LogWarning("Total working minutes evaluated to {TotalMinutes}; expected positive value.", totalMinutes);
                throw new InvalidOperationException("Invalid total working minutes for FocusTimeRatio.");
            }

            var ratio = focusMinutes / totalMinutes;

            var sample = facts.First();
            var dimension = sample.Attributes.TryGetValue("Team", out var team) ? team : "unknown";

            return new KpiResult(
                KpiName   : Kpi.ToString(),
                Value     : Math.Round(ratio, digits: 4),
                Dimension : dimension,
                TimestampUtc: DateTimeOffset.UtcNow,
                Tags      : new Dictionary<string, string>
                {
                    ["EmployeeId"]   = sample.EmployeeId,
                    ["FocusMinutes"] = focusMinutes.ToString(CultureInfo.InvariantCulture),
                    ["TotalMinutes"] = totalMinutes.ToString(CultureInfo.InvariantCulture)
                });
        }

        private static bool IsFocusActivity(string activityType) =>
            activityType is "CodingSession" or "DesignDocEditing" or "CodeReview";
    }

    /// <summary>
    ///     Computes deployment lead-time measured from first commit in a pull-request
    ///     until the artifact is successfully deployed to production.
    /// </summary>
    internal sealed class DeploymentLeadTimeStrategy : IKpiStrategy
    {
        private readonly ILogger<DeploymentLeadTimeStrategy> _logger;
        public DeploymentLeadTimeStrategy(ILogger<DeploymentLeadTimeStrategy> logger) => _logger = logger;
        public KpiType Kpi => KpiType.DeploymentLeadTime;

        public KpiResult Compute(IReadOnlyCollection<ProductivityFact> facts)
        {
            var commits = facts.Where(f => f.ActivityType == "GitCommit").ToList();
            var prodDeploys = facts.Where(f => f.ActivityType == "ProdDeploy").ToList();

            if (!commits.Any() || !prodDeploys.Any())
            {
                _logger.LogInformation("No relevant facts for computing DeploymentLeadTime.");
                throw new InvalidOperationException("Missing commit or deploy events.");
            }

            var firstCommitTs = commits.Min(f => f.StartTimeUtc);
            var firstProdDeployTs = prodDeploys.Min(f => f.EndTimeUtc);

            if (firstProdDeployTs < firstCommitTs)
            {
                _logger.LogWarning("Prod deploy earlier than commit; discarding data.");
                throw new InvalidOperationException("Invalid chronological order for DeploymentLeadTime.");
            }

            var leadTimeHours = (firstProdDeployTs - firstCommitTs).TotalHours;

            return new KpiResult(
                KpiName   : Kpi.ToString(),
                Value     : Math.Round(leadTimeHours, digits: 2),
                Dimension : "Repository",
                TimestampUtc: DateTimeOffset.UtcNow,
                Tags      : new Dictionary<string, string>
                {
                    ["Commits"]    = commits.Count.ToString(CultureInfo.InvariantCulture),
                    ["Deployments"]= prodDeploys.Count.ToString(CultureInfo.InvariantCulture),
                    ["LeadTimeHrs"]= leadTimeHours.ToString(CultureInfo.InvariantCulture)
                });
        }
    }

    /// <summary>
    ///     Estimates the net salary cost of meetings for a given team by multiplying
    ///     the duration with median hourly compensation figure fetched from HRIS.
    /// </summary>
    internal sealed class MeetingCostIndexStrategy : IKpiStrategy
    {
        private readonly ILogger<MeetingCostIndexStrategy> _logger;
        private readonly ICompensationProvider            _compProvider;

        public MeetingCostIndexStrategy(
            ILogger<MeetingCostIndexStrategy> logger,
            ICompensationProvider             compProvider)
        {
            _logger       = logger;
            _compProvider = compProvider;
        }

        public KpiType Kpi => KpiType.MeetingCostIndex;

        public KpiResult Compute(IReadOnlyCollection<ProductivityFact> facts)
        {
            var meetings = facts.Where(f => f.ActivityType == "CalendarEvent").ToList();
            if (!meetings.Any())
            {
                _logger.LogInformation("No meeting facts supplied.");
                throw new InvalidOperationException("Cannot compute MeetingCostIndex without meetings.");
            }

            var totalMinutes = meetings.Sum(m => (m.EndTimeUtc - m.StartTimeUtc).TotalMinutes);
            var employeeIds  = meetings.Select(m => m.EmployeeId).Distinct().ToList();

            var medianHourlyRate = _compProvider.GetMedianHourlyRate(employeeIds);
            var costUsd          = (totalMinutes / 60.0) * medianHourlyRate;

            return new KpiResult(
                KpiName   : Kpi.ToString(),
                Value     : Math.Round(costUsd, digits: 2),
                Dimension : "Team",
                TimestampUtc: DateTimeOffset.UtcNow,
                Tags      : new Dictionary<string, string>
                {
                    ["MeetingMinutes"] = totalMinutes.ToString(CultureInfo.InvariantCulture),
                    ["MedianHrRate"]   = medianHourlyRate.ToString(CultureInfo.InvariantCulture),
                    ["Employees"]      = employeeIds.Count.ToString(CultureInfo.InvariantCulture)
                });
        }
    }

    #endregion

    #region Infrastructure Helpers ───────────────────────────────────────────────────────

    /// <summary>
    ///     Returns median hourly compensation for a group of employees.  The implementation can
    ///     be swapped at runtime (Strategy pattern) to pull data from different HR systems.
    /// </summary>
    public interface ICompensationProvider
    {
        double GetMedianHourlyRate(IReadOnlyCollection<string> employeeIds);
    }

    internal sealed class DummyCompensationProvider : ICompensationProvider
    {
        public double GetMedianHourlyRate(IReadOnlyCollection<string> employeeIds) => 75.0;
    }

    #endregion

    #region Strategy Registry ────────────────────────────────────────────────────────────

    /// <summary>
    ///     Thread-safe registry that stores available strategies and delegates the computation
    ///     request to the matching handler.  The registry logs failures but continues processing
    ///     remaining strategies to maximise metric coverage.
    /// </summary>
    public sealed class StrategyRegistry
    {
        private readonly ILogger<StrategyRegistry>                     _logger;
        private readonly ConcurrentDictionary<KpiType, IKpiStrategy>   _strategies;

        public StrategyRegistry(
            IEnumerable<IKpiStrategy>  strategies,
            ILogger<StrategyRegistry>  logger)
        {
            _logger     = logger;
            _strategies = new ConcurrentDictionary<KpiType, IKpiStrategy>(
                strategies.ToDictionary(s => s.Kpi, s => s));
        }

        /// <summary>
        ///     Computes all registered KPIs.  Strategies that throw will be recorded in logs but
        ///     not propagated upwards to preserve partial success semantics.
        /// </summary>
        public IReadOnlyCollection<KpiResult> ComputeAll(IReadOnlyCollection<ProductivityFact> facts)
        {
            var results = new List<KpiResult>(_strategies.Count);
            foreach (var (kpi, strategy) in _strategies)
            {
                try
                {
                    _logger.LogDebug("Computing KPI {Kpi} using {Strategy}.", kpi, strategy.GetType().Name);
                    var result = strategy.Compute(facts);
                    results.Add(result);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "KPI computation failed for {Kpi}; continuing with next strategy.", kpi);
                }
            }

            if (results.Count == 0)
            {
                _logger.LogWarning("No KPI results produced for the current batch.");
            }

            return results;
        }

        /// <summary>
        ///     Returns true if the registry recognises the KPI.
        /// </summary>
        public bool Contains(KpiType kpi) => _strategies.ContainsKey(kpi);
    }

    #endregion
}

#pragma warning restore CA1031
```