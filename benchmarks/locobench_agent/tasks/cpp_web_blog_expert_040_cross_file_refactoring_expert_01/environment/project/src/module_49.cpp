#include <algorithm>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <exception>
#include <functional>
#include <future>
#include <memory>
#include <mutex>
#include <optional>
#include <stdexcept>
#include <string>
#include <thread>
#include <utility>
#include <vector>

#include <spdlog/spdlog.h>

namespace intra_ledger::blog {

// ============================================================================
// Forward declarations of Repository / Service abstractions.  In the real
// code-base these are provided by other translation units generated by the ORM
// and the Service-Layer modules.
// ============================================================================

struct Post final
{
    std::uint64_t                         id            {0};
    std::string                           slug;
    std::string                           title;
    std::string                           body_markdown;
    std::chrono::system_clock::time_point scheduled_at;   // UTC
    std::chrono::system_clock::time_point published_at;   // UTC
    bool                                  published      {false};

    [[nodiscard]] bool isDue(const std::chrono::system_clock::time_point& now) const
    {
        return !published && scheduled_at <= now;
    }
};

struct IPostRepository
{
    virtual ~IPostRepository() = default;

    // Returns posts scheduled for publishing that are due up to |until|.
    virtual std::vector<Post> fetchScheduledPostsDue(
        const std::chrono::system_clock::time_point& until,
        std::size_t                                   limit) = 0;

    // Publishes the post (updates DB) and returns the new record (with DB-side
    // timestamps filled).
    virtual Post publishPost(std::uint64_t postId) = 0;
};

struct IMailService
{
    virtual ~IMailService() = default;

    // Broadcasts "new post" e-mails to subscribers. Implementation is async and
    // may enqueue additional jobs.
    virtual void notifySubscribers(const Post& post) = 0;
};

struct ISearchIndexer
{
    virtual ~ISearchIndexer() = default;

    // Pushes updated article into the search index.
    virtual void reindex(const Post& post) = 0;
};

// ============================================================================
// Scheduled Publishing Service
// ============================================================================

class ScheduledPublishService
{
public:
    struct Config
    {
        std::size_t          batchSize    {32};
        std::chrono::seconds pollInterval {std::chrono::seconds{30}};
    };

    ScheduledPublishService(std::shared_ptr<IPostRepository> repo,
                            std::shared_ptr<IMailService>   mailer,
                            std::shared_ptr<ISearchIndexer> indexer,
                            Config                           cfg = {})
        : m_repo{std::move(repo)}
        , m_mailer{std::move(mailer)}
        , m_indexer{std::move(indexer)}
        , m_cfg{cfg}
    {
        if (!m_repo || !m_mailer || !m_indexer)
        {
            throw std::invalid_argument(
                "ScheduledPublishService requires non-null dependencies");
        }
    }

    // Polls the DB once and publishes all due posts (up to batch size).
    // Returns number of posts published.
    std::size_t publishDuePosts()
    {
        using clock = std::chrono::system_clock;

        const auto now = clock::now();
        const auto due =
            m_repo->fetchScheduledPostsDue(now, m_cfg.batchSize);

        std::size_t publishedCount = 0;
        for (const auto& post : due)
        {
            try
            {
                auto updated = m_repo->publishPost(post.id);

                // Leave subsequent tasks (mailer + indexer) in parallel where
                // possible.
                publishSideEffectsAsync(updated);

                ++publishedCount;
                SPDLOG_INFO("Published scheduled post id={} slug='{}'",
                            updated.id,
                            updated.slug);
            }
            catch (const std::exception& ex)
            {
                SPDLOG_ERROR(
                    "Failed to publish scheduled post id={} reason={}",
                    post.id,
                    ex.what());
            }
            catch (...)
            {
                SPDLOG_ERROR("Unknown failure while publishing post id={}",
                             post.id);
            }
        }
        return publishedCount;
    }

    // Starts the long-running polling loop in a dedicated thread.
    void start()
    {
        std::scoped_lock lk{m_stateMutex};
        if (m_running)
            return;

        m_running = true;
        m_worker  = std::thread([this] { this->runLoop(); });
    }

    // Requests shutdown and joins worker thread (blocking).
    void stop()
    {
        {
            std::scoped_lock lk{m_stateMutex};
            if (!m_running)
                return;
            m_running = false;
        }

        m_cv.notify_all();
        if (m_worker.joinable())
            m_worker.join();
    }

    ~ScheduledPublishService() { stop(); }

    ScheduledPublishService(const ScheduledPublishService&) = delete;
    ScheduledPublishService& operator=(const ScheduledPublishService&) = delete;

private:
    void runLoop()
    {
        SPDLOG_INFO("ScheduledPublishService worker started");
        while (waitNextPoll())
        {
            std::size_t done = publishDuePosts();
            if (done > 0)
            {
                SPDLOG_DEBUG("ScheduledPublishService handled {} posts", done);
            }
        }
        SPDLOG_INFO("ScheduledPublishService worker stopped");
    }

    // Waits until it's time for next poll or until stop() is called.
    bool waitNextPoll()
    {
        std::unique_lock lk{m_stateMutex};

        if (!m_running)
            return false;

        // Wake earlier if stop() is called.
        const auto status =
            m_cv.wait_for(lk, m_cfg.pollInterval, [this] { return !m_running; });
        return !status; // status==true means predicate triggered -> stop.
    }

    void publishSideEffectsAsync(const Post& post)
    {
        // Email notification â€“ can take seconds or minutes if queue is long.
        std::async(std::launch::async, [mailer = m_mailer, post] {
            try
            {
                mailer->notifySubscribers(post);
            }
            catch (const std::exception& ex)
            {
                SPDLOG_ERROR(
                    "notifySubscribers failed for post id={} reason={}",
                    post.id,
                    ex.what());
            }
        });

        // Reindex is usually fast but may still take a while.
        std::async(std::launch::async, [indexer = m_indexer, post] {
            try
            {
                indexer->reindex(post);
            }
            catch (const std::exception& ex)
            {
                SPDLOG_ERROR("reindex failed for post id={} reason={}",
                             post.id,
                             ex.what());
            }
        });
    }

private:
    const std::shared_ptr<IPostRepository> m_repo;
    const std::shared_ptr<IMailService>    m_mailer;
    const std::shared_ptr<ISearchIndexer>  m_indexer;
    const Config                           m_cfg;

    std::atomic_bool m_running {false};
    std::thread      m_worker;

    std::condition_variable m_cv;
    std::mutex              m_stateMutex;
};

// ============================================================================
// Example stub implementations
// ----------------------------------------------------------------------------
// These stubs provide minimal behaviour to ensure the TU is linkable in unit
// tests that do not mock every dependency.  They would be replaced by real
// production implementations through dependency injection.
// ============================================================================

namespace stub {

class PostRepositoryFinal : public IPostRepository
{
public:
    std::vector<Post> fetchScheduledPostsDue(const std::chrono::system_clock::time_point& until,
                                             std::size_t /*limit*/) override
    {
        std::lock_guard lk {m_mtx};

        std::vector<Post> due;
        due.reserve(m_posts.size());
        for (const auto& p : m_posts)
        {
            if (p.isDue(until))
                due.push_back(p);
        }
        return due;
    }

    Post publishPost(std::uint64_t postId) override
    {
        std::lock_guard lk {m_mtx};

        auto it = std::find_if(m_posts.begin(),
                               m_posts.end(),
                               [postId](const Post& p) { return p.id == postId; });
        if (it == m_posts.end())
            throw std::runtime_error("post not found");

        it->published     = true;
        it->published_at  = std::chrono::system_clock::now();
        return *it;
    }

    // helpers for tests
    void addPost(Post p)
    {
        std::lock_guard lk {m_mtx};
        m_posts.push_back(std::move(p));
    }

private:
    std::vector<Post> m_posts;
    std::mutex        m_mtx;
};

class NoopMailService final : public IMailService
{
public:
    void notifySubscribers(const Post& post) override
    {
        SPDLOG_DEBUG("NoopMailService::notifySubscribers for post id={}", post.id);
    }
};

class NoopSearchIndexer final : public ISearchIndexer
{
public:
    void reindex(const Post& post) override
    {
        SPDLOG_DEBUG("NoopSearchIndexer::reindex post id={}", post.id);
    }
};

} // namespace stub

} // namespace intra_ledger::blog