```cpp
/**
 *  src/module_69.cpp
 *
 *  IntraLedger BlogSuite – SlugService
 *  -----------------------------------
 *  Generates SEO-friendly, collision-free URL slugs for articles, pages,
 *  and other publicly exposed entities.  The implementation takes care of
 *  basic transliteration, whitespace normalization, de-duplication against
 *  already-persisted records, and a fast in-process cache to mitigate
 *  redundant repository round-trips.
 *
 *  The component belongs to the Service Layer and must therefore defer
 *  persistence concerns to the Repository.  It is intentionally free of
 *  direct SQL or ORM code so that it can be reused in unit tests without a
 *  database backend.
 */

#include <algorithm>
#include <chrono>
#include <cctype>
#include <exception>
#include <mutex>
#include <regex>
#include <shared_mutex>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>
#include <unordered_set>

#if defined(BLOGSUITE_ENABLE_SPDLOG)
    #include <spdlog/spdlog.h>
#else
    /*  Lightweight log fall-backs so that this TU can compile
        outside of the full BlogSuite build environment                                */
    #include <iostream>
    #define BLOGSUITE_LOG_INFO(msg)  (std::cerr << "[INFO]  "  << msg << '\n')
    #define BLOGSUITE_LOG_WARN(msg)  (std::cerr << "[WARN]  "  << msg << '\n')
    #define BLOGSUITE_LOG_ERROR(msg) (std::cerr << "[ERROR] " << msg << '\n')
#endif

namespace intraledger::service {

/* ────────────────────────────────────────────────────────────────────────── */
/*  SlugGenerationError                                                     */
/* ────────────────────────────────────────────────────────────────────────── */

class SlugGenerationError final : public std::runtime_error
{
public:
    explicit SlugGenerationError(const std::string &msg)
        : std::runtime_error(msg) {}
};

/* ────────────────────────────────────────────────────────────────────────── */
/*  Repository Contract                                                     */
/* ────────────────────────────────────────────────────────────────────────── */

/**
 *  ArticleRepository
 *
 *  A minimal repository interface.  In production builds the actual
 *  implementation is auto-generated by the ORM (e.g., sqlpp11) and injected
 *  at runtime.  For the sake of portability, this file only references the
 *  contract and does not attempt to instantiate real database connections.
 */
class ArticleRepository
{
public:
    virtual ~ArticleRepository() = default;

    /**
     *  Checks whether a slug already exists for any entry belonging to the
     *  current tenant.  Must be side-effect free.
     */
    virtual bool slugExists(const std::string &slug) const = 0;
};

/* ────────────────────────────────────────────────────────────────────────── */
/*  In-Process TTL Cache                                                    */
/* ────────────────────────────────────────────────────────────────────────── */

/**
 *  A very small, lock-free (readers) TTL cache for recently generated slugs.
 *  Synchronisation happens only on writes, which keeps hot-path lookups
 *  contention-free.
 */
class SlugCache final
{
public:
    using Clock = std::chrono::steady_clock;

    explicit SlugCache(
        std::chrono::seconds ttl            = std::chrono::seconds{300},
        std::size_t          max_elements   = 8'192)
        : m_ttl(ttl), m_maxElements(max_elements) {}

    bool contains(const std::string &slug) const
    {
        const auto now = Clock::now();
        std::shared_lock lock(m_mtx);
        auto it = m_store.find(slug);
        return it != m_store.end() && now - it->second < m_ttl;
    }

    void insert(const std::string &slug)
    {
        const auto now = Clock::now();
        std::unique_lock lock(m_mtx);

        if (m_store.size() >= m_maxElements) {
            purgeUnlocked(now);
        }
        m_store[slug] = now;
    }

private:
    void purgeUnlocked(Clock::time_point now)
    {
        for (auto it = m_store.begin(); it != m_store.end();) {
            if (now - it->second > m_ttl) {
                it = m_store.erase(it);
            } else {
                ++it;
            }
        }
    }

    const std::chrono::seconds                      m_ttl;
    const std::size_t                               m_maxElements;
    mutable std::shared_mutex                       m_mtx;
    std::unordered_map<std::string, Clock::time_point> m_store;
};

/* ────────────────────────────────────────────────────────────────────────── */
/*  SlugService                                                             */
/* ────────────────────────────────────────────────────────────────────────── */

class SlugService final
{
public:
    explicit SlugService(ArticleRepository &repo,
                         std::size_t        max_iterations = 64)
        : m_repo(repo)
        , m_cache()
        , m_maxIterations(max_iterations)
    {
        if (max_iterations == 0U) {
            throw std::invalid_argument("max_iterations must be >= 1");
        }
    }

    /**
     *  Generates a unique slug.  Will throw after `m_maxIterations` attempts
     *  if every generated candidate collided—which in practice can only happen
     *  when an attacker deliberately spams the system with slug look-alikes.
     */
    [[nodiscard]]
    std::string createUniqueSlug(std::string_view title)
    {
        if (title.empty()) {
            throw SlugGenerationError("cannot create slug from empty title");
        }

        auto baseSlug = normalise(title);
        if (baseSlug.empty()) {
            // Title consists solely of unsupported characters
            baseSlug = "post";
        }

        std::string candidate = baseSlug;
        for (std::size_t counter = 0; counter < m_maxIterations; ++counter) {

            // Short-circuit if we already generated this slug during the
            // lifetime of the current process.
            if (m_cache.contains(candidate)) {
                candidate = baseSlug + "-" + std::to_string(counter + 1);
                continue;
            }

            // Ask repository for confirmation.
            const bool exists = safeRepoCheck(candidate);
            if (!exists) {
                m_cache.insert(candidate);
                return candidate;
            }

            candidate = baseSlug + "-" + std::to_string(counter + 1);
        }

        throw SlugGenerationError(
            "failed to generate unique slug after "
            + std::to_string(m_maxIterations) + " attempts"
        );
    }

private:
    /* Normalises arbitrary strings into slug-friendly ASCII. */
    static std::string normalise(std::string_view input)
    {
        // 1. Basic ASCII transliteration – non-ASCII bytes are removed.
        std::string asciiOnly;
        asciiOnly.reserve(input.size());

        for (unsigned char ch : input) {
            if (std::isalnum(ch) || std::isspace(ch) || ch == '-') {
                asciiOnly.push_back(static_cast<char>(std::tolower(ch)));
            }
            // skip every other character (poor man’s transliteration)
        }

        // 2. Collapse whitespace & hyphens to single hyphen
        static const std::regex kCollapse{R"(([\s\-])+)"};
        std::string collapsed = std::regex_replace(asciiOnly, kCollapse, "-");

        // 3. Strip leading / trailing hyphens
        auto trim = [](std::string &s)
        {
            while (!s.empty() && s.front() == '-') s.erase(s.begin());
            while (!s.empty() && s.back()  == '-') s.pop_back();
        };
        trim(collapsed);

        return collapsed;
    }

    bool safeRepoCheck(const std::string &slug) noexcept
    {
        try {
            return m_repo.slugExists(slug);
        } catch (const std::exception &ex) {
            BLOGSUITE_LOG_ERROR(
                "SlugService::safeRepoCheck – repository failure: " << ex.what());
            // Fail closed by assuming the slug exists; this prevents us from
            // issuing duplicate slugs if the DB is in an inconsistent state.
            return true;
        }
    }

    ArticleRepository &m_repo;
    SlugCache          m_cache;
    const std::size_t  m_maxIterations;
};

/* ────────────────────────────────────────────────────────────────────────── */
/*  Example Stub (to compile in isolation)                                  */
/* ────────────────────────────────────────────────────────────────────────── */

#ifdef BLOGSUITE_STANDALONE_TEST

#include <cassert>
#include <iostream>

class InMemoryArticleRepository final : public ArticleRepository
{
public:
    bool slugExists(const std::string &slug) const override
    {
        return m_slugs.find(slug) != m_slugs.end();
    }

    void addSlug(const std::string &slug) { m_slugs.insert(slug); }

private:
    std::unordered_set<std::string> m_slugs;
};

int main()
{
    InMemoryArticleRepository repo;
    repo.addSlug("hello-world");

    SlugService svc(repo);

    const std::string slug1 = svc.createUniqueSlug("Hello World");
    const std::string slug2 = svc.createUniqueSlug("Hello  World!");

    assert(slug1 == "hello-world-1");
    assert(slug2 == "hello-world-2");

    std::cout << "Slug generation OK: "
              << slug1 << ", " << slug2 << '\n';

    return 0;
}
#endif // BLOGSUITE_STANDALONE_TEST

} // namespace intraledger::service
```