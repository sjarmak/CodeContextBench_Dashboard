```rust
//! module_15 – Shared DTOs, pagination helpers and caching hints
//!
//! This module sits at the “VM layer”, acting as a bridge between external
//! request payloads (REST / GraphQL) and the domain layer.  It offers:
//! • Strongly-typed query DTOs with field-level validation  
//! • A generic Paginated<T> wrapper that carries meta information used by the
//!   HTTP and GraphQL transports (links, cursors, record counts, cache hints)  
//! • Thin abstractions that repositories and service handlers can leverage to
//!   avoid duplicating boiler-plate pagination code.
//!
//! The code has no direct dependency on a particular storage backend; it is
//! therefore reused by both PostgreSQL and Redis implementations.

#![allow(clippy::module_name_repetitions)]

use std::time::Duration;

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use uuid::Uuid;
use validator::{Validate, ValidationError};

/// Default items per page if the client omits the `limit` parameter.
///
/// NOTE: We keep this low to discourage large un-cached result sets
///       that would pressure the database memory footprint.
pub const DEFAULT_LIMIT: u16 = 50;
/// Hard upper-bound accepted by the API for the `limit` query parameter.
pub const MAX_LIMIT: u16 = 500;

/// Represents the high-level cache policy the handler has determined.
/// Down-stream layers (GraphQL/REST responders, CDN, reverse proxy) may
/// translate this into appropriate cache-control headers.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum CacheDirective {
    /// The response is safe to store for the given TTL.
    Public { ttl: Duration },
    /// The response is user-specific and must not be shared.
    Private { ttl: Duration },
    /// Never cache – dynamic or sensitive content.
    NoCache,
}

impl Default for CacheDirective {
    fn default() -> Self {
        // Safe default: avoid serving stale or private data by accident.
        Self::NoCache
    }
}

/// Query DTO used by both REST query strings and GraphQL arguments.
///
/// All public endpoints that list ledger entries share these filters.
#[derive(Debug, Clone, Deserialize, Validate)]
pub struct LedgerEntryQueryDto {
    /// Zero-based page index. Optional when `cursor` is used.
    #[validate(range(min = 0, max = 1_000_000))]
    pub page: Option<u32>,

    /// Number of records per page.
    #[validate(range(min = 1, max = MAX_LIMIT as u64))]
    pub limit: Option<u16>,

    /// Alternative to page/limit pagination: points to the next record id.
    #[serde(default)]
    pub cursor: Option<Uuid>,

    /// ISO-8601 lower bound for the entry date.
    #[serde(default)]
    pub from_date: Option<DateTime<Utc>>,

    /// ISO-8601 upper bound for the entry date.
    #[serde(default)]
    pub to_date: Option<DateTime<Utc>>,

    /// Filter on account scope (multi-tenant).
    #[validate(length(min = 1))]
    #[serde(default)]
    pub account_id: Option<String>,
}

impl LedgerEntryQueryDto {
    /// Resolve effective limit taking defaults and user input into account.
    #[must_use]
    pub fn effective_limit(&self) -> u16 {
        self.limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT)
    }
}

/// Metadata returned alongside a record page.
#[derive(Debug, Clone, Serialize)]
pub struct PageInfo {
    pub total_records: Option<u64>,
    pub current_page: Option<u32>,
    pub per_page: Option<u16>,
    pub next_cursor: Option<Uuid>,
    pub has_more: bool,
}

/// Generic paginated response wrapper.
///
/// The struct purposefully keeps a generic `T` without any trait bounds so it
/// can hold both domain entities and view-model structs.
#[derive(Debug, Clone, Serialize)]
pub struct Paginated<T> {
    pub data: Vec<T>,
    pub page_info: PageInfo,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache: Option<CacheDirective>,
}

impl<T> Paginated<T> {
    #[must_use]
    pub fn new(data: Vec<T>, page_info: PageInfo) -> Self {
        Self {
            data,
            page_info,
            cache: None,
        }
    }

    /// Attach a cache hint that upper layers can translate into headers.
    #[must_use]
    pub fn with_cache(mut self, cache: CacheDirective) -> Self {
        self.cache = Some(cache);
        self
    }
}

/// Error variant that wraps validation failures alongside our own domain
/// errors so callers can rely on a single Result<T, VMError> type.
#[derive(Debug, Error)]
pub enum VmError {
    #[error("validation failed: {0}")]
    Validation(String),

    #[error(transparent)]
    Internal(#[from] anyhow::Error),
}

impl From<validator::ValidationErrors> for VmError {
    fn from(fe: validator::ValidationErrors) -> Self {
        VmError::Validation(fe.to_string())
    }
}

/// Repository abstraction that supports cursor & offset pagination.
///
/// Service code SHOULD depend on this trait rather than concrete structs to
/// keep business logic portable across Postgres/Redis/mock implementations.
#[async_trait]
pub trait LedgerEntryRepository {
    type Entity;

    /// Fetch a slice of ledger entries using page-based pagination.
    async fn list_by_page(
        &self,
        query: &LedgerEntryQueryDto,
    ) -> Result<Paginated<Self::Entity>, anyhow::Error>;

    /// Fetch a slice of ledger entries using cursor-based pagination.
    async fn list_by_cursor(
        &self,
        query: &LedgerEntryQueryDto,
    ) -> Result<Paginated<Self::Entity>, anyhow::Error>;
}

/// Helper trait implemented for iterators to accelerate unit tests.
///
/// It transforms an in‐memory Vec<E> into Paginated<E> while synthesising
/// PageInfo.  This is *not* used in production code paths because it would
/// require loading the whole result set in RAM, defeating pagination at the DB
/// level.  In test suites, however, it allows developers to avoid spinning up
/// a Postgres container merely to assert pagination behaviour.
pub trait PaginateInto {
    type Item;

    fn paginate_into(self, query: &LedgerEntryQueryDto) -> Paginated<Self::Item>;
}

impl<I, T> PaginateInto for I
where
    I: IntoIterator<Item = T>,
{
    type Item = T;

    fn paginate_into(self, query: &LedgerEntryQueryDto) -> Paginated<Self::Item> {
        let mut vec: Vec<T> = self.into_iter().collect();
        let total = vec.len() as u64;

        let page = query.page.unwrap_or(0);
        let per_page = query.effective_limit() as usize;
        let offset = (page as usize) * per_page;
        let slice = if offset >= total as usize {
            &[]
        } else {
            let end = (offset + per_page).min(total as usize);
            &vec[offset..end]
        };

        let has_more = offset + slice.len() < total as usize;

        Paginated::new(slice.to_vec(), PageInfo {
            total_records: Some(total),
            current_page: Some(page),
            per_page: Some(per_page as u16),
            next_cursor: None, // meaningless for offset pagination
            has_more,
        })
    }
}

/// Custom validation helpers -------------------------------------------------

/// Ensure `to_date` is not less than `from_date`.
pub fn validate_date_range(dto: &LedgerEntryQueryDto) -> Result<(), ValidationError> {
    match (dto.from_date, dto.to_date) {
        (Some(from), Some(to)) if to < from => {
            let mut err = ValidationError::new("invalid_range");
            err.message = Some("to_date must be greater than from_date".into());
            Err(err)
        }
        _ => Ok(()),
    }
}

/// The ‘validate’ crate does not support struct-level validation by default.
/// We call this utility right after `dto.validate()?` at request handling.
///
/// Example:
/// ```rust
/// let dto = LedgerEntryQueryDto::from_query(query_map)?;
/// dto.validate()?;          // field-level validation
/// validate_date_range(&dto)?; // cross-field validation
/// ```
pub mod prelude {
    pub use super::{
        validate_date_range, CacheDirective, LedgerEntryQueryDto, Paginated, PageInfo, VmError,
        DEFAULT_LIMIT, MAX_LIMIT,
    };
}
```