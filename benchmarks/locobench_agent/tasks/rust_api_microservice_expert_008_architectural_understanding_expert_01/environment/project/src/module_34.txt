```rust
//! src/module_34.rs
//!
//! View-Model definition for the “List Ledger Entries” query.
//!
//! This module lives on the “View-Model” layer of the MVVM-inspired
//! architecture followed by LedgerLink Nexus.  It fulfils the following
//! responsibilities:
//!
//! 1.  Strongly-typed deserialisation of inbound HTTP query parameters
//!     (REST) or GraphQL arguments.
//! 2.  Self-contained, exhaustive validation with business-rule-aware
//!     error reporting.
//! 3.  Pagination & sorting helpers that translate into offset/limit
//!     statements for the Repository layer.
//! 4.  Provision of a deterministic cache/ETag hint that upstream HTTP
//!     handlers and the API-gateway can leverage for smart, fine-grained
//!     response caching.
//! 5.  A loss-free conversion into a pure Command object consumed by the
//!     Service layer.
//!
//! The code purposefully stays free of any web-framework specific
//! concerns so that it can be reused by both REST and GraphQL handlers.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::fmt;
use uuid::Uuid;

use thiserror::Error;

/// Maximum page size we allow through the public API.  This guards both the
/// database from silly `LIMIT` values and our own in-memory allocations.
const MAX_PAGE_SIZE: u32 = 1_000;
/// Default page size when none is provided.
const DEFAULT_PAGE_SIZE: u32 = 100;

/// JSON-serialisable sort order enum.
///
/// Using an enum (instead of a boolean) makes the API clearer and
/// future-proofs us should we one day introduce *case-insensitive* or
/// *natural* sort orders.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SortOrder {
    Asc,
    Desc,
}

impl Default for SortOrder {
    fn default() -> Self {
        SortOrder::Desc
    }
}

/// Runtime validation errors for the list endpoint.
///
/// We purposefully keep this error type independent from any
/// API-gateway/transport error envelope so that it can be reused by CLI
/// tooling and integration tests.
#[derive(Debug, Error)]
pub enum QueryValidationError {
    #[error("page must be greater than or equal to 1")]
    InvalidPage,
    #[error("page_size must be within 1..={0}")]
    InvalidPageSize(u32),
    #[error("`since` must be earlier than `until`")]
    InvalidDateRange,
}

/// Public pagination request object.
/// Mostly a helper reused across many View-Models.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageRequest {
    #[serde(default = "PageRequest::default_page")]
    pub page: u32,
    #[serde(default = "PageRequest::default_page_size")]
    pub page_size: u32,
}

impl PageRequest {
    #[inline(always)]
    fn default_page() -> u32 {
        1
    }
    #[inline(always)]
    fn default_page_size() -> u32 {
        DEFAULT_PAGE_SIZE
    }

    /// Validate page & page_size invariants.
    pub fn validate(&self) -> Result<(), QueryValidationError> {
        if self.page == 0 {
            return Err(QueryValidationError::InvalidPage);
        }
        if !(1..=MAX_PAGE_SIZE).contains(&self.page_size) {
            return Err(QueryValidationError::InvalidPageSize(MAX_PAGE_SIZE));
        }
        Ok(())
    }

    /// Compute offset (0-based) suitable for SQL queries.
    #[inline]
    pub fn offset(&self) -> u32 {
        (self.page - 1) * self.page_size
    }
}

impl Default for PageRequest {
    fn default() -> Self {
        Self {
            page: 1,
            page_size: DEFAULT_PAGE_SIZE,
        }
    }
}

/// Query View-Model for “List Ledger Entries”.
///
/// Implements a small subset of possible filters—extending this is merely
/// a matter of adding more optional fields.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LedgerEntryListQuery {
    /// Optional tenant-scoped account identifier filter.
    pub account_id: Option<Uuid>,
    /// Limit results to entries *not earlier* than this timestamp.
    pub since: Option<DateTime<Utc>>,
    /// Limit results to entries *not later* than this timestamp.
    pub until: Option<DateTime<Utc>>,
    /// Name of the column to sort on (e.g. "value_date").
    #[serde(default)]
    pub sort_by: Option<String>,
    /// Ascending or descending sort direction.
    #[serde(default)]
    pub sort_order: SortOrder,
    /// Pagination details.
    #[serde(flatten)]
    pub page: PageRequest,
}

impl LedgerEntryListQuery {
    /// Runs *all* validations defined for this View-Model.
    pub fn validate(&self) -> Result<(), QueryValidationError> {
        self.page.validate()?;

        if let (Some(since), Some(until)) = (self.since, self.until) {
            if since > until {
                return Err(QueryValidationError::InvalidDateRange);
            }
        }
        Ok(())
    }

    /// Compute a deterministic ETag from the current query parameters.
    ///
    /// Any change in the filtering, sorting, or paging options will produce a
    /// different hash, allowing the API-gateway to serve 304 responses when
    /// appropriate.
    pub fn etag(&self) -> String {
        let mut hasher = Sha256::new();
        // Hash *stable* serialised representation.
        let _ = serde_json::to_writer(&mut hasher, self)
            .expect("serialising View-Model never fails");
        let digest = hasher.finalize();
        hex::encode(digest)
    }
}

/// Command object forwarded to the Service layer.
///
/// This object is oblivious to paging notions other than offset/limit—it is
/// thus decoupled from HTTP-centric vocabulary.
#[derive(Debug, Clone)]
pub struct GetLedgerEntriesCommand {
    pub account_id: Option<Uuid>,
    pub since: Option<DateTime<Utc>>,
    pub until: Option<DateTime<Utc>>,
    pub sort_by: Option<String>,
    pub sort_order: SortOrder,
    pub offset: u32,
    pub limit: u32,
}

impl From<LedgerEntryListQuery> for GetLedgerEntriesCommand {
    fn from(vm: LedgerEntryListQuery) -> Self {
        Self {
            account_id: vm.account_id,
            since: vm.since,
            until: vm.until,
            sort_by: vm.sort_by,
            sort_order: vm.sort_order,
            offset: vm.page.offset(),
            limit: vm.page.page_size,
        }
    }
}

/// Generic paginated (outgoing) response structure.
///
/// The presence of `etag` allows upper layers to short-circuit the payload
/// serialisation entirely if the request already contained a matching
/// `If-None-Match` header.
#[derive(Debug, Serialize)]
pub struct PaginatedResponse<T> {
    pub items: Vec<T>,
    pub total_count: u64,
    pub has_more: bool,
    pub page: PageRequest,
    pub etag: String,
}

impl<T> PaginatedResponse<T> {
    pub fn new(items: Vec<T>, total_count: u64, page: PageRequest, etag: String) -> Self {
        let has_more = (page.page as u64 * page.page_size as u64) < total_count;
        Self {
            items,
            total_count,
            has_more,
            page,
            etag,
        }
    }
}

impl<T> fmt::Display for PaginatedResponse<T>
where
    T: fmt::Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "PaginatedResponse(total={}, page={} size={}, has_more={})",
            self.total_count, self.page.page, self.page.page_size, self.has_more
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::{Duration, TimeZone};

    #[test]
    fn test_page_validation_ok() {
        let pr = PageRequest {
            page: 1,
            page_size: 25,
        };
        assert!(pr.validate().is_ok());
    }

    #[test]
    fn test_page_validation_fails_on_zero_page() {
        let pr = PageRequest {
            page: 0,
            page_size: 25,
        };
        assert!(matches!(
            pr.validate(),
            Err(QueryValidationError::InvalidPage)
        ));
    }

    #[test]
    fn test_date_range_validation() {
        let vm = LedgerEntryListQuery {
            account_id: None,
            since: Some(Utc.ymd(2023, 05, 01).and_hms(0, 0, 0)),
            until: Some(Utc.ymd(2023, 04, 01).and_hms(0, 0, 0)),
            sort_by: None,
            sort_order: SortOrder::Asc,
            page: PageRequest::default(),
        };
        assert!(matches!(
            vm.validate(),
            Err(QueryValidationError::InvalidDateRange)
        ));
    }

    #[test]
    fn test_etag_changes_on_update() {
        let mut vm = LedgerEntryListQuery {
            account_id: Some(Uuid::new_v4()),
            since: None,
            until: None,
            sort_by: None,
            sort_order: SortOrder::Asc,
            page: PageRequest::default(),
        };
        let etag1 = vm.etag();

        // mutate any field -> etag *must* differ
        vm.page.page_size += 1;
        let etag2 = vm.etag();
        assert_ne!(etag1, etag2);
    }

    #[test]
    fn test_offset_calculation() {
        let pr = PageRequest {
            page: 3,
            page_size: 50,
        };
        assert_eq!(pr.offset(), 100);
    }

    #[test]
    fn test_paginated_response_helper() {
        let pr = PageRequest {
            page: 1,
            page_size: 20,
        };
        let resp: PaginatedResponse<u8> =
            PaginatedResponse::new(vec![1, 2, 3], 50, pr.clone(), "etag".to_string());

        assert!(resp.has_more);
        assert_eq!(resp.total_count, 50);
        assert_eq!(resp.page, pr);
    }
}
```