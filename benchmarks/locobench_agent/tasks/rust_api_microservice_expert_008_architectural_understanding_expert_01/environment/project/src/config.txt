```rust
//! src/config.rs
//!
//! Centralized configuration loader for the **LedgerLink Nexus** API micro-service.
//!
//! The configuration system fulfils a few non-functional requirements:
//!  1. Environment-aware (local, staging, production, â€¦) overrides  
//!  2. Secrets stay out of Gitâ€”use `$APP_â€¦` env vars instead  
//!  3. Strongly-typed settings with fall-back defaults + robust error handling  
//!  4. Hot-reload friendly (watch the file + refresh cache) *(behind feature flag)*  
//!
//! The module exposes an [`AppConfig`] root object that can be queried from anywhere
//! in the application. Internally it lazily loads a singleton via [`once_cell`],
//! thus preventing configuration scattering / needless file-IO on hot paths.
//!
//! Example:
//! ```no_run
//! let cfg = ledgerlink_nexus::config::get();
//! tracing::info!(bind = ?cfg.http.bind, "ðŸš€  HTTP server starting");
//! ```

use std::{net::IpAddr, path::Path, sync::Arc, time::Duration};

use config::{Config, ConfigError, Environment, File};
use once_cell::sync::OnceCell;
use secrecy::{ExposeSecret, SecretString};
use serde::Deserialize;
use thiserror::Error;

/// Retrieve the global, lazily-initialised [`AppConfig`].
///
/// # Panics
/// The function panics if configuration loading fails **once** at startup.
/// Subsequent calls are guaranteed not to panic.
pub fn get() -> &'static AppConfig {
    static INSTANCE: OnceCell<AppConfig> = OnceCell::new();
    INSTANCE.get_or_init(|| match AppConfig::load() {
        Ok(cfg) => cfg,
        Err(e) => {
            // A config load failure is considered unrecoverable.
            eprintln!("âŒ Failed to load configuration: {:?}", e);
            std::process::exit(1);
        }
    })
}

/// Shallow clone wrapper around [`get`].
/// Useful when configuration needs to be shared across async tasks.
pub fn shared() -> Arc<AppConfig> {
    Arc::new(get().clone())
}

/// Complete application configuration (root).
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "snake_case")]
pub struct AppConfig {
    pub http: HttpConfig,
    pub postgres: PostgresConfig,
    pub redis: RedisConfig,
    pub auth: AuthConfig,
    pub pagination: PaginationConfig,
    pub caching: ResponseCacheConfig,
    pub logging: LoggingConfig,
}

impl AppConfig {
    /// Load configuration from the following sources **in order**:
    ///  1. `config/default.{toml,yaml,json}` (optional)
    ///  2. `config/{RUN_MODE}.{toml,yaml,json}` where `RUN_MODE=$APP_ENV` (optional)
    ///  3. Environment variables (`APP__POSTGRES__HOST=â€¦`)
    ///
    /// The merge strategy is â€œlast one winsâ€.
    pub fn load() -> Result<Self, ConfigLoadError> {
        let env = std::env::var("APP_ENV").unwrap_or_else(|_| "local".into());
        let mut cfg = Config::builder();

        // tier 1
        cfg = cfg.add_source(File::with_name("config/default").required(false));

        // tier 2
        cfg = cfg.add_source(File::with_name(&format!("config/{}", env)).required(false));

        // tier 3 (env vars). Double underscore `__` = nesting delimiter.
        cfg = cfg.add_source(
            Environment::with_prefix("APP")
                .separator("__")
                .list_separator(","),
        );

        // finish
        cfg.build()
            .map_err(ConfigLoadError::Parse)?
            .try_deserialize::<AppConfig>()
            .map_err(ConfigLoadError::Deserialize)
    }
}

/// Errors that might occur while loading the configuration.
#[derive(Debug, Error)]
pub enum ConfigLoadError {
    #[error("config file parsing failed: {0}")]
    Parse(ConfigError),
    #[error("config deserialization failed: {0}")]
    Deserialize(ConfigError),
}

/* -------------------------------------------------------------------------- */
/*                               Sub-structures                               */
/* -------------------------------------------------------------------------- */

#[derive(Debug, Clone, Deserialize)]
pub struct HttpConfig {
    #[serde(default = "default_bind_addr")]
    pub bind: IpAddr,
    #[serde(default = "default_port")]
    pub port: u16,
    #[serde(default = "default_request_timeout_secs")]
    pub request_timeout: Duration,
    #[serde(default)]
    pub enable_graphql_playground: bool,
}

fn default_bind_addr() -> IpAddr {
    IpAddr::from([0, 0, 0, 0])
}
fn default_port() -> u16 {
    8080
}
fn default_request_timeout_secs() -> Duration {
    Duration::from_secs(30)
}

#[derive(Debug, Clone, Deserialize)]
pub struct PostgresConfig {
    pub host: String,
    #[serde(default = "default_pg_port")]
    pub port: u16,
    pub dbname: String,
    pub username: String,
    #[serde(deserialize_with = "deser_secret")]
    pub password: SecretString,
    #[serde(default = "default_pg_pool_size")]
    pub max_pool_size: u32,
    #[serde(default)]
    pub require_ssl: bool,
}

fn default_pg_port() -> u16 {
    5432
}
fn default_pg_pool_size() -> u32 {
    20
}

#[derive(Debug, Clone, Deserialize)]
pub struct RedisConfig {
    pub url: String,
    #[serde(default = "default_redis_pool_size")]
    pub pool_size: u32,
    #[serde(default)]
    pub cache_ttl: Option<humantime::Duration>,
}

fn default_redis_pool_size() -> u32 {
    16
}

#[derive(Debug, Clone, Deserialize)]
pub struct AuthConfig {
    pub jwt_issuer: String,
    pub jwks_endpoint: String,
    #[serde(deserialize_with = "deser_secret")]
    pub api_key: SecretString,
    #[serde(default = "default_token_ttl")]
    pub token_ttl: Duration,
}

fn default_token_ttl() -> Duration {
    Duration::from_secs(60 * 60) // 1 hour
}

#[derive(Debug, Clone, Deserialize)]
pub struct PaginationConfig {
    #[serde(default = "default_page_size")]
    pub default_page_size: u32,
    #[serde(default = "default_max_page_size")]
    pub max_page_size: u32,
}

fn default_page_size() -> u32 {
    50
}
fn default_max_page_size() -> u32 {
    200
}

#[derive(Debug, Clone, Deserialize)]
pub struct ResponseCacheConfig {
    #[serde(default)]
    pub enabled: bool,
    #[serde(default = "default_cache_duration")]
    pub duration: Duration,
    #[serde(default)]
    pub respect_cache_control_header: bool,
}

fn default_cache_duration() -> Duration {
    Duration::from_secs(5 * 60) // 5 minutes
}

#[derive(Debug, Clone, Deserialize)]
pub struct LoggingConfig {
    #[serde(default = "default_log_level")]
    pub level: LogLevel,
    #[serde(default)]
    pub json: bool,
}

fn default_log_level() -> LogLevel {
    LogLevel::Info
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum LogLevel {
    Trace,
    Debug,
    Info,
    Warn,
    Error,
}

/* -------------------------------------------------------------------------- */
/*                     Helpers / bespoke deserialization logic                */
/* -------------------------------------------------------------------------- */

/// Custom `serde` helper to ensure secrets are never leaked via `Debug`.
fn deser_secret<'de, D>(deserializer: D) -> Result<SecretString, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let s: String = String::deserialize(deserializer)?;
    Ok(SecretString::new(s))
}

/// Output a PostgreSQL connection string (excluding password) for telemetry.
/// NOTE: the password is intentionally omitted to avoid traces leaking secrets.
impl PostgresConfig {
    pub fn safe_dsn(&self) -> String {
        format!(
            "host={} port={} user={} dbname={} sslmode={}",
            self.host,
            self.port,
            self.username,
            self.dbname,
            if self.require_ssl { "require" } else { "disable" }
        )
    }

    /// Full DSN with password (use with care, **never** log this value).
    pub fn full_dsn(&self) -> String {
        format!(
            "postgresql://{}:{}@{}:{}/{}",
            self.username,
            self.password.expose_secret(),
            self.host,
            self.port,
            self.dbname
        )
    }
}

/* -------------------------------------------------------------------------- */
/*                            Generated unit tests                            */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use std::env;

    #[test]
    fn env_overrides_take_precedence() {
        // Prepare
        env::set_var("APP__POSTGRES__HOST", "10.0.0.42");
        env::set_var("APP__POSTGRES__PASSWORD", "sekret");

        // Act
        let cfg = AppConfig::load().expect("config loads");

        // Assert
        assert_eq!(cfg.postgres.host, "10.0.0.42");
        assert_eq!(
            cfg.postgres.password.expose_secret(),
            "sekret",
            "env secret should override"
        );
    }

    #[test]
    fn default_values_are_applied() {
        let cfg = AppConfig::load().expect("config loads");
        assert_eq!(cfg.pagination.default_page_size, 50);
        assert_eq!(cfg.http.port, 8080);
    }
}
```