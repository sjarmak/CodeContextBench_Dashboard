```rust
//! LedgerLink Nexus â€“ Module 66  
//! ---------------------------------------------------------------  
//! This module wires together a *single* production-grade endpoint
//! (`GET /api/v1/ledger_entries`) that demonstrates the key patterns
//! used throughout the larger micro-service: DTO/View separation,
//! validation, pagination helpers, service-layer orchestration,
//! repository pattern, response-caching and observability.
//!
//! The surrounding project (not shown) exposes many more endpoints
//! and concrete backing stores (PostgreSQL, Redis, Vault, etc.).  To
//! keep this file self-contained we provide *in-memory* fall-backs
//! that still satisfy the same runtime contracts so the code compiles
//! and all unit-tests pass.

#![allow(clippy::unused_async)]
#![allow(clippy::needless_pass_by_value)]

use std::{
    collections::HashMap,
    sync::{Arc, RwLock},
    time::{Duration, SystemTime},
};

use actix_web::{
    get,
    http::header,
    middleware::{Logger, NormalizePath},
    web::{self, Data, Json, Query},
    App, HttpResponse, HttpServer, Responder,
};
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use log::{error, info};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use validator::{Validate, ValidationErrors};

/// ---------------------------
/// DTO-Layer (View-Models)
/// ---------------------------
#[derive(Debug, Deserialize, Validate)]
pub struct LedgerEntryQuery {
    /// Optional filter by account ID
    #[validate(length(min = 1, max = 64))]
    pub account_id: Option<String>,

    /// 1-based page index
    #[validate(range(min = 1, max = 10_000))]
    #[serde(default = "LedgerEntryQuery::default_page")]
    pub page: usize,

    /// page size
    #[validate(range(min = 1, max = 1_000))]
    #[serde(default = "LedgerEntryQuery::default_per_page")]
    pub per_page: usize,
}

impl LedgerEntryQuery {
    const fn default_page() -> usize {
        1
    }
    const fn default_per_page() -> usize {
        50
    }
}

#[derive(Debug, Serialize)]
pub struct Paginated<T> {
    pub data: Vec<T>,
    pub page: usize,
    pub per_page: usize,
    pub total: usize,
}

#[derive(Debug, Serialize)]
pub struct LedgerEntryView {
    pub id: Uuid,
    pub account_id: String,
    pub amount: f64,
    pub currency: String,
    pub description: Option<String>,
    pub booked_at: DateTime<Utc>,
}

/// ---------------------------
/// Domain Model
/// ---------------------------
#[derive(Debug, Clone)]
pub struct LedgerEntry {
    pub id: Uuid,
    pub account_id: String,
    pub amount: f64,
    pub currency: String,
    pub description: Option<String>,
    pub booked_at: DateTime<Utc>,
}

impl From<LedgerEntry> for LedgerEntryView {
    fn from(src: LedgerEntry) -> Self {
        Self {
            id: src.id,
            account_id: src.account_id,
            amount: src.amount,
            currency: src.currency,
            description: src.description,
            booked_at: src.booked_at,
        }
    }
}

/// ---------------------------
/// Repository Layer
/// ---------------------------
#[async_trait]
pub trait LedgerEntryRepository: Send + Sync + 'static {
    async fn list(
        &self,
        account_id: Option<&str>,
        page: usize,
        per_page: usize,
    ) -> anyhow::Result<(Vec<LedgerEntry>, usize)>;
}

/// In-memory fallback repository (thread-safe)
pub struct InMemoryLedgerRepo {
    records: Arc<RwLock<Vec<LedgerEntry>>>,
}

impl InMemoryLedgerRepo {
    pub fn seeded() -> Self {
        let mut seeded: Vec<LedgerEntry> = Vec::new();
        for idx in 1..=200 {
            seeded.push(LedgerEntry {
                id: Uuid::new_v4(),
                account_id: format!("ACCT-{:04}", idx % 5),
                amount: (idx as f64) * 10.0,
                currency: "USD".into(),
                description: Some(format!("Seed entry #{idx}")),
                booked_at: Utc::now(),
            });
        }
        Self {
            records: Arc::new(RwLock::new(seeded)),
        }
    }
}

#[async_trait]
impl LedgerEntryRepository for InMemoryLedgerRepo {
    async fn list(
        &self,
        account_id: Option<&str>,
        page: usize,
        per_page: usize,
    ) -> anyhow::Result<(Vec<LedgerEntry>, usize)> {
        let guard = self.records.read().unwrap();
        let filtered: Vec<LedgerEntry> = guard
            .iter()
            .filter(|entry| account_id.map_or(true, |id| id == entry.account_id))
            .cloned()
            .collect();

        let total = filtered.len();
        let start = per_page * (page - 1);
        let end = std::cmp::min(start + per_page, total);

        let slice = if start < total {
            filtered[start..end].to_vec()
        } else {
            Vec::new()
        };

        Ok((slice, total))
    }
}

/// ---------------------------
/// Caching Layer (trait + memory impl)
/// ---------------------------
#[async_trait]
pub trait ResponseCache: Send + Sync + 'static {
    async fn get<T: serde::de::DeserializeOwned + Send>(&self, key: &str) -> Option<T>;
    async fn set<T: serde::Serialize + Send>(&self, key: &str, value: &T, ttl: Duration);
}

#[derive(Default)]
pub struct InMemoryCache {
    map: Arc<RwLock<HashMap<String, (Vec<u8>, SystemTime)>>>,
}

#[async_trait]
impl ResponseCache for InMemoryCache {
    async fn get<T: serde::de::DeserializeOwned + Send>(&self, key: &str) -> Option<T> {
        let guard = self.map.read().unwrap();
        guard.get(key).and_then(|(bytes, exp)| {
            if SystemTime::now() > *exp {
                None
            } else {
                bincode::deserialize(bytes).ok()
            }
        })
    }

    async fn set<T: serde::Serialize + Send>(&self, key: &str, value: &T, ttl: Duration) {
        let mut guard = self.map.write().unwrap();
        let exp = SystemTime::now() + ttl;
        if let Ok(payload) = bincode::serialize(value) {
            guard.insert(key.to_owned(), (payload, exp));
        }
    }
}

/// ---------------------------
/// Service Layer
/// ---------------------------
pub struct LedgerEntryService<R: LedgerEntryRepository, C: ResponseCache> {
    repo: Arc<R>,
    cache: Arc<C>,
}

impl<R: LedgerEntryRepository, C: ResponseCache> LedgerEntryService<R, C> {
    pub fn new(repo: Arc<R>, cache: Arc<C>) -> Self {
        Self { repo, cache }
    }

    pub async fn list_ledger_entries(
        &self,
        query: LedgerEntryQuery,
    ) -> Result<Paginated<LedgerEntryView>, anyhow::Error> {
        // Validate incoming query params
        query.validate().map_err(anyhow::Error::from)?;

        // Cache-key derived from query params
        let cache_key = format!(
            "ledger_entries:{:?}:{:?}:{:?}",
            query.account_id, query.page, query.per_page
        );

        // Try cache first
        if let Some(cached) = self.cache.get::<Paginated<LedgerEntryView>>(&cache_key).await {
            info!("CACHE HIT: {cache_key}");
            return Ok(cached);
        }

        // Fallback to repository
        let (entries, total) = self
            .repo
            .list(query.account_id.as_deref(), query.page, query.per_page)
            .await?;

        let paginated = Paginated {
            data: entries.into_iter().map(LedgerEntryView::from).collect(),
            page: query.page,
            per_page: query.per_page,
            total,
        };

        // Store in cache (60s TTL)
        self.cache
            .set(&cache_key, &paginated, Duration::from_secs(60))
            .await;

        Ok(paginated)
    }
}

/// ---------------------------
/// HTTP / API wiring
/// ---------------------------
#[get("/api/v1/ledger_entries")]
async fn get_ledger_entries(
    query: Query<LedgerEntryQuery>,
    service: Data<Arc<LedgerEntryService<InMemoryLedgerRepo, InMemoryCache>>>,
) -> impl Responder {
    match service.list_ledger_entries(query.into_inner()).await {
        Ok(response) => HttpResponse::Ok()
            .insert_header((header::CACHE_CONTROL, "public, max-age=60"))
            .json(response),
        Err(err) => {
            error!("Failed to list ledger entries: {err:?}");
            let msg = match err.downcast_ref::<ValidationErrors>() {
                Some(validation) => validation.to_string(),
                None => "Internal Server Error".into(),
            };
            let status = if err.is::<ValidationErrors>() {
                actix_web::http::StatusCode::BAD_REQUEST
            } else {
                actix_web::http::StatusCode::INTERNAL_SERVER_ERROR
            };
            HttpResponse::build(status).json(serde_json::json!({ "error": msg }))
        }
    }
}

/// ---------------------------
/// Application Bootstrap
/// ---------------------------
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Initialize structured logging
    env_logger::init();

    let repo = Arc::new(InMemoryLedgerRepo::seeded());
    let cache = Arc::new(InMemoryCache::default());
    let service = Arc::new(LedgerEntryService::new(repo, cache));

    HttpServer::new(move || {
        App::new()
            .wrap(Logger::default())
            .wrap(NormalizePath::trim())
            .app_data(Data::from(service.clone()))
            .service(get_ledger_entries)
    })
    .bind(("0.0.0.0", 8080))?
    .run()
    .await
}

/// ---------------------------
/// Unit Tests
/// ---------------------------
#[cfg(test)]
mod tests {
    use super::*;
    use actix_web::{body::to_bytes, test, App};

    #[actix_rt::test]
    async fn it_validates_query_params() {
        let repo = Arc::new(InMemoryLedgerRepo::seeded());
        let cache = Arc::new(InMemoryCache::default());
        let service = Arc::new(LedgerEntryService::new(repo, cache));

        let req = test::TestRequest::get()
            .uri("/api/v1/ledger_entries?page=0") // invalid page
            .to_http_request();

        let resp = get_ledger_entries(
            Query(LedgerEntryQuery {
                account_id: None,
                page: 0,
                per_page: 50,
            }),
            Data::from(service),
        )
        .await
        .respond_to(&req);

        assert_eq!(resp.status(), actix_web::http::StatusCode::BAD_REQUEST);
    }

    #[actix_rt::test]
    async fn it_returns_paginated_results() {
        let repo = Arc::new(InMemoryLedgerRepo::seeded());
        let cache = Arc::new(InMemoryCache::default());
        let service = Arc::new(LedgerEntryService::new(repo.clone(), cache.clone()));

        let app = test::init_service(
            App::new()
                .app_data(Data::from(service))
                .service(get_ledger_entries),
        )
        .await;

        let req = test::TestRequest::get()
            .uri("/api/v1/ledger_entries?page=1&per_page=20")
            .to_request();

        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());

        let body = to_bytes(resp.into_body()).await.unwrap();
        let page: Paginated<LedgerEntryView> = serde_json::from_slice(&body).unwrap();
        assert_eq!(page.page, 1);
        assert_eq!(page.per_page, 20);
        assert_eq!(page.data.len(), 20);
        assert_eq!(page.total, 200);
    }
}
```