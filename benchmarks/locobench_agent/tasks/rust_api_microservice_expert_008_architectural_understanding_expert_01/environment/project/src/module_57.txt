//! Pagination and caching helpers for LedgerLink Nexus.
//! This module implements PageRequest parsing from HTTP requests,
//! generic Page container, helpers for building HTTP response with
//! pagination metadata, and cache-control hints.

use std::future::{ready, Ready};
use std::num::NonZeroU32;

use actix_web::{
    dev::Payload, error::ErrorBadRequest, http::header, HttpRequest, HttpResponse, FromRequest,
    Responder,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

/// Default items per page if the client did not supply one.
pub const DEFAULT_PER_PAGE: u32 = 50;
/// Maximum items per page to guard against runaway queries.
pub const MAX_PER_PAGE: u32 = 500;

/// Query params accepted by the pagination middleware.
/// Supports `page`, `per_page`, `sort`.
#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]
pub struct PageRequest {
    #[serde(default = "default_page", alias = "p")]
    pub page: NonZeroU32,

    #[serde(default = "default_per_page", alias = "limit")]
    pub per_page: NonZeroU32,

    /// Optional comma-separated list of sort fields (e.g. "-created_at,status").
    #[serde(default)]
    pub sort: Option<String>,
}

fn default_page() -> NonZeroU32 {
    NonZeroU32::new(1).unwrap()
}

fn default_per_page() -> NonZeroU32 {
    NonZeroU32::new(DEFAULT_PER_PAGE).unwrap()
}

impl PageRequest {
    /// Clamp values to the configured bounds.
    fn sanitize(&mut self) {
        if self.per_page.get() > MAX_PER_PAGE {
            self.per_page = NonZeroU32::new(MAX_PER_PAGE).unwrap();
        }
    }
}

impl FromRequest for PageRequest {
    type Error = actix_web::Error;
    type Future = Ready<Result<Self, Self::Error>>;

    fn from_request(req: &HttpRequest, _: &mut Payload) -> Self::Future {
        let mut query: PageRequest = match serde_qs::from_str(req.query_string()) {
            Ok(val) => val,
            Err(e) => return ready(Err(ErrorBadRequest(format!("Invalid query string: {}", e)))),
        };

        query.sanitize();
        ready(Ok(query))
    }
}

/// A container that bundles paginated payload `data` with metadata.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Page<T> {
    pub data: Vec<T>,
    pub page: u32,
    pub per_page: u32,
    pub total: u64,
}

impl<T> Page<T> {
    pub fn new(data: Vec<T>, page: u32, per_page: u32, total: u64) -> Self {
        Self {
            data,
            page,
            per_page,
            total,
        }
    }

    /// Convenience to compute the number of pages available.
    pub fn page_count(&self) -> u64 {
        if self.per_page == 0 {
            return 0;
        }
        (self.total + self.per_page as u64 - 1) / self.per_page as u64
    }
}

/// Wrapper that turns `Page<T: Serialize>` into an `actix_web::Responder`.
/// Adds standard pagination headers and cache-control hints.
pub struct PageResponse<T: Serialize> {
    pub page: Page<T>,
    /// Optional timestamp of the newest record inside `page.data`.
    /// When present, we emit `Last-Modified`.
    pub newest_ts: Option<DateTime<Utc>>,
    /// Duration in seconds the response may be cached.
    pub max_age_seconds: Option<u32>,
}

impl<T> PageResponse<T>
where
    T: Serialize,
{
    pub fn new(page: Page<T>) -> Self {
        Self {
            page,
            newest_ts: None,
            max_age_seconds: None,
        }
    }

    pub fn with_newest_ts(mut self, ts: DateTime<Utc>) -> Self {
        self.newest_ts = Some(ts);
        self
    }

    pub fn with_max_age(mut self, secs: u32) -> Self {
        self.max_age_seconds = Some(secs);
        self
    }
}

impl<T> Responder for PageResponse<T>
where
    T: Serialize,
{
    type Body = actix_web::body::BoxBody;

    fn respond_to(self, req: &HttpRequest) -> HttpResponse<Self::Body> {
        // Serialize body
        let body = match serde_json::to_string(&self.page) {
            Ok(json) => json,
            Err(e) => {
                // Unexpected serialization error
                log::error!("Page serialization error: {}", e);
                return HttpResponse::InternalServerError().finish();
            }
        };

        // Compute strong ETag based on the body. This is cheap for small pages.
        let mut hasher = Sha256::new();
        hasher.update(body.as_bytes());
        let etag_hex = hex::encode(hasher.finalize());
        let etag_val = format!("W/\"{}\"", etag_hex); // Weak ETag

        // Check If-None-Match to support conditional GET
        if let Some(if_none_match) = req.headers().get(header::IF_NONE_MATCH) {
            if if_none_match
                .to_str()
                .map(|s| s == etag_val)
                .unwrap_or(false)
            {
                return HttpResponse::NotModified()
                    .insert_header((header::ETAG, etag_val))
                    .finish();
            }
        }

        // Build response
        let mut res = HttpResponse::Ok();
        res.insert_header((header::CONTENT_TYPE, "application/json"));
        res.insert_header((header::ETAG, etag_val));

        // Pagination meta headers recommended by https://datatracker.ietf.org/doc/html/rfc8288
        res.insert_header((
            header::HeaderName::from_static("x-page"),
            self.page.page.to_string(),
        ));
        res.insert_header((
            header::HeaderName::from_static("x-per-page"),
            self.page.per_page.to_string(),
        ));
        res.insert_header((
            header::HeaderName::from_static("x-total"),
            self.page.total.to_string(),
        ));
        res.insert_header((
            header::HeaderName::from_static("x-total-pages"),
            self.page.page_count().to_string(),
        ));

        // Optional caching hints
        if let Some(ts) = self.newest_ts {
            res.insert_header((header::LAST_MODIFIED, ts.to_rfc2822()));
        }

        let cache_control_val = match self.max_age_seconds {
            Some(sec) => format!("public, max-age={}", sec),
            None => "no-cache".into(),
        };
        res.insert_header((header::CACHE_CONTROL, cache_control_val));

        res.body(body)
    }
}

/// Trait describing a read-only query service able to fetch paginated records.
/// The implementation is expected to live in the service layer and orchestrate
/// repositories + domain models.
#[async_trait::async_trait]
pub trait PaginatedQueryService<Q, R>
where
    Q: Send + Sync,
    R: Send + Sync + Serialize,
{
    /// Execute query with pagination, returning the concrete records and count.
    async fn fetch_page(&self, query: Q, page_req: &PageRequest) -> anyhow::Result<Page<R>>;
}

/// Simple in-memory implementation for unit tests and examples.
pub struct VecQueryService<R> {
    data: Vec<R>,
}

impl<R> VecQueryService<R> {
    pub fn new(data: Vec<R>) -> Self {
        Self { data }
    }
}

#[async_trait::async_trait]
impl<R> PaginatedQueryService<(), R> for VecQueryService<R>
where
    R: Clone + Send + Sync + Serialize + 'static,
{
    async fn fetch_page(&self, _query: (), page_req: &PageRequest) -> anyhow::Result<Page<R>> {
        let start = ((page_req.page.get() - 1) * page_req.per_page.get()) as usize;
        let end = (start + page_req.per_page.get() as usize).min(self.data.len());

        let slice = self.data[start..end].to_vec();
        let page = Page::new(
            slice,
            page_req.page.get(),
            page_req.per_page.get(),
            self.data.len() as u64,
        );
        Ok(page)
    }
}

/// Demonstrative Actix handler showcasing pagination helper.
///
/// ```no_run
/// use actix_web::{get, web};
/// use ledgerlink_pagination::{PageRequest, PageResponse, VecQueryService};
/// use serde::Serialize;
///
/// #[derive(Debug, Clone, Serialize)]
/// struct DemoRecord {
///     id: u32,
/// }
///
/// #[get("/demo")]
/// async fn demo_endpoint(
///     page_req: PageRequest,
///     data: web::Data<VecQueryService<DemoRecord>>,
/// ) -> actix_web::Result<PageResponse<DemoRecord>> {
///     let page = data.fetch_page((), &page_req).await.map_err(|e| {
///         log::error!("demo endpoint error: {}", e);
///         actix_web::error::ErrorInternalServerError("internal error")
///     })?;
///
///     Ok(PageResponse::new(page).with_max_age(60))
/// }
/// ```
#[cfg(test)]
mod tests {
    use super::*;
    use actix_web::test;
    use serde::Serialize;

    #[actix_rt::test]
    async fn test_page_request_parsing_and_clamping() {
        let req = test::TestRequest::with_uri("/?_page=2&_per_page=9999").to_http_request();
        let mut page_req: PageRequest =
            PageRequest::from_request(&req, &mut Payload::None).await.unwrap();
        page_req.sanitize();
        assert_eq!(page_req.page.get(), 1); // invalid param, default to 1
        assert_eq!(page_req.per_page.get(), MAX_PER_PAGE); // clamped
    }

    #[actix_rt::test]
    async fn test_page_response_etag_conditional_get() {
        #[derive(Serialize)]
        struct Foo {
            v: u8,
        }
        let data = vec![Foo { v: 1 }];
        let page = Page::new(data, 1, 1, 1);
        let resp = PageResponse::new(page);

        let req = test::TestRequest::default().to_http_request();
        assert_eq!(resp.respond_to(&req).status(), 200);

        let etag = HttpResponse::Ok()
            .append_header((header::ETAG, "dummy"))
            .finish()
            .headers()
            .get(header::ETAG)
            .unwrap()
            .to_str()
            .unwrap()
            .to_string();

        let req_cond = test::TestRequest::default()
            .insert_header((header::IF_NONE_MATCH, etag))
            .to_http_request();

        assert_eq!(
            PageResponse::new(Page::new(vec![Foo { v: 1 }], 1, 1, 1))
                .respond_to(&req_cond)
                .status(),
            200
        );
    }

    #[actix_rt::test]
    async fn test_vec_query_service_pagination() {
        let data: Vec<i32> = (0..100).collect();
        let service = VecQueryService::new(data.clone());

        let page_req = PageRequest {
            page: NonZeroU32::new(2).unwrap(),
            per_page: NonZeroU32::new(10).unwrap(),
            sort: None,
        };

        let page = service.fetch_page((), &page_req).await.unwrap();
        assert_eq!(page.data.len(), 10);
        assert_eq!(page.page, 2);
        assert_eq!(page.total, data.len() as u64);
        assert_eq!(page.data[0], 10);
    }

    #[test]
    fn test_page_count() {
        let page: Page<()> = Page::new(vec![], 1, 25, 101);
        assert_eq!(page.page_count(), 5);
    }
}