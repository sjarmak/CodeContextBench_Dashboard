```rust
//! Integration‐style tests for the “EduPulse Live” social learning hub.
//!
//! The real application is a large, event-driven distributed system.  In these
//! tests we spin up **in-memory stand-ins** for some of the platform’s core
//! services (event bus, authentication/session management, analytics) and make
//! sure that the public behaviour—the contract—matches expectations.
//!
//! The code in this file is fully self-contained so that it can compile and run
//! without the rest of the production crate being present.  In the real
//! code-base each component would live in its own module/crate and expose a
//! clear interface.

// Std-lib imports ------------------------------------------------------------
use std::{
    collections::{HashMap, HashSet},
    fmt,
    sync::{
        atomic::{AtomicBool, Ordering},
        mpsc::{self, Receiver, Sender},
        Arc, Mutex,
    },
    thread,
    time::{Duration, SystemTime, UNIX_EPOCH},
};

// ─────────────────────────────────────────────────────────────────────────────
// Domain events
// ─────────────────────────────────────────────────────────────────────────────

/// All significant state changes inside EduPulse Live emit a DomainEvent.
#[derive(Debug, Clone)]
enum DomainEvent {
    LessonPublished {
        lesson_id: u64,
        title: String,
    },
    PulseReplied {
        user_id: u64,
        pulse_id: u64,
        reply: String,
    },
    UserLoggedIn {
        user_id: u64,
        session_token: String,
    },
}

/// Basic error type for the EventBus.
#[derive(Debug)]
enum BusError {
    PublishFailed,
}

impl fmt::Display for BusError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BusError::PublishFailed => write!(f, "unable to publish event"),
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// In-memory EventBus (fan-out)
// ─────────────────────────────────────────────────────────────────────────────

/// Very small, in-process, fan-out event bus used exclusively for testing.
///
/// Every call to `subscribe()` registers a new channel (Sender) that will
/// receive a **copy** of every published DomainEvent.  Publication errors are
/// silently swallowed by individual subscribers so that one slow consumer
/// never blocks the rest.
#[derive(Clone, Default)]
struct EventBus {
    subscribers: Arc<Mutex<Vec<Sender<DomainEvent>>>>,
}

impl EventBus {
    /// Create a fresh, empty bus.
    fn new() -> Self {
        Self::default()
    }

    /// Publish an event to all currently active subscribers.
    fn publish(&self, event: DomainEvent) -> Result<(), BusError> {
        let subs = self
            .subscribers
            .lock()
            .expect("poisoned subscriber list in EventBus");

        for tx in subs.iter() {
            // Ignore per-subscriber errors; fire-and-forget semantics.
            let _ = tx.send(event.clone());
        }
        Ok(())
    }

    /// Register a new subscriber and get the receiving end of its channel.
    fn subscribe(&self) -> Receiver<DomainEvent> {
        let (tx, rx) = mpsc::channel();

        self.subscribers
            .lock()
            .expect("poisoned subscriber list in EventBus")
            .push(tx);

        rx
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Authentication & session handling
// ─────────────────────────────────────────────────────────────────────────────

/// Errors produced by `AuthService`.
#[derive(Debug)]
enum AuthError {
    UnknownUser,
    TokenCollision,
}

impl fmt::Display for AuthError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AuthError::UnknownUser => write!(f, "user not found"),
            AuthError::TokenCollision => write!(f, "session-token collision"),
        }
    }
}

/// Thread-safe, in-memory authentication service used in tests.
#[derive(Debug, Default)]
struct AuthService {
    // In production this would be a database call via a repository.
    registered_users: HashSet<u64>,

    // session_token -> user_id
    sessions: Mutex<HashMap<String, u64>>,
}

impl AuthService {
    fn new(registered_users: &[u64]) -> Self {
        Self {
            registered_users: registered_users.iter().copied().collect(),
            sessions: Mutex::new(HashMap::new()),
        }
    }

    /// Log the given user in and produce a fresh session token.
    ///
    /// A DomainEvent is emitted on success.
    fn login(
        &self,
        user_id: u64,
        bus: &EventBus,
    ) -> Result<String, AuthError> {
        if !self.registered_users.contains(&user_id) {
            return Err(AuthError::UnknownUser);
        }

        let token = Self::generate_token(user_id);

        let mut guard = self.sessions.lock().expect("poisoned session map");
        if guard.contains_key(&token) {
            // Unlikely, but should never overwrite another session.
            return Err(AuthError::TokenCollision);
        }
        guard.insert(token.clone(), user_id);
        drop(guard); // Explicitly drop lock before we publish an event.

        bus.publish(DomainEvent::UserLoggedIn {
            user_id,
            session_token: token.clone(),
        })
        .expect("event bus must live for the entire test run");

        Ok(token)
    }

    /// Very naive, deterministic “random” token generator for test purposes.
    fn generate_token(user_id: u64) -> String {
        let epoch_millis = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("system time before 1970?")
            .as_millis();

        format!("{user_id:x}-{epoch_millis:x}")
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Analytics service (consumer)
// ─────────────────────────────────────────────────────────────────────────────

/// Simple analytics worker.  In production this would run in its own process
/// and push data into a columnar store; in tests we only count events.
struct AnalyticsService {
    processed_pulse_replies: Arc<AtomicBool>,
}

impl AnalyticsService {
    fn new() -> (Self, Arc<AtomicBool>) {
        let flag = Arc::new(AtomicBool::new(false));
        let svc = Self {
            processed_pulse_replies: flag.clone(),
        };
        (svc, flag)
    }

    /// Start an **owned** worker thread that listens for events until the
    /// supplied `shutdown_rx` channel is closed.
    fn start(self, bus_rx: Receiver<DomainEvent>, shutdown_rx: Receiver<()>) {
        thread::spawn(move || {
            loop {
                // prefer shutdown over event—non-blocking check
                if let Ok(_) = shutdown_rx.try_recv() {
                    break;
                }
                match bus_rx.recv_timeout(Duration::from_millis(100)) {
                    Ok(event) => self.handle_event(event),
                    Err(mpsc::RecvTimeoutError::Timeout) => continue,
                    Err(mpsc::RecvTimeoutError::Disconnected) => break,
                }
            }
        });
    }

    fn handle_event(&self, ev: DomainEvent) {
        match ev {
            DomainEvent::PulseReplied { .. } => {
                self.processed_pulse_replies
                    .store(true, Ordering::SeqCst);
            }
            _ => {} // ignore all other events
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Tests
// ─────────────────────────────────────────────────────────────────────────────

/// Make sure that a PulseReplied event is observed by the analytics worker.
#[test]
fn pulse_reply_is_forwarded_to_analytics_service() {
    // Arrange
    let bus = EventBus::new();

    // Channel to allow clean shutdown when the test finishes.
    let (shutdown_tx, shutdown_rx) = mpsc::channel();

    // Subscriber and worker bootstrap
    let bus_rx = bus.subscribe();
    let (analytics_service, processed_flag) = AnalyticsService::new();
    analytics_service.start(bus_rx, shutdown_rx);

    // Act
    bus.publish(DomainEvent::PulseReplied {
        user_id: 42,
        pulse_id: 7,
        reply: "Here is my work…".into(),
    })
    .expect("failed to publish event");

    // Give the worker up to 2 seconds real time.
    for _ in 0..20 {
        if processed_flag.load(Ordering::SeqCst) {
            break;
        }
        thread::sleep(Duration::from_millis(100));
    }

    // Clean shutdown
    let _ = shutdown_tx.send(());

    // Assert
    assert!(
        processed_flag.load(Ordering::SeqCst),
        "analytics worker never saw PulseReplied event"
    );
}

/// Verify that a successful login creates a session and emits the right event.
#[test]
fn successful_login_creates_session_and_emits_event() {
    // Arrange
    let bus = EventBus::new();
    let rx = bus.subscribe();

    let auth = AuthService::new(&[1, 2, 3]); // user 1 is registered

    // Act
    let token = auth
        .login(1, &bus)
        .expect("login should succeed for registered user");

    // Assert token shape (very coarse sanity check)
    assert!(
        token.starts_with("1-"),
        "unexpected token format: {token:?}"
    );

    // The next event on the bus must be our login.
    let event =
        rx.recv_timeout(Duration::from_secs(1)).expect("no event received");

    match event {
        DomainEvent::UserLoggedIn {
            user_id,
            session_token,
        } => {
            assert_eq!(user_id, 1);
            assert_eq!(session_token, token);
        }
        other => panic!("unexpected event: {other:?}"),
    }
}

/// Attempting to log in with an unknown user should be rejected.
#[test]
fn unknown_user_cannot_log_in() {
    let bus = EventBus::new();
    let auth = AuthService::new(&[99]); // only user 99 exists

    let res = auth.login(1234, &bus);

    assert!(
        matches!(res, Err(AuthError::UnknownUser)),
        "expected UnknownUser, got {res:?}"
    );
}
```