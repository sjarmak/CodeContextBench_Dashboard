```rust
//! src/module_71.rs
//!
//! Event-bus abstraction layer for **EduPulse Live**.
//!
//! This module offers a clean, dependency-inverted boundary for publishing and
//! consuming domain events inside the monolith as well as across service
//! boundaries through a RabbitMQ broker.  A lightweight in-memory
//! implementation is provided for unit tests and development environments.
//!
//! # Features
//! * Domain-event envelope with strong typing & traceable metadata
//! * Asynchronous, back-pressure aware publishing
//! * Broadcast channel for internal fan-out
//! * RabbitMQ implementation with automatic (re)connection
//! * Structured error handling via `anyhow`
//!
//! # Usage
//! ```rust,no_run
//! use edupulse_eventbus::{EventBus, InMemoryEventBus, DomainEvent, EventKind};
//! use uuid::Uuid;
//!
//! # tokio::runtime::Runtime::new().unwrap().block_on(async {
//! let bus = InMemoryEventBus::default();
//!
//! bus.publish(&DomainEvent::new(
//!     Uuid::new_v4(),
//!     EventKind::LessonPublished,
//!     serde_json::json!({ "lesson_id": 42, "title": "Rust Basics" }),
//! )).await.unwrap();
//!
//! let mut sub = bus.subscribe().await.unwrap();
//! let event = sub.recv().await.unwrap();
//! println!("received: {event:?}");
//! # });
//! ```

use std::{fmt, str::FromStr, time::Duration};

use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use futures_util::StreamExt;
use lapin::{
    options::{BasicConsumeOptions, BasicPublishOptions, QueueDeclareOptions},
    types::FieldTable,
    BasicProperties, Channel, Connection, ConnectionProperties,
};
use log::{debug, error, info, warn};
use serde::{Deserialize, Serialize};
use tokio::{
    select,
    sync::{broadcast, Notify},
    task,
    time,
};
use uuid::Uuid;

/// Maximum number of in-flight events kept in the broadcast buffer.
///
/// When the channel is full, the oldest events are dropped automatically.  
/// Consumers that cannot keep up will receive an `Err(broadcast::error::RecvError::Lagged)`.
const BROADCAST_BUFFER: usize = 1_024;

/// Logical name of the RabbitMQ exchange used for domain events.
const EXCHANGE_NAME: &str = "edupulse.events";

/// ===============================================================================================
/// Domain Model
/// ===============================================================================================

/// Enumeration of all **public** domain-event kinds emitted by EduPulse.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum EventKind {
    LessonPublished,
    QuizSubmitted,
    PeerFeedbackGiven,
    BadgeAwarded,
    PaymentProcessed,
    LearningPulseCreated,
    LearningPulseResponded,
}

impl fmt::Display for EventKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = serde_json::to_string(self).map_err(|_| fmt::Error)?;
        write!(f, "{}", s.trim_matches('"'))
    }
}

impl FromStr for EventKind {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self> {
        serde_json::from_str(&format!("\"{s}\"")).map_err(|e| anyhow!(e))
    }
}

/// Canonical envelope for any cross-service domain event.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEvent {
    /// Unique identifier of *this* event instance (for idempotency).
    pub id: Uuid,
    /// Identifier of the aggregate root responsible for this event.
    pub aggregate_id: Uuid,
    /// Timestamp in UTC when the event occurred (business time, not persisted time).
    pub occurred_at: DateTime<Utc>,
    /// Discriminant for routing & analytics.
    pub kind: EventKind,
    /// JSON blob that contains the actual business payload.
    ///
    /// We keep it untyped at this layer to avoid a monolithic crate that depends on
    /// every bounded context’s internal structures.
    pub data: serde_json::Value,
}

impl DomainEvent {
    /// Create a new [`DomainEvent`] with sane defaults.
    pub fn new(aggregate_id: Uuid, kind: EventKind, data: serde_json::Value) -> Self {
        Self {
            id: Uuid::new_v4(),
            aggregate_id,
            occurred_at: Utc::now(),
            kind,
            data,
        }
    }

    /// Convert to raw bytes for transport (UTF-8 JSON).
    fn to_bytes(&self) -> Result<Vec<u8>> {
        Ok(serde_json::to_vec(self)?)
    }

    /// Attempt to parse a [`DomainEvent`] from a UTF-8 JSON slice.
    fn from_bytes(bytes: &[u8]) -> Result<Self> {
        Ok(serde_json::from_slice(bytes)?)
    }
}

/// ===============================================================================================
/// Event-bus Abstraction
/// ===============================================================================================

/// High-level trait used by application & domain layers.
#[async_trait]
pub trait EventBus: Send + Sync {
    /// Publish a domain event to subscribers.
    async fn publish(&self, event: &DomainEvent) -> Result<()>;

    /// Subscribe to *all* domain events.
    ///
    /// Returns a [`broadcast::Receiver`] which yields owned, cloned copies of the original event.
    /// Receivers are independent; each must keep up with the producer or risk back-pressure.
    async fn subscribe(&self) -> Result<broadcast::Receiver<DomainEvent>>;
}

/// ===============================================================================================
/// In-memory Implementation
/// ===============================================================================================

/// Simplest implementation based on a Tokio broadcast channel.
#[derive(Debug)]
pub struct InMemoryEventBus {
    tx: broadcast::Sender<DomainEvent>,
}

impl Default for InMemoryEventBus {
    fn default() -> Self {
        let (tx, _rx) = broadcast::channel(BROADCAST_BUFFER);
        Self { tx }
    }
}

#[async_trait]
impl EventBus for InMemoryEventBus {
    async fn publish(&self, event: &DomainEvent) -> Result<()> {
        // Cloning incurs a small cost but keeps semantics clear.
        self.tx
            .send(event.clone())
            .map(|_| ())
            .map_err(|e| anyhow!("failed to broadcast event: {e}"))
    }

    async fn subscribe(&self) -> Result<broadcast::Receiver<DomainEvent>> {
        Ok(self.tx.subscribe())
    }
}

/// ===============================================================================================
/// RabbitMQ Implementation
/// ===============================================================================================

/// Production-grade bus backed by a RabbitMQ direct exchange.
///
/// Internally, we re-broadcast all incoming events to an in-process channel so
/// callers use the same API regardless of backend.
pub struct RabbitMqEventBus {
    tx: broadcast::Sender<DomainEvent>,
    /// Notifies background tasks to shut down gracefully.
    shutdown: Notify,
}

impl RabbitMqEventBus {
    /// Establish a new connection and spawn background consumer loop.
    ///
    /// `amqp_addr` should follow the AMQP URI specification, e.g.:
    /// `amqps://user:password@mq.edupulse.cloud:5671/%2f`.
    pub async fn new(amqp_addr: &str) -> Result<Self> {
        let (tx, _rx) = broadcast::channel(BROADCAST_BUFFER);
        let shutdown = Notify::new();
        let cloned_tx = tx.clone();
        let shutdown_listener = shutdown.clone();
        let addr = amqp_addr.to_owned();

        task::spawn(async move {
            loop {
                // Outer reconnect loop.
                match Self::run_consumer(&addr, cloned_tx.clone(), &shutdown_listener).await {
                    Ok(_) => {
                        info!("RabbitMQ consumer terminated gracefully.");
                        break;
                    }
                    Err(e) => {
                        error!("RabbitMQ consumer error: {e:#}. Retrying in 5s…");
                        select! {
                            _ = time::sleep(Duration::from_secs(5)) => continue,
                            _ = shutdown_listener.notified() => break,
                        }
                    }
                }
            }
        });

        Ok(Self { tx, shutdown })
    }

    /// Internal helper that runs a single consumer session until error/shutdown.
    async fn run_consumer(
        amqp_addr: &str,
        tx: broadcast::Sender<DomainEvent>,
        shutdown: &Notify,
    ) -> Result<()> {
        info!("Connecting to RabbitMQ @ {amqp_addr}");
        let conn = Connection::connect(amqp_addr, ConnectionProperties::default())
            .await
            .context("failed to connect to RabbitMQ")?;

        let channel = conn
            .create_channel()
            .await
            .context("failed to open channel")?;

        // Ensure exchange exists (idempotent).
        channel
            .exchange_declare(
                EXCHANGE_NAME,
                lapin::ExchangeKind::Fanout,
                lapin::options::ExchangeDeclareOptions {
                    durable: true,
                    auto_delete: false,
                    internal: false,
                    nowait: false,
                },
                FieldTable::default(),
            )
            .await
            .context("failed to declare exchange")?;

        // Each consumer has its *own* queue with a random name.
        let queue = channel
            .queue_declare(
                "",
                QueueDeclareOptions {
                    durable: false,
                    exclusive: true,
                    auto_delete: true,
                    nowait: false,
                },
                FieldTable::default(),
            )
            .await
            .context("failed to declare queue")?;

        // Bind to the fanout exchange.
        channel
            .queue_bind(
                queue.name().as_str(),
                EXCHANGE_NAME,
                "",
                lapin::options::QueueBindOptions::default(),
                FieldTable::default(),
            )
            .await
            .context("failed to bind queue")?;

        let mut consumer = channel
            .basic_consume(
                queue.name().as_str(),
                "edupulse_consumer",
                BasicConsumeOptions::default(),
                FieldTable::default(),
            )
            .await
            .context("failed to start consumer")?;

        info!("RabbitMQ consumer loop started.");

        loop {
            select! {
                delivery = consumer.next() => match delivery {
                    Some(Ok(delivery)) => Self::handle_delivery(&tx, delivery).await?,
                    Some(Err(e)) => {
                        warn!("RabbitMQ delivery error: {e:#}. Re-establishing consumer…");
                        break;
                    },
                    None => {
                        warn!("RabbitMQ consumer ended unexpectedly.");
                        break;
                    }
                },
                _ = shutdown.notified() => {
                    info!("RabbitMQ consumer received shutdown signal.");
                    break;
                }
            }
        }

        Ok(())
    }

    /// Process a single AMQP delivery and forward to broadcast channel.
    async fn handle_delivery(
        tx: &broadcast::Sender<DomainEvent>,
        delivery: lapin::message::Delivery,
    ) -> Result<()> {
        let event = DomainEvent::from_bytes(&delivery.data)
            .context("failed to deserialize domain event")?;
        // Ack as soon as we can decode; we do not want to block the broker.
        delivery
            .ack(lapin::options::BasicAckOptions::default())
            .await
            .context("failed to ack delivery")?;

        // Propagate to in-process subscribers.
        match tx.send(event) {
            Ok(_subs) => Ok(()),
            Err(e) => {
                warn!("No active subscribers for event; dropped. {e}");
                Ok(())
            }
        }
    }

    /// Publish directly on a separate channel for thread safety.
    async fn publish_on_channel(channel: &Channel, event: &DomainEvent) -> Result<()> {
        channel
            .basic_publish(
                EXCHANGE_NAME,
                "",
                BasicPublishOptions::default(),
                &event.to_bytes()?,
                BasicProperties::default()
                    .with_content_type("application/json".into())
                    .with_message_id(event.id.to_string().into())
                    .with_type(event.kind.to_string().into()),
            )
            .await?
            .await // wait for broker confirmation
            .context("broker did not confirm publish")?;
        Ok(())
    }
}

#[async_trait]
impl EventBus for RabbitMqEventBus {
    async fn publish(&self, event: &DomainEvent) -> Result<()> {
        // We establish a short-lived channel for each publish to keep the API simple
        // and avoid holding channels across async await points inside user code.
        let amqp_url =
            std::env::var("AMQP_URL").unwrap_or_else(|_| "amqp://guest:guest@127.0.0.1:5672/%2f".into());

        let conn = Connection::connect(&amqp_url, ConnectionProperties::default())
            .await
            .context("failed to connect to RabbitMQ for publish")?;
        let channel = conn
            .create_channel()
            .await
            .context("failed to open channel")?;

        Self::publish_on_channel(&channel, event).await
    }

    async fn subscribe(&self) -> Result<broadcast::Receiver<DomainEvent>> {
        Ok(self.tx.subscribe())
    }
}

impl Drop for RabbitMqEventBus {
    fn drop(&mut self) {
        self.shutdown.notify_waiters();
    }
}

/// ===============================================================================================
/// Tests
/// ===============================================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn in_memory_bus_roundtrip() {
        let bus = InMemoryEventBus::default();
        let mut rx = bus.subscribe().await.unwrap();

        let event = DomainEvent::new(
            Uuid::new_v4(),
            EventKind::QuizSubmitted,
            serde_json::json!({"score": 90}),
        );

        bus.publish(&event).await.unwrap();

        let received = rx.recv().await.unwrap();
        assert_eq!(event.kind, received.kind);
        assert_eq!(event.data, received.data);
    }
}
```