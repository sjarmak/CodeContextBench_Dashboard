```rust
//! src/module_3.rs
//!
//! Learning Pulse domain, repository and service layer for the
//! EduPulse-Live platform.  
//!
//! Highlights
//! ----------
//! 1. Domain logic is completely isolated from persistence and messaging.
//! 2. Repository pattern is used to hide Diesel/PostgreSQL details.
//! 3. Every write operation emits a `DomainEvent`, which is forwarded to an
//!    async NATS publisher.  
//! 4. Uses `thiserror` for rich error reporting.
//! 5. All public items are documented, making the module usable as a
//!    standalone crate inside a workspace.
//!
//! NOTE: Actual database migrations, schema generation (`diesel print-schema`),
//! and Tokio runtime boot-strapping live elsewhere in the project.

use std::sync::Arc;
use std::time::SystemTime;

use async_nats::Client as NatsClient;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use diesel::r2d2::{ConnectionManager, PooledConnection};
use diesel::{insert_into, PgConnection, RunQueryDsl};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::sync::mpsc;

/// Table mapping generated by `diesel print-schema`
///
/// ```sql
/// create table learning_pulses
/// (
///     id              uuid primary key,
///     teacher_id      uuid not null,
///     title           text not null,
///     body            text not null,
///     tags            text[] default '{}',
///     created_at      timestamptz not null,
///     updated_at      timestamptz not null
/// );
/// ```
mod schema {
    table! {
        learning_pulses (id) {
            id -> Uuid,
            teacher_id -> Uuid,
            title -> Text,
            body -> Text,
            tags -> Array<Text>,
            created_at -> Timestamptz,
            updated_at -> Timestamptz,
        }
    }
}

use schema::learning_pulses;

/// High-level application error used across service, repository and transport.
/// Keeps I/O specific details at the edge.
#[derive(Debug, Error)]
pub enum AppError {
    #[error("database interaction failed: {0}")]
    Database(#[from] diesel::result::Error),

    #[error("connection pool exhausted")]
    PoolTimeout(#[from] r2d2::Error),

    #[error("serialization error: {0}")]
    Serde(#[from] serde_json::Error),

    #[error("message broker error: {0}")]
    Nats(#[from] async_nats::Error),

    #[error("validation error: {0}")]
    Validation(String),
}

/// Immutable Learning Pulse domain entity.
#[derive(Clone, Debug, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = learning_pulses)]
pub struct LearningPulse {
    pub id: uuid::Uuid,
    pub teacher_id: uuid::Uuid,
    pub title: String,
    pub body: String,
    pub tags: Vec<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Payload for inserting a new pulse.
#[derive(Debug, Insertable)]
#[diesel(table_name = learning_pulses)]
struct NewLearningPulse<'a> {
    id: uuid::Uuid,
    teacher_id: uuid::Uuid,
    title: &'a str,
    body: &'a str,
    tags: &'a Vec<String>,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}

/// Event types emitted by EduPulse core services.
#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type", content = "payload")]
pub enum DomainEvent {
    LearningPulseCreated {
        pulse_id: uuid::Uuid,
        teacher_id: uuid::Uuid,
        timestamp: DateTime<Utc>,
    },
}

/// Repository interface.
///
/// All database access is expressed in terms of this trait, which allows the
/// caller to swap implementations (e.g. for tests or for sharding).
#[async_trait::async_trait]
pub trait LearningPulseRepository: Send + Sync {
    async fn insert(&self, pulse: LearningPulse) -> Result<(), AppError>;
    async fn find(&self, id: uuid::Uuid) -> Result<Option<LearningPulse>, AppError>;
    async fn list_recent(&self, limit: i64) -> Result<Vec<LearningPulse>, AppError>;
}

/// Diesel/PostgreSQL implementation of the repository.
pub struct DieselLearningPulseRepo {
    pool: r2d2::Pool<ConnectionManager<PgConnection>>,
}

impl DieselLearningPulseRepo {
    pub fn new(pool: r2d2::Pool<ConnectionManager<PgConnection>>) -> Self {
        Self { pool }
    }

    fn conn(&self) -> Result<PooledConnection<ConnectionManager<PgConnection>>, AppError> {
        self.pool.get().map_err(AppError::PoolTimeout)
    }
}

#[async_trait::async_trait]
impl LearningPulseRepository for DieselLearningPulseRepo {
    async fn insert(&self, pulse: LearningPulse) -> Result<(), AppError> {
        let conn = self.conn()?;
        // Diesel is synchronous; offload heavy operations to blocking thread-pool.
        tokio::task::spawn_blocking(move || {
            let new_pulse = NewLearningPulse {
                id: pulse.id,
                teacher_id: pulse.teacher_id,
                title: &pulse.title,
                body: &pulse.body,
                tags: &pulse.tags,
                created_at: pulse.created_at,
                updated_at: pulse.updated_at,
            };
            insert_into(learning_pulses::table)
                .values(&new_pulse)
                .execute(&conn)
        })
        .await
        .expect("spawn_blocking panicked")?; // propagate diesel::Error
        Ok(())
    }

    async fn find(&self, id: uuid::Uuid) -> Result<Option<LearningPulse>, AppError> {
        let conn = self.conn()?;
        let result = tokio::task::spawn_blocking(move || {
            learning_pulses::table
                .find(id)
                .first(&conn)
                .optional()
        })
        .await
        .expect("spawn_blocking panicked")?;
        Ok(result)
    }

    async fn list_recent(&self, limit: i64) -> Result<Vec<LearningPulse>, AppError> {
        let conn = self.conn()?;
        let pulses = tokio::task::spawn_blocking(move || {
            learning_pulses::table
                .order(learning_pulses::created_at.desc())
                .limit(limit)
                .load::<LearningPulse>(&conn)
        })
        .await
        .expect("spawn_blocking panicked")?;
        Ok(pulses)
    }
}

/// Abstraction over any message broker that can deliver domain events.
#[async_trait::async_trait]
pub trait EventPublisher: Send + Sync {
    async fn publish(&self, ev: &DomainEvent) -> Result<(), AppError>;
}

pub struct NatsPublisher {
    client: NatsClient,
    subject_prefix: String,
}

impl NatsPublisher {
    pub async fn connect_from_env() -> Result<Self, AppError> {
        let nats_url = std::env::var("NATS_URL").unwrap_or_else(|_| "nats://127.0.0.1:4222".into());
        let client = async_nats::connect(&nats_url).await?;
        Ok(Self {
            client,
            subject_prefix: "edu_pulse.events".into(),
        })
    }

    fn subject_for(&self, ev: &DomainEvent) -> String {
        match ev {
            DomainEvent::LearningPulseCreated { .. } => format!("{}.learning_pulse.created", self.subject_prefix),
        }
    }
}

#[async_trait::async_trait]
impl EventPublisher for NatsPublisher {
    async fn publish(&self, ev: &DomainEvent) -> Result<(), AppError> {
        let subject = self.subject_for(ev);
        let payload = serde_json::to_vec(ev)?;
        self.client.publish(subject, payload.into()).await?;
        Ok(())
    }
}

/// Primary service used by REST controllers and gRPC handlers.
///
/// The service takes ownership of domain logic: validation, repository writes,
/// event emission, etc.
pub struct LearningPulseService {
    repo: Arc<dyn LearningPulseRepository>,
    publisher: Arc<dyn EventPublisher>,
    /// Decouples HTTP latency from broker latency by buffering outgoing events.
    tx: mpsc::Sender<DomainEvent>,
}

impl LearningPulseService {
    pub fn new(
        repo: Arc<dyn LearningPulseRepository>,
        publisher: Arc<dyn EventPublisher>,
    ) -> Self {
        let (tx, mut rx) = mpsc::channel::<DomainEvent>(1024);
        let publisher_clone = publisher.clone();

        // Spawn background task to forward events.
        tokio::spawn(async move {
            while let Some(ev) = rx.recv().await {
                if let Err(e) = publisher_clone.publish(&ev).await {
                    // TODO: push to dead-letter queue or retry mechanism.
                    tracing::error!(error = %e, "failed to publish domain event");
                }
            }
        });

        Self { repo, publisher, tx }
    }

    /// Creates a new learning pulse and publishes corresponding event.
    pub async fn create_pulse(
        &self,
        teacher_id: uuid::Uuid,
        title: String,
        body: String,
        tags: Vec<String>,
    ) -> Result<LearningPulse, AppError> {
        // --- Validation ----------------------------------------------------
        if title.trim().is_empty() {
            return Err(AppError::Validation("title may not be empty".into()));
        }
        if body.trim().is_empty() {
            return Err(AppError::Validation("body may not be empty".into()));
        }

        // --- Entity construction -------------------------------------------
        let now = Utc::now();
        let pulse = LearningPulse {
            id: uuid::Uuid::new_v4(),
            teacher_id,
            title,
            body,
            tags,
            created_at: now,
            updated_at: now,
        };

        // --- Persistence ----------------------------------------------------
        self.repo.insert(pulse.clone()).await?;

        // --- Event emission --------------------------------------------------
        let ev = DomainEvent::LearningPulseCreated {
            pulse_id: pulse.id,
            teacher_id: pulse.teacher_id,
            timestamp: now,
        };
        // Send to buffer; do not await publisher here.
        if let Err(e) = self.tx.send(ev).await {
            tracing::error!(error = ?e, "event buffer channel closed unexpectedly");
        }

        Ok(pulse)
    }

    pub async fn get(&self, id: uuid::Uuid) -> Result<Option<LearningPulse>, AppError> {
        self.repo.find(id).await
    }

    pub async fn most_recent(&self, limit: i64) -> Result<Vec<LearningPulse>, AppError> {
        self.repo.list_recent(limit).await
    }
}

/// Helper that boot-straps the service from environment variables.
///
/// This is usually called by the `main.rs` of the micro-service exposing REST
/// endpoints or gRPC interfaces, but lives here so integration tests can spin
/// up a fully-wired service.
pub async fn new_service_from_env() -> Result<LearningPulseService, AppError> {
    // DATABASE_URL expects something like: postgres://user:pass@host:5432/db_name
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    let manager = ConnectionManager::<PgConnection>::new(database_url);
    let pool = r2d2::Pool::builder()
        .max_size(20)
        .connection_timeout(std::time::Duration::from_secs(5))
        .build(manager)?;

    let repo = Arc::new(DieselLearningPulseRepo::new(pool));
    let publisher = Arc::new(NatsPublisher::connect_from_env().await?);
    Ok(LearningPulseService::new(repo, publisher))
}

// ---------------------------------------------------------------------------
// Unit-tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use uuid::Uuid;

    struct NoopRepo;
    #[async_trait::async_trait]
    impl LearningPulseRepository for NoopRepo {
        async fn insert(&self, _pulse: LearningPulse) -> Result<(), AppError> {
            Ok(())
        }
        async fn find(&self, _id: Uuid) -> Result<Option<LearningPulse>, AppError> {
            Ok(None)
        }
        async fn list_recent(&self, _limit: i64) -> Result<Vec<LearningPulse>, AppError> {
            Ok(vec![])
        }
    }

    struct MemoryPublisher;
    #[async_trait::async_trait]
    impl EventPublisher for MemoryPublisher {
        async fn publish(&self, _ev: &DomainEvent) -> Result<(), AppError> {
            Ok(())
        }
    }

    #[tokio::test]
    async fn create_valid_pulse_succeeds() {
        let svc = LearningPulseService::new(
            Arc::new(NoopRepo),
            Arc::new(MemoryPublisher),
        );

        let res = svc
            .create_pulse(
                Uuid::new_v4(),
                "Test Pulse".into(),
                "Describe quantum tunnelling.".into(),
                vec!["physics".into(), "quantum".into()],
            )
            .await
            .expect("creation failed");

        assert_eq!(res.title, "Test Pulse");
    }

    #[tokio::test]
    async fn create_invalid_pulse_fails() {
        let svc = LearningPulseService::new(
            Arc::new(NoopRepo),
            Arc::new(MemoryPublisher),
        );

        let err = svc
            .create_pulse(
                Uuid::new_v4(),
                "".into(),
                "".into(),
                vec![],
            )
            .await
            .unwrap_err();

        match err {
            AppError::Validation(_) => {}
            other => panic!("unexpected error: {other:?}"),
        }
    }
}
```