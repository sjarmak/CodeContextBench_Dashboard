```rust
//! src/module_70.txt
//! -------------------------------------------------------------
//! Event‐centric core module for EduPulse Live.
//!
//! This module defines core domain events, an event dispatcher
//! abstraction, a minimal in-memory repository, and a service that
//! orchestrates “learning pulse” creation while emitting events.
//!
//! In the real production system these traits would be implemented
//! by Kafka/NATS dispatchers and a Postgres/MongoDB repository,
//! but the scaffolding below is sufficient for unit/integration
//! testing as well as local developer workflows.
//!
//! -------------------------------------------------------------

#![allow(clippy::missing_async)]
#![warn(
    missing_docs,
    clippy::unwrap_used,
    clippy::nursery,
    clippy::pedantic
)]

use std::{
    collections::HashMap,
    sync::{Arc, RwLock},
};

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use thiserror::Error;
use tokio::task;
use tracing::{error, info, instrument, warn};
use uuid::Uuid;

/// Re-export commonly used domain primitives.
pub mod prelude {
    pub use super::{
        EventDispatcher, EventEnvelope, EventMetadata, Pulse, PulseCreated,
        PulseRepository, PulseService, ServiceError,
    };
}

//
// ──────────────────────────────────────────────────────────────────────────
//  Domain: Pulses
// ──────────────────────────────────────────────────────────────────────────
//

/// A short, time-sensitive learning activity authored by a teacher.
#[derive(Debug, Clone)]
pub struct Pulse {
    /// Primary key.
    pub id: Uuid,
    /// Authoring teacher account ID.
    pub teacher_id: Uuid,
    /// Human-friendly title.
    pub title: String,
    /// Markdown/HTML content of the challenge prompt.
    pub content: String,
    /// Creation timestamp, UTC.
    pub created_at: DateTime<Utc>,
}

impl Pulse {
    /// Business-rule validation while constructing a new `Pulse`.
    pub fn new(
        teacher_id: Uuid,
        title: impl Into<String>,
        content: impl Into<String>,
    ) -> Result<Self, PulseValidationError> {
        let title = title.into();
        let content = content.into();

        if title.trim().is_empty() {
            return Err(PulseValidationError::EmptyTitle);
        }
        if title.len() > 140 {
            return Err(PulseValidationError::TitleTooLong);
        }
        if content.trim().is_empty() {
            return Err(PulseValidationError::EmptyContent);
        }

        Ok(Self {
            id: Uuid::new_v4(),
            teacher_id,
            title,
            content,
            created_at: Utc::now(),
        })
    }
}

/// Domain-level validation errors.
#[derive(Debug, Error)]
pub enum PulseValidationError {
    /// Title must not be empty.
    #[error("title must not be empty")]
    EmptyTitle,
    /// Title length exceeded 140 UTF-8 code points.
    #[error("title exceeds 140 characters")]
    TitleTooLong,
    /// Content must not be empty.
    #[error("content must not be empty")]
    EmptyContent,
}

//
// ──────────────────────────────────────────────────────────────────────────
//  Events
// ──────────────────────────────────────────────────────────────────────────
//

/// Marker trait for strongly-typed domain events.
///
/// Implementations MUST be `Send` + `Sync` + `Clone` so they can safely
/// travel across asynchronous boundaries and be queued for dispatch.
pub trait DomainEvent: Send + Sync + Clone {
    /// A camel-cased event key, e.g. `PulseCreated`.
    fn event_key(&self) -> &'static str;
}

/// Concrete event emitted when a teacher publishes a new pulse.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PulseCreated {
    /// Pulse identifier.
    pub pulse_id: Uuid,
    /// Teacher identifier.
    pub teacher_id: Uuid,
    /// Title of the pulse.
    pub title: String,
    /// When the pulse was created.
    pub occurred_at: DateTime<Utc>,
}

impl DomainEvent for PulseCreated {
    fn event_key(&self) -> &'static str {
        "PulseCreated"
    }
}

/// Metadata attached to every event envelope.
///
/// This metadata is largely transport-agnostic and will be mapped to
/// message headers on brokers such as Kafka or NATS.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct EventMetadata {
    /// Unique identifier of the event itself.
    pub id: Uuid,
    /// Timestamp in UTC when the event occurred.
    pub timestamp: DateTime<Utc>,
    /// Correlation chain root (e.g. HTTP request id).
    pub correlation_id: Option<Uuid>,
    /// Immediate parent event id (a.k.a. causation id).
    pub causation_id: Option<Uuid>,
    /// Schema version for safely evolving payloads.
    pub schema_version: u16,
}

/// Transport-agnostic wrapper that bundles the event and required
/// telemetry/trace metadata.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct EventEnvelope<E: DomainEvent> {
    /// Event payload.
    pub payload: E,
    /// Envelope metadata.
    pub meta: EventMetadata,
}

impl<E: DomainEvent> EventEnvelope<E> {
    /// Serialises the envelope to a UTF-8 JSON string.  
    ///  
    /// This format is compatible with most log retention and message bus
    /// systems and can be deserialised using Serde.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }
}

/// Factory helper to create a fully-formed envelope.
///
/// Correlation and causation ids are optional and mostly relevant
/// in distributed tracing scenarios.
#[allow(clippy::needless_pass_by_value)]
#[must_use]
pub fn envelope<E: DomainEvent>(
    payload: E,
    correlation_id: Option<Uuid>,
    causation_id: Option<Uuid>,
) -> EventEnvelope<E> {
    EventEnvelope {
        payload,
        meta: EventMetadata {
            id: Uuid::new_v4(),
            timestamp: Utc::now(),
            correlation_id,
            causation_id,
            schema_version: 1,
        },
    }
}

//
// ──────────────────────────────────────────────────────────────────────────
//  Event Dispatcher
// ──────────────────────────────────────────────────────────────────────────
//

/// Errors raised while dispatching events.
#[derive(Debug, Error)]
pub enum DispatchError {
    /// Network or broker failures.
    #[error("network dispatcher error: {0}")]
    Network(String),
    /// Serialisation or (de)serialisation failures.
    #[error("payload encoding error: {0}")]
    Encoding(String),
}

/// Abstraction behind message-bus clients.
///
/// Implementations are usually thin wrappers over Kafka, RabbitMQ, NATS,
/// etc. The use of `async_trait` allows dispatchers to perform
/// non-blocking IO.
#[async_trait]
pub trait EventDispatcher: Send + Sync + 'static {
    /// Dispatch an envelope to the configured topic/subject.
    async fn dispatch<E: DomainEvent + serde::Serialize + Send + Sync>(
        &self,
        envelope: EventEnvelope<E>,
    ) -> Result<(), DispatchError>;
}

/// A fall-back dispatcher that prints JSON to the tracing layer.
///
/// This is primarily meant for unit tests and local development. It also
/// doubles as a circuit-breaker mechanism should the primary dispatcher
/// fail.
#[derive(Default)]
pub struct StdoutDispatcher;

#[async_trait]
impl EventDispatcher for StdoutDispatcher {
    #[instrument(level = "info", skip(self, envelope))]
    async fn dispatch<E: DomainEvent + serde::Serialize + Send + Sync>(
        &self,
        envelope: EventEnvelope<E>,
    ) -> Result<(), DispatchError> {
        match envelope.to_json() {
            Ok(json) => {
                info!(
                    event_key = envelope.payload.event_key(),
                    payload = %json,
                    "event dispatched via stdout dispatcher"
                );
                Ok(())
            }
            Err(err) => {
                error!(error = %err, "failed to serialise event envelope");
                Err(DispatchError::Encoding(err.to_string()))
            }
        }
    }
}

//
// ──────────────────────────────────────────────────────────────────────────
//  Repository
// ──────────────────────────────────────────────────────────────────────────
//

/// Domain persistence abstraction.
#[async_trait]
pub trait PulseRepository: Send + Sync {
    /// Persist a newly created pulse.
    async fn insert(&self, pulse: Pulse) -> Result<(), RepositoryError>;
}

/// Errors surfaced by repositories.
#[derive(Debug, Error)]
pub enum RepositoryError {
    /// Record already exists (primary key violation).
    #[error("pulse with id `{0}` already exists")]
    Duplicate(Uuid),
    /// Any other persistence layer failure.
    #[error("persistence error: {0}")]
    Io(String),
}

/// Non-production, in-memory repository useful for testing.
#[derive(Default, Clone)]
pub struct InMemoryPulseRepository {
    store: Arc<RwLock<HashMap<Uuid, Pulse>>>,
}

#[async_trait]
impl PulseRepository for InMemoryPulseRepository {
    #[instrument(level = "debug", skip(self, pulse))]
    async fn insert(&self, pulse: Pulse) -> Result<(), RepositoryError> {
        // Use `spawn_blocking` to avoid locking from within an async context.
        let store = Arc::clone(&self.store);
        task::spawn_blocking(move || {
            let mut guard = store
                .write()
                .map_err(|_| RepositoryError::Io("poisoned lock".into()))?;

            if guard.contains_key(&pulse.id) {
                return Err(RepositoryError::Duplicate(pulse.id));
            }
            guard.insert(pulse.id, pulse);
            Ok(())
        })
        .await
        .map_err(|join_err| RepositoryError::Io(join_err.to_string()))?
    }
}

//
// ──────────────────────────────────────────────────────────────────────────
//  Service Layer
// ──────────────────────────────────────────────────────────────────────────
//

/// High-level orchestration API for the Pulse bounded context.
///
/// The service owns no mutable state; all side-effects are deferred to the
/// injected repository and dispatcher, enabling easy testing and mocking.
#[derive(Clone)]
pub struct PulseService<R, D>
where
    R: PulseRepository,
    D: EventDispatcher,
{
    repo: Arc<R>,
    dispatcher: Arc<D>,
}

/// Public service errors.
#[derive(Debug, Error)]
pub enum ServiceError {
    /// Business rule violation.
    #[error("validation failed: {0}")]
    Validation(#[from] PulseValidationError),
    /// Persistence layer error.
    #[error(transparent)]
    Repository(#[from] RepositoryError),
    /// Event dispatcher failure.
    #[error(transparent)]
    Dispatch(#[from] DispatchError),
}

impl<R, D> PulseService<R, D>
where
    R: PulseRepository,
    D: EventDispatcher,
{
    /// Create a new `PulseService`.
    #[must_use]
    pub fn new(repo: Arc<R>, dispatcher: Arc<D>) -> Self {
        Self { repo, dispatcher }
    }

    /// Publish a brand new learning pulse.
    ///
    /// On success, returns the generated `Pulse` (with id). Any downstream
    /// failure (DB write, event dispatch) is surfaced via `ServiceError`.
    #[instrument(
        level = "info",
        skip(self),
        fields(teacher_id = %teacher_id, title = %title)
    )]
    pub async fn create_pulse(
        &self,
        teacher_id: Uuid,
        title: impl Into<String>,
        content: impl Into<String>,
        correlation_id: Option<Uuid>,
    ) -> Result<Pulse, ServiceError> {
        // 1. Construct pulse while enforcing business invariants.
        let pulse = Pulse::new(teacher_id, title, content)?;

        // 2. Persist to repository.
        self.repo.insert(pulse.clone()).await?;

        // 3. Emit `PulseCreated` event asynchronously.
        let event = PulseCreated {
            pulse_id: pulse.id,
            teacher_id: pulse.teacher_id,
            title: pulse.title.clone(),
            occurred_at: pulse.created_at,
        };

        let envelope = envelope(event, correlation_id, None);

        // Fire-and-forget dispatch.  We propagate errors in case upstream
        // callers need transactional guarantees.
        self.dispatcher.dispatch(envelope).await?;

        Ok(pulse)
    }
}

//
// ──────────────────────────────────────────────────────────────────────────
//  Tests
// ──────────────────────────────────────────────────────────────────────────
//

#[cfg(test)]
mod tests {
    use super::*;
    use tracing_test::traced_test;

    #[traced_test]
    #[tokio::test]
    async fn pulse_creation_emits_event_and_persists_record() {
        let repo = Arc::new(InMemoryPulseRepository::default());
        let dispatcher = Arc::new(StdoutDispatcher::default());
        let service = PulseService::new(repo.clone(), dispatcher);

        let teacher_id = Uuid::new_v4();

        let pulse = service
            .create_pulse(
                teacher_id,
                "Binary Trees",
                r#"Explain how binary trees can be used to speed up search."#,
                None,
            )
            .await
            .expect("pulse creation should succeed");

        // Verify the pulse is stored.
        let store_guard = repo.store.read().unwrap();
        assert!(store_guard.contains_key(&pulse.id));

        // Dispatcher writes to tracing; we assert via `traced_test` macro.
        assert!(
            logs_contain("event dispatched via stdout dispatcher"),
            "expected dispatch log entry"
        );
    }

    #[tokio::test]
    async fn invalid_title_is_rejected() {
        let repo = Arc::new(InMemoryPulseRepository::default());
        let dispatcher = Arc::new(StdoutDispatcher::default());
        let service = PulseService::new(repo, dispatcher);

        let err = service
            .create_pulse(Uuid::new_v4(), "", "content", None)
            .await
            .unwrap_err();

        matches!(err, ServiceError::Validation(_));
    }
}
```