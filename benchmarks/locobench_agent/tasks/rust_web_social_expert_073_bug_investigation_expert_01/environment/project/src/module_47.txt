```rust
//! module_47 – Domain services & infrastructure for “Learning Pulses”
//!
//! This file belongs to the EduPulse Live backend.  It is completely
//! self-contained and can be dropped into `src/` and compiled with
//!
//! ```bash
//! cargo add chrono serde serde_json uuid tokio async-trait thiserror tracing
//! ```
//!
//! In production the concrete implementations that speak to Postgres,
//! RabbitMQ / NATS, Redis, etc. live in sibling crates, but the service
//! API, the domain entities and the default “developer-friendly” in-memory
//! components are defined here so that downstream crates and integration
//! tests share a single source of truth.

#![allow(clippy::module_name_repetitions)]

use std::collections::HashMap;
use std::sync::Arc;

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::json;
use thiserror::Error;
use tokio::sync::RwLock;
use tracing::{error, info};
use uuid::Uuid;

/* --------------------------------------------------------------------------
   Domain types
   -------------------------------------------------------------------------- */

/// A “Learning Pulse” represents a short-lived activity created by a teacher.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LearningPulse {
    pub id: Uuid,
    pub title: String,
    pub description: String,
    pub created_by: Uuid,
    pub created_at: DateTime<Utc>,
    pub deadline: Option<DateTime<Utc>>,
}

/// A submission that has been uploaded for a [`LearningPulse`].
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StudentSubmission {
    pub id: Uuid,
    pub pulse_id: Uuid,
    pub student_id: Uuid,
    pub submitted_at: DateTime<Utc>,
    /// The storage bucket key / file path / gist URL etc.
    pub artifact_uri: String,
}

/* --------------------------------------------------------------------------
   Event definitions
   -------------------------------------------------------------------------- */

/// Every domain action produces an event.  The enum purposefully stays *thin*
/// and delegates payload details to an arbitrary JSON value so that we can
/// evolve read-side projections without having to constantly juggle new Rust
/// types around.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum DomainEventKind {
    PulseCreated,
    SubmissionReceived,
}

/// Event envelope enriched with metadata that makes it possible to fully
/// trace causality between commands & events (DDD 101).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventEnvelope {
    pub id: Uuid,
    pub aggregate_id: Uuid,
    pub occurred_at: DateTime<Utc>,

    pub kind: DomainEventKind,
    /// Opaque JSON payload containing the domain information.  Back-end
    /// services that do *not* understand the schema can still pass it through.
    pub payload: serde_json::Value,

    /// Correlation- & causation-IDs provide end-to-end tracing across
    /// multiple bounded contexts and help observability pipelines.
    pub correlation_id: Option<Uuid>,
    pub causation_id: Option<Uuid>,
}

impl EventEnvelope {
    #[must_use]
    pub fn new(
        aggregate_id: Uuid,
        kind: DomainEventKind,
        payload: serde_json::Value,
        correlation_id: Option<Uuid>,
        causation_id: Option<Uuid>,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            aggregate_id,
            occurred_at: Utc::now(),
            kind,
            payload,
            correlation_id,
            causation_id,
        }
    }
}

/* --------------------------------------------------------------------------
   Repository layer
   -------------------------------------------------------------------------- */

/// All application services talk to the data-store via this abstraction which
/// makes it trivial to swap out Postgres for Dynamo, run integration tests
/// fully in memory or integrate a write-behind cache.
#[async_trait]
pub trait LearningPulseRepository: Send + Sync {
    async fn insert_pulse(&self, pulse: &LearningPulse) -> Result<(), RepositoryError>;

    async fn insert_submission(&self, submission: &StudentSubmission)
        -> Result<(), RepositoryError>;

    async fn pulse_exists(&self, pulse_id: Uuid) -> Result<bool, RepositoryError>;
}

/// Database-level error that is intentionally *boring*: callers are not
/// supposed to inspect the root cause, they only need to know whether their
/// mutation succeeded.  (For queries we expose typed errors.)
#[derive(Debug, Error)]
pub enum RepositoryError {
    #[error("database connection lost")]
    ConnectionLost,
    #[error("constraint failed: {0}")]
    ConstraintViolation(String),
    #[error("unknown repository error: {0}")]
    Unknown(String),
}

/* --------------------------------------------------------------------------
   Event publisher abstraction
   -------------------------------------------------------------------------- */

/// Anything that can place events onto a message broker must implement this
/// trait.  The only objective is *at-least-once* delivery; idempotency on the
/// consumer side is mandatory anyway (cf. `id` field on [`EventEnvelope`]).
#[async_trait]
pub trait EventPublisher: Send + Sync {
    async fn publish(&self, event: &EventEnvelope) -> Result<(), EventPublishError>;
}

#[derive(Debug, Error)]
pub enum EventPublishError {
    #[error("transport error: {0}")]
    Transport(String),
    #[error("serialization error: {0}")]
    Serialization(String),
    #[error("unknown: {0}")]
    Unknown(String),
}

/// A no-op fallback that simply logs events.  Useful for local CLI tools
/// or during unit testing where we do not want to spin up NATS/RabbitMQ.
pub struct LoggingEventPublisher;

#[async_trait]
impl EventPublisher for LoggingEventPublisher {
    async fn publish(&self, event: &EventEnvelope) -> Result<(), EventPublishError> {
        info!(?event, "Publishing domain event");
        Ok(())
    }
}

/* --------------------------------------------------------------------------
   Application service
   -------------------------------------------------------------------------- */

/// The service operates on pulses *and* emits domain events.  A typical HTTP
/// handler or GraphQL resolver will hand over all heavy-lifting business logic
/// to this struct.  That way framework glue code stays thin and readable.
pub struct LearningPulseService<R: LearningPulseRepository, E: EventPublisher> {
    repo: Arc<R>,
    publisher: Arc<E>,
}

impl<R, E> LearningPulseService<R, E>
where
    R: LearningPulseRepository + 'static,
    E: EventPublisher + 'static,
{
    pub fn new(repo: Arc<R>, publisher: Arc<E>) -> Self {
        Self { repo, publisher }
    }

    /// Create a new pulse.  Emits a `pulse_created` event *after* the pulse
    /// has been durably persisted (transactional outbox pattern omitted for
    /// brevity but recommended for prod).
    pub async fn create_pulse(
        &self,
        title: String,
        description: String,
        created_by: Uuid,
        deadline: Option<DateTime<Utc>>,
        correlation_id: Option<Uuid>,
    ) -> Result<LearningPulse, ServiceError> {
        let pulse = LearningPulse {
            id: Uuid::new_v4(),
            title,
            description,
            created_by,
            created_at: Utc::now(),
            deadline,
        };

        self.repo.insert_pulse(&pulse).await.map_err(|e| {
            error!(error = %e, "Failed to insert pulse");
            ServiceError::Persistence(e)
        })?;

        // Build & publish event
        let event = EventEnvelope::new(
            pulse.id,
            DomainEventKind::PulseCreated,
            json!({
                "title": pulse.title,
                "description": pulse.description,
                "created_by": pulse.created_by,
                "deadline": pulse.deadline,
            }),
            correlation_id,
            /* causation_id */ None,
        );

        self.publisher.publish(&event).await.map_err(|e| {
            error!(error = %e, "Failed to publish pulse_created event");
            ServiceError::EventPublish(e)
        })?;

        Ok(pulse)
    }

    /// Record a new student submission and emit an event that kicks off
    /// asynchronous workflows such as plagiarism detection, auto-grading,
    /// notifications, etc.
    pub async fn record_submission(
        &self,
        pulse_id: Uuid,
        student_id: Uuid,
        artifact_uri: String,
        correlation_id: Option<Uuid>,
    ) -> Result<StudentSubmission, ServiceError> {
        // Validate that the referenced pulse exists
        if !self.repo.pulse_exists(pulse_id).await.map_err(|e| {
            error!(error = %e, "Repository error while verifying pulse existence");
            ServiceError::Persistence(e)
        })? {
            return Err(ServiceError::UnknownPulse(pulse_id));
        }

        let submission = StudentSubmission {
            id: Uuid::new_v4(),
            pulse_id,
            student_id,
            submitted_at: Utc::now(),
            artifact_uri,
        };

        self.repo
            .insert_submission(&submission)
            .await
            .map_err(|e| {
                error!(error = %e, "Failed to insert submission");
                ServiceError::Persistence(e)
            })?;

        // Kick off event
        let event = EventEnvelope::new(
            pulse_id,
            DomainEventKind::SubmissionReceived,
            json!({
                "submission_id": submission.id,
                "student_id": submission.student_id,
                "artifact_uri": submission.artifact_uri,
            }),
            correlation_id,
            /* causation_id */ None,
        );

        self.publisher.publish(&event).await.map_err(|e| {
            error!(error = %e, "Failed to publish submission_received event");
            ServiceError::EventPublish(e)
        })?;

        Ok(submission)
    }
}

/// High-level business error returned by the service.
#[derive(Debug, Error)]
pub enum ServiceError {
    #[error("repository error: {0}")]
    Persistence(RepositoryError),
    #[error("event publish error: {0}")]
    EventPublish(EventPublishError),
    #[error("pulse {0} does not exist")]
    UnknownPulse(Uuid),
}

/* --------------------------------------------------------------------------
   Reference in-memory repository implementation
   -------------------------------------------------------------------------- */

/// Very small in-memory store for developer tools & unit-tests.  **Do not**
/// use in production, it’s neither transactional nor replicated.
#[derive(Default)]
pub struct InMemoryRepo {
    pulses: RwLock<HashMap<Uuid, LearningPulse>>,
    submissions: RwLock<HashMap<Uuid, StudentSubmission>>,
}

#[async_trait]
impl LearningPulseRepository for InMemoryRepo {
    async fn insert_pulse(&self, pulse: &LearningPulse) -> Result<(), RepositoryError> {
        let mut guard = self.pulses.write().await;
        if guard.contains_key(&pulse.id) {
            return Err(RepositoryError::ConstraintViolation(
                "duplicate pulse id".into(),
            ));
        }
        guard.insert(pulse.id, pulse.clone());
        Ok(())
    }

    async fn insert_submission(
        &self,
        submission: &StudentSubmission,
    ) -> Result<(), RepositoryError> {
        let mut guard = self.submissions.write().await;
        if guard.contains_key(&submission.id) {
            return Err(RepositoryError::ConstraintViolation(
                "duplicate submission id".into(),
            ));
        }
        guard.insert(submission.id, submission.clone());
        Ok(())
    }

    async fn pulse_exists(&self, pulse_id: Uuid) -> Result<bool, RepositoryError> {
        let guard = self.pulses.read().await;
        Ok(guard.contains_key(&pulse_id))
    }
}

/* --------------------------------------------------------------------------
   Mini integration test (can be `cargo test`ed)
   -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use tracing::Level;

    #[tokio::test]
    async fn happy_flow() {
        // Enable logs for the test; `cargo test -- --nocapture` to view them
        let _ = tracing_subscriber::fmt()
            .with_max_level(Level::INFO)
            .with_test_writer()
            .try_init();

        let repo = Arc::new(InMemoryRepo::default());
        let publisher = Arc::new(LoggingEventPublisher);
        let service = LearningPulseService::new(repo, publisher);

        let teacher_id = Uuid::new_v4();
        let pulse = service
            .create_pulse(
                "Rust Ownership Drill".into(),
                "Solve borrow-checker riddles".into(),
                teacher_id,
                None,
                None,
            )
            .await
            .expect("pulse creation should succeed");

        let student_id = Uuid::new_v4();
        let _sub = service
            .record_submission(
                pulse.id,
                student_id,
                "s3://bucket/key/solution.zip".into(),
                None,
            )
            .await
            .expect("submission should succeed");
    }
}
```