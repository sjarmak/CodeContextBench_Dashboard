```rust
//! src/module_65.rs  – Learning Pulse domain module
//! -------------------------------------------------
//! This module encapsulates the core “Learning Pulse” workflow.
//! It follows a traditional Service + Repository split to keep
//! persistence concerns separated from business logic.
//!
//! Layers
//! 1.  domain      – `LearningPulse`, `PulseResponse`, `DomainEvent`
//! 2.  repository  – `LearningPulseRepository` trait + Postgres impl
//! 3.  service     – `LearningPulseService` orchestrates workflow
//!
//! External crates
//! - sqlx         : async, compile-time checked Postgres queries
//! - uuid         : primary keys
//! - chrono       : timestamp management
//! - anyhow       : ergonomic error propagation
//! - serde        : (de)serialization for events
//! - tokio        : async runtime & broadcast channel for event bus
//!
//! # Example
//! ```no_run
//! use std::sync::Arc;
//! use edupulse_live::module_65::*;
//! use sqlx::postgres::PgPoolOptions;
//!
//! #[tokio::main]
//! async fn main() -> anyhow::Result<()> {
//!     let pool = PgPoolOptions::new().connect("postgres://…").await?;
//!     let (event_bus, _) = tokio::sync::broadcast::channel::<DomainEvent>(512);
//!
//!     let repository = Arc::new(PgLearningPulseRepository::new(pool));
//!     let service = LearningPulseService::new(repository, event_bus.clone());
//!
//!     // Teacher creates a pulse
//!     let pulse_id = service
//!         .create_pulse(
//!             UserId::from_uuid(uuid::Uuid::new_v4()),
//!             "Explain Rust lifetimes in 2 minutes".to_owned(),
//!             Utc::now(),
//!         )
//!         .await?;
//!
//!     // Student replies
//!     service
//!         .respond_to_pulse(
//!             pulse_id,
//!             UserId::from_uuid(uuid::Uuid::new_v4()),
//!             "Here's my video response…".to_owned(),
//!         )
//!         .await?;
//!
//!     Ok(())
//! }
//! ```
//!
//! The broadcast event bus intentionally decouples heavier downstream
//! concerns (search indexing, plagiarism checks, etc.) from the hot path
//! by merely emitting `DomainEvent`s.

use std::sync::Arc;

use anyhow::{Context, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::{postgres::PgRow, PgPool, Postgres, Row, Transaction};
use tokio::sync::broadcast::{self, Sender};
use uuid::Uuid;

/* ------------------------------------------------------------- *
 * Domain layer
 * ------------------------------------------------------------- */

/// Wrapper type to guarantee stronger domain semantics than `Uuid`.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct PulseId(Uuid);

impl PulseId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
    pub fn as_uuid(&self) -> Uuid {
        self.0
    }
}

/// Domain-specific user identifier (opaque).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct UserId(Uuid);

impl UserId {
    pub fn from_uuid(id: Uuid) -> Self {
        Self(id)
    }
    pub fn as_uuid(&self) -> Uuid {
        self.0
    }
}

/// Aggregate root representing a Learning Pulse.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LearningPulse {
    pub id: PulseId,
    pub author_id: UserId,
    pub prompt: String,
    pub created_at: DateTime<Utc>,
}

/// Value object representing a learner reply to a pulse.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PulseResponse {
    pub pulse_id: PulseId,
    pub responder_id: UserId,
    pub content: String,
    pub responded_at: DateTime<Utc>,
}

/// Event types emitted by the domain.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DomainEvent {
    LearningPulseCreated {
        pulse_id: PulseId,
        author_id: UserId,
        timestamp: DateTime<Utc>,
    },
    PulseResponded {
        pulse_id: PulseId,
        responder_id: UserId,
        timestamp: DateTime<Utc>,
    },
}

/* ------------------------------------------------------------- *
 * Repository layer
 * ------------------------------------------------------------- */

/// Abstraction for persistence of `LearningPulse`.
#[async_trait::async_trait]
pub trait LearningPulseRepository: Send + Sync + 'static {
    async fn insert(
        &self,
        tx: &mut Transaction<'_, Postgres>,
        pulse: &LearningPulse,
    ) -> Result<()>;

    async fn get(&self, pulse_id: PulseId) -> Result<Option<LearningPulse>>;

    async fn insert_response(
        &self,
        tx: &mut Transaction<'_, Postgres>,
        response: &PulseResponse,
    ) -> Result<()>;
}

/// Concrete Postgres implementation using `sqlx`.
pub struct PgLearningPulseRepository {
    pool: PgPool,
}

impl PgLearningPulseRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait::async_trait]
impl LearningPulseRepository for PgLearningPulseRepository {
    async fn insert(
        &self,
        tx: &mut Transaction<'_, Postgres>,
        pulse: &LearningPulse,
    ) -> Result<()> {
        sqlx::query(
            r#"
            INSERT INTO learning_pulses (id, author_id, prompt, created_at)
            VALUES ($1, $2, $3, $4)
            "#,
        )
        .bind(pulse.id.as_uuid())
        .bind(pulse.author_id.as_uuid())
        .bind(&pulse.prompt)
        .bind(pulse.created_at)
        .execute(&mut *tx)
        .await
        .context("failed to insert learning_pulse")?;
        Ok(())
    }

    async fn get(&self, pulse_id: PulseId) -> Result<Option<LearningPulse>> {
        let maybe_row: Option<PgRow> = sqlx::query(
            r#"
            SELECT id, author_id, prompt, created_at
            FROM learning_pulses
            WHERE id = $1
            "#,
        )
        .bind(pulse_id.as_uuid())
        .fetch_optional(&self.pool)
        .await
        .context("failed to fetch learning_pulse by id")?;

        if let Some(row) = maybe_row {
            Ok(Some(LearningPulse {
                id: PulseId(row.get("id")),
                author_id: UserId(row.get("author_id")),
                prompt: row.get("prompt"),
                created_at: row.get::<DateTime<Utc>, _>("created_at"),
            }))
        } else {
            Ok(None)
        }
    }

    async fn insert_response(
        &self,
        tx: &mut Transaction<'_, Postgres>,
        response: &PulseResponse,
    ) -> Result<()> {
        sqlx::query(
            r#"
            INSERT INTO pulse_responses (pulse_id, responder_id, content, responded_at)
            VALUES ($1, $2, $3, $4)
            "#,
        )
        .bind(response.pulse_id.as_uuid())
        .bind(response.responder_id.as_uuid())
        .bind(&response.content)
        .bind(response.responded_at)
        .execute(&mut *tx)
        .await
        .context("failed to insert pulse_response")?;
        Ok(())
    }
}

/* ------------------------------------------------------------- *
 * Service layer
 * ------------------------------------------------------------- */

/// Handles Learning Pulse use-cases + event emission.
pub struct LearningPulseService<R: LearningPulseRepository> {
    repository: Arc<R>,
    pool: PgPool,
    event_bus: Sender<DomainEvent>,
}

impl<R: LearningPulseRepository> LearningPulseService<R> {
    /// # Arguments
    /// * `repository` – repository implementation
    /// * `event_bus` – broadcast channel sender; clones are cheap
    pub fn new(repository: Arc<R>, event_bus: Sender<DomainEvent>) -> Self {
        // we need access to PgPool for starting transactions; steal it from repo
        // while avoiding exposing it in the trait; downcast expected type
        let pool = repository
            .as_ref()
            .as_any_downcast_ref::<PgLearningPulseRepository>()
            .expect("repository must be PgLearningPulseRepository")
            .pool
            .clone();

        Self {
            repository,
            pool,
            event_bus,
        }
    }

    /// Create a new `LearningPulse` and publish an event.
    pub async fn create_pulse(
        &self,
        author_id: UserId,
        prompt: String,
        timestamp: DateTime<Utc>,
    ) -> Result<PulseId> {
        let mut tx = self
            .pool
            .begin()
            .await
            .context("failed to start db transaction")?;

        let pulse = LearningPulse {
            id: PulseId::new(),
            author_id,
            prompt,
            created_at: timestamp,
        };

        self.repository.insert(&mut tx, &pulse).await?;

        tx.commit().await.context("commit create_pulse")?;

        // best-effort event emission; failure should not abort business tx
        let _ = self.event_bus.send(DomainEvent::LearningPulseCreated {
            pulse_id: pulse.id,
            author_id,
            timestamp,
        });

        Ok(pulse.id)
    }

    /// Persist a student response and emit downstream events.
    pub async fn respond_to_pulse(
        &self,
        pulse_id: PulseId,
        responder_id: UserId,
        content: String,
    ) -> Result<()> {
        // ensure pulse exists before writing response
        let pulse_exists = self.repository.get(pulse_id).await?.is_some();
        if !pulse_exists {
            anyhow::bail!("pulse_id {:?} does not exist", pulse_id);
        }

        let mut tx = self.pool.begin().await?;

        let response = PulseResponse {
            pulse_id,
            responder_id,
            content,
            responded_at: Utc::now(),
        };

        self.repository.insert_response(&mut tx, &response).await?;
        tx.commit().await?;

        let _ = self.event_bus.send(DomainEvent::PulseResponded {
            pulse_id,
            responder_id,
            timestamp: response.responded_at,
        });

        Ok(())
    }
}

/* ------------------------------------------------------------- *
 * Extension helpers
 * ------------------------------------------------------------- */

/// Small helper trait to expose downcasting on trait objects used above.
/// Keeps the public API clean while avoiding `Any` imports in caller code.
pub trait AsAny {
    fn as_any_downcast_ref<T: 'static>(&self) -> Option<&T>;
}

impl<T: 'static> AsAny for T {
    fn as_any_downcast_ref<U: 'static>(&self) -> Option<&U> {
        // SAFETY: Only downcast when the type matches, returning None otherwise
        (std::any::TypeId::of::<U>() == std::any::TypeId::of::<T>())
            .then(|| unsafe { &*(self as *const T as *const U) })
    }
}

impl<R: LearningPulseRepository> AsAny for R {}

/* ------------------------------------------------------------- *
 * Unit tests
 * ------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::{postgres::PgPoolOptions, Executor};

    async fn setup_db() -> PgPool {
        // In real projects one might spin up a Testcontainers instance.
        // For brevity we assume `DATABASE_URL` points to a disposable schema.
        let url = std::env::var("DATABASE_URL").expect("DATABASE_URL not set");
        let pool = PgPoolOptions::new()
            .connect(&url)
            .await
            .expect("connect");
        // minimal schema
        pool.execute(
            r#"
            CREATE TABLE IF NOT EXISTS learning_pulses (
                id UUID PRIMARY KEY,
                author_id UUID NOT NULL,
                prompt TEXT NOT NULL,
                created_at TIMESTAMP WITH TIME ZONE NOT NULL
            );
            CREATE TABLE IF NOT EXISTS pulse_responses (
                pulse_id UUID NOT NULL REFERENCES learning_pulses(id),
                responder_id UUID NOT NULL,
                content TEXT NOT NULL,
                responded_at TIMESTAMP WITH TIME ZONE NOT NULL
            );
            "#,
        )
        .await
        .unwrap();
        pool
    }

    #[tokio::test]
    async fn create_and_respond_flow() -> Result<()> {
        let pool = setup_db().await;
        let (bus_tx, _bus_rx) = broadcast::channel(16);

        let repo = Arc::new(PgLearningPulseRepository::new(pool.clone()));
        let service = LearningPulseService::new(repo, bus_tx);

        let teacher = UserId::from_uuid(Uuid::new_v4());
        let student = UserId::from_uuid(Uuid::new_v4());

        let pulse_id = service
            .create_pulse(teacher, "Describe Diesel connection pooling".into(), Utc::now())
            .await?;

        service
            .respond_to_pulse(pulse_id, student, "Here is my answer".into())
            .await?;

        let stored_pulse = PgLearningPulseRepository::new(pool)
            .get(pulse_id)
            .await?
            .expect("pulse exists");

        assert_eq!(stored_pulse.id, pulse_id);
        Ok(())
    }
}
```