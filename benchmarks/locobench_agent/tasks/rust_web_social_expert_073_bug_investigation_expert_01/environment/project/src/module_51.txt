```rust
//! src/module_51.rs
//!
//! Runtime event-bus abstraction + RabbitMQ implementation used across the
//! “EduPulse Live” platform.  The bus is leveraged by downstream components
//! (search indexer, mailer, achievement engine, etc.) to *publish* and
//! *subscribe* to domain events without creating tight coupling between
//! bounded contexts.
//!
//! The module purposely hides transport details behind a trait so the rest of
//! the code base can depend on abstractions and remain testable.  An example
//! consumer (`SearchIndexer`) is provided at the bottom of the file.
//!
//! NOTE: The real project uses multiple crate boundaries; the entire content
//! is kept in a single file only to satisfy the playground constraints set by
//! the exercise.

#![allow(clippy::module_name_repetitions)]

use std::{
    env,
    fmt::{self, Display, Formatter},
    sync::Arc,
    time::SystemTime,
};

use async_trait::async_trait;
use lapin::{
    options::{
        BasicAckOptions, BasicConsumeOptions, BasicPublishOptions, QueueDeclareOptions,
    },
    types::FieldTable,
    BasicProperties, Channel, Connection, ConnectionProperties, Consumer,
};
use once_cell::sync::OnceCell;
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use thiserror::Error;
use tokio::{spawn, sync::broadcast, task::JoinHandle};
use tracing::{debug, error, info, instrument};

/// Public exports /////////////////////////////////////////////////////////////
pub use error::EventBusError;
pub use event::{DomainEvent, EventEnvelope, EventId, LessonPublished};
pub use rabbit::RabbitMqBus;
pub use search_indexer::SearchIndexer;

/// Module error types
mod error {
    use super::*;

    /// Common error wrapper used across the event bus abstraction.
    #[derive(Debug, Error)]
    pub enum EventBusError {
        #[error("serialization error: {0}")]
        Serialization(#[from] serde_json::Error),
        #[error("message-broker error: {0}")]
        Broker(#[from] lapin::Error),
        #[error("channel closed")]
        ChannelClosed,
        #[error("configuration error: {0}")]
        Configuration(String),
        #[error("task join error: {0}")]
        Join(#[from] tokio::task::JoinError),
    }
}

/// Generic domain events and helpers
mod event {
    use super::*;

    /// Unique identifier for an event.  128-bit rand + 48-bit time prefix (snow-flake like).
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct EventId(u128);

    impl Default for EventId {
        fn default() -> Self {
            use rand::{rngs::OsRng, RngCore};

            let mut random = [0u8; 16];
            OsRng.fill_bytes(&mut random);

            // Mix high-precision time to assist with ordering in analytics.
            let nanos = SystemTime::now()
                .duration_since(SystemTime::UNIX_EPOCH)
                .expect("system clock is before 1970")
                .as_nanos();

            let high = (nanos as u128) << 80;
            let low = u128::from_be_bytes(random);
            EventId(high | low)
        }
    }

    impl Display for EventId {
        fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
            write!(f, "{:032x}", self.0)
        }
    }

    /// Marker trait implemented by every domain event struct.
    pub trait DomainEvent: Serialize + DeserializeOwned + Send + Sync + 'static {
        /// Type identifier, e.g. `"lesson.published"`.
        fn kind() -> &'static str;
    }

    /// Strongly-typed envelope used for (de)serialization.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(bound = "")] // suppress serde(generic) warnings
    pub struct EventEnvelope {
        pub id: EventId,
        pub occurred_at: u128, // unix-epoch nanos
        pub kind: String,
        /// Raw JSON blob – enables schema evolution.
        pub payload: serde_json::Value,
    }

    impl EventEnvelope {
        pub fn new<E>(event: &E) -> Result<Self, serde_json::Error>
        where
            E: DomainEvent,
        {
            Ok(Self {
                id: EventId::default(),
                occurred_at: SystemTime::now()
                    .duration_since(SystemTime::UNIX_EPOCH)
                    .expect("system clock is before 1970")
                    .as_nanos(),
                kind: E::kind().into(),
                payload: serde_json::to_value(event)?,
            })
        }

        pub fn deserialize<E>(&self) -> Result<E, serde_json::Error>
        where
            E: DomainEvent,
        {
            serde_json::from_value(self.payload.clone())
        }
    }

    /// --- SAMPLE EVENT TYPES -------------------------------------------------
    /// Only a subset is implemented for brevity; more should be generated by
    /// the domain model team in separate modules/crates.

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct LessonPublished {
        pub lesson_id: i64,
        pub author_id: i64,
        pub title: String,
        pub published_at: u64,
        pub categories: Vec<String>,
    }

    impl DomainEvent for LessonPublished {
        fn kind() -> &'static str {
            "lesson.published"
        }
    }
}

/// ---------------------------------------------------------------------------
/// ABC: EventBus (publish / subscribe) trait
/// ---------------------------------------------------------------------------
#[async_trait]
pub trait EventBus: Send + Sync {
    /// Publish a concrete event.
    async fn publish<E>(&self, event: &E) -> Result<EventId, EventBusError>
    where
        E: DomainEvent;

    /// Subscribe to events that match the `filter`.  A background task is
    /// spawned internally; consumers receive the deserialized event via the
    /// returned broadcast channel.
    ///
    /// # Parameters
    /// * `filter` – dot-separated pattern; supports wildcards (`*`).
    async fn subscribe<E>(
        &self,
        filter: impl Into<String>,
    ) -> Result<broadcast::Receiver<E>, EventBusError>
    where
        E: DomainEvent;
}

/// ---------------------------------------------------------------------------
/// RabbitMQ implementation
/// ---------------------------------------------------------------------------
mod rabbit {
    use super::*;

    /// Lazily initialized AMQP connection pool.  The small footprint of the
    /// service does not justify a full-blown pool, but we cache the `Connection`
    /// so reconnect storms are mitigated.
    static CONN: OnceCell<Connection> = OnceCell::new();

    /// Helper: Get or establish a single RabbitMQ connection.
    async fn get_connection() -> Result<&'static Connection, EventBusError> {
        if CONN.get().is_some() {
            return Ok(CONN.get().expect("connection initialized"));
        }

        let addr = env::var("EDUPULSE_RABBITMQ_URL")
            .map_err(|_| EventBusError::Configuration("EDUPULSE_RABBITMQ_URL".into()))?;

        let conn = Connection::connect(
            &addr,
            ConnectionProperties::default().with_default_executor(8),
        )
        .await?;

        Ok(CONN.get_or_init(|| conn))
    }

    #[derive(Clone)]
    pub struct RabbitMqBus {
        channel: Arc<Channel>,
    }

    impl RabbitMqBus {
        pub async fn new() -> Result<Self, EventBusError> {
            let conn = get_connection().await?;
            let channel = conn.create_channel().await?;

            // Durable queue required; but consumers may create their own queue
            // bindings in `subscribe`.
            channel
                .queue_declare(
                    "edupulse.events",
                    QueueDeclareOptions {
                        durable: true,
                        ..QueueDeclareOptions::default()
                    },
                    FieldTable::default(),
                )
                .await?;

            Ok(Self {
                channel: Arc::new(channel),
            })
        }
    }

    #[async_trait]
    impl EventBus for RabbitMqBus {
        #[instrument(skip_all, level = "debug", err)]
        async fn publish<E>(&self, event: &E) -> Result<EventId, EventBusError>
        where
            E: DomainEvent,
        {
            let envelope = EventEnvelope::new(event)?;
            let payload = serde_json::to_vec(&envelope)?;

            self.channel
                .basic_publish(
                    "",                    // default exchange
                    "edupulse.events",     // routing key = queue
                    BasicPublishOptions::default(),
                    &payload,
                    BasicProperties::default().with_content_type("application/json".into()),
                )
                .await?
                .await?; // wait for confirmation

            debug!(kind = %envelope.kind, id = %envelope.id, "event published");

            Ok(envelope.id)
        }

        #[instrument(skip_all, level = "debug", err)]
        async fn subscribe<E>(
            &self,
            filter: impl Into<String>,
        ) -> Result<broadcast::Receiver<E>, EventBusError>
        where
            E: DomainEvent,
        {
            let filter = filter.into();
            let (sender, receiver) = broadcast::channel::<E>(512);

            let consumer: Consumer = self
                .channel
                .basic_consume(
                    "edupulse.events",
                    "edupulse_autogen_consumer",
                    BasicConsumeOptions::default(),
                    FieldTable::default(),
                )
                .await?;

            // Spawn detached task pumping AMQP messages into the broadcast bus.
            let channel = self.channel.clone();
            spawn(async move {
                for delivery in consumer {
                    match delivery {
                        Ok(delivery) => {
                            if let Err(e) = handle_delivery::<E>(&filter, &sender, &delivery.data)
                                .await
                            {
                                error!(error = %e, "failed to handle event");
                            }
                            // ACK only if we deserialized without panics; otherwise
                            // the message will re-queue for dead-letter analysis.
                            if let Err(e) = delivery.ack(BasicAckOptions::default()).await {
                                error!(?e, "ACK failed – RabbitMQ channel error");
                            }
                        }
                        Err(e) => error!(?e, "RabbitMQ consumer error"),
                    }
                }
                debug!("RabbitMQ consumer stream finished");
                drop(channel); // ensure closing
            });

            Ok(receiver)
        }
    }

    /// Internal helper to filter events, deserialize concrete type, and forward
    /// to the broadcast sender.
    async fn handle_delivery<E>(
        filter: &str,
        sender: &broadcast::Sender<E>,
        payload: &[u8],
    ) -> Result<(), EventBusError>
    where
        E: DomainEvent,
    {
        let envelope: EventEnvelope = serde_json::from_slice(payload)?;

        // Very naive wildcard matching: `lesson.*` -> `lesson.published`
        let ok = if filter == "*" {
            true
        } else if filter.ends_with('*') {
            envelope
                .kind
                .starts_with(&filter[..filter.len() - 1 /* remove * */])
        } else {
            envelope.kind == filter
        };

        if ok {
            if let Ok(event) = envelope.deserialize::<E>() {
                let _ = sender.send(event); // ignore lagged receivers
            }
        }

        Ok(())
    }
}

/// ---------------------------------------------------------------------------
/// Example consumer: Search Indexer
/// ---------------------------------------------------------------------------
mod search_indexer {
    use super::*;
    use reqwest::StatusCode;

    /// Component responsible for keeping the ElasticSearch index in sync with
    /// canonical data.  The service is stateless; at-most-once delivery is
    /// acceptable because the persistent indexer does periodic `scroll` checks.
    ///
    /// In production this would live in its own micro-service; here we embed an
    /// async background task for demonstration.
    pub struct SearchIndexer {
        bus: Arc<dyn EventBus>,
        elastic_url: String,
        /// `JoinHandle` of the spawned worker
        worker: OnceCell<JoinHandle<()>>,
    }

    impl SearchIndexer {
        /// Instantiate the component, *but* do not subscribe yet.  Call
        /// `run()` to start the background loop so dependency injection & test
        /// harnesses can attach interceptors before side-effects happen.
        pub fn new(bus: Arc<dyn EventBus>) -> Self {
            let elastic_url =
                env::var("EDUPULSE_ELASTIC_URL").unwrap_or_else(|_| "http://localhost:9200".into());

            Self {
                bus,
                elastic_url,
                worker: OnceCell::new(),
            }
        }

        /// Spawn the background task that listens for events and indexes them.
        #[instrument(skip_all)]
        pub async fn run(&self) -> Result<(), EventBusError> {
            let mut rx = self
                .bus
                .subscribe::<LessonPublished>("lesson.*")
                .await?;

            // We keep a single worker; redundant calls to `run` are ignored.
            self.worker.get_or_try_init(|| {
                let elastic_url = self.elastic_url.clone();
                Ok(spawn(async move {
                    while let Ok(event) = rx.recv().await {
                        if let Err(e) = handle_lesson_published(&elastic_url, &event).await {
                            error!(?e, lesson_id = event.lesson_id, "index-push failed");
                        }
                    }
                    info!("search indexer channel closed");
                }))
            })?;

            Ok(())
        }
    }

    #[instrument(skip_all, level = "debug")]
    async fn handle_lesson_published(
        elastic_url: &str,
        evt: &LessonPublished,
    ) -> Result<(), EventBusError> {
        // Build partial document (ElasticSearch upsert)
        #[derive(Serialize)]
        struct LessonDoc<'a> {
            title: &'a str,
            author_id: i64,
            categories: &'a [String],
            published_at: u64,
        }

        let doc = LessonDoc {
            title: &evt.title,
            author_id: evt.author_id,
            categories: &evt.categories,
            published_at: evt.published_at,
        };

        let url = format!("{elastic_url}/edupulse_lessons/_doc/{}?refresh=false", evt.lesson_id);

        let res = reqwest::Client::new()
            .post(&url)
            .json(&doc)
            .send()
            .await
            .map_err(|e| EventBusError::Configuration(format!("HTTP error: {e}")))?;

        if res.status() != StatusCode::CREATED && res.status() != StatusCode::OK {
            let body = res
                .text()
                .await
                .unwrap_or_else(|_| "<body-read-error>".into());
            error!(status = %res.status(), body, "ElasticSearch rejected document");
        } else {
            debug!("indexed lesson #{}", evt.lesson_id);
        }
        Ok(())
    }
}

/// ---------------------------------------------------------------------------
/// Unit tests (uses in-memory fake queue, no RabbitMQ needed)  --------------
/// ---------------------------------------------------------------------------
#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::VecDeque;
    use tokio::sync::Mutex;

    /// Very small in-memory bus for deterministic tests.
    struct MemoryBus {
        buf: Arc<Mutex<VecDeque<EventEnvelope>>>,
    }

    impl MemoryBus {
        fn new() -> Self {
            Self {
                buf: Arc::new(Mutex::new(VecDeque::new())),
            }
        }
    }

    #[async_trait]
    impl EventBus for MemoryBus {
        async fn publish<E>(&self, event: &E) -> Result<EventId, EventBusError>
        where
            E: DomainEvent,
        {
            let envelope = EventEnvelope::new(event)?;
            self.buf.lock().await.push_back(envelope.clone());
            Ok(envelope.id)
        }

        async fn subscribe<E>(
            &self,
            _filter: impl Into<String>,
        ) -> Result<broadcast::Receiver<E>, EventBusError>
        where
            E: DomainEvent,
        {
            let (tx, rx) = broadcast::channel(10);
            let buf = self.buf.clone();

            // Feed existing events
            spawn(async move {
                let mut guard = buf.lock().await;
                for e in guard.drain(..) {
                    if let Ok(evt) = e.deserialize::<E>() {
                        let _ = tx.send(evt);
                    }
                }
            });

            Ok(rx)
        }
    }

    #[tokio::test]
    async fn publish_and_receive_memorybus() -> Result<(), EventBusError> {
        let bus = MemoryBus::new();
        let evt = LessonPublished {
            lesson_id: 42,
            author_id: 7,
            title: "Trait Objects 101".into(),
            published_at: 1_692_654_880,
            categories: vec!["rust".into(), "programming".into()],
        };

        bus.publish(&evt).await?;

        let mut rx = bus.subscribe::<LessonPublished>("*").await?;
        let received = rx.recv().await.expect("event missing");
        assert_eq!(received.lesson_id, 42);

        Ok(())
    }
}
```
