```rust
//! tests/test_utils.rs
//! -------------------------------------------------------------
//! Integration-style tests for the `web_social` utility helpers.
//!
//! NOTE: In a real repository these helpers would live in
//! `web_social::utils` and the following import would be used:
//
//!     use web_social::utils::*;
//
//! For the purpose of making this file self-contained and
//! compilable in isolation, a greatly simplified copy of the
//! utilities is embedded directly below under `mod utils`.
//!
//! The tests exercise the most important behaviour around:
//!   • Secure token generation
//!   • Slugification of user-facing titles
//!   • Lightweight JSON event-schema validation
//!
//! The test-cases intentionally cover happy-paths, edge-cases, and
//! concurrency scenarios to simulate real-world production load.
//! -------------------------------------------------------------

// -----------------------------------------------------------------------------
// Dummy implementation (stand-in for the real library code)
// -----------------------------------------------------------------------------
mod utils {
    use std::collections::HashSet;
    use std::str::FromStr;

    use chrono::{DateTime, Utc};
    use serde::{Deserialize, Serialize};
    use thiserror::Error;
    use uuid::Uuid;

    // ---------------------------------------------------------
    // Secure Token Generation
    // ---------------------------------------------------------
    #[derive(Debug, Error)]
    pub enum TokenError {
        #[error("requested token length must be > 0")]
        InvalidLength,
    }

    /// Generates a cryptographically secure, URL-safe token with
    /// the exact length requested. Internally we create a
    /// `UuidV4` and extend it with additional random bytes if
    /// necessary.
    pub fn generate_secure_token(target_len: usize) -> Result<String, TokenError> {
        if target_len == 0 {
            return Err(TokenError::InvalidLength);
        }

        let mut token = base64::encode(Uuid::new_v4().as_bytes())
            .replace(['+', '/', '='], ""); // URL safe

        // Extend until we reach the requested length
        while token.len() < target_len {
            token.push_str(
                &base64::encode(Uuid::new_v4().as_bytes())
                    .replace(['+', '/', '='], ""),
            );
        }
        token.truncate(target_len);
        Ok(token)
    }

    // ---------------------------------------------------------
    // Slugification
    // ---------------------------------------------------------
    /// Returns a URL-safe slug for titles, user names, etc.
    ///
    /// Rules:
    ///   • ASCII-alphanumeric kept as is (lower-cased)
    ///   • Unicode letters are transliterated to ASCII if possible
    ///   • Any sequence of non-alphanumeric chars becomes a single '-'
    ///   • Leading / trailing '-' are trimmed
    pub fn slugify(input: &str) -> String {
        let mut slug = String::with_capacity(input.len());
        let mut prev_dash = false;

        for ch in input.chars() {
            let lc = ch.to_ascii_lowercase();
            if lc.is_ascii_alphanumeric() {
                slug.push(lc);
                prev_dash = false;
            } else {
                if !prev_dash {
                    slug.push('-');
                    prev_dash = true;
                }
            }
        }

        slug.trim_matches('-').to_string()
    }

    // ---------------------------------------------------------
    // Event Schema Validation
    // ---------------------------------------------------------
    #[derive(Debug, Deserialize, Serialize, PartialEq, Eq)]
    pub struct Event<'a> {
        pub id: Uuid,
        #[serde(rename = "type")]
        pub event_type: &'a str,
        pub version: u16,
        #[serde(with = "chrono::serde::ts_milliseconds")]
        pub created_at: DateTime<Utc>,
    }

    #[derive(Debug, Error)]
    pub enum EventValidationError {
        #[error("payload is not valid JSON: {0}")]
        JsonError(#[from] serde_json::Error),
        #[error("field 'version' must be greater than 0")]
        InvalidVersion,
        #[error("'id' field is not a valid UUID")]
        InvalidId,
        #[error("event type must be non-empty")]
        EmptyEventType,
        #[error("duplicate event id")]
        DuplicateId,
    }

    /// Parses a JSON payload into an `Event` and performs
    /// additional domain-specific validation such as:
    ///   • `version` must be > 0
    ///   • `event_type` must not be empty
    ///   • UUID must be valid
    ///   • Id must be unique within the provided `seen_ids` set
    pub fn verify_event_schema<'a>(
        payload: &'a str,
        seen_ids: &mut HashSet<Uuid>,
    ) -> Result<Event<'a>, EventValidationError> {
        let evt: Event<'a> = serde_json::from_str(payload)?;
        if evt.version == 0 {
            return Err(EventValidationError::InvalidVersion);
        }
        if evt.event_type.trim().is_empty() {
            return Err(EventValidationError::EmptyEventType);
        }
        // UUID validity is already enforced by serde + Uuid but
        // we add an explicit check for completeness.
        Uuid::from_str(evt.id.as_hyphenated().to_string().as_str())
            .map_err(|_| EventValidationError::InvalidId)?;

        if !seen_ids.insert(evt.id) {
            return Err(EventValidationError::DuplicateId);
        }

        Ok(evt)
    }
}

// -----------------------------------------------------------------------------
// Actual test-cases
// -----------------------------------------------------------------------------
use std::collections::HashSet;

use utils::*;

#[test]
fn test_secure_token_length_and_uniqueness() {
    const TOKEN_LEN: usize = 32;
    const RUNS: usize = 1_000;

    let mut unique = std::collections::HashSet::with_capacity(RUNS);
    for _ in 0..RUNS {
        let token = generate_secure_token(TOKEN_LEN).expect("token generation failed");
        assert_eq!(
            token.len(),
            TOKEN_LEN,
            "generated token does not match requested length"
        );
        // Make sure token is URL-safe
        assert!(
            token.chars()
                .all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_'),
            "token contains non-URL-safe characters"
        );
        unique.insert(token);
    }

    assert_eq!(
        unique.len(),
        RUNS,
        "expected all generated tokens to be unique"
    );
}

#[test]
fn test_slugify_various_inputs() {
    let cases = [
        ("Hello World!", "hello-world"),
        ("Rust––The-Book", "rust-the-book"),
        ("___Multiple   separators___", "multiple-separators"),
        ("Trailing & Leading *Punctuation*", "trailing-leading-punctuation"),
        ("", ""),
    ];

    for (input, expected) in cases {
        assert_eq!(
            slugify(input),
            expected,
            "slug mismatch for input '{input}'"
        );
    }
}

#[test]
fn test_event_schema_valid_payload() {
    let json = format!(
        r#"{{
            "id": "{uuid}",
            "type": "lesson.published",
            "version": 3,
            "created_at": {timestamp}
        }}"#,
        uuid = uuid::Uuid::new_v4(),
        timestamp = chrono::Utc::now().timestamp_millis()
    );

    let mut seen = HashSet::new();
    let evt = verify_event_schema(&json, &mut seen).expect("should be valid");
    assert_eq!(evt.version, 3);
    assert_eq!(evt.event_type, "lesson.published");
    assert!(seen.contains(&evt.id), "event id should be registered as seen");
}

#[test]
fn test_event_schema_invalid_cases() {
    // Missing event_type
    let json_missing_field = format!(
        r#"{{
            "id": "{uuid}",
            "version": 1,
            "created_at": {timestamp}
        }}"#,
        uuid = uuid::Uuid::new_v4(),
        timestamp = chrono::Utc::now().timestamp_millis()
    );

    let mut seen = HashSet::new();
    let err = verify_event_schema(&json_missing_field, &mut seen).unwrap_err();
    matches!(err, utils::EventValidationError::JsonError(_));

    // Duplicate ID
    let id = uuid::Uuid::new_v4();
    let json1 = format!(
        r#"{{
            "id": "{id}",
            "type": "quiz.graded",
            "version": 1,
            "created_at": {ts1}
        }}"#,
        id = id,
        ts1 = chrono::Utc::now().timestamp_millis()
    );
    let json2 = format!(
        r#"{{
            "id": "{id}",
            "type": "quiz.graded",
            "version": 2,
            "created_at": {ts2}
        }}"#,
        id = id,
        ts2 = chrono::Utc::now().timestamp_millis()
    );

    let mut seen = HashSet::new();
    assert!(verify_event_schema(&json1, &mut seen).is_ok());
    let err = verify_event_schema(&json2, &mut seen).unwrap_err();
    matches!(err, utils::EventValidationError::DuplicateId);

    // Version = 0
    let json_bad_version = format!(
        r#"{{
            "id": "{uuid}",
            "type": "asset.uploaded",
            "version": 0,
            "created_at": {timestamp}
        }}"#,
        uuid = uuid::Uuid::new_v4(),
        timestamp = chrono::Utc::now().timestamp_millis()
    );
    let mut seen = HashSet::new();
    let err = verify_event_schema(&json_bad_version, &mut seen).unwrap_err();
    matches!(err, utils::EventValidationError::InvalidVersion);
}

#[test]
fn test_concurrent_token_generation() {
    use std::sync::{Arc, Mutex};
    use std::thread;

    const THREADS: usize = 8;
    const TOKENS_PER_THREAD: usize = 500;
    const TOKEN_LEN: usize = 48;

    let uniq = Arc::new(Mutex::new(std::collections::HashSet::new()));
    let mut handles = Vec::with_capacity(THREADS);

    for _ in 0..THREADS {
        let uniq = Arc::clone(&uniq);
        handles.push(thread::spawn(move || {
            for _ in 0..TOKENS_PER_THREAD {
                let token = generate_secure_token(TOKEN_LEN).unwrap();
                let mut guard = uniq.lock().unwrap();
                assert!(
                    guard.insert(token),
                    "duplicate token generated across threads"
                );
            }
        }));
    }

    for h in handles {
        h.join().expect("thread failed");
    }

    let guard = uniq.lock().unwrap();
    assert_eq!(
        guard.len(),
        THREADS * TOKENS_PER_THREAD,
        "unexpected number of unique tokens"
    );
}
```