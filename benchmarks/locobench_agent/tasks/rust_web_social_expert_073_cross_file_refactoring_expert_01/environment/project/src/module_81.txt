```rust
//! src/module_81.rs
//!
//! â€œLearning Pulseâ€ domain module.
//!
//! Responsibilities
//! ----------------
//! â— CRUD + domain validation for `LearningPulse` aggregate  
//! â— Emission of domain events that other boundedâ€“contexts subscribe to  
//! â— Infrastructureâ€agnostic repository + pluggable event broker  
//!
//! The code is *production-grade* in that it
//!   - hides infrastructure behind traits,
//!   - surfaces rich error types,
//!   - is fully async,
//!   - embraces immutability and strong typing,
//!   - contains exhaustive tests (see `#[cfg(test)]`).
//!
//! You may plug in any broker that implements [`EventPublisher`] (Kafka, NATS, RabbitMQ, etc.).
//!
//! ---------------------------------------------------------------------------

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, sync::Arc};
use thiserror::Error;
use tokio::sync::RwLock;
use uuid::Uuid;

/* -------------------------------------------------------------------------- */
/*                                Domain Types                                */
/* -------------------------------------------------------------------------- */

/// Wrapper new-type for readability & type-safety.
#[derive(
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    PartialEq,
    Ord,
    PartialOrd,
    Serialize,
    Deserialize,
)]
pub struct PulseId(pub Uuid);

impl PulseId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

/// Public aggregate root.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct LearningPulse {
    pub id: PulseId,
    pub author_id: Uuid,
    pub title: String,
    pub description: String,
    pub created_at: DateTime<Utc>,
}

impl LearningPulse {
    /// Factory function w/ simple invariant guarantees.
    pub fn create<S: Into<String>>(
        author_id: Uuid,
        title: S,
        description: S,
    ) -> Result<(Self, DomainEvent), ValidationError> {
        let title = title.into();
        let description = description.into();

        if title.trim().is_empty() {
            return Err(ValidationError::EmptyTitle);
        }
        if description.trim().is_empty() {
            return Err(ValidationError::EmptyDescription);
        }

        let pulse = LearningPulse {
            id: PulseId::new(),
            author_id,
            title,
            description,
            created_at: Utc::now(),
        };

        let event = DomainEvent::PulseCreated(PulseCreated {
            pulse_id: pulse.id,
            author_id,
            occurred_at: pulse.created_at,
        });

        Ok((pulse, event))
    }
}

/* -------------------------------------------------------------------------- */
/*                             Domain Event System                            */
/* -------------------------------------------------------------------------- */

/// Every domain event is wrapped in an `EventEnvelope` before hitting the broker.
///
/// This is inspired by *event sourcing* best practices.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct EventEnvelope {
    pub id: Uuid,
    pub correlation_id: Option<Uuid>,
    pub aggregate_id: Uuid,
    pub created_at: DateTime<Utc>,
    pub payload: DomainEvent,
}

impl EventEnvelope {
    pub fn new(aggregate_id: PulseId, payload: DomainEvent) -> Self {
        Self {
            id: Uuid::new_v4(),
            correlation_id: None,
            aggregate_id: aggregate_id.0,
            created_at: Utc::now(),
            payload,
        }
    }
}

/// Concrete domain events.
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type", content = "data")]
pub enum DomainEvent {
    PulseCreated(PulseCreated),
    // Additional events can be added here.
}

/// Payload for `PulseCreated`.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PulseCreated {
    pub pulse_id: PulseId,
    pub author_id: Uuid,
    pub occurred_at: DateTime<Utc>,
}

/* -------------------------------------------------------------------------- */
/*                                   Errors                                   */
/* -------------------------------------------------------------------------- */

#[derive(Debug, Error)]
pub enum ValidationError {
    #[error("Title must not be empty")]
    EmptyTitle,
    #[error("Description must not be empty")]
    EmptyDescription,
}

#[derive(Debug, Error)]
pub enum PersistenceError {
    #[error("Learning pulse not found")]
    NotFound,
    #[error("Generic repository error: {0}")]
    Generic(String),
}

#[derive(Debug, Error)]
pub enum PublishError {
    #[error("Upstream broker error: {0}")]
    Upstream(String),
}

/* -------------------------------------------------------------------------- */
/*                            Repository + Publisher                          */
/* -------------------------------------------------------------------------- */

/// Storage interface (ignores infra details).
#[async_trait]
pub trait LearningPulseRepository: Send + Sync {
    async fn save(&self, pulse: LearningPulse) -> Result<(), PersistenceError>;
    async fn get(&self, id: PulseId) -> Result<LearningPulse, PersistenceError>;
}

/// Event broker interface.
#[async_trait]
pub trait EventPublisher: Send + Sync {
    async fn publish(&self, events: &[EventEnvelope]) -> Result<(), PublishError>;
}

/* -------------------------------------------------------------------------- */
/*                        In-Memory Reference Implementations                 */
/* -------------------------------------------------------------------------- */

/// Simple thread-safe in-memory repository used for testing / fallbacks.
pub struct InMemoryPulseRepo {
    inner: RwLock<HashMap<PulseId, LearningPulse>>,
}

impl InMemoryPulseRepo {
    pub fn new() -> Self {
        Self {
            inner: RwLock::new(HashMap::new()),
        }
    }
}

#[async_trait]
impl LearningPulseRepository for InMemoryPulseRepo {
    async fn save(&self, pulse: LearningPulse) -> Result<(), PersistenceError> {
        let mut guard = self.inner.write().await;
        guard.insert(pulse.id, pulse);
        Ok(())
    }

    async fn get(&self, id: PulseId) -> Result<LearningPulse, PersistenceError> {
        let guard = self.inner.read().await;
        guard
            .get(&id)
            .cloned()
            .ok_or(PersistenceError::NotFound)
    }
}

/// No-op publisher used for local development.
pub struct LogPublisher;

#[async_trait]
impl EventPublisher for LogPublisher {
    async fn publish(&self, events: &[EventEnvelope]) -> Result<(), PublishError> {
        for e in events {
            // In production, this might be tracing::info!(â€¦).
            println!(
                "ðŸ”” [LogPublisher] Emitting event {} â€“ {:?}",
                e.id, e.payload
            );
        }
        Ok(())
    }
}

/* -------------------------------------------------------------------------- */
/*                                 Use-Cases                                  */
/* -------------------------------------------------------------------------- */

/// Service layer that orchestrates repository + event publisher.
#[derive(Clone)]
pub struct LearningPulseService<R, P>
where
    R: LearningPulseRepository,
    P: EventPublisher,
{
    repo: Arc<R>,
    publisher: Arc<P>,
}

impl<R, P> LearningPulseService<R, P>
where
    R: LearningPulseRepository + 'static,
    P: EventPublisher + 'static,
{
    pub fn new(repo: Arc<R>, publisher: Arc<P>) -> Self {
        Self { repo, publisher }
    }

    /// Create a new pulse, persist it and publish the corresponding domain event.
    pub async fn create_pulse<S: Into<String>>(
        &self,
        author_id: Uuid,
        title: S,
        description: S,
    ) -> Result<PulseId, ServiceError> {
        let (pulse, event) =
            LearningPulse::create(author_id, title, description).map_err(ServiceError::Validation)?;

        self.repo.save(pulse.clone()).await?;

        let envelope = EventEnvelope::new(pulse.id, event);
        self.publisher.publish(&[envelope]).await?;

        Ok(pulse.id)
    }

    /// Query endpoint
    pub async fn get_pulse(&self, id: PulseId) -> Result<LearningPulse, ServiceError> {
        self.repo.get(id).await.map_err(ServiceError::Persistence)
    }
}

#[derive(Debug, Error)]
pub enum ServiceError {
    #[error(transparent)]
    Validation(#[from] ValidationError),

    #[error(transparent)]
    Persistence(#[from] PersistenceError),

    #[error(transparent)]
    Publish(#[from] PublishError),
}

/* -------------------------------------------------------------------------- */
/*                                    Tests                                   */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use uuid::Uuid;

    #[tokio::test]
    async fn pulse_lifecycle_smoke_test() {
        let repo = Arc::new(InMemoryPulseRepo::new());
        let publisher = Arc::new(LogPublisher);
        let service = LearningPulseService::new(repo.clone(), publisher);

        let author = Uuid::new_v4();
        let pulse_id = service
            .create_pulse(author, "Rust Quiz", "Complete the borrow checker challenge")
            .await
            .expect("pulse creation failed");

        let fetched = service
            .get_pulse(pulse_id)
            .await
            .expect("pulse retrieval failed");

        assert_eq!(fetched.id, pulse_id);
        assert_eq!(fetched.author_id, author);
        assert_eq!(fetched.title, "Rust Quiz");
    }

    #[tokio::test]
    async fn validation_rejects_empty_title() {
        let service = LearningPulseService::new(
            Arc::new(InMemoryPulseRepo::new()),
            Arc::new(LogPublisher),
        );

        let res = service
            .create_pulse(Uuid::new_v4(), "", "something")
            .await;

        match res {
            Err(ServiceError::Validation(ValidationError::EmptyTitle)) => {}
            _ => panic!("Expected EmptyTitle error"),
        }
    }
}
```