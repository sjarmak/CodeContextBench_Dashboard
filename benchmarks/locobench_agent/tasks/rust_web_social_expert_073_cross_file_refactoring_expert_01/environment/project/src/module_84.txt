```rust
// src/module_84.txt
//
// Eventing module for “EduPulse Live – Event-Driven Social Learning Hub”.
// This file defines strongly-typed domain events, wraps them in a CloudEvent
// compliant envelope, and ships them to a message broker (NATS in this case).
//
// The code is production-grade, async-safe, and can be reused by any service
// in the ecosystem that needs to emit or consume events generated by the core
// API layer.
//
// Dependencies (Cargo.toml):
// --------------------------
// [dependencies]
// async-nats   = "0.30"
// async-trait  = "0.1"
// chrono       = { version = "0.4", features = ["serde"] }
// serde        = { version = "1.0", features = ["derive"] }
// serde_json   = "1.0"
// thiserror    = "1.0"
// tracing      = "0.1"
// uuid         = { version = "1", features = ["serde", "v4"] }

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tracing::{error, instrument, warn};
use uuid::Uuid;

// -------------------------------------------------------------------------------------------------
// Domain-level events
// -------------------------------------------------------------------------------------------------

/// LearningPulseCreated is fired the moment a teacher posts a new “learning pulse”.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LearningPulseCreated {
    pub pulse_id: Uuid,
    pub teacher_id: Uuid,
    pub course_id: Uuid,
    pub title: String,
    pub created_at: DateTime<Utc>,
}

/// StudentReplySubmitted is emitted when a student uploads a reply to a pulse.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StudentReplySubmitted {
    pub reply_id: Uuid,
    pub student_id: Uuid,
    pub pulse_id: Uuid,
    pub submitted_at: DateTime<Utc>,
}

/// QuizSubmitted is triggered once a student has finalised a quiz attempt.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuizSubmitted {
    pub quiz_id: Uuid,
    pub student_id: Uuid,
    pub attempt_id: Uuid,
    pub score: Option<f32>,
    pub submitted_at: DateTime<Utc>,
}

/// Enum wrapper that allows serialising / deserialising heterogeneous events.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", content = "attributes")]
pub enum DomainEvent {
    #[serde(rename = "learning_pulse.created")]
    LearningPulseCreated(LearningPulseCreated),

    #[serde(rename = "student_reply.submitted")]
    StudentReplySubmitted(StudentReplySubmitted),

    #[serde(rename = "quiz.submitted")]
    QuizSubmitted(QuizSubmitted),
}

// -------------------------------------------------------------------------------------------------
// CloudEvent envelope
// -------------------------------------------------------------------------------------------------

/// Minimal CloudEvent 1.0 implementation tailored to our needs.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloudEvent {
    /// Unique event id.
    pub id: Uuid,

    /// Identifies the organisation or service emitting the event, e.g. "auth-service".
    pub source: String,

    /// Must be `"1.0"` according to the spec.
    pub specversion: &'static str,

    /// Event type, e.g. `"learning_pulse.created"`.
    #[serde(rename = "type")]
    pub event_type: String,

    /// MIME type of `data` (always `application/json` here).
    pub datacontenttype: &'static str,

    /// RFC 3339 timestamp.
    pub time: DateTime<Utc>,

    /// Optional subject—left for downstream services that need multi-tenant routing.
    pub subject: Option<String>,

    /// Actual domain event payload.
    pub data: DomainEvent,
}

impl CloudEvent {
    /// Wraps a `DomainEvent` in a CloudEvent envelope.
    pub fn new<S: Into<String>>(source: S, event: DomainEvent) -> Self {
        let event_type = match &event {
            DomainEvent::LearningPulseCreated(_) => "learning_pulse.created",
            DomainEvent::StudentReplySubmitted(_) => "student_reply.submitted",
            DomainEvent::QuizSubmitted(_) => "quiz.submitted",
        }
        .to_owned();

        Self {
            id: Uuid::new_v4(),
            source: source.into(),
            specversion: "1.0",
            event_type,
            datacontenttype: "application/json",
            time: Utc::now(),
            subject: None,
            data: event,
        }
    }
}

// -------------------------------------------------------------------------------------------------
// Message-bus abstraction
// -------------------------------------------------------------------------------------------------

/// Generic, async event-bus interface.
///
/// By using `async_trait` we keep the call-sites ergonomic while retaining the
/// option to plug in any broker—NATS, Kafka, Redis Streams, or Postgres LISTEN/NOTIFY.
#[async_trait]
pub trait EventBus: Send + Sync {
    /// Publishes a CloudEvent to the underlying transport.
    async fn publish(&self, event: CloudEvent) -> Result<(), EventBusError>;
}

/// Runtime errors that may occur while communicating with the event bus.
#[derive(Debug, Error)]
pub enum EventBusError {
    #[error("JSON serialisation failed: {0}")]
    Serde(#[from] serde_json::Error),

    #[error("NATS I/O error: {0}")]
    Nats(#[from] async_nats::Error),

    #[error("transport layer closed unexpectedly")]
    Closed,

    #[error("unknown error: {0}")]
    Other(#[from] Box<dyn std::error::Error + Send + Sync>),
}

// -------------------------------------------------------------------------------------------------
// NATS implementation
// -------------------------------------------------------------------------------------------------

/// Concrete `EventBus` backed by a NATS subject hierarchy.
///
/// Events are published under `<prefix>.<event_type>`; e.g.
/// `edupulse.learning_pulse.created`.
pub struct NatsEventBus {
    client: async_nats::Client,
    subject_prefix: String,
}

impl NatsEventBus {
    /// Connects to a NATS server and returns an `EventBus` implementation.
    pub async fn connect<S: Into<String>>(
        nats_url: &str,
        subject_prefix: S,
    ) -> Result<Self, async_nats::Error> {
        let client = async_nats::connect(nats_url).await?;
        Ok(Self {
            client,
            subject_prefix: subject_prefix.into(),
        })
    }

    #[inline]
    fn to_subject(&self, event_type: &str) -> String {
        format!("{}.{}", self.subject_prefix, event_type.replace('/', "."))
    }
}

#[async_trait]
impl EventBus for NatsEventBus {
    #[instrument(skip(self, event), fields(event_type = %event.event_type))]
    async fn publish(&self, event: CloudEvent) -> Result<(), EventBusError> {
        let subject = self.to_subject(&event.event_type);
        let bytes = serde_json::to_vec(&event)?;

        // The underlying client uses at-most-once semantics. For financial
        // operations we would switch to JetStream with persistent storage.
        self.client.publish(subject, bytes.into()).await?;
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
// High-level publisher façade
// -------------------------------------------------------------------------------------------------

/// Convenience wrapper that exposes explicit functions for each domain event.
///
/// This keeps controller code highly readable:
/// `publisher.student_reply_submitted(payload).await?;`
pub struct EventPublisher<B: EventBus> {
    bus: B,
    source: String,
}

impl<B: EventBus> EventPublisher<B> {
    pub fn new<S: Into<String>>(bus: B, source: S) -> Self {
        Self {
            bus,
            source: source.into(),
        }
    }

    #[instrument(skip(self))]
    pub async fn learning_pulse_created(
        &self,
        payload: LearningPulseCreated,
    ) -> Result<(), EventBusError> {
        let ev =
            CloudEvent::new(self.source.clone(), DomainEvent::LearningPulseCreated(payload));
        self.bus.publish(ev).await
    }

    #[instrument(skip(self))]
    pub async fn student_reply_submitted(
        &self,
        payload: StudentReplySubmitted,
    ) -> Result<(), EventBusError> {
        let ev =
            CloudEvent::new(self.source.clone(), DomainEvent::StudentReplySubmitted(payload));
        self.bus.publish(ev).await
    }

    #[instrument(skip(self))]
    pub async fn quiz_submitted(&self, payload: QuizSubmitted) -> Result<(), EventBusError> {
        let ev = CloudEvent::new(self.source.clone(), DomainEvent::QuizSubmitted(payload));
        self.bus.publish(ev).await
    }
}

// -------------------------------------------------------------------------------------------------
// Unit tests
// -------------------------------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use futures::executor::block_on;

    /// Simple in-memory event-bus used to assert that we can publish events
    /// without hitting a real NATS instance. It captures the last message so
    /// that assertions can be made on the envelope contents.
    struct DummyBus {
        last_event: std::sync::Mutex<Option<CloudEvent>>,
    }

    impl DummyBus {
        fn new() -> Self {
            Self {
                last_event: std::sync::Mutex::new(None),
            }
        }
    }

    #[async_trait]
    impl EventBus for DummyBus {
        async fn publish(&self, event: CloudEvent) -> Result<(), EventBusError> {
            *self
                .last_event
                .lock()
                .expect("mutex poisoned") = Some(event);
            Ok(())
        }
    }

    #[test]
    fn publisher_emits_correct_event_type() {
        let bus = DummyBus::new();
        let publisher = EventPublisher::new(bus, "unit-test");

        let pulse_id = Uuid::new_v4();
        let teacher_id = Uuid::new_v4();
        let course_id = Uuid::new_v4();

        let payload = LearningPulseCreated {
            pulse_id,
            teacher_id,
            course_id,
            title: "The Unit Circle Challenge".into(),
            created_at: Utc::now(),
        };

        block_on(async {
            publisher
                .learning_pulse_created(payload.clone())
                .await
                .expect("publish failed");
        });

        let evt = publisher
            .bus
            .last_event
            .lock()
            .unwrap()
            .clone()
            .expect("no event captured");

        match evt.data {
            DomainEvent::LearningPulseCreated(inner) => {
                assert_eq!(inner.pulse_id, pulse_id);
                assert_eq!(evt.event_type, "learning_pulse.created");
            }
            _ => panic!("unexpected event"),
        }
    }
}
```