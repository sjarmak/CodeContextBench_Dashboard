```rust
//! src/module_31.rs  (stored as module_31.txt in prompt)
//!
//! Domain: Learning Pulse (short activities or challenges teachers post).
//!
//! This module exposes a service layer that is responsible for creating new
//! learning pulses, persisting them, and emitting a domain event so that other
//! subsystems (search indexer, push-notification service, analytics, etc.) can
//! react asynchronously.
//!
//! Design decisions
//! ----------------
//! • Repository Pattern  – `PulseRepository` decouples persistence from domain.
//! • Service Layer       – `PulseService` hosts business rules & coordination.
//! • Event Publisher     – `EventPublisher` hides AMQP (Lapin) details.
//! • Error Handling      – `thiserror` + `anyhow` for ergonomic error bubbles.
//! • Async/await         – all public APIs are async to avoid blocking runtimes.
//!
//! Dependencies (Cargo.toml excerpt)
//! ---------------------------------
//! sqlx = { version = "0.7", features = ["postgres", "runtime-tokio-native-tls", "uuid"] }
//! lapin = { version = "2", features = ["runtime-tokio"] }
//! chrono = "0.4"
//! uuid = { version = "1", features = ["v4"] }
//! async-trait = "0.1"
//! serde = { version = "1", features = ["derive"] }
//! thiserror = "1"
//! anyhow = "1"

use std::sync::Arc;

use anyhow::{Context, Result};
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use lapin::{
    options::BasicPublishOptions,
    publisher_confirm::Confirmation,
    BasicProperties, Channel,
};
use serde::{Deserialize, Serialize};
use sqlx::{postgres::PgQueryResult, PgPool, Row};
use thiserror::Error;
use uuid::Uuid;

/// Domain entity representing a learning pulse.
///
/// In practice this would likely live in a separate `domain` crate to avoid
/// dependency pollution, but is kept local for brevity.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LearningPulse {
    pub id: Uuid,
    pub author_id: Uuid,
    pub title: String,
    pub description: String,
    pub created_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
}

/// DTO emitted onto the message broker when a new pulse is created.
#[derive(Debug, Serialize, Deserialize)]
pub struct LearningPulseCreated {
    pub pulse_id: Uuid,
    pub author_id: Uuid,
    pub occurred_at: DateTime<Utc>,
}

impl From<&LearningPulse> for LearningPulseCreated {
    fn from(p: &LearningPulse) -> Self {
        LearningPulseCreated {
            pulse_id: p.id,
            author_id: p.author_id,
            occurred_at: Utc::now(),
        }
    }
}

/// Business-level errors that can occur while working with pulses.
#[derive(Debug, Error)]
pub enum PulseError {
    #[error("title must not be empty")]
    EmptyTitle,
    #[error("description must not be empty")]
    EmptyDescription,
    #[error("expiry must be in the future")]
    InvalidExpiry,
    #[error("database operation failed: {0}")]
    Db(#[from] sqlx::Error),
    #[error("message broker failure: {0}")]
    Broker(#[from] lapin::Error),
}

/// Abstraction over persistence mechanism for `LearningPulse`.
#[async_trait]
pub trait PulseRepository: Send + Sync {
    async fn insert(&self, pulse: &LearningPulse) -> Result<(), PulseError>;
}

/// Postgres implementation using `sqlx`.
pub struct PostgresPulseRepository {
    pool: PgPool,
}

impl PostgresPulseRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl PulseRepository for PostgresPulseRepository {
    async fn insert(&self, pulse: &LearningPulse) -> Result<(), PulseError> {
        let query = r#"
            INSERT INTO learning_pulse (id, author_id, title, description, created_at, expires_at)
            VALUES ($1, $2, $3, $4, $5, $6)
        "#;

        sqlx::query(query)
            .bind(pulse.id)
            .bind(pulse.author_id)
            .bind(&pulse.title)
            .bind(&pulse.description)
            .bind(pulse.created_at)
            .bind(pulse.expires_at)
            .execute(&self.pool)
            .await
            .map(|_: PgQueryResult| ())
            .context("failed to insert learning pulse")?;

        Ok(())
    }
}

/// Abstraction over an event publisher.
///
/// In production we rely on RabbitMQ via Lapin, but tests can substitute an
/// in-memory stub.
#[async_trait]
pub trait EventPublisher: Send + Sync {
    async fn publish(&self, routing_key: &str, payload: &[u8]) -> Result<(), PulseError>;
}

/// RabbitMQ implementation of [EventPublisher].
pub struct AmqpEventPublisher {
    channel: Channel,
    exchange: String,
}

impl AmqpEventPublisher {
    pub fn new(channel: Channel, exchange: impl Into<String>) -> Self {
        Self {
            channel,
            exchange: exchange.into(),
        }
    }
}

#[async_trait]
impl EventPublisher for AmqpEventPublisher {
    async fn publish(&self, routing_key: &str, payload: &[u8]) -> Result<(), PulseError> {
        let confirm: Confirmation = self
            .channel
            .basic_publish(
                &self.exchange,
                routing_key,
                BasicPublishOptions::default(),
                payload,
                BasicProperties::default(),
            )
            .await?
            .await?;

        if confirm.is_nack() {
            return Err(PulseError::Broker(lapin::Error::InvalidAck));
        }
        Ok(())
    }
}

/// High-level service responsible for domain logic around learning pulses.
pub struct PulseService<R, P>
where
    R: PulseRepository,
    P: EventPublisher,
{
    repo: Arc<R>,
    publisher: Arc<P>,
}

impl<R, P> PulseService<R, P>
where
    R: PulseRepository + 'static,
    P: EventPublisher + 'static,
{
    pub fn new(repo: Arc<R>, publisher: Arc<P>) -> Self {
        Self { repo, publisher }
    }

    /// Creates a new learning pulse and emits a `LearningPulseCreated` event.
    ///
    /// Validation rules:
    /// * Title & description cannot be empty
    /// * Expires_at, if provided, must be in the future
    pub async fn create_pulse(
        &self,
        author_id: Uuid,
        title: impl Into<String>,
        description: impl Into<String>,
        expires_at: Option<DateTime<Utc>>,
    ) -> Result<LearningPulse, PulseError> {
        let title = title.into();
        let description = description.into();

        if title.trim().is_empty() {
            return Err(PulseError::EmptyTitle);
        }
        if description.trim().is_empty() {
            return Err(PulseError::EmptyDescription);
        }
        if let Some(expiry) = expires_at {
            if expiry <= Utc::now() {
                return Err(PulseError::InvalidExpiry);
            }
        }

        let pulse = LearningPulse {
            id: Uuid::new_v4(),
            author_id,
            title,
            description,
            created_at: Utc::now(),
            expires_at,
        };

        // Persist transactionally. In a real system, we might use a local
        // outbox table to guarantee atomicity of DB & broker writes.
        self.repo.insert(&pulse).await?;

        // Publish event – failures bubble up; caller may choose to retry.
        let event = LearningPulseCreated::from(&pulse);
        let payload = serde_json::to_vec(&event).expect("serializing LearningPulseCreated");

        let routing_key = "domain.learning_pulse.created";
        self.publisher.publish(routing_key, &payload).await?;

        Ok(pulse)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Mutex;

    /// In-memory test implementation of `PulseRepository`.
    struct InMemoryRepo {
        pulses: Mutex<Vec<LearningPulse>>,
    }

    impl InMemoryRepo {
        fn new() -> Self {
            Self {
                pulses: Mutex::new(Vec::new()),
            }
        }
    }

    #[async_trait]
    impl PulseRepository for InMemoryRepo {
        async fn insert(&self, pulse: &LearningPulse) -> Result<(), PulseError> {
            self.pulses.lock().unwrap().push(pulse.clone());
            Ok(())
        }
    }

    /// Test publisher that simply records payloads.
    struct RecordingPublisher {
        messages: Mutex<Vec<Vec<u8>>>,
    }

    impl RecordingPublisher {
        fn new() -> Self {
            Self {
                messages: Mutex::new(Vec::new()),
            }
        }
    }

    #[async_trait]
    impl EventPublisher for RecordingPublisher {
        async fn publish(&self, _routing_key: &str, payload: &[u8]) -> Result<(), PulseError> {
            self.messages.lock().unwrap().push(payload.to_vec());
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_create_pulse_happy_path() {
        let repo = Arc::new(InMemoryRepo::new());
        let publisher = Arc::new(RecordingPublisher::new());

        let service = PulseService::new(repo.clone(), publisher.clone());

        let author_id = Uuid::new_v4();
        let pulse = service
            .create_pulse(
                author_id,
                "Binary Search Challenge",
                "Submit a Rust implementation of binary search.",
                Some(Utc::now() + chrono::Duration::days(7)),
            )
            .await
            .expect("expected success");

        assert_eq!(pulse.author_id, author_id);
        assert!(!publisher.messages.lock().unwrap().is_empty());
        assert_eq!(repo.pulses.lock().unwrap().len(), 1);
    }

    #[tokio::test]
    async fn test_validation_errors() {
        let repo = Arc::new(InMemoryRepo::new());
        let publisher = Arc::new(RecordingPublisher::new());
        let service = PulseService::new(repo, publisher);

        let res = service
            .create_pulse(
                Uuid::new_v4(),
                "",
                "desc",
                Some(Utc::now() + chrono::Duration::days(1)),
            )
            .await;
        assert!(matches!(res, Err(PulseError::EmptyTitle)));

        let res = service
            .create_pulse(
                Uuid::new_v4(),
                "Title",
                "",
                Some(Utc::now() + chrono::Duration::days(1)),
            )
            .await;
        assert!(matches!(res, Err(PulseError::EmptyDescription)));

        let res = service
            .create_pulse(Uuid::new_v4(), "T", "D", Some(Utc::now()))
            .await;
        assert!(matches!(res, Err(PulseError::InvalidExpiry)));
    }
}
```