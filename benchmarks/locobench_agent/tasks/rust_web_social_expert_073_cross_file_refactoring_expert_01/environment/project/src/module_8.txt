```rust
//! Event framework for EduPulse Live.
//!
//! Provides abstractions and an in-memory implementation for publishing and
//! subscribing to domain events.  Production deployments can swap the
//! `InMemoryBroker` with a real message broker (NATS, Kafka, RabbitMQ, etc.)
//! without touching the domain code.

use std::{
    collections::HashMap,
    sync::Arc,
    time::{SystemTime, UNIX_EPOCH},
};

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::{
    sync::{broadcast, Mutex},
    task::JoinHandle,
};
use tracing::{debug, error, info};
use uuid::Uuid;

/// Human-readable routing key.
pub type Topic = String;

/// Errors produced by the broker layer.
#[derive(Debug, Error)]
pub enum BrokerError {
    #[error("message serialization failed: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("channel error: {0}")]
    Channel(#[from] broadcast::error::RecvError),

    #[error("topic not found: {0}")]
    TopicNotFound(String),

    #[error("unknown broker error: {0}")]
    Unknown(String),
}

/// Envelope that wraps every domain event.
///
/// Adds metadata such as a unique id and timestamp.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventEnvelope<T>
where
    T: Serialize + Send + Sync + 'static,
{
    /// Globally unique event identifier.
    pub id: Uuid,

    /// Logical routing key.
    pub topic: Topic,

    /// Milliseconds since UNIX_EPOCH.
    pub ts_millis: u128,

    /// Optional correlation id to track causality chains.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub correlation_id: Option<Uuid>,

    /// Actual domain payload.
    pub payload: T,
}

impl<T> EventEnvelope<T>
where
    T: Serialize + Send + Sync + 'static,
{
    /// Create a new envelope with the current system time.
    pub fn new(topic: impl Into<Topic>, payload: T) -> Self {
        Self {
            id: Uuid::new_v4(),
            topic: topic.into(),
            ts_millis: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .expect("system clock drift")
                .as_millis(),
            correlation_id: None,
            payload,
        }
    }

    /// Attach or overwrite the correlation id.
    pub fn with_correlation_id(mut self, id: Uuid) -> Self {
        self.correlation_id = Some(id);
        self
    }
}

/// High-level abstraction over different message brokers.
#[async_trait]
pub trait EventBroker: Send + Sync {
    /// Publish a domain event.
    async fn publish<T>(&self, event: EventEnvelope<T>) -> Result<(), BrokerError>
    where
        T: Serialize + Send + Sync + 'static;

    /// Subscribe to a topic, returning a stream-like handle.
    async fn subscribe(&self, topic: Topic) -> Result<Subscription, BrokerError>;

    /// Gracefully stop internal background tasks.
    async fn stop(&self) -> Result<(), BrokerError>;
}

/// Stream-like subscription that yields raw JSON bytes.
///
/// The consumer decides how to deserialize them.
#[derive(Debug)]
pub struct Subscription {
    topic: Topic,
    rx: broadcast::Receiver<Vec<u8>>,
}

impl Subscription {
    pub fn topic(&self) -> &str {
        &self.topic
    }

    pub async fn recv(&mut self) -> Result<Vec<u8>, BrokerError> {
        let bytes = self.rx.recv().await?;
        Ok(bytes)
    }
}

/// In-memory broker backed by Tokio broadcast channels.
///
/// Suitable for unit tests and local development but **not** for production.
#[derive(Clone)]
pub struct InMemoryBroker {
    /// Mapping topic â‡’ channel sender.
    inner: Arc<Mutex<HashMap<Topic, broadcast::Sender<Vec<u8>>>>>,
    /// Background tasks (reserved for future use).
    tasks: Arc<Mutex<Vec<JoinHandle<()>>>>,
}

impl InMemoryBroker {
    pub fn new() -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            tasks: Arc::new(Mutex::new(Vec::new())),
        }
    }

    async fn get_sender(&self, topic: &Topic) -> broadcast::Sender<Vec<u8>> {
        let mut guard = self.inner.lock().await;
        guard
            .entry(topic.clone())
            .or_insert_with(|| broadcast::channel::<Vec<u8>>(1024).0)
            .clone()
    }
}

#[async_trait]
impl EventBroker for InMemoryBroker {
    async fn publish<T>(&self, event: EventEnvelope<T>) -> Result<(), BrokerError>
    where
        T: Serialize + Send + Sync + 'static,
    {
        let bytes = serde_json::to_vec(&event)?;
        let sender = self.get_sender(&event.topic).await;

        match sender.send(bytes) {
            Ok(receivers) => {
                debug!(
                    "published event {} on '{}' ({} receivers)",
                    event.id, event.topic, receivers
                );
                Ok(())
            }
            Err(e) => {
                error!("publish failed: {e}");
                Err(BrokerError::Unknown(e.to_string()))
            }
        }
    }

    async fn subscribe(&self, topic: Topic) -> Result<Subscription, BrokerError> {
        let sender = self.get_sender(&topic).await;
        Ok(Subscription {
            topic,
            rx: sender.subscribe(),
        })
    }

    async fn stop(&self) -> Result<(), BrokerError> {
        let mut tasks = self.tasks.lock().await;
        for handle in tasks.drain(..) {
            handle.abort();
        }
        info!("in-memory broker stopped");
        Ok(())
    }
}

/// Example domain events.

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LessonPublished {
    pub lesson_id: Uuid,
    pub author_id: Uuid,
    pub title: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuizSubmitted {
    pub quiz_id: Uuid,
    pub student_id: Uuid,
    pub score: f32,
}

/// High-level typed facade used by application services.
#[derive(Clone)]
pub struct EventBus {
    broker: Arc<dyn EventBroker>,
}

impl EventBus {
    pub fn new(broker: Arc<dyn EventBroker>) -> Self {
        Self { broker }
    }

    /// Generic emit helper.
    pub async fn emit<T>(&self, topic: impl Into<Topic>, payload: T) -> Result<(), BrokerError>
    where
        T: Serialize + Send + Sync + 'static,
    {
        let env = EventEnvelope::new(topic, payload);
        self.broker.publish(env).await
    }

    // --------------------------------------------------
    // Convenience wrappers for known domain events.
    // --------------------------------------------------

    pub async fn lesson_published(&self, e: LessonPublished) -> Result<(), BrokerError> {
        self.emit("learning.lesson.published", e).await
    }

    pub async fn quiz_submitted(&self, e: QuizSubmitted) -> Result<(), BrokerError> {
        self.emit("learning.quiz.submitted", e).await
    }

    // --------------------------------------------------
    // Typed subscriptions
    // --------------------------------------------------

    pub async fn on_lesson_published(
        &self,
    ) -> Result<TypedSubscription<LessonPublished>, BrokerError> {
        let raw = self.broker.subscribe("learning.lesson.published".into()).await?;
        Ok(TypedSubscription::from_raw(raw))
    }

    pub async fn on_quiz_submitted(
        &self,
    ) -> Result<TypedSubscription<QuizSubmitted>, BrokerError> {
        let raw = self.broker.subscribe("learning.quiz.submitted".into()).await?;
        Ok(TypedSubscription::from_raw(raw))
    }
}

/// Strongly-typed subscription wrapper.
pub struct TypedSubscription<T>
where
    T: for<'de> Deserialize<'de> + Send + 'static,
{
    inner: Subscription,
    _phantom: std::marker::PhantomData<T>,
}

impl<T> TypedSubscription<T>
where
    T: for<'de> Deserialize<'de> + Send + 'static,
{
    fn from_raw(inner: Subscription) -> Self {
        Self {
            inner,
            _phantom: Default::default(),
        }
    }

    pub async fn recv(&mut self) -> Result<T, BrokerError> {
        let bytes = self.inner.recv().await?;
        let envelope: EventEnvelope<T> = serde_json::from_slice(&bytes)?;
        Ok(envelope.payload)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::{timeout, Duration};

    #[tokio::test]
    async fn roundtrip_lesson_published() {
        let broker = Arc::new(InMemoryBroker::new());
        let bus = EventBus::new(broker);

        let mut sub = bus.on_lesson_published().await.unwrap();

        let evt = LessonPublished {
            lesson_id: Uuid::new_v4(),
            author_id: Uuid::new_v4(),
            title: "Advanced Rust Lifetimes".into(),
        };

        bus.lesson_published(evt.clone()).await.unwrap();

        let received = timeout(Duration::from_secs(1), sub.recv())
            .await
            .expect("timed-out")
            .unwrap();

        assert_eq!(evt.lesson_id, received.lesson_id);
        assert_eq!(evt.title, received.title);
    }
}
```