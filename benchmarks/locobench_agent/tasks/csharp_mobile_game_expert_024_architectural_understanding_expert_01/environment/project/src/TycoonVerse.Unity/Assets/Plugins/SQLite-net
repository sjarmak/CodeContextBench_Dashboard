```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using SQLite;
using UnityEngine;

namespace TycoonVerse.Infrastructure.Persistence
{
    /// <summary>
    /// Event arguments raised when a database error occurs.
    /// </summary>
    public sealed class DatabaseErrorEventArgs : EventArgs
    {
        public DatabaseErrorEventArgs(string operation, Exception exception)
        {
            Operation  = operation;
            Exception  = exception;
        }

        public string    Operation { get; }
        public Exception Exception { get; }
    }

    /// <summary>
    /// Abstraction for a shared, async-only connection to the gameâ€™s SQLite database.
    /// </summary>
    public interface ISQLiteConnectionProvider : IDisposable
    {
        SQLiteAsyncConnection Connection { get; }
        Task InitializeAsync(CancellationToken ct = default);
        event EventHandler<DatabaseErrorEventArgs> DatabaseError;
    }

    /// <summary>
    /// Singleton MonoBehaviour responsible for configuring, opening and maintaining a single
    /// <see cref="SQLiteAsyncConnection"/> instance for the lifetime of the application.
    /// </summary>
    [DefaultExecutionOrder(-1000)]
    public sealed class SQLiteConnectionProvider : MonoBehaviour, ISQLiteConnectionProvider
    {
        private const string DatabaseName = "TycoonVerse.db";

#if SQLCIPHER
        // Replace with a secure runtime key in production.
        private const string CipherPassword = "ReplaceWithSecurePassword!";
#endif

        private static readonly SemaphoreSlim                 InitLock            = new SemaphoreSlim(1, 1);
        private static readonly ConcurrentDictionary<string,bool> AppliedMigrations = new();
        private static          SQLiteConnectionProvider       _instance;

        private SQLiteAsyncConnection _asyncConnection;
        private bool                  _initialized;
        private bool                  _disposed;

        public static ISQLiteConnectionProvider Instance
        {
            get
            {
                if (_instance != null) return _instance;

                var go = new GameObject("[SQLiteConnectionProvider]");
                DontDestroyOnLoad(go);
                _instance = go.AddComponent<SQLiteConnectionProvider>();
                return _instance;
            }
        }

        public event EventHandler<DatabaseErrorEventArgs> DatabaseError;

        /// <inheritdoc/>
        public SQLiteAsyncConnection Connection =>
            _initialized
                ? _asyncConnection
                : throw new InvalidOperationException(
                    "Database not initialized. Call InitializeAsync before using the connection.");

        #region MonoBehaviour

        private async void Awake()
        {
            if (_instance != null && _instance != this)
            {
                Destroy(gameObject);
                return;
            }

            _instance = this;
            DontDestroyOnLoad(gameObject);

            try
            {
                using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));
                await InitializeAsync(cts.Token).ConfigureAwait(true);
            }
            catch (Exception ex)
            {
                NotifyError("Awake.InitializeAsync", ex);
            }
        }

        private void OnDestroy() => Dispose();

        #endregion

        #region ISQLiteConnectionProvider

        /// <inheritdoc/>
        public async Task InitializeAsync(CancellationToken ct = default)
        {
            if (_initialized) return;

            await InitLock.WaitAsync(ct).ConfigureAwait(false);
            try
            {
                if (_initialized) return;

                var dbPath = ResolveDatabasePath();

#if SQLCIPHER
                var connectionString = new SQLiteConnectionString(dbPath, storeDateTimeAsTicks: true, key: CipherPassword);
#else
                var connectionString = new SQLiteConnectionString(dbPath, storeDateTimeAsTicks: true);
#endif
                _asyncConnection = new SQLiteAsyncConnection(connectionString);

                await ApplyMigrationsAsync(ct).ConfigureAwait(false);
                _initialized = true;
            }
            catch (Exception ex)
            {
                NotifyError("InitializeAsync", ex);
                throw;
            }
            finally
            {
                InitLock.Release();
            }
        }

        /// <inheritdoc/>
        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;

            try
            {
                _asyncConnection?.CloseAsync().ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[SQLite] Dispose failed: {ex}");
            }
        }

        #endregion

        #region Private Helpers

        private static string ResolveDatabasePath()
        {
#if UNITY_EDITOR
            var root = Application.dataPath;
#elif UNITY_ANDROID && !UNITY_EDITOR
            var root = Application.persistentDataPath;
#elif UNITY_IOS && !UNITY_EDITOR
            var root = Path.Combine(Application.persistentDataPath, "..");
#else
            var root = Application.persistentDataPath;
#endif
            if (!Directory.Exists(root)) Directory.CreateDirectory(root);
            return Path.Combine(root, DatabaseName);
        }

        private async Task ApplyMigrationsAsync(CancellationToken ct)
        {
            // Register new migrations here.
            var migrations = new List<ISchemaMigration>
            {
                new Migration_001_CreateCoreTables(),
                new Migration_002_AddIndices()
            };

            foreach (var migration in migrations)
            {
                if (AppliedMigrations.ContainsKey(migration.Id)) continue;

                try
                {
                    await _asyncConnection.RunInTransactionAsync(conn => migration.Execute(conn))
                                          .ConfigureAwait(false);

                    AppliedMigrations.TryAdd(migration.Id, true);
                    Debug.Log($"[SQLite] Migration {migration.Id} applied ({migration.Description}).");
                }
                catch (Exception ex)
                {
                    NotifyError($"ApplyMigration.{migration.Id}", ex);
                    throw;
                }
            }
        }

        private void NotifyError(string operation, Exception ex)
        {
            Debug.LogError($"[SQLite] Error during '{operation}': {ex}");
            DatabaseError?.Invoke(this, new DatabaseErrorEventArgs(operation, ex));
        }

        #endregion
    }

    #region Migration Infrastructure

    internal interface ISchemaMigration
    {
        string Id          { get; }
        string Description { get; }
        void   Execute(SQLiteConnection connection);
    }

    internal sealed class Migration_001_CreateCoreTables : ISchemaMigration
    {
        public string Id          => "001";
        public string Description => "Create initial domain tables";

        public void Execute(SQLiteConnection connection)
        {
            connection.CreateTable<PlayerDto>();
            connection.CreateTable<CompanyDto>();
            connection.CreateTable<LedgerEntryDto>();
        }
    }

    internal sealed class Migration_002_AddIndices : ISchemaMigration
    {
        public string Id          => "002";
        public string Description => "Add indices for performance optimisation";

        public void Execute(SQLiteConnection connection)
        {
            connection.Execute(
                "CREATE INDEX IF NOT EXISTS IDX_LedgerEntry_PlayerId_Date ON LedgerEntry(PlayerId,EntryDate);");
        }
    }

    #endregion

    #region DTOs

    [Table("Player")]
    internal sealed class PlayerDto
    {
        [PrimaryKey, AutoIncrement] public int      Id          { get; set; }
        [Indexed]                    public string   Uid         { get; set; }
        public                       string   DisplayName { get; set; }
        public                       DateTime CreatedUtc  { get; set; }
    }

    [Table("Company")]
    internal sealed class CompanyDto
    {
        [PrimaryKey, AutoIncrement] public int      Id              { get; set; }
        [Indexed]                    public int      PlayerId        { get; set; }
        public                       string   Name            { get; set; }
        public                       decimal  Cash            { get; set; }
        public                       DateTime LastUpdatedUtc  { get; set; }
    }

    [Table("LedgerEntry")]
    internal sealed class LedgerEntryDto
    {
        [PrimaryKey, AutoIncrement] public long     Id        { get; set; }
        [Indexed]                    public int      PlayerId  { get; set; }
        public                       int      CompanyId { get; set; }
        [Indexed]                    public DateTime EntryDate { get; set; }
        public                       string   Account   { get; set; }
        public                       decimal  Delta     { get; set; }
        public                       string   Memo      { get; set; }
    }

    #endregion
}
```