```csharp
// File: TycoonVerse/src/TycoonVerse.Unity/Assets/Scenes/LoadingScreen.unity
// NOTE: Although Unity scenes are stored as YAML, in TycoonVerse we embed the controller
// script directly under the same logical path for clarity inside our code-gen pipeline.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using TMPro;
using TycoonVerse.Infrastructure.Analytics;
using TycoonVerse.Infrastructure.CrashReporting;
using TycoonVerse.Infrastructure.Connectivity;
using TycoonVerse.Infrastructure.Localization;

namespace TycoonVerse.Unity.Scenes
{
    /// <summary>
    /// LoadingScreen is responsible for asynchronously loading the next scene
    /// while displaying a progress bar, rotating gameplay tips, and routing
    /// telemetry.  It follows a simplified MVVM approach in which this MonoBehaviour
    /// acts as both View and ViewModel, and it pushes progress updates through the
    /// Observer pattern so external listeners (e.g., intro animations) can react.
    ///
    /// Usage:
    ///     LoadingScreen.Load("DashboardScene", new Dictionary<string, object> { ... });
    /// </summary>
    public class LoadingScreen : MonoBehaviour, IObservable<float>
    {
        // ---------------------------------------------------------------------
        // Serialized UI references
        // ---------------------------------------------------------------------
        [Header("UI References")]
        [SerializeField] private Slider _progressBar;
        [SerializeField] private TMP_Text _progressLabel;
        [SerializeField] private TMP_Text _tipLabel;
        [SerializeField] private CanvasGroup _canvasGroup;

        // ---------------------------------------------------------------------
        // Configuration
        // ---------------------------------------------------------------------
        [Header("Behaviour")]
        [Tooltip("Minimum time to keep the loading screen visible, in seconds.  Guarantees UX consistency.")]
        [SerializeField] private float _minimumDisplayTime = 2.0f;

        [Tooltip("Tips that are displayed randomly while loading.")]
        [SerializeField] private TextAsset _tipsJson; // Localized via key -> string map

        // ---------------------------------------------------------------------
        // Static bootstrap API
        // ---------------------------------------------------------------------
        private static string _sceneToLoad;
        private static object _payload;

        /// <summary>
        /// Initiates loading of <paramref name="sceneName"/> and shows the loading screen.
        /// An optional <paramref name="payload"/> can be passed (e.g., user save-game id)
        /// and will be stored in <see cref="SceneLoadContext"/>.
        /// </summary>
        public static void Load(string sceneName, object payload = null)
        {
            if (string.IsNullOrWhiteSpace(sceneName))
                throw new ArgumentException("sceneName cannot be null or empty", nameof(sceneName));

            _sceneToLoad = sceneName;
            _payload     = payload;

            // The Loading screen is part of the build settings, so we simply load it additive.
            SceneManager.LoadScene("LoadingScreen", LoadSceneMode.Single);
        }

        // ---------------------------------------------------------------------
        // Lifecycle
        // ---------------------------------------------------------------------
        private readonly List<IObserver<float>> _observers = new();
        private string[] _localizedTips;

        private void Awake()
        {
            DontDestroyOnLoad(this); // Persist while loading next scene
            ParseTips();
        }

        private void Start()
        {
            // Telemetry entry point
            AnalyticsService.Instance.TrackScreen("LoadingScreen");

            // Kick off loading
            StartCoroutine(LoadSceneCoroutine());
        }

        private void ParseTips()
        {
            try
            {
                // _tipsJson is expected to be an array of keys, each one localized on demand.
                _localizedTips = _tipsJson == null
                    ? Array.Empty<string>()
                    : JsonUtility.FromJson<TipContainer>(_tipsJson.text).Tips;
            }
            catch (Exception ex)
            {
                CrashReporter.Report(ex);
                _localizedTips = Array.Empty<string>();
            }
        }

        // ---------------------------------------------------------------------
        // Coroutine
        // ---------------------------------------------------------------------
        private IEnumerator LoadSceneCoroutine()
        {
            if (string.IsNullOrEmpty(_sceneToLoad))
            {
                // Defensive fallback; shouldn't happen in production
                const string fallback = "MainMenu";
                CrashReporter.Report("SceneToLoad was not set. Falling back to " + fallback);
                _sceneToLoad = fallback;
            }

            var displayTimer = 0f;
            var op = SceneManager.LoadSceneAsync(_sceneToLoad, LoadSceneMode.Single);
            op.allowSceneActivation = false;

            // Inject payload into a static context bag for the target scene to consume
            SceneLoadContext.Payload = _payload;
            _payload = null; // Clear to avoid accidental reuse

            // Random tip rotation
            var nextTipTime = 0f;
            var tipInterval = 4f;

            while (!op.isDone)
            {
                // Load progress is reported as [0, 0.9] until allowed to activate
                var normalizedProgress = Mathf.Clamp01(op.progress / 0.9f);
                UpdateProgress(normalizedProgress);

                // Tip rotation
                if (Time.time >= nextTipTime)
                {
                    RotateTip();
                    nextTipTime = Time.time + tipInterval;
                }

                displayTimer += Time.deltaTime;

                // We only allow scene activation once it's fully loaded AND we've met the minimum display duration.
                if (normalizedProgress >= 0.99f && displayTimer >= _minimumDisplayTime)
                {
                    op.allowSceneActivation = true;
                }

                yield return null;
            }

            // Fade out quickly
            yield return StartCoroutine(FadeOut());

            NotifyCompletion();

            // Scene has switched; we can safely self-destroy.
            Destroy(gameObject);
        }

        private void UpdateProgress(float value)
        {
            _progressBar.value = value;
            _progressLabel.text = $"{Mathf.RoundToInt(value * 100)}%";
            NotifyObservers(value);
        }

        private void RotateTip()
        {
            if (_localizedTips.Length == 0) return;
            var idx = UnityEngine.Random.Range(0, _localizedTips.Length);
            var key = _localizedTips[idx];
            _tipLabel.text = LocalizationService.GetLocalizedString(key);
        }

        private IEnumerator FadeOut()
        {
            const float fadeDuration = .3f;
            var t = 0f;
            while (t < fadeDuration)
            {
                t += Time.deltaTime;
                _canvasGroup.alpha = 1f - Mathf.Clamp01(t / fadeDuration);
                yield return null;
            }
        }

        // ---------------------------------------------------------------------
        // Observer Pattern implementation
        // ---------------------------------------------------------------------
        public IDisposable Subscribe(IObserver<float> observer)
        {
            if (!_observers.Contains(observer)) _observers.Add(observer);
            return new Unsubscriber(_observers, observer);
        }

        private void NotifyObservers(float value)
        {
            foreach (var observer in _observers)
            {
                try
                {
                    observer.OnNext(value);
                }
                catch (Exception ex)
                {
                    CrashReporter.Report(ex);
                }
            }
        }

        private void NotifyCompletion()
        {
            foreach (var observer in _observers)
            {
                try
                {
                    observer.OnCompleted();
                }
                catch (Exception ex)
                {
                    CrashReporter.Report(ex);
                }
            }
        }

        private sealed class Unsubscriber : IDisposable
        {
            private readonly List<IObserver<float>> _list;
            private readonly IObserver<float> _observer;

            public Unsubscriber(List<IObserver<float>> list, IObserver<float> observer)
            {
                _list     = list;
                _observer = observer;
            }

            public void Dispose()
            {
                if (_observer != null && _list.Contains(_observer))
                    _list.Remove(_observer);
            }
        }

        // ---------------------------------------------------------------------
        // Helpers
        // ---------------------------------------------------------------------
        [Serializable]
        private class TipContainer
        {
            public string[] Tips;
        }
    }

    /// <summary>
    /// Static bag for passing a payload between scenes without coupling.
    /// The content is cleared as soon as the target scene reads it.
    /// </summary>
    public static class SceneLoadContext
    {
        private static object _payload;

        public static object Payload
        {
            get
            {
                var tmp = _payload;
                _payload = null; // one-time read
                return tmp;
            }
            internal set => _payload = value;
        }
    }
}
```