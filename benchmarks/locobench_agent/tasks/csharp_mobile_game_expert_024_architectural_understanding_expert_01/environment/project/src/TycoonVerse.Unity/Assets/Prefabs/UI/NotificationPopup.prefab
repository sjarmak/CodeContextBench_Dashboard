```csharp
// File: Assets/Scripts/UI/NotificationPopup.cs
// Path mirrors prefab location: TycoonVerse/Assets/Prefabs/UI/NotificationPopup.prefab
// -----------------------------------------------------------------------------------------------------------------
// Description
// ------------
// Runtime controller for the "NotificationPopup" prefab.  Implements a lightweight MVVM approach so the visual
// representation stays separated from the underlying data/state.  Observes the global NotificationCenter (Observer
// pattern) and shows contextual messages (errors, info, achievements, etc.).  Handles fade-in/out animations, 
// auto-dismiss, and analytics instrumentation.
//
// NOTE: All public API members purposefully avoid any direct scene references so that the prefab can be spawned
// via Addressables / Object-Pool systems without tight coupling.
// -----------------------------------------------------------------------------------------------------------------

#nullable enable
using System;
using System.Collections;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace TycoonVerse.UI
{
    /// <summary>
    ///     Encapsulates read-only information used to build a notification popup.
    /// </summary>
    public readonly struct NotificationPayload
    {
        public readonly string Title;
        public readonly string Message;
        public readonly Sprite? Icon;
        public readonly NotificationType Type;
        public readonly float? OverrideDisplaySeconds;

        public NotificationPayload(string title,
                                   string message,
                                   NotificationType type           = NotificationType.Info,
                                   Sprite?          icon           = null,
                                   float?           displaySeconds = null)
        {
            Title                 = title;
            Message               = message;
            Type                  = type;
            Icon                  = icon;
            OverrideDisplaySeconds = displaySeconds;
        }
    }

    /// <summary>
    ///     Severity / category for color-coding & analytics.
    /// </summary>
    public enum NotificationType
    {
        Info     = 0,
        Success  = 1,
        Warning  = 2,
        Error    = 3,
        Critical = 4
    }

    /// <summary>
    ///     ViewModel implementing <see cref="INotifyPropertyChanged" /> to satisfy MVVM binding expectations.
    /// </summary>
    internal sealed class NotificationPopupViewModel : INotifyPropertyChanged
    {
        private string             _title   = string.Empty;
        private string             _message = string.Empty;
        private Sprite?            _icon;
        private NotificationType   _type;
        private float              _displayDuration;

        public string Title
        {
            get => _title;
            set => SetField(ref _title, value);
        }

        public string Message
        {
            get => _message;
            set => SetField(ref _message, value);
        }

        public Sprite? Icon
        {
            get => _icon;
            set => SetField(ref _icon, value);
        }

        public NotificationType Type
        {
            get => _type;
            set => SetField(ref _type, value);
        }

        /// <summary>Seconds until auto-dismiss.</summary>
        public float DisplayDuration
        {
            get => _displayDuration;
            set => SetField(ref _displayDuration, Mathf.Max(0, value));
        }

        public event PropertyChangedEventHandler? PropertyChanged;

        private bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
        {
            if (Equals(field, value)) return false;

            field = value;
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
            return true;
        }
    }

    /// <summary>
    ///     Runtime controller attached to <c>NotificationPopup.prefab</c>.
    /// </summary>
    [DisallowMultipleComponent]
    public sealed class NotificationPopup : MonoBehaviour
    {
        // --- Serialized references ------------------------------------------------------------------------------ //
        [Header("UI - References")]
        [SerializeField] private CanvasGroup        canvasGroup   = null!;
        [SerializeField] private TextMeshProUGUI    titleText     = null!;
        [SerializeField] private TextMeshProUGUI    messageText   = null!;
        [SerializeField] private Image              iconImage     = null!;
        [SerializeField] private Button             closeButton   = null!;

        [Header("Timings (seconds)")]
        [Tooltip("Default time to fade in/out.")]
        [SerializeField] private float fadeDuration = 0.33f;
        [Tooltip("How long the popup stays visible if the payload does not override.")]
        [SerializeField] private float defaultDisplaySeconds = 4f;

        [Header("Colors")]
        [SerializeField] private Color infoColor     = new(0.20f, 0.58f, 0.99f);
        [SerializeField] private Color successColor  = new(0.21f, 0.8f,  0.43f);
        [SerializeField] private Color warningColor  = new(0.96f, 0.74f, 0.23f);
        [SerializeField] private Color errorColor    = new(0.93f, 0.33f, 0.23f);
        [SerializeField] private Color criticalColor = new(0.84f, 0.12f, 0.14f);

        // --- Private state -------------------------------------------------------------------------------------- //
        private readonly NotificationPopupViewModel _vm = new();
        private Coroutine?                          _lifecycleRoutine;

        private static readonly int FadeParam = Animator.StringToHash("Alpha");

        #region Unity callbacks
        private void Awake()
        {
            if (!TryValidateSerializedData())
                enabled = false; // critical failure => disable script to prevent spam.
        }

        private void OnEnable()
        {
            // Subscribe to global event bus (Observer pattern).
            NotificationCenter.NotificationReceived += HandleNotification;
            closeButton.onClick.AddListener(HandleCloseClicked);

            // Bind ViewModel -> UI once per enable.
            _vm.PropertyChanged += RefreshVisual;
        }

        private void OnDisable()
        {
            NotificationCenter.NotificationReceived -= HandleNotification;
            closeButton.onClick.RemoveListener(HandleCloseClicked);
            _vm.PropertyChanged -= RefreshVisual;

            // Ensure coroutines are cleaned up to avoid memory leaks.
            if (_lifecycleRoutine != null)
            {
                StopCoroutine(_lifecycleRoutine);
                _lifecycleRoutine = null;
            }
        }
        #endregion

        #region Observer handler
        private void HandleNotification(NotificationPayload payload)
        {
            // Populate ViewModel
            _vm.Title            = payload.Title;
            _vm.Message          = payload.Message;
            _vm.Icon             = payload.Icon;
            _vm.Type             = payload.Type;
            _vm.DisplayDuration  = payload.OverrideDisplaySeconds ?? defaultDisplaySeconds;

            // Start lifecycle (fade-in, stay, fade-out)
            if (_lifecycleRoutine != null) StopCoroutine(_lifecycleRoutine);
            _lifecycleRoutine = StartCoroutine(LifecycleRoutine());

            // Analytics fire-and-forget
            TrySendAnalytics(payload);
        }
        #endregion

        #region Private helpers
        private void RefreshVisual(object? sender, PropertyChangedEventArgs e)
        {
            switch (e.PropertyName)
            {
                case nameof(NotificationPopupViewModel.Title):
                    titleText.text = _vm.Title;
                    break;
                case nameof(NotificationPopupViewModel.Message):
                    messageText.text = _vm.Message;
                    break;
                case nameof(NotificationPopupViewModel.Icon):
                    bool hasIcon = _vm.Icon != null;
                    iconImage.gameObject.SetActive(hasIcon);
                    if (hasIcon) iconImage.sprite = _vm.Icon;
                    break;
                case nameof(NotificationPopupViewModel.Type):
                    SetBackgroundColor(_vm.Type);
                    break;
                // Default display duration does not affect visuals directly.
            }
        }

        private IEnumerator LifecycleRoutine()
        {
            canvasGroup.interactable = true;

            // Fade in
            yield return FadeCanvasGroup(0f, 1f, fadeDuration);

            // Wait
            yield return new WaitForSeconds(_vm.DisplayDuration);

            // Fade out
            yield return FadeCanvasGroup(1f, 0f, fadeDuration);

            canvasGroup.interactable = false;

            // Only hide after fade to avoid input blocking.
            gameObject.SetActive(false);
        }

        private IEnumerator FadeCanvasGroup(float from, float to, float duration)
        {
            float time = 0f;
            while (time < duration)
            {
                time += Time.unscaledDeltaTime;
                canvasGroup.alpha = Mathf.Lerp(from, to, time / duration);
                yield return null;
            }

            canvasGroup.alpha = to;
        }

        private void HandleCloseClicked()
        {
            if (_lifecycleRoutine != null) StopCoroutine(_lifecycleRoutine);
            _lifecycleRoutine = StartCoroutine(FadeCanvasGroup(canvasGroup.alpha, 0f, fadeDuration));
        }

        private void SetBackgroundColor(NotificationType type)
        {
            Color selected = type switch
            {
                NotificationType.Info     => infoColor,
                NotificationType.Success  => successColor,
                NotificationType.Warning  => warningColor,
                NotificationType.Error    => errorColor,
                NotificationType.Critical => criticalColor,
                _                         => infoColor
            };

            // Assuming the root object has an Image for background:
            if (TryGetComponent<Image>(out var bg))
                bg.color = selected;
        }

        private bool TryValidateSerializedData()
        {
            bool valid =
                canvasGroup   != null &&
                titleText     != null &&
                messageText   != null &&
                iconImage     != null &&
                closeButton   != null;

            if (!valid)
                Debug.LogError("[NotificationPopup] Missing serialized references. " +
                               "Please re-assign required UI fields in prefab.", this);

            return valid;
        }

        private static void TrySendAnalytics(in NotificationPayload payload)
        {
#if ENABLE_LOGGING || DEVELOPMENT_BUILD
            try
            {
                // Optional analytics layer (implementation lives elsewhere).
                Analytics.AnalyticsService.RecordEvent(
                    "ui_notification_impression",
                    ("type",        payload.Type.ToString()),
                    ("title",       payload.Title),
                    ("display_sec", payload.OverrideDisplaySeconds?.ToString("0.0") ?? "default"));
            }
            catch (Exception ex)
            {
                // Swallow analytics errors in production; do not disrupt UX.
                Debug.LogWarning($"[NotificationPopup] Analytics failed: {ex.Message}");
            }
#endif
        }
        #endregion
    }

    // -----------------------------------------------------------------------------------------------------------------
    // NotificationCenter  (Singleton with thread-safe lazy instantiation)
    // -----------------------------------------------------------------------------------------------------------------
    public sealed class NotificationCenter
    {
        private static readonly object _lock      = new();
        private static NotificationCenter? _instance;

        public static NotificationCenter Instance
        {
            get
            {
                lock (_lock)
                {
                    _instance ??= new NotificationCenter();
                    return _instance;
                }
            }
        }

        // Event raised when any module publishes a notification.
        public static event Action<NotificationPayload> NotificationReceived
        {
            add    => Instance._notificationReceived += value;
            remove => Instance._notificationReceived -= value;
        }

        private event Action<NotificationPayload>? _notificationReceived;

        private NotificationCenter() { /* Singleton hidden ctor */ }

        /// <summary>
        ///     Publish a notification to all observers.
        /// </summary>
        public static void Publish(NotificationPayload payload)
        {
            Instance._notificationReceived?.Invoke(payload);
        }
    }
}
```