```csharp
// ------------------------------------------------------------
// File: TycoonVerse/src/TycoonVerse.Unity/Assets/Plugins/Firebase/FirebaseService.cs
// Description: Centralised, production-grade fa√ßade around Firebase
//              Analytics, Crashlytics, and RemoteConfig for TycoonVerse.
// ------------------------------------------------------------

#if UNITY_EDITOR || UNITY_ANDROID || UNITY_IOS
#define FIREBASE_ENABLED
#endif

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Events;

#if FIREBASE_ENABLED
using Firebase;
using Firebase.Analytics;
using Firebase.Crashlytics;
using Firebase.Extensions;
using Firebase.RemoteConfig;
#endif

namespace TycoonVerse.Infrastructure.Firebase
{
    /// <summary>
    /// Represents the current initialization state of Firebase.
    /// </summary>
    public enum FirebaseInitializationState
    {
        Uninitialized,
        Initializing,
        Initialized,
        Failed
    }

    /// <summary>
    /// Event fired once Firebase is fully initialized.
    /// </summary>
    [Serializable]
    public sealed class FirebaseInitializedEvent : UnityEvent<FirebaseInitializationState, Exception> { }

    /// <summary>
    /// A resilient, thread-safe Singleton that adapts Firebase functionality 
    /// (Analytics, Crashlytics, RemoteConfig) to the TycoonVerse architecture.
    /// </summary>
    public sealed class FirebaseService : MonoBehaviour
    {
        #region Singleton Implementation
        private static readonly object _lock = new object();
        private static FirebaseService _instance;

        public static FirebaseService Instance
        {
            get
            {
                if (_instance != null) return _instance;

                lock (_lock)
                {
                    if (_instance == null)
                    {
                        _instance = new GameObject("[Singleton] FirebaseService")
                            .AddComponent<FirebaseService>();
                        DontDestroyOnLoad(_instance.gameObject);
                    }
                }

                return _instance;
            }
        }
        #endregion

        #region Public API
        public FirebaseInitializationState State { get; private set; } = FirebaseInitializationState.Uninitialized;

        /// <summary>
        /// UnityEvent exposed for designers to hook into initialization completion.
        /// </summary>
        public FirebaseInitializedEvent OnFirebaseInitialized = new FirebaseInitializedEvent();

        /// <summary>
        /// Adds an event to be logged to Firebase Analytics. 
        /// If Firebase isn't ready or network is unavailable, the event is queued.
        /// </summary>
        /// <param name="eventName">Analytics event name</param>
        /// <param name="parameters">Optional parameters</param>
        public void LogAnalyticsEvent(string eventName, Dictionary<string, object> parameters = null)
        {
            if (string.IsNullOrWhiteSpace(eventName)) return;

            var analyticEvent = new AnalyticEvent(eventName, parameters);

            if (CanSendEvents)
            {
                FlushEvent(analyticEvent);
            }
            else
            {
                _pendingEvents.Enqueue(analyticEvent);
                PersistEventsToDiskAsync().Forget();
            }
        }

        /// <summary>
        /// Sets a user property for analytics segmentation.
        /// </summary>
        public void SetUserProperty(string name, string value)
        {
#if FIREBASE_ENABLED
            if (State != FirebaseInitializationState.Initialized) return;
            FirebaseAnalytics.SetUserProperty(name, value);
#endif
        }

        /// <summary>
        /// Records a non-fatal exception to Crashlytics.
        /// </summary>
        public void RecordNonFatal(Exception ex, string context = null)
        {
#if FIREBASE_ENABLED
            if (State != FirebaseInitializationState.Initialized) return;

            Crashlytics.Log($"Context: {context}");
            Crashlytics.LogException(ex);
#endif
        }

        /// <summary>
        /// Asynchronously fetches the latest Remote Config values with sane timeouts.
        /// </summary>
        public async Task<bool> FetchRemoteConfigAsync(TimeSpan? cacheDuration = null, CancellationToken ct = default)
        {
#if FIREBASE_ENABLED
            if (State != FirebaseInitializationState.Initialized) return false;

            try
            {
                var duration = (ulong)(cacheDuration ?? TimeSpan.FromHours(12)).TotalSeconds;
                var fetchTask = RemoteConfig.FetchAsync(duration);
                await fetchTask.ContinueWithOnMainThread(_ => { }, ct);

                if (ct.IsCancellationRequested) return false;

                var activateTask = RemoteConfig.ActivateAsync();
                await activateTask.ContinueWithOnMainThread(_ => { }, ct);
                return true;
            }
            catch (Exception ex)
            {
                Debug.LogException(ex);
                return false;
            }
#else
            await Task.CompletedTask;
            return false;
#endif
        }
        #endregion

        #region Unity Lifecycle
        private void Awake()
        {
            // Enforce Singleton.
            if (_instance != null && _instance != this)
            {
                Destroy(gameObject);
                return;
            }

            InitializeFirebaseAsync().Forget();
        }

        private void OnEnable()
        {
            Application.logMessageReceivedThreaded += HandleUnityLog;
        }

        private void OnDisable()
        {
            Application.logMessageReceivedThreaded -= HandleUnityLog;
        }

        private void Update()
        {
            FlushPendingEventsIfPossible();
        }
        #endregion

        #region Initialization
        private async Task InitializeFirebaseAsync()
        {
            if (State != FirebaseInitializationState.Uninitialized) return;

            State = FirebaseInitializationState.Initializing;

#if FIREBASE_ENABLED
            var dependencyTask = FirebaseApp.CheckAndFixDependenciesAsync();
            await dependencyTask;

            if (dependencyTask.Result != DependencyStatus.Available)
            {
                var ex = new InvalidOperationException($"Firebase dependencies missing: {dependencyTask.Result}");
                FailInitialization(ex);
                return;
            }

            _app = FirebaseApp.DefaultInstance;

            // FirebaseAnalytics requires default app initialised before use.
            FirebaseAnalytics.SetAnalyticsCollectionEnabled(true);

            // Attach Crashlytics capture for unhandled exceptions
            AppDomain.CurrentDomain.UnhandledException += (_, args) =>
                Crashlytics.LogException(args.ExceptionObject as Exception ?? new Exception("Unhandled Exception"));

            await LoadPersistedEventsAsync();

            State = FirebaseInitializationState.Initialized;
            Debug.Log("[FirebaseService] Initialized successfully.");
            OnFirebaseInitialized.Invoke(State, null);
#else
            var ex = new PlatformNotSupportedException("Firebase SDK not enabled for current build target.");
            FailInitialization(ex);
#endif
        }

        private void FailInitialization(Exception ex)
        {
            State = FirebaseInitializationState.Failed;
            Debug.LogError($"[FirebaseService] Initialization failed: {ex}");
            OnFirebaseInitialized.Invoke(State, ex);
        }
        #endregion

        #region Analytics Queue & Persistence
        private const string OfflineEventFile = "pending_events.json";

        private readonly ConcurrentQueue<AnalyticEvent> _pendingEvents = new ConcurrentQueue<AnalyticEvent>();
        private FirebaseApp _app;

        private bool CanSendEvents =>
            State == FirebaseInitializationState.Initialized &&
            Application.internetReachability != NetworkReachability.NotReachable;

        private void FlushPendingEventsIfPossible()
        {
            if (!CanSendEvents || _pendingEvents.IsEmpty) return;

            while (_pendingEvents.TryDequeue(out var analyticEvent))
            {
                FlushEvent(analyticEvent);
            }

            // Drop persisted file if queue fully drained.
            DeletePersistedEventsFile();
        }

        private void FlushEvent(AnalyticEvent analyticEvent)
        {
#if FIREBASE_ENABLED
            var parameters = new List<Parameter>();

            if (analyticEvent.Parameters != null)
            {
                foreach (var kvp in analyticEvent.Parameters)
                {
                    switch (kvp.Value)
                    {
                        case string s:
                            parameters.Add(new Parameter(kvp.Key, s));
                            break;
                        case int i:
                            parameters.Add(new Parameter(kvp.Key, i));
                            break;
                        case long l:
                            parameters.Add(new Parameter(kvp.Key, l));
                            break;
                        case double d:
                            parameters.Add(new Parameter(kvp.Key, d));
                            break;
                        case float f:
                            parameters.Add(new Parameter(kvp.Key, f));
                            break;
                        default:
                            parameters.Add(new Parameter(kvp.Key, kvp.Value.ToString()));
                            break;
                    }
                }
            }

            FirebaseAnalytics.LogEvent(analyticEvent.Name, parameters.ToArray());
#endif
        }

        private async Task PersistEventsToDiskAsync()
        {
            try
            {
                var events = _pendingEvents.ToArray();
                var json = JsonHelper.ToJson(events, prettyPrint: false);
                var path = Path.Combine(Application.persistentDataPath, OfflineEventFile);

                using (var writer = new StreamWriter(path, false))
                {
                    await writer.WriteAsync(json);
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[FirebaseService] Failed to persist events: {ex}");
            }
        }

        private async Task LoadPersistedEventsAsync()
        {
            var path = Path.Combine(Application.persistentDataPath, OfflineEventFile);

            if (!File.Exists(path)) return;

            try
            {
                string json;
                using (var reader = new StreamReader(path))
                {
                    json = await reader.ReadToEndAsync();
                }

                var events = JsonHelper.FromJson<AnalyticEvent>(json);
                foreach (var e in events) _pendingEvents.Enqueue(e);
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[FirebaseService] Failed to read persisted events: {ex}");
            }
        }

        private void DeletePersistedEventsFile()
        {
            var path = Path.Combine(Application.persistentDataPath, OfflineEventFile);
            if (File.Exists(path))
            {
                File.Delete(path);
            }
        }
        #endregion

        #region Crashlytics Logging
        private void HandleUnityLog(string condition, string stackTrace, LogType type)
        {
#if FIREBASE_ENABLED
            if (State != FirebaseInitializationState.Initialized) return;

            if (type == LogType.Exception || type == LogType.Assert || type == LogType.Error)
            {
                Crashlytics.Log($"UnityLog: {condition}");
                Crashlytics.LogException(new Exception(stackTrace));
            }
#endif
        }
        #endregion
    }

    #region Helper Types
    /// <summary>
    /// Lightweight DTO for queued analytics events.
    /// </summary>
    [Serializable]
    internal struct AnalyticEvent
    {
        public string Name;
        public Dictionary<string, object> Parameters;

        public AnalyticEvent(string name, Dictionary<string, object> parameters)
        {
            Name = name;
            Parameters = parameters;
        }
    }

    /// <summary>
    /// Unity doesn't provide a built-in way to serialise complex arrays to JSON,
    /// so we provide a minimal helper wrapper.
    /// </summary>
    internal static class JsonHelper
    {
        private struct Wrapper<T> { public T[] Items; }

        public static string ToJson<T>(T[] array, bool prettyPrint = false)
        {
            var wrapper = new Wrapper<T> { Items = array };
            return JsonUtility.ToJson(wrapper, prettyPrint);
        }

        public static T[] FromJson<T>(string json)
        {
            var wrapper = JsonUtility.FromJson<Wrapper<T>>(json);
            return wrapper.Items ?? Array.Empty<T>();
        }
    }

    /// <summary>
    /// Extensions for safely fire-and-forget Tasks without warnings.
    /// </summary>
    internal static class TaskExtensions
    {
        public static void Forget(this Task task)
        {
            if (task == null) return;
            task.ConfigureAwait(false);
        }
    }
    #endregion
}
```