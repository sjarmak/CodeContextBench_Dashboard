```csharp
// --------------------------------------------------------------------------------------------------------------------
// <copyright file="IPushNotificationService.cs" company="TycoonVerse">
//   All rights reserved.  Unauthorized copying of this file, via any medium is strictly prohibited.
//   Proprietary and confidential.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace TycoonVerse.Application.Interfaces.Services
{
    /// <summary>
    ///     Abstraction for a cross–platform push-notification provider.
    ///     The implementation maps to FCM/APNs (or a mock provider during
    ///     offline play and unit testing) and is responsible for the full
    ///     push-lifecycle: registration, topic subscription, queuing,
    ///     scheduling, analytics-tracking, and user-interaction callbacks.
    /// </summary>
    /// <remarks>
    ///     The interface purposefully resides in the Application layer so that
    ///     Domain models remain free of infrastructure concerns while the UI
    ///     (Unity) can observe the <see cref="NotificationReceived"/> event.
    /// </remarks>
    public interface IPushNotificationService
    {
        /// <summary>
        ///     Initializes the native notification provider and (optionally)
        ///     requests user permission for alerts, badges, and sounds.
        /// </summary>
        /// <param name="options">Initialization flags that influence startup behavior.</param>
        /// <param name="cancellationToken">A token to monitor for cancellation requests.</param>
        Task InitializeAsync(
            PushNotificationInitOptions options,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     Registers/refreshes the device token with the backend.
        ///     On iOS this maps to the APNs token whereas on Android this maps
        ///     to the FCM registration ID.
        /// </summary>
        /// <param name="deviceToken">The platform specific device token.</param>
        /// <param name="platform">Mobile OS platform.</param>
        /// <param name="customAttributes">
        ///     Optional payload to include along with the token registration
        ///     (e.g. locale, timezone, device-specs).  These are forwarded to
        ///     the analytics/CRM pipeline for richer segmentation.
        /// </param>
        /// <param name="cancellationToken">Cancellation token.</param>
        Task RegisterDeviceAsync(
            string deviceToken,
            DevicePlatform platform,
            IReadOnlyDictionary<string, string>? customAttributes = null,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     Subscribes the device/user to the given topic so that subsequent
        ///     notifications can be broadcast to the segment.
        /// </summary>
        Task SubscribeToTopicAsync(
            NotificationTopic topic,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     Removes the device/user from the given topic.
        /// </summary>
        Task UnsubscribeFromTopicAsync(
            NotificationTopic topic,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     Sends a notification immediately.  In production this is mainly
        ///     used for local notifications or in-app triggered pushes.
        /// </summary>
        Task SendAsync(
            PushNotificationMessage message,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     Schedules a local notification that will be dispatched by the
        ///     OS at the requested UTC time even if the app is in the
        ///     background.  The returned ID can later be used to cancel it.
        /// </summary>
        /// <returns>A deterministic identifier generated by the provider.</returns>
        Task<Guid> ScheduleAsync(
            PushNotificationMessage message,
            DateTimeOffset scheduledUtcTime,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     Cancels a previously scheduled notification.
        /// </summary>
        Task CancelScheduledAsync(
            Guid notificationId,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     Retrieves the list of notifications that are still pending on
        ///     the local device (does not query the server-side queue).
        /// </summary>
        Task<IReadOnlyCollection<ScheduledNotificationInfo>> GetScheduledAsync(
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     Raised whenever a push notification arrives while the app is in
        ///     the foreground or when the user opens the app by tapping a
        ///     background notification.
        /// </summary>
        event EventHandler<NotificationReceivedEventArgs> NotificationReceived;
    }

    #region Supporting Types

    /// <summary>
    ///     Mobile OS platform so that the backend can differentiate payload
    ///     formats, badge behavior, and deep-link structures.
    /// </summary>
    public enum DevicePlatform
    {
        Unknown = 0,
        iOS     = 1,
        Android = 2
    }

    /// <summary>
    ///     Topics represent high-level channels to which players can opt-in/out.
    ///     Server-side campaigns target these topics to deliver segmented pushes.
    /// </summary>
    public enum NotificationTopic
    {
        SystemAlerts,
        MarketingOffers,
        SocialInteractions,
        LogisticsUpdates
    }

    /// <summary>
    ///     Priority hints—mapped to <c>apns-priority</c> and <c>fcm-priority</c>
    ///     headers—affect delivery speed and summaries in the notifications tray.
    /// </summary>
    public enum NotificationPriority
    {
        Low      = 0,
        Normal   = 1,
        High     = 2,
        Critical = 3
    }

    /// <summary>
    ///     Logical notification channels used internally by the game to
    ///     categorize the purpose of a push.
    /// </summary>
    public enum NotificationChannel
    {
        Default,
        Silent,
        BadgeOnly
    }

    /// <summary>
    ///     Contains initialization flags consumed by
    ///     <see cref="IPushNotificationService.InitializeAsync"/>.
    /// </summary>
    public sealed class PushNotificationInitOptions
    {
        /// <summary>
        ///     If <c>true</c>, requests authorization from the user immediately
        ///     on initialization; otherwise the app must invoke the permission
        ///     prompt explicitly at a later time.
        /// </summary>
        public bool RequestUserAuthorizationOnStart { get; init; } = true;

        /// <summary>
        ///     Determines which topics the user is automatically subscribed to
        ///     at initialization.  When <c>null</c> the service preserves
        ///     server-side defaults.
        /// </summary>
        public IReadOnlyDictionary<NotificationTopic, bool>? DefaultSubscriptions { get; init; }

        /// <summary>
        ///     Enables the forwarding of delivery/interaction events to the
        ///     analytics pipeline so that the design team can A/B test
        ///     engagement strategies.
        /// </summary>
        public bool EnableAnalyticsTracking { get; init; } = true;
    }

    /// <summary>
    ///     Data transfer object representing a push payload ready for delivery.
    /// </summary>
    /// <param name="Title">Headline displayed in the notification tray.</param>
    /// <param name="Body">Message body.</param>
    /// <param name="Data">
    ///     Arbitrary key/value pairs passed to the app upon delivery
    ///     (e.g., deep-link route, promo code, campaign ID).
    /// </param>
    /// <param name="Priority">Delivery urgency.</param>
    /// <param name="Channel">Logical channel within the game.</param>
    public sealed record PushNotificationMessage(
        string Title,
        string Body,
        IDictionary<string, string>? Data = null,
        NotificationPriority Priority = NotificationPriority.Normal,
        NotificationChannel Channel = NotificationChannel.Default);

    /// <summary>
    ///     Metadata describing an OS-level scheduled notification.
    /// </summary>
    /// <param name="Id">Provider specific identifier.</param>
    /// <param name="Message">The original push payload.</param>
    /// <param name="ScheduledUtcTime">When the OS will deliver the push.</param>
    public sealed record ScheduledNotificationInfo(
        Guid Id,
        PushNotificationMessage Message,
        DateTimeOffset ScheduledUtcTime);

    /// <summary>
    ///     Event args raised when a push arrives or is opened.
    /// </summary>
    public sealed class NotificationReceivedEventArgs : EventArgs
    {
        public NotificationReceivedEventArgs(PushNotificationMessage message, bool wasTapped)
        {
            Message  = message ?? throw new ArgumentNullException(nameof(message));
            WasTapped = wasTapped;
        }

        /// <summary>
        ///     Original payload delivered by the provider.
        /// </summary>
        public PushNotificationMessage Message { get; }

        /// <summary>
        ///     <c>true</c> when the user tapped the notification to open the
        ///     app; <c>false</c> when the notification was received while the
        ///     app was active (foreground).
        /// </summary>
        public bool WasTapped { get; }
    }

    #endregion
}
```