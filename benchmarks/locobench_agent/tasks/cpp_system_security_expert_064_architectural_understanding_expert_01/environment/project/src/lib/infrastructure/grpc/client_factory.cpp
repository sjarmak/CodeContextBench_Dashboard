// Copyright (c) 2024 Fortinet
// FortiLedger360 Enterprise Security Suite
//
// File: src/lib/infrastructure/grpc/client_factory.cpp
//
// Description:
//  Centralised factory responsible for instantiating gRPC stubs for the
//  FortiLedger360 service-mesh.  The factory transparently handles:
//
//   * mTLS credential construction (root-CA, client cert / key)
//   * Channel argument initialisation (keepalive, LB policy, compression, …)
//   * Endpoint discovery (from in-process registry / configuration)
//   * Thread-safe channel caching & rudimentary round-robin load-balancing
//   * Sensible error handling + logging hooks
//
//  NOTE: This component is deliberately self-contained; higher-level layers
//  depend only on the generated service stubs—not on the particulars of
//  channel/credential management.  This keeps Policy (how do we talk) separate
//  from Mechanism (what do we talk about).

#include <grpcpp/grpcpp.h>
#include <fstream>
#include <iostream>
#include <memory>
#include <mutex>
#include <random>
#include <shared_mutex>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

// -----------------------------------------------------------------------------
// Forward declarations of generated stubs.
//
// In the real repository these headers are generated by the protobuf compiler
// (protoc) and reside in `generated/` or similar.  We forward-declare them here
// to keep this file self-contained.
//
//     #include <scanner.grpc.pb.h>
//     #include <metrics.grpc.pb.h>
//     #include <config_manager.grpc.pb.h>
//     #include <backup_node.grpc.pb.h>
//     #include <alert_broker.grpc.pb.h>
//
// -----------------------------------------------------------------------------
namespace fl360::mesh::generated
{
class ScannerService;
class MetricsService;
class ConfigManagerService;
class BackupNodeService;
class AlertBrokerService;
} // namespace fl360::mesh::generated

namespace fl360::infrastructure::grpc
{

// -----------------------------------------------------------------------------
// Utility helpers
// -----------------------------------------------------------------------------
namespace
{

// RAII wrapper for file reading
std::string read_file_or_throw(const std::string &path)
{
    std::ifstream in(path, std::ios::binary);
    if (!in.is_open())
    {
        throw std::runtime_error("Unable to open file: " + path);
    }

    std::string contents;
    in.seekg(0, std::ios::end);
    contents.resize(static_cast<std::size_t>(in.tellg()));
    in.seekg(0, std::ios::beg);
    in.read(contents.data(), static_cast<std::streamsize>(contents.size()));
    return contents;
}

// Thread-safe random-device (used for endpoint shuffling)
std::mt19937 &rng()
{
    static thread_local std::mt19937 generator{std::random_device{}()};
    return generator;
}

} // namespace

// -----------------------------------------------------------------------------
// Public types
// -----------------------------------------------------------------------------

// Logical service enumeration used by clients of this factory
enum class MeshService
{
    kScanner,
    kMetrics,
    kConfigManager,
    kBackupNode,
    kAlertBroker
};

// Holds connection specific configuration (set by bootstrap / operator)
struct GrpcClientConfig
{
    bool use_tls                    = true;
    std::string root_ca_path        = "/etc/fortiledger360/ca.pem";
    std::string client_cert_path    = "/etc/fortiledger360/cert.pem";
    std::string client_key_path     = "/etc/fortiledger360/key.pem";
    std::chrono::milliseconds rpc_default_deadline{5'000}; // 5 seconds
    std::vector<std::pair<std::string, std::string>> channel_args;
};

// In-process registry of endpoints.  A production system would likely wire this
// up to Consul, etcd, DNS-SRV, or another source of truth.  For the purpose of
// this example we keep it as an in-memory structure.
struct Endpoint
{
    std::string host;
    uint16_t    port;
};

using EndpointList = std::vector<Endpoint>;

class MeshRegistry
{
public:
    // Registers endpoints for a given service (idempotent)
    void register_service(MeshService svc, EndpointList endpoints)
    {
        std::unique_lock lock(mutex_);
        registry_[svc] = std::move(endpoints);
    }

    // Retrieves endpoints for a service. Throws if none registered.
    EndpointList endpoints_for(MeshService svc) const
    {
        std::shared_lock lock(mutex_);
        auto it = registry_.find(svc);
        if (it == registry_.end() || it->second.empty())
        {
            throw std::runtime_error(
                "MeshRegistry: no endpoints registered for requested service");
        }
        return it->second; // copy on purpose (cheap for small vectors)
    }

private:
    mutable std::shared_mutex
        mutex_; // mutable so const .endpoints_for() can lock for reading
    std::unordered_map<MeshService, EndpointList> registry_;
};

// -----------------------------------------------------------------------------
// ClientFactory
// -----------------------------------------------------------------------------
class ClientFactory
{
public:
    ClientFactory(GrpcClientConfig cfg, std::shared_ptr<MeshRegistry> registry);

    // ---------------------------------------------------------------------
    // Stub creation helpers.  Each call returns a NEW stub instance,
    // backed by a shared, cached channel.
    // ---------------------------------------------------------------------
    std::unique_ptr<fl360::mesh::generated::ScannerService::Stub>
    create_scanner_client();
    std::unique_ptr<fl360::mesh::generated::MetricsService::Stub>
    create_metrics_client();
    std::unique_ptr<fl360::mesh::generated::ConfigManagerService::Stub>
    create_config_manager_client();
    std::unique_ptr<fl360::mesh::generated::BackupNodeService::Stub>
    create_backup_node_client();
    std::unique_ptr<fl360::mesh::generated::AlertBrokerService::Stub>
    create_alert_broker_client();

private:
    using ChannelPtr  = std::shared_ptr<grpc::Channel>;
    using ChannelPool = std::unordered_map<MeshService, ChannelPtr>;

    ChannelPtr channel_for(MeshService svc);

    // Credential helper
    std::shared_ptr<grpc::ChannelCredentials> build_credentials();

    // Picks (pseudo) random endpoint and builds channel args
    std::pair<std::string, grpc::ChannelArguments>
    pick_endpoint_and_args(MeshService svc);

    GrpcClientConfig              cfg_;
    std::shared_ptr<MeshRegistry> registry_;

    // Cached channels because they are thread-safe and expensive to create
    ChannelPool          channels_;
    mutable std::mutex   channels_mutex_;
};

// -----------------------------------------------------------------------------
// Implementation
// -----------------------------------------------------------------------------
ClientFactory::ClientFactory(GrpcClientConfig cfg,
                             std::shared_ptr<MeshRegistry> registry)
    : cfg_{std::move(cfg)}, registry_{std::move(registry)}
{
    if (!registry_)
    {
        throw std::invalid_argument(
            "ClientFactory requires a non-null MeshRegistry");
    }
}

// ---------------------------------
// Public stub creators
// ---------------------------------
#define FL360_CREATE_STUB(fn_name, enum_value, stub_name)                       \
    std::unique_ptr<fl360::mesh::generated::stub_name::Stub>                    \
    ClientFactory::fn_name()                                                    \
    {                                                                           \
        auto ch = channel_for(enum_value);                                      \
        return fl360::mesh::generated::stub_name::NewStub(ch);                  \
    }

FL360_CREATE_STUB(create_scanner_client, MeshService::kScanner, ScannerService)
FL360_CREATE_STUB(create_metrics_client, MeshService::kMetrics, MetricsService)
FL360_CREATE_STUB(create_config_manager_client, MeshService::kConfigManager,
                  ConfigManagerService)
FL360_CREATE_STUB(create_backup_node_client, MeshService::kBackupNode,
                  BackupNodeService)
FL360_CREATE_STUB(create_alert_broker_client, MeshService::kAlertBroker,
                  AlertBrokerService)

#undef FL360_CREATE_STUB

// ---------------------------------
// Private helpers
// ---------------------------------
ClientFactory::ChannelPtr ClientFactory::channel_for(MeshService svc)
{
    {
        // Fast path: look-up without locking (double-checked locking pattern)
        std::scoped_lock lock(channels_mutex_);
        auto             it = channels_.find(svc);
        if (it != channels_.end())
        {
            return it->second;
        }
    }

    // Channel needs to be created
    auto [endpoint, args] = pick_endpoint_and_args(svc);
    auto credentials      = build_credentials();

    auto channel = grpc::CreateCustomChannel(endpoint, credentials, args);
    if (!channel)
    {
        throw std::runtime_error("Failed to create channel for " + endpoint);
    }

    {
        std::scoped_lock lock(channels_mutex_);
        // Another thread might have beaten us to it; honour the first write
        auto [it, inserted] = channels_.emplace(svc, channel);
        if (!inserted)
        {
            channel = it->second; // use existing
        }
    }
    return channel;
}

std::shared_ptr<grpc::ChannelCredentials> ClientFactory::build_credentials()
{
    if (!cfg_.use_tls)
    {
        return grpc::InsecureChannelCredentials();
    }

    grpc::SslCredentialsOptions ssl_opts;
    try
    {
        ssl_opts.pem_root_certs = read_file_or_throw(cfg_.root_ca_path);
        ssl_opts.pem_cert_chain = read_file_or_throw(cfg_.client_cert_path);
        ssl_opts.pem_private_key = read_file_or_throw(cfg_.client_key_path);
    }
    catch (const std::exception &ex)
    {
        // Surface a descriptive error; caller decides how to react.
        throw std::runtime_error(
            std::string("TLS credential construction failed: ") + ex.what());
    }

    return grpc::SslCredentials(ssl_opts);
}

std::pair<std::string, grpc::ChannelArguments>
ClientFactory::pick_endpoint_and_args(MeshService svc)
{
    EndpointList endpoints = registry_->endpoints_for(svc);

    // Shuffle & pick first (fast + good enough for small endpoint sets)
    std::shuffle(endpoints.begin(), endpoints.end(), rng());
    const Endpoint &chosen = endpoints.front();

    grpc::ChannelArguments args;
    // Default keep-alive so the connections don’t go stale
    args.SetInt(GRPC_ARG_KEEPALIVE_TIME_MS, 30'000);             // 30s
    args.SetInt(GRPC_ARG_KEEPALIVE_TIMEOUT_MS, 10'000);          // 10s
    args.SetInt(GRPC_ARG_KEEPALIVE_PERMIT_WITHOUT_CALLS, 1);
    args.SetCompressionAlgorithm(GRPC_COMPRESS_GZIP);

    // User supplied overrides
    for (const auto &[k, v] : cfg_.channel_args)
    {
        args.SetString(k, v);
    }

    std::string endpoint = chosen.host + ":" + std::to_string(chosen.port);
    return {std::move(endpoint), args};
}

} // namespace fl360::infrastructure::grpc