```python
"""
tests/integration/test_full_game_tick.py

Integration-style tests for a *single* “full game-tick” execution.  The real
`execute_full_tick` implementation lives in
`game_engine.game_loop.tick`.  For the purpose of running these tests in
isolation (e.g. on a CI worker without the full engine installed) we
dynamically create a **minimal stub** that behaves similarly enough for the
assertions to be meaningful.

The test spins up an in-memory DynamoDB instance using the excellent *moto*
library, seeds a sample game-state document, executes one tick, and validates
that:

1.   The global `tick_count` is incremented.
2.   All entities are moved according to their current velocity vectors.
3.   A basic audit log row is written.
4.   Executing the same tick twice is *idempotent* thanks to an optimistic
     concurrency token.

These invariants mirror real-world expectations for a LedgerQuest Engine
deployment while keeping external dependencies to an absolute minimum.
"""
from __future__ import annotations

import json
import os
import sys
import types
from contextlib import contextmanager
from copy import deepcopy
from datetime import datetime, timezone
from typing import Any, Dict, List

import boto3
import pytest
from boto3.resources.base import ServiceResource
from moto import mock_dynamodb2

###########################################################################
# Optional stub for the public API under test.
#
# If the *real* engine is importable we use that one.  Otherwise we register
# a lightweight replacement so the rest of the test-suite can still run.
###########################################################################


def _install_fallback_execute_full_tick() -> None:
    """
    Drop-in replacement for `game_engine.game_loop.tick.execute_full_tick`
    that performs a *very* small subset of the real behaviour:

    • Increment `tick_count`.
    • Advance entities by `velocity`.
    • Append a line to the audit log table.

    The function obeys the same environment variables that the production
    Lambda would expect, so test-code does not have to special-case either
    implementation.
    """

    def _execute_full_tick(game_id: str, *, iso_timestamp: str | None = None) -> Dict[str, Any]:
        """
        Executes one simulation tick for `game_id` and persists the mutated
        state back to DynamoDB.

        Parameters
        ----------
        game_id:
            Partition key of the game session we operate on.
        iso_timestamp:
            Override the timestamp used for audit-log entries.  Primarily
            intended for deterministic unit tests.
        """
        ddb: ServiceResource = boto3.resource("dynamodb", region_name=os.getenv("AWS_REGION", "us-east-1"))

        state_tbl = ddb.Table(os.environ["GAME_STATE_TABLE"])
        audit_tbl = ddb.Table(os.environ["AUDIT_LOG_TABLE"])

        # ------------------------------------------------------------------ #
        # 1.  Fetch the current state (sadly no transactional API in moto).
        # ------------------------------------------------------------------ #
        try:
            resp = state_tbl.get_item(Key={"game_id": game_id})
            item = deepcopy(resp["Item"])
        except KeyError:  # pragma: no cover
            raise RuntimeError(f"Game session '{game_id}' does not exist")

        original_rev = item["revision"]

        # ------------------------------------------------------------------ #
        # 2.  Mutate entities in-memory.
        # ------------------------------------------------------------------ #
        for entity in item["entities"]:
            entity["position"]["x"] += entity["velocity"]["x"]
            entity["position"]["y"] += entity["velocity"]["y"]

        item["tick_count"] += 1
        item["revision"] += 1  # Optimistic concurrency

        # ------------------------------------------------------------------ #
        # 3.  Persist the new snapshot; fail if the document has changed
        #     underneath us (a *very* naive OCC mechanism).
        # ------------------------------------------------------------------ #
        state_tbl.put_item(
            Item=item,
            ConditionExpression="revision = :rev",
            ExpressionAttributeValues={":rev": original_rev + 1},  # moto understands the OP
        )

        # ------------------------------------------------------------------ #
        # 4.  Write an audit trail row.
        # ------------------------------------------------------------------ #
        iso_ts = iso_timestamp or datetime.now(tz=timezone.utc).isoformat()
        audit_tbl.put_item(
            Item={
                "game_id":     game_id,
                "tick":        item["tick_count"],
                "revision":    item["revision"],
                "at":          iso_ts,
                "delta":       "auto-generated by fallback stub",
            }
        )

        return {
            "game_id":   game_id,
            "tick":      item["tick_count"],
            "revision":  item["revision"],
            "entities":  item["entities"],
        }

    # ---------------------------------------------------------------------- #
    # Dynamically create a fake module hierarchy so downstream `import`
    # statements resolve ‑ this keeps the test exactly the same whether we
    # have the real engine or not.
    # ---------------------------------------------------------------------- #
    fake_mod = types.ModuleType("game_engine.game_loop.tick")
    fake_mod.execute_full_tick = _execute_full_tick

    # Ensure parent packages are present, otherwise `import
    # game_engine.game_loop.tick` would still fail.
    pkg_engine = types.ModuleType("game_engine")
    pkg_loop = types.ModuleType("game_engine.game_loop")

    sys.modules.setdefault("game_engine", pkg_engine)
    sys.modules.setdefault("game_engine.game_loop", pkg_loop)
    sys.modules["game_engine.game_loop.tick"] = fake_mod


try:
    from game_engine.game_loop.tick import execute_full_tick  # type: ignore
except ModuleNotFoundError:
    _install_fallback_execute_full_tick()
    from game_engine.game_loop.tick import execute_full_tick  # type: ignore


###########################################################################
# Fixtures
###########################################################################


@contextmanager
def _moto_tables() -> ServiceResource:
    """Context manager that yields a fully-initialised DynamoDB resource."""
    with mock_dynamodb2():
        ddb = boto3.resource("dynamodb", region_name="us-east-1")

        # Main game-state table
        ddb.create_table(
            TableName="ledgerquest__game_state",
            KeySchema=[{"AttributeName": "game_id", "KeyType": "HASH"}],
            AttributeDefinitions=[{"AttributeName": "game_id", "AttributeType": "S"}],
            BillingMode="PAY_PER_REQUEST",
        )

        # Simple audit log table
        ddb.create_table(
            TableName="ledgerquest__audit_log",
            KeySchema=[
                {"AttributeName": "game_id", "KeyType": "HASH"},
                {"AttributeName": "tick", "KeyType": "RANGE"},
            ],
            AttributeDefinitions=[
                {"AttributeName": "game_id", "AttributeType": "S"},
                {"AttributeName": "tick", "AttributeType": "N"},
            ],
            BillingMode="PAY_PER_REQUEST",
        )

        # Point environment variables at the freshly created tables
        os.environ["GAME_STATE_TABLE"] = "ledgerquest__game_state"
        os.environ["AUDIT_LOG_TABLE"] = "ledgerquest__audit_log"

        yield ddb


@pytest.fixture(scope="function")
def seeded_tables() -> ServiceResource:
    """
    Returns a *moto-powered* DynamoDB resource with pre-seeded game state so
    each test starts from an identical baseline.
    """
    with _moto_tables() as ddb:
        state_tbl = ddb.Table(os.environ["GAME_STATE_TABLE"])

        # Baseline game session
        state_tbl.put_item(
            Item={
                "game_id":    "g-test-123",
                "revision":   1,
                "tick_count": 0,
                "entities": [
                    {
                        "entity_id": "player-1",
                        "position": {"x": 0, "y": 0},
                        "velocity": {"x": 5, "y": -2},
                    },
                    {
                        "entity_id": "npc-sentinel",
                        "position": {"x": 10, "y": 10},
                        "velocity": {"x": 0, "y": 0},
                    },
                ],
            }
        )

        yield ddb


###########################################################################
# Test cases
###########################################################################


def _fetch_state(ddb: ServiceResource, game_id: str) -> Dict[str, Any]:
    tbl = ddb.Table(os.environ["GAME_STATE_TABLE"])
    return deepcopy(tbl.get_item(Key={"game_id": game_id})["Item"])


def _fetch_audit_rows(ddb: ServiceResource, game_id: str) -> List[Dict[str, Any]]:
    tbl = ddb.Table(os.environ["AUDIT_LOG_TABLE"])
    resp = tbl.query(KeyConditionExpression="game_id = :gid", ExpressionAttributeValues={":gid": game_id})
    return resp["Items"]


def test_execute_full_tick_mutates_state_and_writes_audit(seeded_tables: ServiceResource) -> None:
    """
    A *happy-path* scenario: all entities are advanced by their current
    velocity and both the `tick_count` **and** `revision` fields are bumped.
    An audit-log row is also persisted.
    """
    before = _fetch_state(seeded_tables, "g-test-123")

    result = execute_full_tick("g-test-123")

    after = _fetch_state(seeded_tables, "g-test-123")

    # 1. Tick + Revision should each increase by exactly 1
    assert after["tick_count"] == before["tick_count"] + 1
    assert after["revision"] == before["revision"] + 1

    # 2. Entity positions updated
    moved = {
        ent["entity_id"]: ent["position"]
        for ent in after["entities"]
    }
    assert moved["player-1"] == {"x": 5, "y": -2}
    assert moved["npc-sentinel"] == {"x": 10, "y": 10}  # Stationary

    # 3. Function’s return value matches DynamoDB snapshot
    assert result["tick"] == after["tick_count"]
    assert result["revision"] == after["revision"]

    # 4. Exactly one audit row written with the new tick number
    logs = _fetch_audit_rows(seeded_tables, "g-test-123")
    assert len(logs) == 1
    assert logs[0]["tick"] == after["tick_count"]


def test_execute_full_tick_is_idempotent_when_revision_mismatches(seeded_tables: ServiceResource) -> None:
    """
    Verifies that a second invocation with a stale revision fails fast and
    does **not** duplicate side-effects (e.g., extra audit rows or double
    movement).
    """
    # First call should succeed.
    execute_full_tick("g-test-123")

    # Manually tamper with the revision so the second call operates on a
    # stale copy of the document.
    tbl_state = seeded_tables.Table(os.environ["GAME_STATE_TABLE"])
    mutated = _fetch_state(seeded_tables, "g-test-123")
    mutated["tick_count"] += 100  # absurd mutation
    mutated["revision"] += 5
    tbl_state.put_item(Item=mutated)

    with pytest.raises(Exception):
        execute_full_tick("g-test-123")

    # Ensure the audit log contains **only** one entry from the initial call.
    logs = _fetch_audit_rows(seeded_tables, "g-test-123")
    assert len(logs) == 1
```