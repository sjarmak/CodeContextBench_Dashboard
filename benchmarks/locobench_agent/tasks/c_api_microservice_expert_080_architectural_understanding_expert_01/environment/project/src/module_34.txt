```c
/**
 * MercuryMonolith Commerce Hub
 * ----------------------------------------
 * Module 34: Metrics & Monitoring (Prometheus-style exposition)
 *
 * This compilation unit implements a minimal but production-grade
 * in-memory metrics registry that exposes Counters, Gauges and Histograms
 * in Prometheus exposition format.  The registry is thread-safe and is
 * intended to be shared by all subsystems (HTTP, GraphQL, Repository,
 * Event-Bus, etc.) to provide uniform monitoring across the monolith.
 *
 * Design notes
 * ------------
 * 1. The registry is backed by the ubiquitous uthash (single-header
 *    hash-table implementation) for fast O(1) look-ups.
 * 2. Concurrent updates use a read-write lock to keep the hot path
 *    (mutations) uncontended while still allowing concurrent scrapes.
 * 3. The API is intentionally small; more advanced features (e.g.
 *    exemplars, native histograms) can be layered on top later.
 * 4. Public functions are prefixed with mm_mon_ to avoid collisions in
 *    the unified symbol space of the monolith.
 *
 * Copyright (c) 2024
 * SPDX-License-Identifier: MIT
 */

#include <assert.h>
#include <errno.h>
#include <inttypes.h>
#include <pthread.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "uthash.h"            /* Third-party, permissive single header   */
#include "version.h"           /* Auto-generated by build system          */
#include "mm_log.h"            /* Project-local structured logging macro  */

/*--------------------------------------------------*
 *               Type declarations                   *
 *--------------------------------------------------*/

typedef enum {
    MM_MON_COUNTER   = 0,
    MM_MON_GAUGE     = 1,
    MM_MON_HISTOGRAM = 2
} mm_mon_type_t;

/* A key/value pair (max 16 labels per sample keeps things honest) */
typedef struct {
    const char *key;
    const char *value;
} mm_mon_label_t;

#define MM_MON_MAX_LABELS 16U

typedef struct {
    double upper_bound;               /* +Inf bucket included separately   */
    uint64_t count;
} mm_mon_hist_bucket_t;

/* Forward declaration for hash-table node */
typedef struct mm_mon_metric_s mm_mon_metric_t;

struct mm_mon_metric_s {
    mm_mon_type_t type;
    char         *name;               /* includes optional namespace       */
    uint32_t      label_count;
    mm_mon_label_t labels[MM_MON_MAX_LABELS];

    union {
        struct { uint64_t value; } counter;
        struct { double    value; } gauge;
        struct {                            /* classic Prometheus histogram */
            double                  *bounds;        /* N explicit bounds    */
            mm_mon_hist_bucket_t    *buckets;       /* N+1 counts           */
            uint32_t                 bucket_count;  /* N                    */
            double                   sum;           /* running sum          */
        } hist;
    } as;

    UT_hash_handle hh;                /* uthash handle                     */
};

/*--------------------------------------------------*
 *           Module-wide static variables            *
 *--------------------------------------------------*/

static struct {
    mm_mon_metric_t *registry;        /* Head of uthash metrics table      */
    pthread_rwlock_t lock;            /* Registry guard (RW lock)          */
} g_ctx = { .registry = NULL, .lock = PTHREAD_RWLOCK_INITIALIZER };

/*--------------------------------------------------*
 *         Helper / internal utility functions       *
 *--------------------------------------------------*/

/* Concatenate name+labels into unique key for hash lookup */
static char *
mon__build_key(const char *name,
               uint32_t labels,
               const mm_mon_label_t *lbls)
{
    size_t sz = strlen(name) + 1; /* include null */
    for (uint32_t i = 0; i < labels; ++i)
        sz += strlen(lbls[i].key) + 1 + strlen(lbls[i].value) + 1;

    char *buf = malloc(sz);
    if (!buf) return NULL;

    strcpy(buf, name);
    char *p = buf + strlen(name);

    for (uint32_t i = 0; i < labels; ++i) {
        *p++ = '|';
        strcpy(p, lbls[i].key);   p += strlen(lbls[i].key);
        *p++ = '=';
        strcpy(p, lbls[i].value); p += strlen(lbls[i].value);
    }
    *p = '\0';
    return buf; /* ownership passed to caller */
}

static mm_mon_metric_t *
mon__find(const char *name,
          uint32_t labels,
          const mm_mon_label_t *lbls)
{
    char *key = mon__build_key(name, labels, lbls);
    if (!key) return NULL;

    mm_mon_metric_t *m = NULL;
    HASH_FIND_STR(g_ctx.registry, key, m);
    free(key);
    return m;
}

/* Caller must hold write lock */
static mm_mon_metric_t *
mon__create(mm_mon_type_t type,
            const char *name,
            uint32_t labels,
            const mm_mon_label_t *lbls,
            const double *bounds,
            uint32_t bucket_cnt)
{
    char *key = mon__build_key(name, labels, lbls);
    if (!key) return NULL;

    mm_mon_metric_t *m = calloc(1, sizeof(*m));
    if (!m) {
        free(key);
        return NULL;
    }

    m->type = type;
    m->name = strdup(name);
    m->label_count = labels;
    for (uint32_t i = 0; i < labels; ++i) {
        m->labels[i].key   = strdup(lbls[i].key);
        m->labels[i].value = strdup(lbls[i].value);
    }

    if (type == MM_MON_HISTOGRAM) {
        m->as.hist.bounds       = calloc(bucket_cnt, sizeof(double));
        m->as.hist.buckets      = calloc(bucket_cnt + 1, sizeof(mm_mon_hist_bucket_t));
        if (!m->as.hist.bounds || !m->as.hist.buckets) {
            MM_LOG_ERROR("metrics", "histogram allocation failure");
            free(key);
            /* leak detection omitted for brevity; will be cleaned up on shutdown */
            return NULL;
        }
        memcpy(m->as.hist.bounds, bounds, bucket_cnt * sizeof(double));
        for (uint32_t i = 0; i < bucket_cnt; ++i)
            m->as.hist.buckets[i].upper_bound = bounds[i];
        m->as.hist.buckets[bucket_cnt].upper_bound = INFINITY; /* +Inf bucket */
        m->as.hist.bucket_count = bucket_cnt;
        m->as.hist.sum          = 0.0;
    }

    HASH_ADD_KEYPTR(hh, g_ctx.registry, key, strlen(key), m);
    /* key is owned by uthash (stored inside hh->key ptr) */
    return m;
}

/* Write formatted label set to buffer; returns new cursor */
static char *
mon__write_labels(char *dst, const mm_mon_metric_t *m)
{
    if (m->label_count == 0) return dst;

    *dst++ = '{';
    for (uint32_t i = 0; i < m->label_count; ++i) {
        size_t n = sprintf(dst, "%s=\"%s\"%s",
                           m->labels[i].key,
                           m->labels[i].value,
                           (i + 1 == m->label_count) ? "" : ",");
        dst += n;
    }
    *dst++ = '}';
    return dst;
}

/*--------------------------------------------------*
 *          Public API (visible to project)          *
 *--------------------------------------------------*/

/**
 * mm_mon_init()
 * Initialize monitoring subsystem (idempotent).
 */
int mm_mon_init(void)
{
    static bool initialized = false;
    if (initialized) return 0;
    initialized = true;

    int rc = pthread_rwlock_init(&g_ctx.lock, NULL);
    if (rc) {
        MM_LOG_ERROR("metrics", "rwlock init failed: %s", strerror(rc));
        return -1;
    }
    MM_LOG_INFO("metrics", "Monitoring subsystem initialized (MercuryMonolith/%s)", MM_VERSION_STR);
    return 0;
}

/**
 * mm_mon_counter_inc()
 * Increment a counter by 'amt' (defaults to +1).
 */
int mm_mon_counter_inc(const char               *name,
                       uint64_t                  amt,
                       uint32_t                  label_count,
                       const mm_mon_label_t     *labels)
{
    if (!name || amt == 0 || label_count > MM_MON_MAX_LABELS) return EINVAL;

    /* Fast path: optimistic read lock */
    pthread_rwlock_rdlock(&g_ctx.lock);
    mm_mon_metric_t *m = mon__find(name, label_count, labels);
    if (m && m->type != MM_MON_COUNTER) {
        pthread_rwlock_unlock(&g_ctx.lock);
        return EINVAL;
    }
    if (m) {
        __atomic_add_fetch(&m->as.counter.value, amt, __ATOMIC_RELAXED);
        pthread_rwlock_unlock(&g_ctx.lock);
        return 0;
    }
    pthread_rwlock_unlock(&g_ctx.lock);

    /* Slow path: upgrade to write lock and possibly create metric */
    pthread_rwlock_wrlock(&g_ctx.lock);
    m = mon__find(name, label_count, labels);
    if (!m) {
        m = mon__create(MM_MON_COUNTER, name, label_count, labels, NULL, 0);
        if (!m) {
            pthread_rwlock_unlock(&g_ctx.lock);
            return ENOMEM;
        }
    }
    __atomic_add_fetch(&m->as.counter.value, amt, __ATOMIC_RELAXED);
    pthread_rwlock_unlock(&g_ctx.lock);
    return 0;
}

/**
 * mm_mon_gauge_set()
 * Set gauge to given value.
 */
int mm_mon_gauge_set(const char           *name,
                     double                value,
                     uint32_t              label_count,
                     const mm_mon_label_t *labels)
{
    if (!name || label_count > MM_MON_MAX_LABELS) return EINVAL;

    pthread_rwlock_rdlock(&g_ctx.lock);
    mm_mon_metric_t *m = mon__find(name, label_count, labels);
    if (m && m->type != MM_MON_GAUGE) {
        pthread_rwlock_unlock(&g_ctx.lock);
        return EINVAL;
    }
    if (m) {
        __atomic_store_n(&m->as.gauge.value, value, __ATOMIC_RELAXED);
        pthread_rwlock_unlock(&g_ctx.lock);
        return 0;
    }
    pthread_rwlock_unlock(&g_ctx.lock);

    pthread_rwlock_wrlock(&g_ctx.lock);
    m = mon__find(name, label_count, labels);
    if (!m) {
        m = mon__create(MM_MON_GAUGE, name, label_count, labels, NULL, 0);
        if (!m) {
            pthread_rwlock_unlock(&g_ctx.lock);
            return ENOMEM;
        }
    }
    __atomic_store_n(&m->as.gauge.value, value, __ATOMIC_RELAXED);
    pthread_rwlock_unlock(&g_ctx.lock);
    return 0;
}

/**
 * mm_mon_hist_observe()
 * Observe a value in the histogram.  Bounds array must be monotonically
 * increasing.  The bounds array and count only need to be provided on
 * the first call; subsequent calls may pass NULL/0.
 */
int mm_mon_hist_observe(const char           *name,
                        double                value,
                        const double         *bounds,
                        uint32_t              bucket_cnt,
                        uint32_t              label_count,
                        const mm_mon_label_t *labels)
{
    if (!name || label_count > MM_MON_MAX_LABELS) return EINVAL;

    pthread_rwlock_rdlock(&g_ctx.lock);
    mm_mon_metric_t *m = mon__find(name, label_count, labels);
    if (m && m->type != MM_MON_HISTOGRAM) {
        pthread_rwlock_unlock(&g_ctx.lock);
        return EINVAL;
    }

    if (m) {
        /* fast path update */
        uint32_t i;
        for (i = 0; i <= m->as.hist.bucket_count; ++i) {
            if (value <= m->as.hist.buckets[i].upper_bound) {
                __atomic_add_fetch(&m->as.hist.buckets[i].count, 1, __ATOMIC_RELAXED);
            }
        }
        __atomic_add_fetch(&m->as.hist.sum, value, __ATOMIC_RELAXED);
        pthread_rwlock_unlock(&g_ctx.lock);
        return 0;
    }
    pthread_rwlock_unlock(&g_ctx.lock);

    /* create on first touch */
    if (!bounds || bucket_cnt == 0) return EINVAL;

    pthread_rwlock_wrlock(&g_ctx.lock);
    m = mon__find(name, label_count, labels);
    if (!m) {
        m = mon__create(MM_MON_HISTOGRAM, name, label_count, labels, bounds, bucket_cnt);
        if (!m) {
            pthread_rwlock_unlock(&g_ctx.lock);
            return ENOMEM;
        }
    }
    uint32_t i;
    for (i = 0; i <= m->as.hist.bucket_count; ++i) {
        if (value <= m->as.hist.buckets[i].upper_bound) {
            m->as.hist.buckets[i].count += 1;
        }
    }
    m->as.hist.sum += value;
    pthread_rwlock_unlock(&g_ctx.lock);
    return 0;
}

/**
 * mm_mon_scrape()
 * Produce current registry snapshot in Prometheus exposition format.
 * Caller passes an already-allocated buffer and its length.  Function
 * returns number of bytes written (excluding final '\0') or negative
 * errno-like error.
 */
ssize_t mm_mon_scrape(char *out, size_t out_len)
{
    if (!out || out_len == 0) return -EINVAL;

    size_t used = 0;
    int rc = pthread_rwlock_rdlock(&g_ctx.lock);
    if (rc) return -rc;

    mm_mon_metric_t *m, *tmp;
    HASH_ITER(hh, g_ctx.registry, m, tmp) {
        /* # HELP and # TYPE lines (once per metric family) */
        char line[256];
        int n = snprintf(line, sizeof line,
                         "# HELP %s auto-generated metric\n"
                         "# TYPE %s %s\n",
                         m->name, m->name,
                         m->type == MM_MON_COUNTER   ? "counter"   :
                         m->type == MM_MON_GAUGE     ? "gauge"     :
                                                       "histogram");
        if (used + n >= out_len) { rc = -ENOSPC; goto end; }
        memcpy(out + used, line, n);
        used += n;

        char lbl_buf[512];

        switch (m->type) {
        case MM_MON_COUNTER: {
            char *p = lbl_buf;
            p = mon__write_labels(p, m);
            *p = '\0';
            n = snprintf(line, sizeof line, "%s%s %" PRIu64 "\n",
                         m->name, lbl_buf, m->as.counter.value);
            break;
        }
        case MM_MON_GAUGE: {
            char *p = lbl_buf;
            p = mon__write_labels(p, m);
            *p = '\0';
            n = snprintf(line, sizeof line, "%s%s %f\n",
                         m->name, lbl_buf, m->as.gauge.value);
            break;
        }
        case MM_MON_HISTOGRAM: {
            /* buckets */
            uint64_t cumulative = 0;
            for (uint32_t i = 0; i <= m->as.hist.bucket_count; ++i) {
                cumulative += m->as.hist.buckets[i].count;
                char *p = lbl_buf;
                /* append 'le' synthetic label */
                uint32_t base_lbls = m->label_count;
                mm_mon_label_t tmp_lbls[MM_MON_MAX_LABELS + 1];
                memcpy(tmp_lbls, m->labels, base_lbls * sizeof(mm_mon_label_t));
                char ub[32];
                if (isinf(m->as.hist.buckets[i].upper_bound))
                    strcpy(ub, "+Inf");
                else
                    snprintf(ub, sizeof ub, "%g", m->as.hist.buckets[i].upper_bound);

                tmp_lbls[base_lbls].key   = "le";
                tmp_lbls[base_lbls].value = ub;

                mm_mon_metric_t fake = *m;
                fake.label_count = base_lbls + 1;
                memcpy(fake.labels, tmp_lbls, fake.label_count * sizeof(mm_mon_label_t));

                p = mon__write_labels(p, &fake);
                *p = '\0';
                n = snprintf(line, sizeof line, "%s_bucket%s %" PRIu64 "\n",
                             m->name, lbl_buf, cumulative);
                if (used + n >= out_len) { rc = -ENOSPC; goto end; }
                memcpy(out + used, line, n); used += n;
            }
            /* _sum and _count */
            n = snprintf(line, sizeof line, "%s_sum %f\n%s_count %" PRIu64 "\n",
                         m->name, m->as.hist.sum,
                         m->name, m->as.hist.buckets[m->as.hist.bucket_count].count);
            break;
        }
        default: n = 0; break;
        }

        if (used + n >= out_len) { rc = -ENOSPC; goto end; }
        memcpy(out + used, line, n); used += n;
    }

    rc = 0;
end:
    pthread_rwlock_unlock(&g_ctx.lock);
    if (rc) return rc;
    if (used >= out_len) return -ENOSPC;
    out[used] = '\0';
    return (ssize_t)used;
}

/**
 * mm_mon_shutdown()
 * Free all resources; typically called during graceful shut-down.
 */
void mm_mon_shutdown(void)
{
    pthread_rwlock_wrlock(&g_ctx.lock);
    mm_mon_metric_t *m, *tmp;
    HASH_ITER(hh, g_ctx.registry, m, tmp) {
        HASH_DEL(g_ctx.registry, m);

        free(m->name);
        for (uint32_t i = 0; i < m->label_count; ++i) {
            free((void *)m->labels[i].key);
            free((void *)m->labels[i].value);
        }
        if (m->type == MM_MON_HISTOGRAM) {
            free(m->as.hist.bounds);
            free(m->as.hist.buckets);
        }
        free(m);
    }
    pthread_rwlock_unlock(&g_ctx.lock);
    pthread_rwlock_destroy(&g_ctx.lock);
    memset(&g_ctx, 0, sizeof g_ctx);
}

/*--------------------------------------------------*
 *                Self-test (optional)               *
 *--------------------------------------------------*/
#ifdef MM_MON_MODULE_SELFTEST
#include <unistd.h>

static void test_basic(void)
{
    mm_mon_init();

    mm_mon_counter_inc("http_requests_total", 1, 0, NULL);

    mm_mon_label_t l_route = { .key = "route", .value = "/v1/orders" };
    mm_mon_counter_inc("http_requests_total", 1, 1, &l_route);

    double bounds[] = { 0.5, 0.9, 1.5 };
    mm_mon_hist_observe("http_request_duration_seconds", 0.73, bounds, 3, 1, &l_route);
    mm_mon_hist_observe("http_request_duration_seconds", 1.1, NULL, 0, 1, &l_route);

    char buf[4096];
    ssize_t sz = mm_mon_scrape(buf, sizeof buf);
    write(STDOUT_FILENO, buf, (size_t)sz);
    mm_mon_shutdown();
}

int main(void)
{
    test_basic();
    return 0;
}
#endif /* MM_MON_MODULE_SELFTEST */
```