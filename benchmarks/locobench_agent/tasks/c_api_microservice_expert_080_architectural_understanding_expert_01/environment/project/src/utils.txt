/*
 * MercuryMonolith Commerce Hub
 * File: src/utils.txt          (intentionally kept as *.txt so it can be #included verbatim)
 *
 * Purpose:
 *   A small, header-only utility library that is shared across the entire monolithic
 *   code-base.  All helpers are prefixed with “mm_” (Mercury Monolith) to avoid
 *   collisions.  The implementation is written in plain C99 and is free of external
 *   dependencies except for the standard C library and, optionally, Win32 BCrypt for
 *   cryptographically-secure random bytes on Windows.
 *
 *   Compile-time options:
 *     -DMM_UTILS_STATIC   Make all symbols ‘static’ to keep them translation-unit local
 *     -DMM_UTILS_IMPL     In ONE compilation unit, define this macro before including
 *                         the header to emit the function bodies.
 *
 * Usage:
 *     #define MM_UTILS_IMPL        // <-- exactly in *one* .c file
 *     #include "src/utils.txt"
 *
 * License: MIT
 */

#ifndef MM_UTILS_H
#define MM_UTILS_H

/* ================================================================
 *  Standard headers
 * ================================================================ */
#include <stdint.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <errno.h>

#ifdef _WIN32
    #include <windows.h>
    #include <bcrypt.h>
    #pragma comment(lib, "bcrypt.lib")
#else
    #include <fcntl.h>
    #include <unistd.h>
#endif

/* ================================================================
 *  Macro helpers
 * ================================================================ */
#ifndef MM_UTILS_STATIC
    #define MMUTILS_VISIBILITY
#else
    #define MMUTILS_VISIBILITY static
#endif

/*  Compile-time array length */
#define MM_COUNTOF(arr) (sizeof(arr)/sizeof((arr)[0]))

/* Prevent unused parameter warnings */
#define MM_UNUSED(x) (void)(x)

/* ================================================================
 *  Return codes
 * ================================================================ */
typedef enum {
    MM_OK = 0,
    MM_ERR = -1,
    MM_ENOMEM = -2,
    MM_EINVAL = -3,
    MM_ETOOSMALL = -4,
    MM_EIO = -5
} mm_rc;

/* ================================================================
 *  String helpers
 * ================================================================ */

/* Trim leading/trailing ASCII whitespace.  Returns a pointer *inside* the original
 * string and writes length to *out_len (optional).  The returned string is NOT
 * null-terminated; caller must copy if needed. */
MMUTILS_VISIBILITY const char *mm_trim_ascii(const char *input,
                                             size_t in_len,
                                             size_t *out_len);

/* Safe strncpy replacement that always NUL-terminates and returns error if buf_sz
 * is 0 or if src length > buf_sz-1. */
MMUTILS_VISIBILITY mm_rc mm_safe_strcpy(char       *dst,
                                        size_t      buf_sz,
                                        const char *src);

/* Percent-decoding (URL decode).  dst may equal src for in-place decode.
 * Returns number of bytes written (excluding final NUL) or negative mm_rc on error. */
MMUTILS_VISIBILITY int mm_percent_decode(char *dst, const char *src, size_t src_len);

/* Percent-encode.  Encodes bytes outside unreserved set (RFC 3986).  If dst == NULL,
 * returns length required (excluding final NUL).  Returns negative mm_rc codes on err. */
MMUTILS_VISIBILITY int mm_percent_encode(char       *dst,
                                         size_t      dst_cap,
                                         const char *src,
                                         size_t      src_len);

/* Base64url encode (used for JWT).  If dst == NULL, returns size needed. */
MMUTILS_VISIBILITY int mm_base64url_encode(char       *dst,
                                           size_t      dst_cap,
                                           const void *src,
                                           size_t      src_len);

/* ================================================================
 *  Time helpers
 * ================================================================ */

/* Returns current UTC time as ISO-8601 “YYYY-MM-DDTHH:MM:SS.sssZ”.
 * Writes into caller-supplied buf of at least 25 bytes. */
MMUTILS_VISIBILITY mm_rc mm_iso8601_timestamp(char buf[32]);

/* Returns milliseconds since UNIX epoch. */
MMUTILS_VISIBILITY uint64_t mm_epoch_millis(void);

/* ================================================================
 *  UUID helpers
 * ================================================================ */

/* Generate RFC-4122 v4 UUID string “xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx”.
 * buf must be >= 37 bytes. */
MMUTILS_VISIBILITY mm_rc mm_uuid_v4(char buf[37]);

/* ================================================================
 *  Random bytes (cryptographically secure)
 * ================================================================ */
MMUTILS_VISIBILITY mm_rc mm_random_bytes(void *out, size_t len);

/* ================================================================
 *  Implementation
 * ================================================================ */
#ifdef MM_UTILS_IMPL
#include <assert.h>

/* =========  Private helpers  ======== */
MMUTILS_VISIBILITY static int is_unreserved(int ch)
{
    return (ch >= 'A' && ch <= 'Z') ||
           (ch >= 'a' && ch <= 'z') ||
           (ch >= '0' && ch <= '9') ||
           (ch == '-' || ch == '_' || ch == '.' || ch == '~');
}

/* =========  String helpers  ========= */
const char *mm_trim_ascii(const char *input,
                          size_t      in_len,
                          size_t     *out_len)
{
    if (!input) {
        if (out_len) *out_len = 0;
        return NULL;
    }

    size_t start = 0;
    while (start < in_len && isspace((unsigned char)input[start]))
        start++;

    size_t end = in_len;
    while (end > start && isspace((unsigned char)input[end - 1]))
        --end;

    if (out_len) *out_len = end - start;
    return input + start;
}

mm_rc mm_safe_strcpy(char *dst, size_t buf_sz, const char *src)
{
    if (!dst || !src)                return MM_EINVAL;
    if (buf_sz == 0)                 return MM_ETOOSMALL;

    size_t len = strlen(src);
    if (len >= buf_sz)               return MM_ETOOSMALL;

    memcpy(dst, src, len + 1); /* include NUL */
    return MM_OK;
}

/* Convert hex value of two characters. */
static int hex2byte(char hi, char lo)
{
    int hi_val = isdigit(hi) ? hi - '0' : tolower(hi) - 'a' + 10;
    int lo_val = isdigit(lo) ? lo - '0' : tolower(lo) - 'a' + 10;
    if (hi_val < 0 || hi_val > 15 || lo_val < 0 || lo_val > 15)
        return -1;
    return (hi_val << 4) | lo_val;
}

int mm_percent_decode(char *dst, const char *src, size_t src_len)
{
    if (!dst || !src) return MM_EINVAL;

    char *out = dst;
    for (size_t i = 0; i < src_len; ++i) {
        if (src[i] == '%' && i + 2 < src_len) {
            int v = hex2byte(src[i + 1], src[i + 2]);
            if (v < 0) return MM_EINVAL;
            *out++ = (char)v;
            i += 2;
        } else if (src[i] == '+') {
            *out++ = ' ';
        } else {
            *out++ = src[i];
        }
    }
    *out = '\0';
    return (int)(out - dst);
}

int mm_percent_encode(char *dst,
                      size_t dst_cap,
                      const char *src,
                      size_t src_len)
{
    static const char *hex = "0123456789ABCDEF";
    size_t needed = 0;

    /* First pass: compute length */
    for (size_t i = 0; i < src_len; ++i) {
        needed += is_unreserved((unsigned char)src[i]) ? 1 : 3;
    }

    if (!dst) return (int)needed;          /* dry run mode */
    if (dst_cap < needed + 1) return MM_ETOOSMALL;

    /* Second pass: write output */
    size_t out_i = 0;
    for (size_t i = 0; i < src_len; ++i) {
        unsigned char ch = (unsigned char)src[i];
        if (is_unreserved(ch)) {
            dst[out_i++] = (char)ch;
        } else {
            dst[out_i++] = '%';
            dst[out_i++] = hex[ch >> 4];
            dst[out_i++] = hex[ch & 15];
        }
    }
    dst[out_i] = '\0';
    return (int)out_i;
}

/* ---- Base64url ---- */
/* Lookup table for base64 encoding.  URL variant: '+'->'-', '/'->'_', no padding. */
static const char b64url_table[64] =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789-_";

int mm_base64url_encode(char *dst,
                        size_t dst_cap,
                        const void *src,
                        size_t src_len)
{
    const uint8_t *in = (const uint8_t *)src;
    size_t needed = ((src_len + 2) / 3) * 4;
    if (!dst) return (int)needed;      /* dry run */

    if (dst_cap < needed + 1) return MM_ETOOSMALL;

    size_t out_i = 0;
    for (size_t i = 0; i < src_len; i += 3) {
        uint32_t triple = (in[i] << 16);
        if (i + 1 < src_len) triple |= (in[i + 1] << 8);
        if (i + 2 < src_len) triple |= in[i + 2];

        dst[out_i++] = b64url_table[(triple >> 18) & 0x3F];
        dst[out_i++] = b64url_table[(triple >> 12) & 0x3F];

        if (i + 1 < src_len)
            dst[out_i++] = b64url_table[(triple >> 6) & 0x3F];
        if (i + 2 < src_len)
            dst[out_i++] = b64url_table[triple & 0x3F];
    }

    dst[out_i] = '\0';
    return (int)out_i;
}

/* =========  Time helpers  ========= */
mm_rc mm_iso8601_timestamp(char buf[32])
{
    struct timespec ts;
#if defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)
    if (clock_gettime(CLOCK_REALTIME, &ts) != 0) {
        return MM_EIO;
    }
#else
    struct timeval tv;
    if (gettimeofday(&tv, NULL) != 0) {
        return MM_EIO;
    }
    ts.tv_sec  = tv.tv_sec;
    ts.tv_nsec = tv.tv_usec * 1000;
#endif

    struct tm tm;
#if defined(_WIN32)
    if (gmtime_s(&tm, &ts.tv_sec) != 0) return MM_EIO;
#else
    if (gmtime_r(&ts.tv_sec, &tm) == NULL) return MM_EIO;
#endif

    int ms = (int)(ts.tv_nsec / 1000000);
    int len = snprintf(buf, 32, "%04d-%02d-%02dT%02d:%02d:%02d.%03dZ",
                       tm.tm_year + 1900,
                       tm.tm_mon + 1,
                       tm.tm_mday,
                       tm.tm_hour,
                       tm.tm_min,
                       tm.tm_sec,
                       ms);
    return (len > 0 && (size_t)len < 32) ? MM_OK : MM_ETOOSMALL;
}

uint64_t mm_epoch_millis(void)
{
#if defined(_WIN32)
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);
    uint64_t t = (((uint64_t)ft.dwHighDateTime << 32) | ft.dwLowDateTime);
    /* Windows epoch is 1601-01-01; convert to Unix epoch (1970-01-01) */
    t -= 116444736000000000ULL;
    return t / 10000ULL;
#else
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (uint64_t)ts.tv_sec * 1000ULL + ts.tv_nsec/1000000ULL;
#endif
}

/* =========  Random bytes  ========= */
mm_rc mm_random_bytes(void *out, size_t len)
{
#ifdef _WIN32
    NTSTATUS st = BCryptGenRandom(NULL, (PUCHAR)out, (ULONG)len,
                                  BCRYPT_USE_SYSTEM_PREFERRED_RNG);
    return (st == STATUS_SUCCESS) ? MM_OK : MM_ERR;
#else
    int fd = open("/dev/urandom", O_RDONLY);
    if (fd < 0) return MM_EIO;
    size_t read_total = 0;
    while (read_total < len) {
        ssize_t r = read(fd, (uint8_t *)out + read_total, len - read_total);
        if (r <= 0) { close(fd); return MM_EIO; }
        read_total += (size_t)r;
    }
    close(fd);
    return MM_OK;
#endif
}

/* =========  UUID  ========= */
mm_rc mm_uuid_v4(char buf[37])
{
    uint8_t rnd[16];
    if (mm_random_bytes(rnd, sizeof(rnd)) != MM_OK)
        return MM_ERR;

    /* Set variant (10xxxxxx) and version (0100xxxx) */
    rnd[6] = (rnd[6] & 0x0F) | 0x40;
    rnd[8] = (rnd[8] & 0x3F) | 0x80;

    int len = snprintf(buf, 37,
                       "%02x%02x%02x%02x-"
                       "%02x%02x-"
                       "%02x%02x-"
                       "%02x%02x-"
                       "%02x%02x%02x%02x%02x%02x",
                       rnd[0], rnd[1], rnd[2], rnd[3],
                       rnd[4], rnd[5],
                       rnd[6], rnd[7],
                       rnd[8], rnd[9],
                       rnd[10], rnd[11], rnd[12], rnd[13], rnd[14], rnd[15]);
    return (len == 36) ? MM_OK : MM_ERR;
}

#endif /* MM_UTILS_IMPL */
#endif /* MM_UTILS_H */
