/*
 * src/module_47.txt
 *
 * MercuryMonolith Commerce Hub
 * ----------------------------------
 * Thread-safe in-memory HTTP response cache with LRU eviction, TTL support,
 * structured logging, and metrics hooks.
 *
 * This module is used by the Presentation layer (REST / GraphQL gateway) to
 * avoid repetitive (and often expensive) service calls for idempotent queries.
 *
 * Build artefact: gets compiled as a regular C unit even though the file has a
 * .txt extension – our CMakeLists adds the appropriate flags.
 */

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include <stdio.h>
#include <errno.h>

/* ---------------------------------------------------------------------------
 * External runtime hooks
 * -------------------------------------------------------------------------*/

/* Structured logging — implemented in `core/logging.c` */
extern void mm_log_info (const char *fmt, ...)   __attribute__((format(printf, 1, 2)));
extern void mm_log_warn (const char *fmt, ...)   __attribute__((format(printf, 1, 2)));
extern void mm_log_error(const char *fmt, ...)   __attribute__((format(printf, 1, 2)));

/* Prometheus-compatible counter helpers — implemented in `core/metrics.c` */
extern void mm_metrics_inc_counter(const char *name);
extern void mm_metrics_set_gauge   (const char *name, double value);

/* ---------------------------------------------------------------------------
 * Hash helpers
 * -------------------------------------------------------------------------*/

static uint64_t djb2_hash(const char *s)
{
    uint64_t h = 5381;
    for (unsigned char c; (c = (unsigned char)*s++);)
        h = ((h << 5) + h) + c;    /* h * 33 + c */
    return h;
}

/* ---------------------------------------------------------------------------
 * Cache data structures
 * -------------------------------------------------------------------------*/

/* Represents a cached HTTP response */
typedef struct rc_entry_t {
    char               *key;         /* Composite request fingerprint         */
    uint8_t            *payload;     /* Raw HTTP body                         */
    size_t              len;         /* Payload length                        */
    int                 status_code; /* e.g. 200, 304, 404                    */

    time_t              expires_at;  /* Epoch seconds; 0 => no expiry         */

    /* Doubly-linked list for LRU ordering */
    struct rc_entry_t  *prev;
    struct rc_entry_t  *next;
} rc_entry_t;

/* Open-addressing hash table slot */
typedef struct {
    rc_entry_t *entry;   /* NULL means empty; tombstones not needed because
                           we never delete individually except via eviction */
} rc_slot_t;

typedef struct {
    /* Configuration */
    size_t      capacity_bytes;  /* Hard memory limit for payload bytes  */
    size_t      table_size;      /* Number of buckets (power of two)     */

    /* Runtime state */
    size_t      used_bytes;      /* Sum of `len` for live entries        */
    size_t      num_items;       /* Live entry count                     */

    rc_slot_t  *table;           /* Hash buckets                         */

    rc_entry_t *lru_head;        /* Most recently used                   */
    rc_entry_t *lru_tail;        /* Least recently used                  */

    pthread_mutex_t lock;        /* Global cache lock (coarse)           */
} response_cache_t;

/* ---------------------------------------------------------------------------
 * Forward decl
 * -------------------------------------------------------------------------*/
static void   rc_promote_lru_unlocked(response_cache_t *c, rc_entry_t *e);
static void   rc_evict_if_needed_unlocked(response_cache_t *c, size_t required);
static void   rc_unlink_lru_unlocked(response_cache_t *c, rc_entry_t *e);
static void   rc_link_lru_head_unlocked(response_cache_t *c, rc_entry_t *e);
static void   rc_table_insert_unlocked(response_cache_t *c, rc_entry_t *e);

/* ---------------------------------------------------------------------------
 * Public API
 * -------------------------------------------------------------------------*/

/*
 * response_cache_create()
 *
 * capacity_bytes — upper bound for raw payload bytes (metadata is extra)
 * buckets        — preferred bucket count (will be rounded up to power-of-2)
 *
 * Returns an initialised cache or NULL on allocation failure.
 */
response_cache_t *response_cache_create(size_t capacity_bytes, size_t buckets)
{
    if (capacity_bytes == 0 || buckets == 0) {
        errno = EINVAL;
        return NULL;
    }

    /* Round up to next power of two */
    size_t size_pow2 = 1;
    while (size_pow2 < buckets) {
        size_pow2 <<= 1;
        if (size_pow2 == 0) { /* overflow */
            errno = ERANGE;
            return NULL;
        }
    }

    response_cache_t *c = calloc(1, sizeof(*c));
    if (!c)
        return NULL;

    c->table = calloc(size_pow2, sizeof(rc_slot_t));
    if (!c->table) {
        free(c);
        return NULL;
    }

    c->capacity_bytes = capacity_bytes;
    c->table_size     = size_pow2;

    pthread_mutex_init(&c->lock, NULL);

    mm_log_info("[cache] Created response cache — capacity=%zu MB, buckets=%zu",
                capacity_bytes / (1024 * 1024), size_pow2);
    mm_metrics_set_gauge("response_cache.capacity_bytes", (double)capacity_bytes);

    return c;
}

/*
 * response_cache_destroy()
 */
void response_cache_destroy(response_cache_t *c)
{
    if (!c) return;

    pthread_mutex_lock(&c->lock);

    for (size_t i = 0; i < c->table_size; ++i) {
        rc_entry_t *e = c->table[i].entry;
        if (e) {
            free(e->key);
            free(e->payload);
            free(e);
        }
    }
    free(c->table);

    pthread_mutex_unlock(&c->lock);
    pthread_mutex_destroy(&c->lock);
    free(c);

    mm_log_info("[cache] Response cache destroyed");
}

/*
 * response_cache_put()
 *
 * Adds or replaces a cache entry.
 * `ttl_secs` of 0 disables expiration.
 *
 * Returns 0 on success, or an errno value.
 */
int response_cache_put(response_cache_t *c,
                       const char *key,
                       const void *payload,
                       size_t len,
                       int status_code,
                       uint32_t ttl_secs)
{
    if (!c || !key || !payload || len == 0)
        return EINVAL;

    /* Duplicate key & payload first (to avoid copying while holding lock) */
    char   *key_copy     = strdup(key);
    uint8_t *payload_copy = malloc(len);
    if (!key_copy || !payload_copy) {
        free(key_copy);
        free(payload_copy);
        return ENOMEM;
    }
    memcpy(payload_copy, payload, len);

    rc_entry_t *e = calloc(1, sizeof(*e));
    if (!e) {
        free(key_copy);
        free(payload_copy);
        return ENOMEM;
    }

    e->key         = key_copy;
    e->payload     = payload_copy;
    e->len         = len;
    e->status_code = status_code;
    e->expires_at  = ttl_secs ? (time(NULL) + ttl_secs) : 0;

    pthread_mutex_lock(&c->lock);

    /* Evict items until we have room */
    rc_evict_if_needed_unlocked(c, len);

    /* Replace existing entry if present */
    uint64_t hash = djb2_hash(key);
    size_t   idx  = hash & (c->table_size - 1);
    for (size_t probe = 0; probe < c->table_size; ++probe) {
        rc_slot_t *slot = &c->table[idx];
        if (!slot->entry) break;

        if (strcmp(slot->entry->key, key) == 0) {
            /* Existing entry found; unlink from LRU & free memory */
            rc_entry_t *old = slot->entry;
            c->used_bytes -= old->len;
            rc_unlink_lru_unlocked(c, old);

            free(old->key);
            free(old->payload);
            free(old);
            slot->entry = NULL;
            c->num_items--;
            break;
        }
        idx = (idx + 1) & (c->table_size - 1);
    }

    /* Insert new entry */
    rc_table_insert_unlocked(c, e);
    rc_link_lru_head_unlocked(c, e);
    c->used_bytes += len;
    c->num_items++;

    pthread_mutex_unlock(&c->lock);

    mm_metrics_inc_counter("response_cache.insert");
    mm_metrics_set_gauge("response_cache.bytes", (double)c->used_bytes);
    return 0;
}

/*
 * response_cache_get()
 *
 * If present and not expired, returns payload copy (caller owns) and status.
 * Otherwise returns ENOENT.
 */
int response_cache_get(response_cache_t *c,
                       const char *key,
                       int *out_status_code,
                       void **out_payload,
                       size_t *out_len)
{
    if (!c || !key || !out_status_code || !out_payload || !out_len)
        return EINVAL;

    pthread_mutex_lock(&c->lock);

    uint64_t hash = djb2_hash(key);
    size_t   idx  = hash & (c->table_size - 1);

    rc_entry_t *hit = NULL;
    for (size_t probe = 0; probe < c->table_size; ++probe) {
        rc_slot_t *slot = &c->table[idx];
        if (!slot->entry)
            break; /* Empty bucket => not found */

        if (strcmp(slot->entry->key, key) == 0) {
            hit = slot->entry;
            break;
        }
        idx = (idx + 1) & (c->table_size - 1);
    }

    if (!hit) {
        pthread_mutex_unlock(&c->lock);
        mm_metrics_inc_counter("response_cache.miss");
        return ENOENT;
    }

    /* Check TTL */
    time_t now = time(NULL);
    if (hit->expires_at && hit->expires_at < now) {
        /* Expired -> evict */
        c->used_bytes -= hit->len;
        rc_unlink_lru_unlocked(c, hit);

        free(hit->key);
        free(hit->payload);
        free(hit);

        /* Remove from table */
        c->table[idx].entry = NULL;
        c->num_items--;

        pthread_mutex_unlock(&c->lock);
        mm_metrics_inc_counter("response_cache.expired");
        mm_metrics_set_gauge("response_cache.bytes", (double)c->used_bytes);
        return ENOENT;
    }

    /* Promote to LRU head */
    rc_promote_lru_unlocked(c, hit);

    /* Copy payload for caller */
    void *copy = malloc(hit->len);
    if (!copy) {
        pthread_mutex_unlock(&c->lock);
        return ENOMEM;
    }
    memcpy(copy, hit->payload, hit->len);

    *out_status_code = hit->status_code;
    *out_payload     = copy;
    *out_len         = hit->len;

    pthread_mutex_unlock(&c->lock);

    mm_metrics_inc_counter("response_cache.hit");
    return 0;
}

/*
 * response_cache_purge_expired()
 *
 * Opportunistically walks LRU tail → head until a non-expired item is found.
 * Executed by a background janitor thread elsewhere in the Hub.
 */
void response_cache_purge_expired(response_cache_t *c)
{
    if (!c) return;

    pthread_mutex_lock(&c->lock);
    time_t now = time(NULL);

    rc_entry_t *e = c->lru_tail;
    while (e) {
        if (e->expires_at && e->expires_at < now) {
            rc_entry_t *prev = e->prev;

            /* Remove from hash table */
            uint64_t hash = djb2_hash(e->key);
            size_t   idx  = hash & (c->table_size - 1);
            for (;;) {
                rc_slot_t *slot = &c->table[idx];
                if (slot->entry == e) {
                    slot->entry = NULL;
                    break;
                }
                idx = (idx + 1) & (c->table_size - 1);
            }

            /* Remove from LRU */
            rc_unlink_lru_unlocked(c, e);
            c->used_bytes -= e->len;
            c->num_items--;

            free(e->key);
            free(e->payload);
            free(e);

            e = prev;
        } else {
            /* Tail is not expired => stop */
            break;
        }
    }

    pthread_mutex_unlock(&c->lock);
    mm_metrics_set_gauge("response_cache.bytes", (double)c->used_bytes);
}

/* ---------------------------------------------------------------------------
 * Internal helpers (UNLOCKED — caller must hold cache lock)
 * -------------------------------------------------------------------------*/

static void rc_unlink_lru_unlocked(response_cache_t *c, rc_entry_t *e)
{
    if (e->prev) e->prev->next = e->next;
    if (e->next) e->next->prev = e->prev;
    if (c->lru_head == e) c->lru_head = e->next;
    if (c->lru_tail == e) c->lru_tail = e->prev;
    e->prev = e->next = NULL;
}

static void rc_link_lru_head_unlocked(response_cache_t *c, rc_entry_t *e)
{
    e->prev = NULL;
    e->next = c->lru_head;
    if (c->lru_head) c->lru_head->prev = e;
    c->lru_head = e;
    if (!c->lru_tail) c->lru_tail = e;
}

static void rc_promote_lru_unlocked(response_cache_t *c, rc_entry_t *e)
{
    if (c->lru_head == e) return;  /* Already at front */

    rc_unlink_lru_unlocked(c, e);
    rc_link_lru_head_unlocked(c, e);
}

static void rc_evict_if_needed_unlocked(response_cache_t *c, size_t required)
{
    while (c->used_bytes + required > c->capacity_bytes && c->lru_tail) {
        rc_entry_t *victim = c->lru_tail;

        /* Remove from hash table */
        uint64_t hash = djb2_hash(victim->key);
        size_t   idx  = hash & (c->table_size - 1);
        for (;;) {
            rc_slot_t *slot = &c->table[idx];
            if (slot->entry == victim) {
                slot->entry = NULL;
                break;
            }
            idx = (idx + 1) & (c->table_size - 1);
        }

        rc_unlink_lru_unlocked(c, victim);
        c->used_bytes -= victim->len;
        c->num_items--;

        mm_metrics_inc_counter("response_cache.eviction");

        free(victim->key);
        free(victim->payload);
        free(victim);
    }
}

static void rc_table_insert_unlocked(response_cache_t *c, rc_entry_t *e)
{
    uint64_t hash = djb2_hash(e->key);
    size_t   idx  = hash & (c->table_size - 1);

    for (size_t probe = 0; probe < c->table_size; ++probe) {
        rc_slot_t *slot = &c->table[idx];
        if (!slot->entry) {
            slot->entry = e;
            return;
        }
        idx = (idx + 1) & (c->table_size - 1);
    }

    /* Should never happen if eviction logic is correct */
    mm_log_error("[cache] Failed to insert entry; table is full");
}

/* ---------------------------------------------------------------------------
 * Diagnostics helpers
 * -------------------------------------------------------------------------*/

#ifdef MM_CACHE_SELFTEST
/* Simple diagnostic main() to unit-test the cache in isolation.
 * Compile with:
 *   gcc -DMM_CACHE_SELFTEST -pthread -o selftest module_47.txt
 */
#include <assert.h>

int main(void)
{
    response_cache_t *c = response_cache_create(1024 * 1024, 64); /* 1 MiB */

    const char *key = "GET:/api/v1/products?id=42";
    const char *body = "{ \"id\": 42 }";

    assert(response_cache_put(c, key, body, strlen(body) + 1, 200, 1) == 0);

    int status; void *payload; size_t len;
    assert(response_cache_get(c, key, &status, &payload, &len) == 0);
    assert(status == 200);
    assert(len == strlen(body) + 1);
    assert(strcmp(payload, body) == 0);
    free(payload);

    /* Wait > ttl */
    sleep(2);
    assert(response_cache_get(c, key, &status, &payload, &len) == ENOENT);

    response_cache_destroy(c);
    puts("self-test OK");
    return 0;
}
#endif