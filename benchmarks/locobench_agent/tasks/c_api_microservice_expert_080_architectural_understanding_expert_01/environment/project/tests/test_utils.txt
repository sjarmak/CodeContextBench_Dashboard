```c
/**
 * tests/test_utils.c
 *
 * Integration-style sanity checks for MercuryMonolith’s reusable helpers.
 *
 * All tests are executed with the Criterion test-runner:
 *    $ meson test            # when building with Meson
 * or $ ninja -C build test   # CMake / Ninja
 *
 * The test-suite intentionally touches “public” entry-points only; no private
 * headers are included.  Doing so guarantees that we are validating the same
 * interface an external module would rely on.
 */

#include <criterion/criterion.h>
#include <criterion/new/assert.h>

#include <inttypes.h>
#include <stdatomic.h>
#include <stdio.h>
#include <string.h>
#include <threads.h>

#include "core/utils/base64.h"
#include "core/utils/json.h"
#include "core/utils/logger.h"
#include "core/utils/str.h"
#include "core/utils/time.h"
#include "core/utils/url.h"
#include "core/utils/uuid.h"

/* ------------------------------------------------------------------------- */
/*  UUID                                                                     */
/* ------------------------------------------------------------------------- */
Test(Utils, uuid_generate_is_unique)
{
    uuid_t uuids[1024];

    for (size_t i = 0; i < cr_arr_size(uuids); ++i) {
        uuid_generate(uuids[i]);
    }

    /* Naïve uniqueness test — quadratic but fine for only 1 Ki entries. */
    for (size_t i = 0; i < cr_arr_size(uuids); ++i) {
        for (size_t j = i + 1; j < cr_arr_size(uuids); ++j) {
            cr_assert_neq(uuid_compare(uuids[i], uuids[j]), 0,
                          "UUID collision between indices %zu and %zu", i, j);
        }
    }
}

/* ------------------------------------------------------------------------- */
/*  String helpers                                                           */
/* ------------------------------------------------------------------------- */
Test(Utils, slugify_basic)
{
    const char *src  = "Hello, World! Mercury Monolith -- 2023 Edition";
    char       *slug = str_slugify(src);

    cr_assert_str_eq(slug, "hello-world-mercury-monolith-2023-edition");
    free(slug);
}

Test(Utils, human_readable_bytes)
{
    char buf[16];

    str_human_readable_bytes(1536, buf, sizeof(buf));
    cr_expect_str_eq(buf, "1.50 KiB");

    str_human_readable_bytes(10 * 1024 * 1024, buf, sizeof(buf));
    cr_expect_str_eq(buf, "10.00 MiB");
}

/* ------------------------------------------------------------------------- */
/*  URL helpers                                                              */
/* ------------------------------------------------------------------------- */
Test(Utils, url_encode_decode_roundtrip)
{
    const char *original = "foo=bar&baz=hello world/ä";
    char       *encoded  = url_encode(original);
    char       *decoded  = url_decode(encoded);

    cr_assert_str_eq(decoded, original,
                     "Round-trip encode/decode mismatch: '%s' vs '%s'",
                     decoded, original);

    free(encoded);
    free(decoded);
}

/* ------------------------------------------------------------------------- */
/*  Base-64                                                                  */
/* ------------------------------------------------------------------------- */
Test(Utils, base64_encode_decode_roundtrip)
{
    const uint8_t payload[] = { 0xde, 0xad, 0xbe, 0xef, 0x00, 0x27 };

    char   *b64;
    size_t  out_len;
    uint8_t *decoded;

    b64     = base64_encode(payload, sizeof(payload));
    decoded = base64_decode(b64, &out_len);

    cr_assert_not_null(decoded);
    cr_assert_eq(out_len, sizeof(payload));
    cr_assert_arr_eq(decoded, payload, out_len);

    free(b64);
    free(decoded);
}

/* ------------------------------------------------------------------------- */
/*  JSON                                                                     */
/* ------------------------------------------------------------------------- */
Test(Utils, json_parsing)
{
    const char *input =
        "{ \"name\": \"Mercury\", \"version\": 42, "
        "\"features\": [\"orders\", \"catalog\"] }";

    json_document_t *doc = json_parse(input);
    cr_assert_not_null(doc);

    cr_assert_eq(json_doc_get_type(doc, "name"),     JSON_STRING);
    cr_assert_eq(json_doc_get_type(doc, "version"),  JSON_NUMBER);
    cr_assert_eq(json_doc_get_type(doc, "features"), JSON_ARRAY);

    cr_expect_str_eq(json_doc_get_string(doc, "name"), "Mercury");
    cr_expect_eq(json_doc_get_int(doc, "version"), 42);
    cr_expect_str_eq(json_doc_get_string_at(doc, "features", 0), "orders");

    json_doc_destroy(doc);
}

/* ------------------------------------------------------------------------- */
/*  Monotonic clock                                                          */
/* ------------------------------------------------------------------------- */
Test(Utils, monotonic_clock_increases)
{
    uint64_t t1 = time_monotonic_ns();
    utils_sleep_ms(10);
    uint64_t t2 = time_monotonic_ns();

    cr_assert_gt(t2, t1, "Monotonic clock did not advance (t1=%" PRIu64
                         ", t2=%" PRIu64 ")", t1, t2);
}

/* ------------------------------------------------------------------------- */
/*  Logger (thread-safety)                                                   */
/* ------------------------------------------------------------------------- */
static atomic_int g_log_counter = 0;

static int
logger_thread_entry(void *unused)
{
    (void)unused;

    char tag[32];
    const int id = atomic_fetch_add(&g_log_counter, 1);
    snprintf(tag, sizeof(tag), "worker-%d", id);

    for (int i = 0; i < 100; ++i)
        logger_info("stress", "%s message-%d", tag, i);

    return 0;
}

Test(Utils, logger_thread_safety)
{
    const size_t THREADS = 8;
    thrd_t       handles[THREADS];

    logger_set_level(LOG_LEVEL_INFO);
    logger_set_mode(LOG_MODE_RING_BUFFER);

    for (size_t i = 0; i < THREADS; ++i)
        cr_assert_eq(thrd_create(&handles[i], logger_thread_entry, NULL), thrd_success);

    for (size_t i = 0; i < THREADS; ++i)
        thrd_join(handles[i], NULL);

    /* Ring-buffer should stay healthy under heavy concurrency.              */
    cr_assert(logger_is_healthy(),
              "Logger reported internal corruption after multithreaded use.");
}
```