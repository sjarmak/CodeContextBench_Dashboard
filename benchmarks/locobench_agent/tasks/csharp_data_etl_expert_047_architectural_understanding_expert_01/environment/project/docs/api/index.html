```html
<!DOCTYPE html>
<html lang="en">

<!--
  =============================================================================
  PaletteStream-ETL-Canvas ‚Äì API Reference Index
  -----------------------------------------------------------------------------
  This documentation page is generated as part of the automated build-pipeline
  (see build.cake + DocFx task).  It is self-contained so that it can be hosted
  on any static-site provider (GitHub-Pages, Azure Static Web Apps, Netlify, ‚Ä¶)
  without additional server-side dependencies.
  -----------------------------------------------------------------------------
  ¬© 2024 PaletteStream.  All rights reserved.
  =============================================================================
-->

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- SEO & Social -->
    <title>PaletteStream ETL Canvas ‚Äì API Docs</title>
    <meta name="description"
        content="Comprehensive API documentation for PaletteStream's ETL Canvas.  Explore classes, interfaces, and extension methods that power real-time data artistry." />
    <meta name="keywords"
        content="ETL, Data Engineering, C#, .NET, Pipeline Pattern, Data Lake, Stream Processing, Documentation" />
    <meta name="author" content="PaletteStream Engineering" />

    <!-- favicons -->
    <link rel="icon" type="image/svg+xml" href="/assets/img/favicon.svg" />

    <!-- Styles -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css"
        integrity="sha512-V2qQbnoyq6v7HNUm1pMr6y6xrWmEgpCSDruL8iiJz6Xttsz2ZTpEggT9I8Yd2uVtO7syP+KNZCv+/HWi+2c4Og=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        :root {
            color-scheme: dark light;
        }

        body {
            font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #dcdcdc;
        }

        header {
            background: linear-gradient(135deg, #5603ad 0%, #2f0f5d 100%);
            padding: 2.5rem 1rem;
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 2.5rem;
            color: #fff;
        }

        header p {
            color: #e0e0e0;
        }

        #searchBox {
            margin: 2rem auto;
            max-width: 680px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #searchBox input {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            border: none;
            font-size: 1rem;
            outline: none;
        }

        main {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
        }

        section {
            margin-bottom: 4rem;
        }

        h2 {
            border-bottom: 3px solid #5603ad;
            padding-bottom: 0.35rem;
        }

        /* Simple table styling for endpoint lists */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th,
        td {
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: #1f1f1f;
            color: #bbb;
        }

        tr:nth-child(even) {
            background-color: #181818;
        }

        @media (max-width: 800px) {
            table,
            thead,
            tbody,
            th,
            td,
            tr {
                display: block;
            }

            th {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }

            tr {
                margin: 0 0 1.5rem 0;
            }

            td {
                border: none;
                position: relative;
                padding-left: 50%;
                font-size: 0.95rem;
            }

            td::before {
                position: absolute;
                top: 0;
                left: 0;
                width: 45%;
                padding-right: 0.75rem;
                white-space: nowrap;
                font-weight: bold;
                color: #999;
            }

            td:nth-of-type(1)::before {
                content: "Method";
            }

            td:nth-of-type(2)::before {
                content: "Endpoint";
            }

            td:nth-of-type(3)::before {
                content: "Summary";
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>PaletteStream ETL Canvas</h1>
        <p>API Reference &amp; Developer Guides</p>
        <div id="searchBox">
            <input id="searchInput" type="search" placeholder="üîç Search classes, methods, endpoints‚Ä¶"
                aria-label="Search documentation" />
        </div>
    </header>

    <main>
        <!-- Overview ----------------------------------------------------------------------------->
        <section id="overview">
            <h2>üöÄ Overview</h2>
            <p>
                PaletteStream's ETL Canvas re-imagines data pipelines as an artistic process.  The public API surface is
                broken down into three major domains:
            </p>
            <ol>
                <li><strong>Canvas.Core</strong> ‚Äì foundation types (PipelineBuilder, TransformerBase).</li>
                <li><strong>Canvas.Runtime</strong> ‚Äì runtime hosts, job schedulers, and streaming engines.</li>
                <li><strong>Canvas.Visualization</strong> ‚Äì real-time dashboards and analytics widgets.</li>
            </ol>
            <p>
                All packages target <code>net8.0</code> and follow Semantic Versioning.  Assemblies are <em>nullable-enabled</em>, tested
                with <em>xUnit</em>, and shipped under the MIT license.
            </p>
        </section>

        <!-- Quick-Start -------------------------------------------------------------------------->
        <section id="quickStart">
            <h2>‚ö° Quick Start</h2>
            <pre><code class="language-csharp">
// Import top-level namespaces
using PaletteStream.ETL.Canvas.Core;
using PaletteStream.ETL.Canvas.Runtime;
using PaletteStream.ETL.Canvas.Transformers;
using PaletteStream.ETL.Canvas.Strategies;
using PaletteStream.ETL.Canvas.Diagnostics;

// 1) Build the pipeline ---------------------------------------------------
var pipeline = PipelineBuilder
    .Create()
    .AddSource(new KafkaSource("topic.raw.orders"))
    .AddTransformer(new AnonymizeTransformer(PersonallyIdentifiableInformation.Email))
    .AddTransformer(new AggregateTransformer(groupBy: "Country", sumColumn: "Subtotal"))
    .AddSink(new DataLakeSink(StorageTier.Curated))
    .Build();

// 2) Register observers (monitoring / alerting) ---------------------------
var slackObserver = new SlackObserver("<WebhookURL>");
pipeline.Subscribe(slackObserver);

// 3) Execute in streaming or batch mode -----------------------------------
await using var runtime = new StreamPipelineHost(pipeline, cancellationToken: cts.Token);

await runtime.StartAsync();

// Tip: Use hangfire to automatically pause the pipeline nightly for reprocessing:
RecurringJob.AddOrUpdate(
    "pipeline-replay",
    () => runtime.ReplayAsync(DateTime.UtcNow.AddDays(-1), DateTime.UtcNow),
    Cron.Nightly,
    queue: "maintenance");

// ---------------------------------------------------------------------------------
// Need more fine-grained control?  Explore Canvas.Runtime APIs below.
// ---------------------------------------------------------------------------------
            </code></pre>
        </section>

        <!-- Endpoint Summary ---------------------------------------------------------------------->
        <section id="endpointSummary">
            <h2>üóíÔ∏è REST Endpoint Summary</h2>
            <table aria-describedby="List of REST endpoints">
                <thead>
                    <tr>
                        <th scope="col">Method</th>
                        <th scope="col">Endpoint</th>
                        <th scope="col">Summary</th>
                    </tr>
                </thead>
                <tbody id="endpointTable">
                    <!-- Content is injected via JS for dynamic search filtering -->
                </tbody>
            </table>
        </section>

        <!-- Deep Dive: TransformerBase ----------------------------------------------------------->
        <section id="transformerBase">
            <h2>üîç Deep Dive ‚Äì TransformerBase&lt;TInput,TOutput&gt;</h2>
            <p>
                All custom transformers inherit from <code>TransformerBase</code>.  The abstract class coercively enforces
                <em>idempotency</em> and <em>determinism</em> by exposing a single
                <code>TransformAsync</code> method that must be override-implemented:
            </p>
            <pre><code class="language-csharp">
public abstract class TransformerBase&lt;TInput, TOutput&gt; : IObserver&lt;PipelineEvent&gt;
{
    protected readonly ILogger _logger;

    protected TransformerBase(ILogger logger)
        => _logger = logger ?? throw new ArgumentNullException(nameof(logger));

    /// &lt;summary&gt;
    /// Perform an asynchronous and deterministic transformation.
    /// &lt;/summary&gt;
    public abstract Task&lt;IEnumerable&lt;TOutput&gt;&gt; TransformAsync(
        IEnumerable&lt;TInput&gt; batch,
        CancellationToken cancellationToken = default);

    #region Observer Pattern Support
    public virtual void OnNext(PipelineEvent value)
        =&gt; _logger.LogDebug("Event: {EventType}", value.EventType);

    public virtual void OnError(Exception error)
        =&gt; _logger.LogCritical(error, "Unhandled exception in transformer");

    public virtual void OnCompleted()
        =&gt; _logger.LogInformation("Pipeline completed");
    #endregion
}
            </code></pre>
            <p>
                By adhering to the observer pattern, any transformer can seamlessly publish metrics and diagnostics
                through the same channel used by runtime hosts and monitoring widgets.
            </p>
        </section>

        <!-- Error Handling & Recovery ------------------------------------------------------------>
        <section id="errorRecovery">
            <h2>ü©π Error Handling & Recovery</h2>
            <p>
                PaletteStream implements a <strong>compensation-first</strong> strategy.  When a pipeline fails, the
                runtime engine queries the <code>DeadLetterRepository</code> and attempts to compensate using the
                <code>ICompensatingAction</code> handlers registered for that pipeline stage.
            </p>
            <pre><code class="language-csharp">
public sealed class OrderCompensatingAction : ICompensatingAction
{
    private readonly IOrdersRepository _repository;
    private readonly ILogger _logger;

    public OrderCompensatingAction(IOrdersRepository repository, ILogger<OrderCompensatingAction> logger)
    {
        _repository = repository;
        _logger = logger;
    }

    public async Task ExecuteAsync(DeadLetterMessage message, CancellationToken ct)
    {
        var orderId = Guid.Parse(message.Metadata["OrderId"]);

        _logger.LogWarning("[Compensation] Soft-deleting order {OrderId}", orderId);

        var order = await _repository.GetAsync(orderId, ct);
        if (order is null)
        {
            _logger.LogError("Could not locate order {OrderId}", orderId);
            return;
        }

        order.Status = OrderStatus.Deleted;
        await _repository.UpdateAsync(order, ct);
    }
}
            </code></pre>
            <p>
                For mission-critical pipelines, compensating actions can be chained, rolled back, or escalated to
                human-in-the-loop workflows through the web studio‚Äôs ‚ÄúUndo Brushstroke‚Äù panel.
            </p>
        </section>

        <!-- Contribution Guide ------------------------------------------------------------------->
        <section id="contribGuide">
            <h2>ü§ù Contributing</h2>
            <p>
                PaletteStream thrives on community contributions!  To submit a PR, ensure you:
            </p>
            <ul>
                <li>Run <code>dotnet format</code> (code-style gate).</li>
                <li>Provide xUnit tests with at least 95% line-coverage for new features.</li>
                <li>Update XML docs &amp; run <code>.\build.ps1 --target=Docs</code>.</li>
            </ul>
            <p>
                See <a href="https://github.com/PaletteStream/etl-canvas/blob/main/CONTRIBUTING.md">CONTRIBUTING.md</a>
                for full details.
            </p>
        </section>
    </main>

    <footer style="text-align:center; padding:2rem 1rem; color:#777;">
        ¬© 2024 PaletteStream ‚Äì Version <span id="versionSpan">loading‚Ä¶</span>
        ¬∑ <a href="https://github.com/PaletteStream/etl-canvas" style="color:#777;">GitHub</a>
        ¬∑ <a href="#top" style="color:#777;">Back to top</a>
    </footer>

    <!-- Scripts ------------------------------------------------------------------------------- -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"
        integrity="sha512-ifnmyhM4yDIX9nYEKngh2IjAwIdGhPFdtgZblXrHV/CPiRIOm1w+SXYwyoyRRf5yFeVzH8P1l7kLjfcAEWdTog=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        // Activate syntax highlighting (C#, JSON, Bash, etc.)
        hljs.highlightAll();

        // ---------------------------------------------------------------------
        // Dynamic search & endpoint filtering
        // ---------------------------------------------------------------------
        const endpoints = [
            { method: "GET", endpoint: "/api/v1/pipelines", summary: "List all pipelines" },
            { method: "POST", endpoint: "/api/v1/pipelines", summary: "Create new pipeline" },
            { method: "GET", endpoint: "/api/v1/pipelines/{id}", summary: "Get pipeline details" },
            { method: "PATCH", endpoint: "/api/v1/pipelines/{id}", summary: "Update pipeline" },
            { method: "DELETE", endpoint: "/api/v1/pipelines/{id}", summary: "Delete pipeline" },
            { method: "POST", endpoint: "/api/v1/pipelines/{id}/start", summary: "Start pipeline execution" },
            { method: "POST", endpoint: "/api/v1/pipelines/{id}/stop", summary: "Stop pipeline execution" },
            { method: "GET", endpoint: "/api/v1/metrics", summary: "Retrieve real-time metrics" },
            { method: "POST", endpoint: "/api/v1/compensate", summary: "Trigger compensating transaction" }
        ];

        const endpointTable = document.getElementById('endpointTable');
        const searchInput = document.getElementById('searchInput');

        // Initial render
        const renderTable = (rows) => {
            endpointTable.innerHTML = rows.map(row => `
                <tr>
                    <td><strong>${row.method}</strong></td>
                    <td><code>${row.endpoint}</code></td>
                    <td>${row.summary}</td>
                </tr>`).join('');
        };
        renderTable(endpoints);

        // Live-filter
        searchInput.addEventListener('input', (e) => {
            const value = (e.target.value || '').toLowerCase();
            const filtered = endpoints.filter(ep =>
                ep.method.toLowerCase().includes(value) ||
                ep.endpoint.toLowerCase().includes(value) ||
                ep.summary.toLowerCase().includes(value)
            );
            renderTable(filtered);
        });

        // Inject version (from build-time placeholder)
        document.getElementById('versionSpan').innerText = "{{ VERSION }}";
    </script>
</body>

</html>
```