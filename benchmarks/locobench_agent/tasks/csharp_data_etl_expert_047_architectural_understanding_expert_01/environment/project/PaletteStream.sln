```csharp
// File: tests/PaletteStream.DataEtl.Tests/PipelineDirectorTests.cs
//
// This test-suite exercises critical behaviour of the ETL “Palette” pipeline.
// Although the real production classes live in the Data-ETL project, a set of
// minimal, *compile-time* test doubles are declared here (internal to the test
// assembly) so the suite remains self-contained and functional regardless of
// CI discovery order.  When the tests run against the actual implementation
// these doubles are ignored thanks to assembly-level aliasing (see csproj).

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using Xunit;

namespace PaletteStream.DataEtl.Tests
{
    #region —— Contracts duplicated from production for compile-time safety ——

    /// <summary>
    /// Immutable pigment that flows through the pipeline.
    /// In production this is backed by an Apache Arrow record batch / DataFrame.
    /// </summary>
    public sealed record PigmentFrame(Guid Id, IReadOnlyDictionary<string, object?> Columns);

    public interface IPipelineStage
    {
        string Name { get; }

        /// <summary>
        /// Asynchronously transforms <paramref name="input"/> into a new frame.
        /// </summary>
        Task<PigmentFrame> ExecuteAsync(PigmentFrame input, CancellationToken ct = default);
    }

    public interface IEventBus
    {
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct = default);
    }

    public interface IErrorRecoveryService
    {
        Task CompensateAsync(PigmentFrame failedFrame, Exception ex, CancellationToken ct = default);
    }

    #endregion

    #region —— Minimal pipeline director used as SUT in tests ——

    internal sealed class PipelineDirector
    {
        private readonly IReadOnlyList<IPipelineStage> _stages;
        private readonly IEventBus _eventBus;
        private readonly IErrorRecoveryService _recoveryService;
        private readonly ILogger<PipelineDirector> _logger;

        public PipelineDirector(
            IEnumerable<IPipelineStage> stages,
            IEventBus eventBus,
            IErrorRecoveryService recoveryService,
            ILogger<PipelineDirector> logger)
        {
            _stages = stages.ToList().AsReadOnly();
            _eventBus = eventBus;
            _recoveryService = recoveryService;
            _logger = logger;
        }

        /// <summary>
        /// Executes the pipeline sequentially; every stage receives the output
        /// from the previous one.  Observer pattern: each stage completion is
        /// broadcast through <see cref="_eventBus"/>.
        /// </summary>
        public async Task<PigmentFrame> ExecuteAsync(
            PigmentFrame initialFrame,
            CancellationToken ct = default)
        {
            PigmentFrame current = initialFrame;

            foreach (var stage in _stages)
            {
                ct.ThrowIfCancellationRequested();

                try
                {
                    _logger.LogInformation("Starting stage {Stage}", stage.Name);
                    current = await stage.ExecuteAsync(current, ct).ConfigureAwait(false);

                    await _eventBus.PublishAsync(
                        new StageCompleted(current.Id, stage.Name, DateTimeOffset.UtcNow),
                        ct).ConfigureAwait(false);

                    _logger.LogInformation(
                        "Stage {Stage} completed for Frame {FrameId}", stage.Name, current.Id);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Stage {Stage} failed. Triggering compensation.", stage.Name);
                    await _recoveryService.CompensateAsync(current, ex, ct).ConfigureAwait(false);
                    throw; // ensure upstream caller is aware
                }
            }

            return current;
        }
    }

    public sealed record StageCompleted(Guid FrameId, string StageName, DateTimeOffset OccurredOn);

    #endregion

    #region —— Test fixtures ——

    public class PipelineDirectorFixture : IAsyncLifetime
    {
        public PigmentFrame SeedFrame { get; private set; } = default!;

        public Task InitializeAsync()
        {
            // generate deterministic sample frame
            SeedFrame = new PigmentFrame(
                Guid.NewGuid(),
                new Dictionary<string, object?>
                {
                    ["artist"]     = "Ada Lovelace",
                    ["temperature"] = 42,
                    ["timestamp"]  = DateTimeOffset.UtcNow
                });

            return Task.CompletedTask;
        }

        public Task DisposeAsync() => Task.CompletedTask;
    }

    #endregion

    #region —— Tests ——

    [CollectionDefinition(nameof(PipelineDirectorCollection))]
    public sealed class PipelineDirectorCollection : ICollectionFixture<PipelineDirectorFixture> { }

    [Collection(nameof(PipelineDirectorCollection))]
    public class PipelineDirectorTests
    {
        private readonly PipelineDirectorFixture _fixture;

        public PipelineDirectorTests(PipelineDirectorFixture fixture)
        {
            _fixture = fixture;
        }

        [Fact(DisplayName = "Pipeline executes all stages in sequence and emits StageCompleted events.")]
        public async Task ExecuteAsync_Should_RunStagesAndEmitEvents()
        {
            // Arrange
            var stageOrder = new ConcurrentQueue<string>();

            var stage1 = MakeMockStage("Cleanse", frame =>
            {
                var cleansed = frame with
                {
                    Columns = frame.Columns.ToDictionary(kv => kv.Key, kv => kv.Value)
                };
                cleansed.Columns["cleansed"] = true;
                return cleansed;
            }, stageOrder);

            var stage2 = MakeMockStage("Enrich", frame =>
            {
                var enriched = frame with
                {
                    Columns = frame.Columns.ToDictionary(kv => kv.Key, kv => kv.Value)
                };
                enriched.Columns["enriched"] = true;
                return enriched;
            }, stageOrder);

            var eventBusMock = new Mock<IEventBus>();
            var publishedEvents = new List<StageCompleted>();

            eventBusMock
                .Setup(b => b.PublishAsync(It.IsAny<StageCompleted>(), It.IsAny<CancellationToken>()))
                .Callback<object, CancellationToken>((e, _) => publishedEvents.Add((StageCompleted)e))
                .Returns(Task.CompletedTask);

            var recoveryMock = new Mock<IErrorRecoveryService>();

            var loggerMock = new Mock<ILogger<PipelineDirector>>();

            var director = new PipelineDirector(
                new[] { stage1.Object, stage2.Object },
                eventBusMock.Object,
                recoveryMock.Object,
                loggerMock.Object);

            // Act
            var result = await director.ExecuteAsync(_fixture.SeedFrame);

            // Assert
            stageOrder.Should().ContainInOrder("Cleanse", "Enrich");
            publishedEvents.Should().HaveCount(2);

            publishedEvents
                .Select(pe => pe.StageName)
                .Should()
                .ContainInOrder("Cleanse", "Enrich");

            result.Columns.Should().ContainKey("cleansed").And.ContainKey("enriched");
            recoveryMock.Verify(r => r.CompensateAsync(It.IsAny<PigmentFrame>(), It.IsAny<Exception>(),
                It.IsAny<CancellationToken>()), Times.Never);
        }

        [Fact(DisplayName = "Failed stage triggers compensation and propagates exception.")]
        public async Task ExecuteAsync_WhenStageFails_Should_CompensateAndThrow()
        {
            // Arrange
            var failingStage = new Mock<IPipelineStage>();
            failingStage.SetupGet(s => s.Name).Returns("Failing-Stage");
            failingStage
                .Setup(s => s.ExecuteAsync(It.IsAny<PigmentFrame>(), It.IsAny<CancellationToken>()))
                .ThrowsAsync(new InvalidOperationException("Invalid pigment"));

            var recoveryMock = new Mock<IErrorRecoveryService>();
            var loggerMock   = new Mock<ILogger<PipelineDirector>>();
            var eventBusMock = new Mock<IEventBus>();

            var director = new PipelineDirector(
                new[] { failingStage.Object },
                eventBusMock.Object,
                recoveryMock.Object,
                loggerMock.Object);

            // Act
            Func<Task> act = async () => await director.ExecuteAsync(_fixture.SeedFrame);

            // Assert
            var ex = await Assert.ThrowsAsync<InvalidOperationException>(act);
            ex.Message.Should().Be("Invalid pigment");

            recoveryMock.Verify(r =>
                    r.CompensateAsync(It.Is<PigmentFrame>(f => f.Id == _fixture.SeedFrame.Id),
                                      It.IsAny<InvalidOperationException>(),
                                      It.IsAny<CancellationToken>()),
                Times.Once);

            eventBusMock.Verify(b =>
                    b.PublishAsync(It.IsAny<StageCompleted>(), It.IsAny<CancellationToken>()),
                Times.Never);
        }

        [Theory(DisplayName = "ColorBlendingStrategy blends pigments as expected")]
        [InlineData(0.2f, 0.8f, 0.8f)]
        [InlineData(0.5f, 0.5f, 0.5f)]
        [InlineData(1.0f, 0.0f, 1.0f)]
        public void ColorBlendingStrategy_Should_BlendChannelsCorrectly(
            float red, float blue, float expectedPurple)
        {
            // Arrange
            var blender = new ColorBlendingStrategy();

            // Act
            var purple = blender.Blend(red, blue);

            // Assert
            purple.Should().BeApproximately(expectedPurple, precision: 3);
        }

        #region —— Helpers ——

        private static Mock<IPipelineStage> MakeMockStage(
            string name,
            Func<PigmentFrame, PigmentFrame> transform,
            ConcurrentQueue<string> orderRecorder)
        {
            var mock = new Mock<IPipelineStage>();
            mock.SetupGet(s => s.Name).Returns(name);
            mock.Setup(s => s.ExecuteAsync(It.IsAny<PigmentFrame>(), It.IsAny<CancellationToken>()))
                .ReturnsAsync((PigmentFrame input, CancellationToken _) =>
                {
                    orderRecorder.Enqueue(name);
                    return transform(input);
                });

            return mock;
        }

        #endregion
    }

    #endregion

    #region —— Strategy sample implementation ——

    /// <summary>
    /// Very small sample "strategy" so the <see cref="ColorBlendingStrategy_Should_BlendChannelsCorrectly"/>
    /// theory has concrete code to exercise. Production code performs GPU-accelerated
    /// matrix math; our version is intentionally lightweight.
    /// </summary>
    internal sealed class ColorBlendingStrategy
    {
        /// <summary>
        /// Blends red + blue channels to produce a purple intensity.
        /// </summary>
        /// <remarks>
        /// red and blue are expected to be in range [0, 1].
        /// A naïve algorithm is used here for demo purposes.
        /// </remarks>
        public float Blend(float redIntensity, float blueIntensity)
        {
            redIntensity = Clamp01(redIntensity);
            blueIntensity = Clamp01(blueIntensity);

            // Purple intensity is simply the greater of the two—
            // think “screen” blend mode in Photoshop.
            var purple = MathF.Max(redIntensity, blueIntensity);

            return purple;
        }

        private static float Clamp01(float v) => v switch
        {
            < 0f => 0f,
            > 1f => 1f,
            _    => v
        };
    }

    #endregion
}
```