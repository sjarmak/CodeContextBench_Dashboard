@using System
@using System.Threading.Tasks
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.Extensions.Logging
@using CanvasCraft.WebApp.Services.ExperimentTracking
@using CanvasCraft.WebApp.Services.FeatureStore
@using CanvasCraft.WebApp.Services.ModelRegistry

<button class="btn btn-link d-md-none sidebar-toggle" @onclick="ToggleCollapse">
    <span class="oi oi-menu"></span>
</button>

<nav class="sidebar @( _collapsed ? "collapsed" : string.Empty )">
    <div class="sidebar-header">
        <a href="" class="brand">CanvasCraft ML Studio</a>
    </div>

    <ul class="nav flex-column">
        <li class="nav-item">
            <NavLink href="/" Match="NavLinkMatch.All" class="nav-link">
                <span class="oi oi-dashboard" aria-hidden="true"></span> Dashboard
            </NavLink>
        </li>

        <li class="nav-item">
            <NavLink href="datasets" class="nav-link">
                <span class="oi oi-folder" aria-hidden="true"></span> Datasets
            </NavLink>
        </li>

        <li class="nav-item">
            <NavLink href="experiments" class="nav-link">
                <span class="oi oi-flask" aria-hidden="true"></span> Experiments
                @if (_experimentBadgeCount > 0)
                {
                    <span class="badge badge-pill badge-info ml-auto">@_experimentBadgeCount</span>
                }
            </NavLink>
        </li>

        <li class="nav-item">
            <NavLink href="feature-store" class="nav-link">
                <span class="oi oi-database" aria-hidden="true"></span> Feature Store
                @if (_featureStoreUpdates > 0)
                {
                    <span class="badge badge-pill badge-warning ml-auto">@_featureStoreUpdates</span>
                }
            </NavLink>
        </li>

        <li class="nav-item">
            <NavLink href="model-registry" class="nav-link">
                <span class="oi oi-box" aria-hidden="true"></span> Model Registry
                @if (_modelRegistryAlerts > 0)
                {
                    <span class="badge badge-pill badge-danger ml-auto">@_modelRegistryAlerts</span>
                }
            </NavLink>
        </li>

        <li class="nav-item">
            <NavLink href="hyperparameter-tuning" class="nav-link">
                <span class="oi oi-aperture" aria-hidden="true"></span> Hyperparameter Tuning
            </NavLink>
        </li>

        <li class="nav-item">
            <NavLink href="monitoring" class="nav-link">
                <span class="oi oi-pulse" aria-hidden="true"></span> Monitoring
            </NavLink>
        </li>

        <li class="nav-item">
            <NavLink href="serving-gallery" class="nav-link">
                <span class="oi oi-image" aria-hidden="true"></span> Serving Gallery
            </NavLink>
        </li>
    </ul>
</nav>

@code
{
    #region Injected Services

    [Inject] private NavigationManager NavigationManager { get; set; } = default!;
    [Inject] private AuthenticationStateProvider AuthStateProvider { get; set; } = default!;
    [Inject] private ExperimentTrackingService ExperimentTrackingService { get; set; } = default!;
    [Inject] private FeatureStoreService FeatureStoreService { get; set; } = default!;
    [Inject] private ModelRegistryService ModelRegistryService { get; set; } = default!;
    [Inject] private ILogger<NavMenu> Logger { get; set; } = default!;

    #endregion

    private bool _collapsed = false;

    private int _experimentBadgeCount;
    private int _featureStoreUpdates;
    private int _modelRegistryAlerts;

    private readonly object _syncRoot = new();

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Pre-populate counts.
            await RefreshBadgesAsync();

            // Subscribe to service events so the UI updates reactively.
            ExperimentTrackingService.PendingRunsChanged += HandleExperimentChanged;
            FeatureStoreService.FeatureGroupsChanged += HandleFeatureStoreChanged;
            ModelRegistryService.ModelAlertsChanged += HandleModelRegistryChanged;

            // Ensure authentication state is tracked (e.g., role-based nav filtering).
            AuthStateProvider.AuthenticationStateChanged += HandleAuthStateChanged;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing navigation menu.");
        }
    }

    private void ToggleCollapse()
    {
        _collapsed = !_collapsed;
    }

    private async Task RefreshBadgesAsync()
    {
        try
        {
            _experimentBadgeCount   = await ExperimentTrackingService.GetPendingRunsAsync();
            _featureStoreUpdates    = await FeatureStoreService.GetPendingFeatureGroupUpdatesAsync();
            _modelRegistryAlerts    = await ModelRegistryService.GetActiveAlertsAsync();

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to refresh navigation badges.");
        }
    }

    #region Event Handlers

    private void HandleExperimentChanged(object? sender, int pendingRuns)
    {
        lock (_syncRoot)
        {
            _experimentBadgeCount = pendingRuns;
        }

        InvokeAsync(StateHasChanged);
    }

    private void HandleFeatureStoreChanged(object? sender, int pendingUpdates)
    {
        lock (_syncRoot)
        {
            _featureStoreUpdates = pendingUpdates;
        }

        InvokeAsync(StateHasChanged);
    }

    private void HandleModelRegistryChanged(object? sender, int activeAlerts)
    {
        lock (_syncRoot)
        {
            _modelRegistryAlerts = activeAlerts;
        }

        InvokeAsync(StateHasChanged);
    }

    private void HandleAuthStateChanged(Task<AuthenticationState> task)
    {
        // In this example we always show the same nav items, but this hook enables
        // role-based UI logic should it be required in the future.
        InvokeAsync(StateHasChanged);
    }

    #endregion

    #region IDisposable

    public void Dispose()
    {
        // Clean up event subscriptions to avoid memory leaks.
        ExperimentTrackingService.PendingRunsChanged -= HandleExperimentChanged;
        FeatureStoreService.FeatureGroupsChanged     -= HandleFeatureStoreChanged;
        ModelRegistryService.ModelAlertsChanged      -= HandleModelRegistryChanged;
        AuthStateProvider.AuthenticationStateChanged -= HandleAuthStateChanged;
    }

    #endregion
}