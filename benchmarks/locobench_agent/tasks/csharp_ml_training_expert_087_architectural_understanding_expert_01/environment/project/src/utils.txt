using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;

namespace CanvasCraft.MLStudio.Utils
{
    /// <summary>
    ///     Central utility hub for CanvasCraft ML Studio.
    ///     Houses helper classes that are reused throughout the project
    ///     (hashing, JSON serialization, retry policies, temp workspace management, etc.).
    /// </summary>
    public static class StudioUtils
    {
        #region Hashing

        /// <summary>
        ///     Computes deterministic SHA-256 hashes for files or entire folder trees. Used by
        ///     Experiment Tracking, Feature Store, and Model Registry to verify the integrity of
        ///     data artifacts and model checkpoints.
        /// </summary>
        public static class DataArtifactHasher
        {
            /// <summary>
            ///     Calculates a SHA-256 hash for a single file.
            /// </summary>
            /// <param name="filePath">Absolute or relative path to the file.</param>
            /// <returns>Hex-encoded SHA-256 hash string.</returns>
            public static string HashFile(string filePath)
            {
                if (string.IsNullOrWhiteSpace(filePath))
                    throw new ArgumentException("File path must not be null or empty.", nameof(filePath));

                if (!File.Exists(filePath))
                    throw new FileNotFoundException("File does not exist.", filePath);

                using var sha = SHA256.Create();
                using var stream = File.OpenRead(filePath);
                var hashBytes = sha.ComputeHash(stream);
                return BitConverter.ToString(hashBytes).Replace("-", string.Empty).ToLowerInvariant();
            }

            /// <summary>
            ///     Calculates a deterministic SHA-256 hash for a directory tree. The hash is stable
            ///     across machines and OSes as long as file contents and relative paths remain
            ///     identical. Hidden/system files are ignored by default.
            /// </summary>
            /// <param name="directoryPath">Root directory.</param>
            /// <param name="includeHidden">
            ///     Whether to include hidden or system files (defaults to false).
            /// </param>
            /// <param name="cancellationToken">Optional cancellation token.</param>
            /// <exception cref="DirectoryNotFoundException"></exception>
            public static async Task<string> HashDirectoryAsync(
                string directoryPath,
                bool includeHidden = false,
                CancellationToken cancellationToken = default)
            {
                if (string.IsNullOrWhiteSpace(directoryPath))
                    throw new ArgumentException("Directory path must not be null or empty.", nameof(directoryPath));

                if (!Directory.Exists(directoryPath))
                    throw new DirectoryNotFoundException($"Directory '{directoryPath}' was not found.");

                // Collect all file paths in a deterministic order (sorted)
                var filePaths = Directory
                    .EnumerateFiles(directoryPath, "*", SearchOption.AllDirectories)
                    .Where(p => includeHidden || !IsHidden(p))
                    .OrderBy(p => p, StringComparer.OrdinalIgnoreCase)
                    .ToList();

                using var sha = SHA256.Create();

                foreach (var path in filePaths)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    // Add relative path bytes to the hash to account for structure
                    var relativePath = Path.GetRelativePath(directoryPath, path)
                        .Replace(Path.DirectorySeparatorChar, '/'); // path normalization

                    var pathBytes = Encoding.UTF8.GetBytes(relativePath);
                    sha.TransformBlock(pathBytes, 0, pathBytes.Length, null, 0);

                    // Hash file content
                    await using var stream = File.OpenRead(path);
                    var buffer = new byte[8192];
                    int bytesRead;

                    while ((bytesRead = await stream.ReadAsync(buffer.AsMemory(0, buffer.Length), cancellationToken)) > 0)
                    {
                        sha.TransformBlock(buffer, 0, bytesRead, null, 0);
                    }
                }

                // Finalize incremental hash
                sha.TransformFinalBlock(Array.Empty<byte>(), 0, 0);
                return BitConverter.ToString(sha.Hash!).Replace("-", string.Empty).ToLowerInvariant();
            }

            private static bool IsHidden(string path)
            {
                var attr = File.GetAttributes(path);
                return attr.HasFlag(FileAttributes.Hidden) || attr.HasFlag(FileAttributes.System);
            }
        }

        #endregion

        #region Serialization

        /// <summary>
        ///     Lightweight JSON helper built around System.Text.Json with
        ///     preconfigured options suitable for human-readable logs and long-term storage.
        /// </summary>
        public static class JsonSerializerHelper
        {
            private static readonly JsonSerializerOptions DefaultOptions = new()
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = true,
                IgnoreNullValues = true,
                Converters =
                {
                    new JsonStringEnumConverter(JsonNamingPolicy.CamelCase)
                }
            };

            /// <summary>
            ///     Serializes an object to JSON using default CanvasCraft options.
            /// </summary>
            public static string Serialize(object @object, JsonSerializerOptions? options = null)
            {
                if (@object is null) throw new ArgumentNullException(nameof(@object));
                return JsonSerializer.Serialize(@object, options ?? DefaultOptions);
            }

            /// <summary>
            ///     Deserializes a JSON string into the supplied type.
            /// </summary>
            /// <typeparam name="T">Target POCO type.</typeparam>
            /// <param name="json">JSON payload.</param>
            /// <exception cref="JsonException">Thrown when input cannot be parsed.</exception>
            public static T Deserialize<T>(string json, JsonSerializerOptions? options = null)
            {
                if (string.IsNullOrWhiteSpace(json))
                    throw new ArgumentException("JSON must not be null or empty.", nameof(json));

                return JsonSerializer.Deserialize<T>(json, options ?? DefaultOptions)
                       ?? throw new JsonException($"Failed to deserialize JSON into {typeof(T).Name}.");
            }
        }

        #endregion

        #region Retry

        /// <summary>
        ///     Simple, dependency-free retry helper for handling transient failures
        ///     (network hiccups, I/O contention, etc.). Backoff strategy is
        ///     exponential with jitter.
        /// </summary>
        public static class RetryHelper
        {
            /// <summary>
            ///     Executes an asynchronous operation with a customizable retry policy.
            /// </summary>
            /// <typeparam name="T">Result type.</typeparam>
            /// <param name="operation">The operation to invoke.</param>
            /// <param name="maxAttempts">Number of tries before re-throwing.</param>
            /// <param name="baseDelay">Initial back-off delay.</param>
            /// <param name="shouldRetry">Optional predicate to decide retry by exception.</param>
            public static async Task<T> ExecuteWithRetryAsync<T>(
                Func<int, Task<T>> operation,
                int maxAttempts = 3,
                TimeSpan? baseDelay = null,
                Func<Exception, bool>? shouldRetry = null)
            {
                if (operation == null) throw new ArgumentNullException(nameof(operation));
                if (maxAttempts < 1) throw new ArgumentOutOfRangeException(nameof(maxAttempts));

                baseDelay ??= TimeSpan.FromMilliseconds(200);
                shouldRetry ??= _ => true;

                var attempt = 0;

                while (true)
                {
                    try
                    {
                        attempt++;
                        return await operation(attempt).ConfigureAwait(false);
                    }
                    catch (Exception ex) when (attempt < maxAttempts && shouldRetry(ex))
                    {
                        var delay = TimeSpan.FromMilliseconds(
                            (baseDelay.Value.TotalMilliseconds * Math.Pow(2, attempt - 1))  // exponential
                            * (0.8 + Random.Shared.NextDouble() * 0.4));                   // jitter 80-120%

                        await Task.Delay(delay);
                    }
                }
            }
        }

        #endregion

        #region DisposableDirectory

        /// <summary>
        ///     Represents an isolated temporary workspace folder that cleans itself up.
        ///     Crucial for sandboxed model training runs on shared build agents.
        /// </summary>
        public sealed class DisposableDirectory : IDisposable
        {
            /// <summary>
            ///     Full path to the temporary directory.
            /// </summary>
            public string Path { get; }

            private bool _disposed;

            /// <summary>
            ///     Creates a new unique temp directory inside the system temp path, or under
            ///     a custom root if provided.
            /// </summary>
            public DisposableDirectory(string? root = null)
            {
                root ??= System.IO.Path.GetTempPath();
                var dirName = $"ccraft_{DateTime.UtcNow:yyyyMMdd_HHmmss}_{Guid.NewGuid():N}";
                Path = System.IO.Path.Combine(root, dirName);
                Directory.CreateDirectory(Path);
            }

            /// <summary>
            ///     Creates a sub-directory in the temp workspace and returns its full path.
            /// </summary>
            public string CreateSubDirectory(string relativeName)
            {
                if (string.IsNullOrWhiteSpace(relativeName))
                    throw new ArgumentException("Subdirectory name must not be null or empty.", nameof(relativeName));

                var sanitized = SanitizeFileName(relativeName);
                var subDir = System.IO.Path.Combine(Path, sanitized);
                Directory.CreateDirectory(subDir);
                return subDir;
            }

            public void Dispose()
            {
                if (_disposed) return;
                try
                {
                    Directory.Delete(Path, recursive: true);
                }
                catch (IOException)
                {
                    // Best-effort: mark for deletion on reboot
                    _ = Win32Native.MarkDirectoryForDeleteOnReboot(Path);
                }
                catch (UnauthorizedAccessException)
                {
                    // Same fallback
                    _ = Win32Native.MarkDirectoryForDeleteOnReboot(Path);
                }
                finally
                {
                    _disposed = true;
                    GC.SuppressFinalize(this);
                }
            }

            ~DisposableDirectory()
            {
                Dispose();
            }

            private static string SanitizeFileName(string name)
            {
                var invalidChars = System.IO.Path.GetInvalidFileNameChars();
                var sanitized = new string(name.Select(ch => invalidChars.Contains(ch) ? '_' : ch).ToArray());
                return sanitized.Trim();
            }

            /// <summary>
            ///     Minimal P/Invoke helper for MoveFileEx to mark resources
            ///     for deletion on the next reboot (Windows-only).
            ///     If compiled on non-Windows OS, the call is ignored.
            /// </summary>
            private static class Win32Native
            {
                private const int MOVEFILE_DELAY_UNTIL_REBOOT = 0x4;

                [System.Runtime.InteropServices.DllImport("kernel32.dll", SetLastError = true, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
                private static extern bool MoveFileEx(string lpExistingFileName, string? lpNewFileName, int dwFlags);

                public static bool MarkDirectoryForDeleteOnReboot(string directoryPath)
                {
                    // Not supported on non-Windows systems
                    if (!OperatingSystem.IsWindows()) return false;

                    return MoveFileEx(directoryPath, null, MOVEFILE_DELAY_UNTIL_REBOOT);
                }
            }
        }

        #endregion
    }
}