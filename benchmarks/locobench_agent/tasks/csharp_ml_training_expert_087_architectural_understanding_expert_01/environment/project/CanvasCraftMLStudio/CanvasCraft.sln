```csharp
// ===========================================
// CanvasCraft ML Studio â€“ Training Pipeline
// File: TrainingPipeline.cs
// Project: CanvasCraft ML Studio (ml_training)
// ===========================================

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace CanvasCraft.MLStudio.Pipeline
{
    #region Pipeline Core

    /// <summary>
    /// Abstraction for a single step in the ML pipeline. Each step is observable and
    /// can modify the shared <see cref="PipelineContext"/>.
    /// </summary>
    public interface IPipelineStep
    {
        string Name { get; }

        /// <summary>
        /// Executes the step asynchronously.
        /// </summary>
        Task<PipelineContext> ExecuteAsync(PipelineContext context, CancellationToken token = default);

        /// <summary>
        /// Raised whenever <see cref="Status"/> changes.
        /// </summary>
        event EventHandler<PipelineStepStatusChangedEventArgs>? StatusChanged;

        StepStatus Status { get; }
    }

    /// <summary>
    /// Shared, mutable pipeline state. Acts as the glue that passes artifacts from step to step.
    /// </summary>
    public sealed class PipelineContext
    {
        public IDataView? RawData { get; init; }
        public IDataView? Features { get; set; }
        public ITransformer? TrainedModel { get; set; }
        public DataViewSchema? ModelSchema { get; set; }
        public Dictionary<string, object> Properties { get; } = new(StringComparer.OrdinalIgnoreCase);

        public T Get<T>(string key) => (T)Properties[key];
        public void Set<T>(string key, T value) => Properties[key] = value;

        public PipelineContext WithRawData(IDataView data) => this with { RawData = data };
    }

    /// <summary>
    /// Concrete implementation of <see cref="IPipelineStep"/> providing default error handling
    /// and progress notifications.
    /// </summary>
    public abstract class PipelineStepBase : IPipelineStep
    {
        private readonly ILogger _logger;
        private StepStatus _status = StepStatus.Pending;

        protected PipelineStepBase(ILogger logger) => _logger = logger;

        public abstract string Name { get; }

        public StepStatus Status
        {
            get => _status;
            protected set
            {
                if (_status == value) return;
                _status = value;
                StatusChanged?.Invoke(this, new PipelineStepStatusChangedEventArgs(Name, value, DateTimeOffset.UtcNow));
            }
        }

        public event EventHandler<PipelineStepStatusChangedEventArgs>? StatusChanged;

        public async Task<PipelineContext> ExecuteAsync(PipelineContext context, CancellationToken token = default)
        {
            try
            {
                Status = StepStatus.Running;
                _logger.LogInformation("Step '{Step}' started.", Name);

                var result = await ExecuteCoreAsync(context, token).ConfigureAwait(false);

                Status = StepStatus.Succeeded;
                _logger.LogInformation("Step '{Step}' succeeded.", Name);
                return result;
            }
            catch (Exception ex)
            {
                Status = StepStatus.Failed;
                _logger.LogError(ex, "Step '{Step}' failed.", Name);
                throw; // bubble up; pipeline orchestrator decides fate
            }
        }

        protected abstract Task<PipelineContext> ExecuteCoreAsync(PipelineContext context, CancellationToken token);
    }

    public enum StepStatus
    {
        Pending,
        Running,
        Succeeded,
        Failed,
        Skipped
    }

    public sealed record PipelineStepStatusChangedEventArgs(string StepName, StepStatus Status, DateTimeOffset Timestamp);

    #endregion

    #region Concrete Steps

    public sealed class DataIngestionStep : PipelineStepBase
    {
        private readonly Func<MLContext, IDataView> _dataLoader;
        private readonly MLContext _mlContext;

        public DataIngestionStep(MLContext mlContext, Func<MLContext, IDataView> dataLoader, ILogger<DataIngestionStep> logger)
            : base(logger)
        {
            _mlContext = mlContext;
            _dataLoader = dataLoader;
        }

        public override string Name => "Data Ingestion";

        protected override Task<PipelineContext> ExecuteCoreAsync(PipelineContext context, CancellationToken token)
        {
            IDataView data = _dataLoader(_mlContext);
            context = context.WithRawData(data);
            return Task.FromResult(context);
        }
    }

    public sealed class FeatureEngineeringStep : PipelineStepBase
    {
        private readonly IFeatureEngineeringStrategy _strategy;
        private readonly ILogger _logger;
        private readonly MLContext _mlContext;

        public FeatureEngineeringStep(MLContext mlContext,
                                      IFeatureEngineeringStrategy strategy,
                                      ILogger<FeatureEngineeringStep> logger)
            : base(logger)
        {
            _mlContext = mlContext;
            _strategy = strategy;
            _logger = logger;
        }

        public override string Name => "Feature Engineering";

        protected override Task<PipelineContext> ExecuteCoreAsync(PipelineContext context, CancellationToken token)
        {
            if (context.RawData is null)
                throw new InvalidOperationException("Raw data is required before feature engineering.");

            IDataView engineered = _strategy.Apply(_mlContext, context.RawData);
            context.Features = engineered;

            _logger.LogDebug("Feature engineering produced schema: {Schema}", engineered.Schema);
            return Task.FromResult(context);
        }
    }

    public sealed class ModelTrainingStep : PipelineStepBase
    {
        private readonly Func<MLContext, IEstimator<ITransformer>> _trainerFactory;
        private readonly MLContext _mlContext;

        public ModelTrainingStep(MLContext mlContext,
                                 Func<MLContext, IEstimator<ITransformer>> trainerFactory,
                                 ILogger<ModelTrainingStep> logger)
            : base(logger)
        {
            _mlContext = mlContext;
            _trainerFactory = trainerFactory;
        }

        public override string Name => "Model Training";

        protected override async Task<PipelineContext> ExecuteCoreAsync(PipelineContext context, CancellationToken token)
        {
            if (context.Features is null)
                throw new InvalidOperationException("Features are required before training.");

            IEstimator<ITransformer> pipeline = _trainerFactory(_mlContext);
            var model = pipeline.Fit(context.Features);

            context.TrainedModel = model;
            context.ModelSchema = context.Features.Schema;

            // Simulate async training for long-running tasks
            await Task.Yield();
            return context;
        }
    }

    public sealed class ModelEvaluationStep : PipelineStepBase
    {
        private readonly Func<MLContext, IDataView> _testDataLoader;
        private readonly MLContext _mlContext;

        public ModelEvaluationStep(MLContext mlContext,
                                   Func<MLContext, IDataView> testDataLoader,
                                   ILogger<ModelEvaluationStep> logger)
            : base(logger)
        {
            _mlContext = mlContext;
            _testDataLoader = testDataLoader;
        }

        public override string Name => "Model Evaluation";

        protected override Task<PipelineContext> ExecuteCoreAsync(PipelineContext context, CancellationToken token)
        {
            if (context.TrainedModel is null)
                throw new InvalidOperationException("A trained model is required for evaluation.");

            IDataView testData = _testDataLoader(_mlContext);

            var predictions = context.TrainedModel.Transform(testData);
            var metrics = _mlContext.BinaryClassification.Evaluate(predictions);

            context.Set("metrics", metrics);
            return Task.FromResult(context);
        }
    }

    public sealed class ModelRegistrationStep : PipelineStepBase
    {
        private readonly IModelRegistry _registry;

        public ModelRegistrationStep(IModelRegistry registry, ILogger<ModelRegistrationStep> logger)
            : base(logger) => _registry = registry;

        public override string Name => "Model Registration";

        protected override async Task<PipelineContext> ExecuteCoreAsync(PipelineContext context, CancellationToken token)
        {
            if (context.TrainedModel is null)
                throw new InvalidOperationException("A trained model must exist before registration.");

            var id = await _registry.RegisterAsync(context.TrainedModel, context.ModelSchema!, context.Properties, token)
                                    .ConfigureAwait(false);

            context.Set("modelId", id);
            return context;
        }
    }

    #endregion

    #region Strategy + Factory

    /// <summary>
    /// Contract for feature engineering strategies.
    /// </summary>
    public interface IFeatureEngineeringStrategy
    {
        IDataView Apply(MLContext mlContext, IDataView input);
    }

    public sealed class DefaultFeatureEngineeringStrategy : IFeatureEngineeringStrategy
    {
        public IDataView Apply(MLContext mlContext, IDataView input)
        {
            var pipeline = mlContext.Transforms
                                    .ReplaceMissingValues("Features")
                                    .NormalizeMinMax("Features");
            return pipeline.Fit(input).Transform(input);
        }
    }

    /// <summary>
    /// Factory for obtaining a strategy based on runtime hints.
    /// </summary>
    public static class FeatureEngineeringStrategyFactory
    {
        public static IFeatureEngineeringStrategy Create(string paletteName) =>
            paletteName switch
            {
                "default" or null => new DefaultFeatureEngineeringStrategy(),
                _ => throw new NotSupportedException($"Palette '{paletteName}' is not supported.")
            };
    }

    #endregion

    #region Observer

    public interface IPipelineObserver
    {
        void OnStepStatusChanged(object? sender, PipelineStepStatusChangedEventArgs args);
    }

    /// <summary>
    /// Simple observer that writes step events to the supplied <see cref="ILogger"/>.
    /// </summary>
    public sealed class LoggingPipelineObserver : IPipelineObserver
    {
        private readonly ILogger _logger;

        public LoggingPipelineObserver(ILogger<LoggingPipelineObserver> logger) => _logger = logger;

        public void OnStepStatusChanged(object? sender, PipelineStepStatusChangedEventArgs args)
        {
            _logger.LogInformation("[{Time:o}] Step '{Step}' is {Status}",
                                   args.Timestamp, args.StepName, args.Status);
        }
    }

    #endregion

    #region Orchestrator

    /// <summary>
    /// Orchestrates a series of <see cref="IPipelineStep"/> instances, applying the Pipeline Pattern.
    /// </summary>
    public sealed class TrainingPipeline
    {
        private readonly IList<IPipelineStep> _steps;
        private readonly IList<IPipelineObserver> _observers;
        private readonly ILogger _logger;

        public TrainingPipeline(IList<IPipelineStep> steps,
                                IEnumerable<IPipelineObserver>? observers,
                                ILogger<TrainingPipeline> logger)
        {
            _steps      = steps ?? throw new ArgumentNullException(nameof(steps));
            _observers  = observers is null ? new List<IPipelineObserver>() : new List<IPipelineObserver>(observers);
            _logger     = logger;
            WireUpObservers();
        }

        public async Task<PipelineContext> RunAsync(PipelineContext context, CancellationToken token = default)
        {
            foreach (var step in _steps)
            {
                token.ThrowIfCancellationRequested();
                context = await step.ExecuteAsync(context, token).ConfigureAwait(false);
            }

            _logger.LogInformation("Pipeline execution completed.");
            return context;
        }

        private void WireUpObservers()
        {
            foreach (var step in _steps)
            {
                step.StatusChanged += (_, args) =>
                {
                    foreach (var observer in _observers)
                        observer.OnStepStatusChanged(step, args);
                };
            }
        }
    }

    #endregion

    #region Model Registry Abstractions

    /// <summary>
    /// Simplified interface for storing trained models in a registry.
    /// </summary>
    public interface IModelRegistry
    {
        ValueTask<string> RegisterAsync(ITransformer model,
                                        DataViewSchema schema,
                                        IReadOnlyDictionary<string, object> metadata,
                                        CancellationToken token = default);
    }

    /// <summary>
    /// In-memory registry for demo/testing purposes.
    /// </summary>
    public sealed class InMemoryModelRegistry : IModelRegistry
    {
        private readonly Dictionary<string, (ITransformer model, DataViewSchema schema, DateTimeOffset timestamp)> _store = new();
        private readonly ILogger _logger;

        public InMemoryModelRegistry(ILogger<InMemoryModelRegistry> logger) => _logger = logger;

        public ValueTask<string> RegisterAsync(ITransformer model, DataViewSchema schema,
                                               IReadOnlyDictionary<string, object> metadata,
                                               CancellationToken token = default)
        {
            string id = Guid.NewGuid().ToString("N");
            _store[id] = (model, schema, DateTimeOffset.UtcNow);
            _logger.LogInformation("Model registered with ID: {ModelId}", id);
            return ValueTask.FromResult(id);
        }
    }

    #endregion
}
```