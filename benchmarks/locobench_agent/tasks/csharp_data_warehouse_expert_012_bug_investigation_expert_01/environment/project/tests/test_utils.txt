```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using FluentAssertions;
using Moq;
using Xunit;
using PulseOps.Warehouse.Shared.Utils;
using PulseOps.Warehouse.Shared.Models;

namespace PulseOps.Warehouse.Tests.Utils
{
    /// <summary>
    /// Unit-tests for commonly used helper/utilities that power the PulseOps
    /// Warehouse fabric.  All tests run in-memory and are therefore safe to
    /// execute in parallel on the build server.
    /// </summary>
    public sealed class UtilityTests
    {
        #region ──────────────── Timestamp / DateTime helpers ────────────────

        [Theory(DisplayName = "Iso8601Timestamp.ParseUtc() must round-trip arbitrary UTC dates")]
        [InlineData("2023-01-01T00:00:00Z")]
        [InlineData("1997-07-16T19:20:30Z")]
        [InlineData("2050-12-31T23:59:59Z")]
        public void Iso8601Timestamp_ParseUtc_RoundTrips(string iso)
        {
            // Act
            var utc = Iso8601Timestamp.ParseUtc(iso);
            var roundTripped = Iso8601Timestamp.ToIso8601(utc);

            // Assert
            roundTripped.Should().Be(iso);
            utc.Kind.Should().Be(DateTimeKind.Utc);
        }

        [Fact(DisplayName = "Iso8601Timestamp.ToEpochMilliseconds() should be epoch-compatible")]
        public void Iso8601Timestamp_ToEpochMilliseconds_Works()
        {
            // Arrange
            var dt = new DateTime(1970, 01, 01, 00, 00, 01, DateTimeKind.Utc);

            // Act
            long epochMs = Iso8601Timestamp.ToEpochMilliseconds(dt);

            // Assert
            epochMs.Should().Be(1000);
        }

        [Fact(DisplayName = "Iso8601Timestamp.ParseUtc() throws on non-UTC input")]
        public void Iso8601Timestamp_ParseUtc_ShouldThrowOnLocalTime()
        {
            // Arrange
            const string localTime = "2023-06-18T12:00:00+02:00";

            // Act
            Action act = () => Iso8601Timestamp.ParseUtc(localTime);

            // Assert
            act.Should()
               .Throw<ArgumentException>()
               .WithMessage("*input must be in UTC (Z-suffix)*");
        }

        #endregion

        #region ──────────────── Partition Key generator ────────────────

        [Theory(DisplayName = "PartitionKeyGenerator.Generate() creates deterministic keys")]
        [InlineData("tenant-001", "repo/service-a", 1688219200L)]
        [InlineData("tenant-001", "repo/service-a", 1688219200L)] // deliberately repeated
        [InlineData("tenant-999", "repo/service-b", 1688219201L)]
        public void PartitionKeyGenerator_ShouldBeDeterministic(
            string tenant,
            string granularitySource,
            long timestamp)
        {
            // Arrange
            var g1 = PartitionKeyGenerator.Generate(tenant, granularitySource, timestamp);
            var g2 = PartitionKeyGenerator.Generate(tenant, granularitySource, timestamp);

            // Act / Assert
            g1.Should().Be(g2, "same inputs must yield identical partition keys");
            g1.Should().MatchRegex(@"^[a-z0-9\-]{36}$"); // encoded GUID-format
        }

        [Fact(DisplayName = "PartitionKeyGenerator.Generate() should be evenly distributed")]
        public void PartitionKeyGenerator_ShouldUniformlyDistribute()
        {
            // Arrange
            const int sampleSize = 10_000;
            var keys = new HashSet<string>();

            // Act
            for (int i = 0; i < sampleSize; i++)
            {
                keys.Add(PartitionKeyGenerator.Generate(
                    $"tenant-{i % 50}",
                    $"repo/foo-{i % 5}",
                    1688219200L + i));
            }

            // Assert
            double uniqueRatio = (double)keys.Count / sampleSize;
            uniqueRatio.Should().BeGreaterThan(0.99); // at most 1% collisions
        }

        #endregion

        #region ──────────────── RetryPolicy (exponential back-off w/ jitter) ────────────────

        [Fact(DisplayName = "RetryPolicy should retry configured number of attempts")]
        public async Task RetryPolicy_ShouldRetryExpectedAttempts()
        {
            // Arrange
            var attempts = 0;
            var policy = RetryPolicy
               .Builder()
               .WithMaxRetries(3)
               .WithBaseDelay(TimeSpan.FromMilliseconds(10))
               .Build();

            // Act
            await policy.ExecuteAsync(async () =>
            {
                attempts++;
                throw new InvalidOperationException("boom");
            }).ContinueWith(_ => { }); // ignore resulting exception for test

            // Assert
            attempts.Should().Be(4); // 3 retries + 1 original
        }

        [Fact(DisplayName = "RetryPolicy should short-circuit on success")]
        public async Task RetryPolicy_ShouldReturnImmediatelyOnSuccess()
        {
            // Arrange
            var attempts = 0;
            var policy = RetryPolicy
               .Builder()
               .WithMaxRetries(5)
               .WithBaseDelay(TimeSpan.FromMilliseconds(10))
               .Build();

            // Act
            await policy.ExecuteAsync(async () =>
            {
                if (++attempts == 2)
                    return; // success on second attempt

                throw new Exception("transient failure");
            });

            // Assert
            attempts.Should().Be(2);
        }

        [Fact(DisplayName = "RetryPolicy should propagate when CancellationToken is cancelled")]
        public async Task RetryPolicy_ShouldHonorCancellationToken()
        {
            // Arrange
            var cts = new System.Threading.CancellationTokenSource();
            var policy = RetryPolicy
               .Builder()
               .WithMaxRetries(10)
               .WithBaseDelay(TimeSpan.FromMilliseconds(50))
               .Build();

            // cancel after first attempt
            var attempt = 0;
            cts.CancelAfter(TimeSpan.FromMilliseconds(5));

            // Act
            Func<Task> act = () => policy.ExecuteAsync(async token =>
            {
                attempt++;
                await Task.Delay(100, token); // long running task
                throw new Exception("should not reach");
            }, cts.Token);

            // Assert
            await act.Should()
                     .ThrowAsync<OperationCanceledException>();

            attempt.Should().Be(1);
        }

        #endregion

        #region ──────────────── JSON diff serializer ────────────────

        [Fact(DisplayName = "JsonPatchGenerator should skip unchanged properties")]
        public void JsonPatchGenerator_ShouldSkipUnchanged()
        {
            // Arrange
            var original = new UserProfile
            {
                Email = "bob@corp.com",
                FullName = "Bob Foo",
                Department = "R&D"
            };

            var modified = original with { Department = "Engineering" };

            // Act
            var patch = JsonPatchGenerator.CreatePatch(original, modified);

            // Assert
            patch.Should().ContainSingle(operation =>
                operation.Path.EndsWith("/Department") &&
                operation.Operation == "replace");
        }

        [Fact(DisplayName = "JsonPatchGenerator should produce empty patch when identical")]
        public void JsonPatchGenerator_ShouldBeEmptyOnNoChange()
        {
            // Arrange
            var profile = new UserProfile
            {
                Email = "alice@corp.com",
                FullName = "Alice Bar",
                Department = "Finance"
            };

            // Act
            var patch = JsonPatchGenerator.CreatePatch(profile, profile);

            // Assert
            patch.Should().BeEmpty();
        }

        #endregion
    }

    // ---------------------------------------------------------------------
    // The following record is test-fixture only.  The production model lives
    // under Shared.Models but gets trimmed in CI’s “test-only” publish phase
    // for quicker unit test boot-time.
    // ---------------------------------------------------------------------
    internal sealed record UserProfile
    {
        public string Email { get; init; } = string.Empty;
        public string FullName { get; init; } = string.Empty;
        public string Department { get; init; } = string.Empty;
    }
}
```