```csharp
// ---------------------------------------------------------------------------------------------------------------------
//  File:          src/config.txt   (yes, despite the extension this file intentionally holds C# code)
//  Project:       PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//  Description:   Strongly–typed, self-validating configuration layer shared by all Lambda micro-components.
//                 This module centralises runtime configuration discovery (AWS Systems Manager, Secrets Manager,
//                 Environment-Variables, Local JSON fallback) and provides a single source-of-truth object graph
//                 that downstream services can consume via dependency-injection.
//
//  NOTE:          • Each Options-record exposes a Validate() guard that throws a descriptive ConfigurationException
//                   when required keys are missing or malformed.
//                 • The loader implements a “fail-fast” philosophy—broken configuration aborts the cold-start early.
// ---------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Linq;
using Amazon.Extensions.NETCore.Setup;
using Amazon.SecretsManager;
using Amazon.SecretsManager.Model;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Configuration.Json;

namespace PulseOps.Warehouse.Configuration
{
    /// <summary>
    ///     Entry-point for all configuration access.  Call AppConfig.Load() once during cold-start and register the
    ///     returned <see cref="WarehouseOptions"/> instance into the DI container (e.g., services.AddSingleton(options)).
    /// </summary>
    public static class AppConfig
    {
        private const string LocalSettingsFile = "appsettings.local.json";
        private const string SecretsPrefix     = "PulseOpsWarehouse/";   // Systems-Manager/Secrets-Manager common prefix

        /// <summary>
        ///     Discovers and builds the <see cref="WarehouseOptions"/> object graph from all supported sources:
        ///        1. AWS Secrets Manager (JSON secret blobs)
        ///        2. Local JSON file (developer machines & unit tests)
        ///        3. Environment variables (Lambda & CI/CD)
        ///        4. Hard-coded defaults
        /// </summary>
        public static WarehouseOptions Load()
        {
            var builder = new ConfigurationBuilder();

            // 1️⃣  Local JSON (only if file exists—helps when running `dotnet run` locally)
            if (File.Exists(LocalSettingsFile))
            {
                builder.AddJsonFile(LocalSettingsFile, optional: false, reloadOnChange: true);
            }

            // 2️⃣  Environment variables
            builder.AddEnvironmentVariables();

            // 3️⃣  AWS Secrets Manager — if AWS execution context is detected
            if (IsRunningOnAws())
            {
                var secretsManager = new AmazonSecretsManagerClient();
                foreach (string secretName in DiscoverSecretNames(secretsManager))
                {
                    string secretValue = FetchSecret(secretsManager, secretName);
                    // Each secret is expected to be a flat JSON object
                    builder.AddJsonStream(new MemoryStream(System.Text.Encoding.UTF8.GetBytes(secretValue)));
                }
            }

            IConfigurationRoot configuration = builder.Build();

            // Bind strongly-typed options
            var options = new WarehouseOptions();
            configuration.Bind(options);

            // Fail-fast validation
            options.Validate();

            return options;
        }

        #region Helpers

        private static bool IsRunningOnAws() =>
            !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("AWS_LAMBDA_FUNCTION_NAME"));

        private static IEnumerable<string> DiscoverSecretNames(IAmazonSecretsManager client)
        {
            string nextToken = null;
            do
            {
                var request  = new ListSecretsRequest { NextToken = nextToken };
                var response = client.ListSecretsAsync(request).GetAwaiter().GetResult();

                foreach (var secret in response.SecretList.Where(s => s.Name.StartsWith(SecretsPrefix, StringComparison.OrdinalIgnoreCase)))
                {
                    yield return secret.Name;
                }

                nextToken = response.NextToken;
            } while (nextToken != null);
        }

        private static string FetchSecret(IAmazonSecretsManager client, string secretName)
        {
            try
            {
                var response = client.GetSecretValueAsync(new GetSecretValueRequest { SecretId = secretName })
                                      .GetAwaiter().GetResult();
                return response.SecretString;
            }
            catch (Exception ex)
            {
                throw new ConfigurationException($"Unable to retrieve secret '{secretName}'.", ex);
            }
        }

        #endregion
    }

    /// <summary>
    ///     Root-level configuration object consumed application-wide.
    /// </summary>
    public sealed record WarehouseOptions
    {
        public AwsOptions             Aws             { get; init; } = new();
        public StorageOptions         Storage         { get; init; } = new();
        public StreamOptions          Streams         { get; init; } = new();
        public ObservabilityOptions   Observability   { get; init; } = new();
        public ProcessingOptions      Processing      { get; init; } = new();

        // Consolidated validation entry-point
        public void Validate()
        {
            Aws.Validate();
            Storage.Validate();
            Streams.Validate();
            Observability.Validate();
            Processing.Validate();
        }
    }

    // -----------------------------------------------------------------------------------------------------------------
    // Strongly-typed option children
    // -----------------------------------------------------------------------------------------------------------------
    public sealed record AwsOptions
    {
        [Required] public string Region           { get; init; } = "us-east-1";
        [Required] public string AccountId        { get; init; } = string.Empty;
        [Required] public string ResourcePrefix   { get; init; } = "pulseops";

        public void Validate()
        {
            Require(nameof(AccountId), AccountId);
            Require(nameof(ResourcePrefix), ResourcePrefix);
        }
    }

    public sealed record StorageOptions
    {
        [Required] public string RawBucketName            { get; init; } = string.Empty;
        [Required] public string CuratedBucketName        { get; init; } = string.Empty;
        [Required] public string AthenaQueryResultsBucket { get; init; } = string.Empty;

        public void Validate()
        {
            Require(nameof(RawBucketName), RawBucketName);
            Require(nameof(CuratedBucketName), CuratedBucketName);
            Require(nameof(AthenaQueryResultsBucket), AthenaQueryResultsBucket);
        }
    }

    public sealed record StreamOptions
    {
        [Required] public string IngestionStreamArn { get; init; } = string.Empty;
        [Required] public string DlqArn             { get; init; } = string.Empty; // Dead-Letter queue for poison pills
        public int MaxRetryAttempts                 { get; init; } = 3;

        public void Validate()
        {
            Require(nameof(IngestionStreamArn), IngestionStreamArn);
            Require(nameof(DlqArn), DlqArn);

            if (MaxRetryAttempts is < 0 or > 10)
                throw new ConfigurationException($"{nameof(MaxRetryAttempts)} must be between 0 and 10 (inclusive).");
        }
    }

    public sealed record ObservabilityOptions
    {
        public bool        EnableStructuredLogging { get; init; } = true;
        public bool        EnableTracing           { get; init; } = true;
        [Required] public string LogLevel          { get; init; } = "Information";
        public void Validate() => Require(nameof(LogLevel), LogLevel);
    }

    public sealed record ProcessingOptions
    {
        public int  ParallelShardCount    { get; init; } = 4;
        public bool EnableBackfillLambda  { get; init; } = true;
        public int  BatchWindowSeconds    { get; init; } = 900;

        public void Validate()
        {
            if (ParallelShardCount <= 0)
                throw new ConfigurationException($"{nameof(ParallelShardCount)} must be greater than zero.");

            if (BatchWindowSeconds is < 60 or > 3600)
                throw new ConfigurationException($"{nameof(BatchWindowSeconds)} must be between 60 and 3600 seconds.");
        }
    }

    // -----------------------------------------------------------------------------------------------------------------
    //  Helper utilities
    // -----------------------------------------------------------------------------------------------------------------
    [Serializable]
    public sealed class ConfigurationException : Exception
    {
        public ConfigurationException(string message, Exception innerException = null)
            : base(message, innerException) { }
    }

    internal static class ValidationExtensions
    {
        public static void Require(string name, string value)
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ConfigurationException($"Configuration value '{name}' is required and cannot be empty.");
        }
    }
}
```