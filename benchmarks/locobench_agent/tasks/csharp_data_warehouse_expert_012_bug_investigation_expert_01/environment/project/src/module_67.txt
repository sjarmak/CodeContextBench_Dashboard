```csharp
// --------------------------------------------------------------------------------------------------------------------
// <copyright>
//   PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//   © 2024 VelocityLayer, Inc.  All rights reserved.
// </copyright>
// <author>PulseOps Engineering</author>
// <summary>
//   Core transformation engine and strategy implementations.
//   File: src/module_67.cs   (kept .txt extension in repo for historical reasons)
// </summary>
// --------------------------------------------------------------------------------------------------------------------

#nullable enable

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    /// <summary>
    /// Immutable domain object that represents a raw event emitted by upstream ingestion Lambdas.
    /// </summary>
    public sealed record StreamEvent(
        string   Source,           // e.g. "calendar", "git", "cicd"
        string   Type,             // e.g. "meeting.created", "commit", "deployment.succeeded"
        byte[]   Payload,          // JSON-encoded payload
        DateTime TimestampUtc      // ISO 8601 UTC timestamp
    );

    /// <summary>
    /// Immutable domain object that represents an individual KPI sample produced by
    /// a <see cref="ITransformationStrategy"/>.
    /// </summary>
    public sealed record TransformationResult(
        string                     Metric,       // e.g. "focus_time_ratio"
        IReadOnlyDictionary<string, object?> Data,
        DateTime                   CalculatedAtUtc
    );

    /// <summary>
    /// Common contract for transformation strategies.  Each strategy converts a raw
    /// <see cref="StreamEvent"/> into zero or more <see cref="TransformationResult"/> objects.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>The friendly identifier of the strategy.</summary>
        string Name { get; }

        /// <summary>
        /// True when the strategy can handle the given <paramref name="streamEvent"/>.
        /// </summary>
        bool CanHandle(in StreamEvent streamEvent);

        /// <summary>
        /// Transforms the event into domain KPIs.
        /// </summary>
        ValueTask<IReadOnlyCollection<TransformationResult>> TransformAsync(
            StreamEvent      streamEvent,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Strategy that computes the focus-time ratio from calendar events.
    /// </summary>
    public sealed class FocusTimeRatioStrategy : ITransformationStrategy
    {
        private readonly ILogger<FocusTimeRatioStrategy> _logger;

        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger) => _logger = logger;

        public string Name => "focus_time_ratio";

        public bool CanHandle(in StreamEvent streamEvent) =>
            streamEvent.Source.Equals("calendar", StringComparison.OrdinalIgnoreCase) &&
            streamEvent.Type.Equals("meeting.batch", StringComparison.OrdinalIgnoreCase);

        public ValueTask<IReadOnlyCollection<TransformationResult>> TransformAsync(
            StreamEvent       streamEvent,
            CancellationToken cancellationToken = default)
        {
            try
            {
                var document = JsonDocument.Parse(streamEvent.Payload);
                double totalMeetingMinutes = 0;
                double totalFocusMinutes   = 0;

                foreach (var meeting in document.RootElement.GetProperty("meetings").EnumerateArray())
                {
                    totalMeetingMinutes += meeting.GetProperty("durationMinutes").GetDouble();
                    if (meeting.GetProperty("isFocusTime").GetBoolean())
                    {
                        totalFocusMinutes += meeting.GetProperty("durationMinutes").GetDouble();
                    }
                }

                var ratio = totalMeetingMinutes == 0
                    ? 0
                    : Math.Round(totalFocusMinutes / totalMeetingMinutes, 3);

                var kpi = new TransformationResult(
                    Metric: "focus_time_ratio",
                    Data: new Dictionary<string, object?>
                    {
                        ["ratio"]             = ratio,
                        ["total_meeting_min"] = totalMeetingMinutes,
                        ["total_focus_min"]   = totalFocusMinutes
                    },
                    CalculatedAtUtc: DateTime.UtcNow);

                return ValueTask.FromResult<IReadOnlyCollection<TransformationResult>>(new[] { kpi });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "[KPI:FocusTimeRatio] Failed to transform calendar event (id: {Source}/{Type}).",
                    streamEvent.Source, streamEvent.Type);
                throw; // propagate to DLQ via Lambda’s failure handling
            }
        }
    }

    /// <summary>
    /// Strategy that computes deployment lead-time given a commit and corresponding deployment event.
    /// Uses an in-memory correlation cache; for production, consider DynamoDB with TTL.
    /// </summary>
    public sealed class DeploymentLeadTimeStrategy : ITransformationStrategy
    {
        private readonly ILogger<DeploymentLeadTimeStrategy> _logger;

        // (commitSha -> timestampUtc)
        private readonly ConcurrentDictionary<string, DateTime> _commitCache = new();

        public DeploymentLeadTimeStrategy(ILogger<DeploymentLeadTimeStrategy> logger) => _logger = logger;

        public string Name => "deployment_lead_time";

        public bool CanHandle(in StreamEvent streamEvent) =>
            streamEvent.Source is "git" or "cicd";

        public ValueTask<IReadOnlyCollection<TransformationResult>> TransformAsync(
            StreamEvent       streamEvent,
            CancellationToken cancellationToken = default)
        {
            var payload = JsonDocument.Parse(streamEvent.Payload).RootElement;
            switch (streamEvent.Source)
            {
                case "git" when streamEvent.Type == "commit":
                {
                    var sha = payload.GetProperty("sha").GetString()!;
                    var committedAt = payload.GetProperty("timestampUtc").GetDateTime();
                    _commitCache.TryAdd(sha, committedAt);
                    // no KPI yet, wait for deployment event
                    return ValueTask.FromResult<IReadOnlyCollection<TransformationResult>>(Array.Empty<TransformationResult>());
                }

                case "cicd" when streamEvent.Type == "deployment.succeeded":
                {
                    var sha = payload.GetProperty("commitSha").GetString()!;
                    if (!_commitCache.TryRemove(sha, out var committedAt))
                    {
                        // Commit not found; maybe commit happened before in back-fill. Log and bail out.
                        _logger.LogWarning(
                            "[KPI:DeploymentLeadTime] Commit {Sha} missing from cache; ignoring deployment event.",
                            sha);
                        return ValueTask.FromResult<IReadOnlyCollection<TransformationResult>>(Array.Empty<TransformationResult>());
                    }

                    var deployedAt = payload.GetProperty("deployedAtUtc").GetDateTime();
                    var leadTime   = (deployedAt - committedAt).TotalMinutes;

                    var kpi = new TransformationResult(
                        Metric: "deployment_lead_time",
                        Data: new Dictionary<string, object?>
                        {
                            ["commitSha"]       = sha,
                            ["leadTimeMinutes"] = leadTime
                        },
                        CalculatedAtUtc: DateTime.UtcNow);

                    return ValueTask.FromResult<IReadOnlyCollection<TransformationResult>>(new[] { kpi });
                }

                default:
                    // Should never reach here if CanHandle() is correct.
                    throw new InvalidOperationException($"Unexpected event {streamEvent.Source}/{streamEvent.Type}");
            }
        }
    }

    /// <summary>
    /// Registry that lazily instantiates and holds all available <see cref="ITransformationStrategy"/>s.
    /// Acts as the single source-of-truth for strategy discovery.
    /// </summary>
    public sealed class TransformationStrategyRegistry
    {
        private readonly IReadOnlyList<ITransformationStrategy> _strategies;

        public TransformationStrategyRegistry(Func<Type, object> serviceFactory)
        {
            _strategies = new ITransformationStrategy[]
            {
                (ITransformationStrategy)serviceFactory(typeof(FocusTimeRatioStrategy)),
                (ITransformationStrategy)serviceFactory(typeof(DeploymentLeadTimeStrategy)),
                // Add new strategies here ⤴
            };
        }

        public IEnumerable<ITransformationStrategy> GetCandidates(in StreamEvent streamEvent)
        {
            foreach (var strat in _strategies)
            {
                if (strat.CanHandle(streamEvent))
                    yield return strat;
            }
        }
    }

    /// <summary>
    /// Main orchestration engine.  Accepts a batch of <see cref="StreamEvent"/>s,
    /// dispatches them to the correct strategy in parallel, and aggregates results.
    /// 
    /// Thread-safe and stateless — perfect for Lambda/Serverless invocations.
    /// </summary>
    public sealed class TransformationEngine
    {
        private readonly TransformationStrategyRegistry _registry;
        private readonly ILogger<TransformationEngine>  _logger;

        public TransformationEngine(
            TransformationStrategyRegistry registry,
            ILogger<TransformationEngine>  logger)
        {
            _registry = registry;
            _logger   = logger;
        }

        /// <summary>
        /// Processes a batch of raw events and returns KPI results.
        /// </summary>
        public async Task<IReadOnlyCollection<TransformationResult>> TransformAsync(
            IReadOnlyCollection<StreamEvent> events,
            CancellationToken                cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(events);

            if (events.Count == 0)
            {
                return Array.Empty<TransformationResult>();
            }

            var sw = Stopwatch.StartNew();
            var kpiBag = new ConcurrentBag<TransformationResult>();

            // .NET 6+: Parallel.ForEachAsync uses async-await inside
            await Parallel.ForEachAsync(events, cancellationToken, async (streamEvent, ct) =>
            {
                try
                {
                    var candidates = _registry.GetCandidates(streamEvent);
                    foreach (var strategy in candidates)
                    {
                        var kpis = await strategy.TransformAsync(streamEvent, ct).ConfigureAwait(false);
                        foreach (var kpi in kpis)
                        {
                            kpiBag.Add(kpi);
                        }
                    }
                }
                catch (Exception ex) when (HandleError(ex, streamEvent))
                {
                    // swallow after logging, as HandleError already dealt with it.
                }
            }).ConfigureAwait(false);

            _logger.LogInformation(
                "Transformation batch finished: {TotalEvents} events, {TotalKpis} KPIs, {ElapsedMs} ms.",
                events.Count, kpiBag.Count, sw.ElapsedMilliseconds);

            return kpiBag.ToArray();
        }

        /// <summary>
        /// Centralized error-handling policy. Returns false to rethrow and bubble up to runtime,
        /// true to suppress the exception (already logged).
        /// </summary>
        private bool HandleError(Exception ex, in StreamEvent streamEvent,
            [CallerMemberName] string? caller = null)
        {
            _logger.LogError(ex,
                "[TransformEngine] {Caller} failed for event {Source}/{Type} — routed to DLQ.",
                caller, streamEvent.Source, streamEvent.Type);

            // Return true so that Parallel.ForEachAsync continues processing other events.
            // The failed item will end up in DLQ via Lambda’s batch item failure response.
            return true;
        }
    }
}
```