```csharp
// File: src/module_56.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
// Language: C# (.NET 6)

// -----------------------------------------------------------------------------
//  NOTE: This file aggregates several closely-related types to keep the sample
//  self-contained.  In production, each class/record would belong in its own
//  source file.
// -----------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region Domain Types

    /// <summary>
    /// Raw, unprocessed event emitted by an upstream ingestion Lambda.
    /// </summary>
    /// <param name="Source">Logical origin (e.g. calendar, ci_cd, github).</param>
    /// <param name="Payload">Arbitrary JSON payload emitted by the source system.</param>
    /// <param name="Timestamp">UTC timestamp when the event happened.</param>
    /// <param name="Headers">Key/value meta from the transport layer.</param>
    public sealed record StreamRecord(
        string Source,
        JsonDocument Payload,
        DateTime Timestamp,
        IReadOnlyDictionary<string, string> Headers);

    /// <summary>
    /// Normalized, analytics-ready KPI produced by a transformation strategy.
    /// </summary>
    /// <param name="KpiName">Canonical KPI identifier.</param>
    /// <param name="Value">Numeric KPI value.</param>
    /// <param name="Unit">Measurement unit (e.g. hrs, pct, ms).</param>
    /// <param name="ComputedAt">UTC timestamp when the KPI was calculated.</param>
    /// <param name="Meta">Additional data useful for downstream consumers.</param>
    public sealed record TransformedKpi(
        string KpiName,
        decimal Value,
        string Unit,
        DateTime ComputedAt,
        IReadOnlyDictionary<string, object?> Meta);

    #endregion

    #region Exceptions

    /// <summary>
    /// Thrown when no suitable strategy can map a raw <see cref="StreamRecord"/> into a KPI.
    /// </summary>
    public sealed class TransformationStrategyNotFoundException : Exception
    {
        public TransformationStrategyNotFoundException(string? message) : base(message) { }
    }

    #endregion

    #region Strategy Infrastructure

    /// <summary>
    /// Contract for pluggable transformation strategies.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>
        /// Human-readable strategy identifier (used for diagnostics).
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Whether the strategy can handle the supplied <see cref="StreamRecord"/>.
        /// </summary>
        bool CanHandle(in StreamRecord record);

        /// <summary>
        /// Execute the transformation and return a KPI.
        /// </summary>
        Task<TransformedKpi> TransformAsync(
            StreamRecord record,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Base-class convenience helper for simple strategies.
    /// </summary>
    public abstract class TransformationStrategyBase : ITransformationStrategy
    {
        protected readonly ILogger Logger;

        protected TransformationStrategyBase(ILogger logger) => Logger = logger;

        public abstract string Name { get; }

        public abstract bool CanHandle(in StreamRecord record);

        public abstract Task<TransformedKpi> TransformAsync(
            StreamRecord record,
            CancellationToken cancellationToken = default);

        #region Utils

        protected static decimal SafeDivide(decimal numerator, decimal denominator) =>
            denominator == 0 ? 0 : numerator / denominator;

        #endregion
    }

    /// <summary>
    /// Strategy resolver leveraging reflection to discover implementations of
    /// <see cref="ITransformationStrategy"/> at runtime.
    /// </summary>
    public sealed class StrategyResolver
    {
        private readonly IReadOnlyList<Func<ILogger, ITransformationStrategy>> _strategyFactories;
        private readonly ILogger _logger;
        private readonly ConcurrentDictionary<string, ITransformationStrategy> _cache = new();

        public StrategyResolver(ILoggerFactory loggerFactory)
        {
            _logger = loggerFactory.CreateLogger<StrategyResolver>();

            _strategyFactories = DiscoverStrategies()
                .Select(type =>
                    (Func<ILogger, ITransformationStrategy>)(logger =>
                        (ITransformationStrategy)Activator.CreateInstance(type, logger)!))
                .ToList();

            if (!_strategyFactories.Any())
            {
                _logger.LogWarning(
                    "No transformation strategies were discovered.  " +
                    "TransformationEngine will fail to process incoming events.");
            }
        }

        /// <summary>
        /// Attempt to locate a strategy capable of handling <paramref name="record"/>.
        /// </summary>
        public ITransformationStrategy Resolve(in StreamRecord record)
        {
            // Optimistic fast-path:  reuse previously matched strategy based on Source.
            if (_cache.TryGetValue(record.Source, out var cached) && cached.CanHandle(record))
            {
                return cached;
            }

            foreach (var factory in _strategyFactories)
            {
                var candidate = factory(_logger); // strategies are lightweight
                if (!candidate.CanHandle(record)) continue;

                // Cache for subsequent lookups
                _cache[record.Source] = candidate;
                return candidate;
            }

            throw new TransformationStrategyNotFoundException(
                $"No strategy could handle source '{record.Source}'.");
        }

        private static IEnumerable<Type> DiscoverStrategies()
        {
            var assembly = Assembly.GetExecutingAssembly();
            return assembly
                .GetTypes()
                .Where(t =>
                    t is { IsAbstract: false, IsInterface: false } &&
                    typeof(ITransformationStrategy).IsAssignableFrom(t) &&
                    t.GetConstructors().Any(c =>
                        c.GetParameters().Length == 1 &&
                        c.GetParameters()[0].ParameterType == typeof(ILogger)))
                .ToArray();
        }
    }

    /// <summary>
    /// Main façade used by Lambda entry-points: takes a raw <see cref="StreamRecord"/>,
    /// resolves the appropriate strategy and returns a KPI.
    /// </summary>
    public sealed class TransformationEngine
    {
        private readonly StrategyResolver _resolver;
        private readonly ILogger _logger;

        public TransformationEngine(StrategyResolver resolver, ILoggerFactory loggerFactory)
        {
            _resolver = resolver;
            _logger = loggerFactory.CreateLogger<TransformationEngine>();
        }

        public async Task<TransformedKpi> TransformAsync(
            StreamRecord record,
            CancellationToken cancellationToken = default)
        {
            try
            {
                var strategy = _resolver.Resolve(record);
                _logger.LogDebug(
                    "Resolved strategy '{StrategyName}' for source '{Source}'.",
                    strategy.Name,
                    record.Source);

                var kpi = await strategy.TransformAsync(record, cancellationToken)
                    .ConfigureAwait(false);

                _logger.LogInformation(
                    "KPI {KpiName}={KpiValue} {Unit} generated by {StrategyName}.",
                    kpi.KpiName,
                    kpi.Value.ToString(CultureInfo.InvariantCulture),
                    kpi.Unit,
                    strategy.Name);

                return kpi;
            }
            catch (TransformationStrategyNotFoundException)
            {
                _logger.LogWarning(
                    "Unsupported stream record. Source={Source}, Timestamp={Timestamp:o}",
                    record.Source,
                    record.Timestamp);
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(
                    ex,
                    "Unexpected error while transforming record from {Source}.",
                    record.Source);
                throw;
            }
        }
    }

    #endregion

    #region Concrete Strategies

    /// <summary>
    /// Calculates engineers' focus-time ratio from calendar events (busy vs free).
    /// Example KPI: FocusTimePct.
    /// </summary>
    internal sealed class FocusTimeStrategy : TransformationStrategyBase
    {
        public const string SourceKey = "calendar";
        public FocusTimeStrategy(ILogger logger) : base(logger) { }

        public override string Name => nameof(FocusTimeStrategy);

        public override bool CanHandle(in StreamRecord record) =>
            string.Equals(record.Source, SourceKey, StringComparison.OrdinalIgnoreCase) &&
            record.Payload.RootElement.TryGetProperty("events", out _);

        public override Task<TransformedKpi> TransformAsync(
            StreamRecord record,
            CancellationToken cancellationToken = default)
        {
            var root = record.Payload.RootElement;

            var totalMinutes = 0m;
            var focusMinutes = 0m;

            foreach (var ev in root.GetProperty("events").EnumerateArray())
            {
                var duration = ev.GetProperty("durationMinutes").GetDecimal();
                totalMinutes += duration;

                var isMeeting = ev.GetProperty("isMeeting").GetBoolean();
                if (!isMeeting) focusMinutes += duration;
            }

            var ratio = SafeDivide(focusMinutes, totalMinutes);

            var kpi = new TransformedKpi(
                KpiName: "FocusTimePct",
                Value: Math.Round(ratio * 100, 2),
                Unit: "pct",
                ComputedAt: DateTime.UtcNow,
                Meta: new Dictionary<string, object?>
                {
                    ["TotalMinutes"] = totalMinutes,
                    ["FocusMinutes"] = focusMinutes
                });

            return Task.FromResult(kpi);
        }
    }

    /// <summary>
    /// Computes deployment lead-time from CI/CD telemetry.
    /// Example KPI: DeploymentLeadTimeHours.
    /// </summary>
    internal sealed class DeploymentLeadTimeStrategy : TransformationStrategyBase
    {
        public const string SourceKey = "ci_cd";
        public DeploymentLeadTimeStrategy(ILogger logger) : base(logger) { }

        public override string Name => nameof(DeploymentLeadTimeStrategy);

        public override bool CanHandle(in StreamRecord record) =>
            string.Equals(record.Source, SourceKey, StringComparison.OrdinalIgnoreCase) &&
            record.Payload.RootElement.TryGetProperty("commits", out _);

        public override Task<TransformedKpi> TransformAsync(
            StreamRecord record,
            CancellationToken cancellationToken = default)
        {
            var root = record.Payload.RootElement;
            var commits = root.GetProperty("commits");

            var durations = new List<decimal>();
            foreach (var commit in commits.EnumerateArray())
            {
                var created = commit.GetProperty("committedAt").GetDateTime();
                var deployed = commit.GetProperty("deployedAt").GetDateTime();
                durations.Add((decimal)(deployed - created).TotalHours);
            }

            var average = durations.Count == 0 ? 0 : durations.Average();

            var kpi = new TransformedKpi(
                KpiName: "DeploymentLeadTimeHours",
                Value: Math.Round(average, 2),
                Unit: "hrs",
                ComputedAt: DateTime.UtcNow,
                Meta: new Dictionary<string, object?>
                {
                    ["Samples"] = durations.Count,
                    ["Min"] = durations.DefaultIfEmpty(0).Min(),
                    ["Max"] = durations.DefaultIfEmpty(0).Max()
                });

            return Task.FromResult(kpi);
        }
    }

    /// <summary>
    /// Estimates meeting cost by multiplying participant salaries with meeting duration.
    /// Example KPI: MeetingCostUSD.
    /// </summary>
    internal sealed class MeetingCostStrategy : TransformationStrategyBase
    {
        public const string SourceKey = "calendar";
        public MeetingCostStrategy(ILogger logger) : base(logger) { }

        public override string Name => nameof(MeetingCostStrategy);

        public override bool CanHandle(in StreamRecord record)
        {
            if (!string.Equals(record.Source, SourceKey, StringComparison.OrdinalIgnoreCase))
                return false;

            var root = record.Payload.RootElement;
            return root.TryGetProperty("events", out var eventsProp) &&
                   eventsProp.EnumerateArray().Any(ev => ev.GetProperty("isMeeting").GetBoolean());
        }

        public override Task<TransformedKpi> TransformAsync(
            StreamRecord record,
            CancellationToken cancellationToken = default)
        {
            decimal totalCost = 0m;
            var root = record.Payload.RootElement;

            foreach (var ev in root.GetProperty("events").EnumerateArray())
            {
                if (!ev.GetProperty("isMeeting").GetBoolean()) continue;

                var durationHours =
                    ev.GetProperty("durationMinutes").GetDecimal() / 60m;

                foreach (var participant in ev.GetProperty("participants").EnumerateArray())
                {
                    var hourlyRate = participant
                        .GetProperty("hourlyRateUSD")
                        .GetDecimal();

                    totalCost += hourlyRate * durationHours;
                }
            }

            var kpi = new TransformedKpi(
                KpiName: "MeetingCostUSD",
                Value: Math.Round(totalCost, 2),
                Unit: "usd",
                ComputedAt: DateTime.UtcNow,
                Meta: new Dictionary<string, object?>
                {
                    ["Currency"] = "USD"
                });

            return Task.FromResult(kpi);
        }
    }

    #endregion
}
```