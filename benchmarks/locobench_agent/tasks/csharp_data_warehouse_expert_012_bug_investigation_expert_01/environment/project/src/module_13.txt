```csharp
// ------------------------------------------------------------------------------------------
//  PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//  ----------------------------------------------------------------------------
//  File:    module_13.cs
//  Project: data_warehouse
//  Author:  Auto–generated by AI assistant
//  Purpose: Implements a plug-and-play Transformation Engine that wires up the
//           Strategy-Pattern to allow business-logic to be swapped on-the-fly
//           without triggering a full redeploy of the Lambda micro-function.
//           This is accomplished by leveraging dependency-injection,
//           reflection-based key discovery, and a thread-safe in-memory cache.
// ------------------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformation
{
    #region Public Contracts

    /// <summary>
    /// Strongly-typed context that flows through the transformation engine.
    /// </summary>
    /// <param name="DataSetId">
    ///     A canonical identifier for the dataset (e.g. "focus-time-ratio").
    /// </param>
    /// <param name="Payload">
    ///     The raw JSON payload to be transformed. The contract is purposely
    ///     flexible so that heterogeneous event types can be handled by the
    ///     strategy pattern without schema coupling.
    /// </param>
    /// <param name="IngestedAt">
    ///     Timestamp indicating when the event was ingested into the warehouse.
    /// </param>
    public sealed record TransformContext(
        string DataSetId,
        JsonElement Payload,
        DateTimeOffset IngestedAt);

    /// <summary>
    /// Canonical result produced by any transformation strategy.
    /// </summary>
    /// <param name="DataSetId">Echo of the incoming dataset identifier.</param>
    /// <param name="Metrics">Key-value pairs representing calculated KPIs.</param>
    /// <param name="GeneratedAt">Timestamp when the result was produced.</param>
    public sealed record TransformResult(
        string DataSetId,
        IReadOnlyDictionary<string, double> Metrics,
        DateTimeOffset GeneratedAt);

    /// <summary>
    /// Attribute used to decorate <see cref="ITransformationStrategy"/> concrete
    /// implementations with one or more dataset keys they can handle.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
    public sealed class StrategyKeyAttribute : Attribute
    {
        public StrategyKeyAttribute(string key) => Key = key;

        public string Key { get; }
    }

    /// <summary>
    /// Defines the contract for an atomic piece of transformation logic.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>
        /// Determines whether this strategy can handle <paramref name="context"/>.
        /// Returning <c>true</c> short-circuits further probing.
        /// </summary>
        bool CanHandle(TransformContext context);

        /// <summary>
        /// Executes the transformation asynchronously.
        /// </summary>
        ValueTask<TransformResult> ExecuteAsync(
            TransformContext context,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Exception thrown when no <see cref="ITransformationStrategy"/> can be
    /// resolved for a given dataset.
    /// </summary>
    public sealed class UnknownTransformationStrategyException : Exception
    {
        public UnknownTransformationStrategyException(string dataSetId)
            : base($"Cannot resolve transformation strategy for dataset '{dataSetId}'.")
        { }
    }

    #endregion

    #region Transformation Engine

    /// <summary>
    /// The <see cref="TransformationEngine"/> acts as an orchestrator that
    /// selects the appropriate <see cref="ITransformationStrategy"/> based on
    /// <see cref="TransformContext.DataSetId"/> and delegates execution.
    /// </summary>
    public sealed class TransformationEngine
    {
        private readonly IReadOnlyList<ITransformationStrategy> _strategies;
        private readonly ILogger<TransformationEngine> _logger;

        // Thread-safe cache for O(1) lookups on subsequent invocations.
        private readonly ConcurrentDictionary<string, ITransformationStrategy> _strategyCache =
            new(StringComparer.OrdinalIgnoreCase);

        public TransformationEngine(
            IEnumerable<ITransformationStrategy> strategies,
            ILogger<TransformationEngine> logger)
        {
            _strategies = strategies?.ToList().AsReadOnly()
                          ?? throw new ArgumentNullException(nameof(strategies));

            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Executes the transformation pipeline for the supplied context.
        /// </summary>
        public async ValueTask<TransformResult> TransformAsync(
            TransformContext context,
            CancellationToken cancellationToken = default)
        {
            if (context is null) throw new ArgumentNullException(nameof(context));

            ITransformationStrategy strategy = ResolveStrategy(context);
            _logger.LogDebug(
                "Selected strategy '{Strategy}' for DataSetId='{DataSetId}'",
                strategy.GetType().Name,
                context.DataSetId);

            try
            {
                return await strategy.ExecuteAsync(context, cancellationToken)
                                     .ConfigureAwait(false);
            }
            catch (Exception ex) when (ex is not OperationCanceledException)
            {
                _logger.LogError(ex,
                    "Transformation failed for DataSetId='{DataSetId}' via strategy '{Strategy}'",
                    context.DataSetId,
                    strategy.GetType().Name);

                // Surface the exception so that the Lambda can forward it
                // to the DLQ/DeadLetterTopic for automated triage.
                throw;
            }
        }

        private ITransformationStrategy ResolveStrategy(TransformContext context)
        {
            // Fast path — check concurrent cache.
            if (_strategyCache.TryGetValue(context.DataSetId, out var cached))
            {
                return cached;
            }

            // Fallback to reflection-based discovery.
            ITransformationStrategy? resolved = _strategies.FirstOrDefault(s =>
            {
                // Prefer attribute-based matching.
                var attrKeys = s.GetType()
                    .GetCustomAttributes(typeof(StrategyKeyAttribute), inherit: false)
                    .OfType<StrategyKeyAttribute>()
                    .Select(a => a.Key);

                return attrKeys.Any(k => k.Equals(context.DataSetId, StringComparison.OrdinalIgnoreCase))
                       || s.CanHandle(context);
            });

            if (resolved is null)
            {
                throw new UnknownTransformationStrategyException(context.DataSetId);
            }

            // Cache for future calls.
            _strategyCache.TryAdd(context.DataSetId, resolved);
            return resolved;
        }
    }

    #endregion

    #region Sample Strategies

    /// <summary>
    /// Calculates the Ratio of Focus Time vs Meeting Time for a given user/day.
    /// The incoming payload is expected to have the following JSON shape:
    ///
    /// {
    ///   "focusMinutes":   274,
    ///   "meetingMinutes": 102
    /// }
    /// </summary>
    [StrategyKey("focus-time-ratio")]
    public sealed class FocusTimeRatioStrategy : ITransformationStrategy
    {
        private readonly ILogger<FocusTimeRatioStrategy> _logger;

        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger) => _logger = logger;

        public bool CanHandle(TransformContext context)
            => string.Equals(context.DataSetId, "focus-time-ratio", StringComparison.OrdinalIgnoreCase);

        public ValueTask<TransformResult> ExecuteAsync(
            TransformContext context,
            CancellationToken cancellationToken = default)
        {
            double focusMinutes = context.Payload.GetProperty("focusMinutes").GetDouble();
            double meetingMinutes = context.Payload.GetProperty("meetingMinutes").GetDouble();

            double ratio = Math.Round(
                meetingMinutes is 0
                    ? 1 // 100% focus if zero meetings.
                    : focusMinutes / (focusMinutes + meetingMinutes),
                4,
                MidpointRounding.AwayFromZero);

            var metrics = new Dictionary<string, double>(StringComparer.OrdinalIgnoreCase)
            {
                ["focus_minutes"]   = focusMinutes,
                ["meeting_minutes"] = meetingMinutes,
                ["focus_ratio"]     = ratio
            };

            _logger.LogInformation(
                "Calculated Focus Ratio = {Ratio:P2} (Focus={Focus}m, Meeting={Meeting}m)",
                ratio, focusMinutes, meetingMinutes);

            return new ValueTask<TransformResult>(new TransformResult(
                context.DataSetId,
                metrics,
                DateTimeOffset.UtcNow));
        }
    }

    /// <summary>
    /// Calculates Deployment Lead-Time in hours based on commit-to-production
    /// timestamps found in repository webhook events.
    ///
    /// {
    ///   "commitTime":      "2023-04-12T07:31:00Z",
    ///   "prodDeployTime":  "2023-04-13T12:09:00Z"
    /// }
    /// </summary>
    [StrategyKey("deployment-lead-time")]
    public sealed class DeploymentLeadTimeStrategy : ITransformationStrategy
    {
        private readonly ILogger<DeploymentLeadTimeStrategy> _logger;

        public DeploymentLeadTimeStrategy(ILogger<DeploymentLeadTimeStrategy> logger) => _logger = logger;

        public bool CanHandle(TransformContext context)
            => string.Equals(context.DataSetId, "deployment-lead-time", StringComparison.OrdinalIgnoreCase);

        public ValueTask<TransformResult> ExecuteAsync(
            TransformContext context,
            CancellationToken cancellationToken = default)
        {
            DateTime commitTime = DateTime.Parse(
                context.Payload.GetProperty("commitTime").GetString()!,
                CultureInfo.InvariantCulture,
                DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal);

            DateTime prodTime = DateTime.Parse(
                context.Payload.GetProperty("prodDeployTime").GetString()!,
                CultureInfo.InvariantCulture,
                DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal);

            double hours = Math.Round((prodTime - commitTime).TotalHours, 2);

            var metrics = new Dictionary<string, double>(StringComparer.OrdinalIgnoreCase)
            {
                ["lead_time_hours"] = hours
            };

            _logger.LogInformation(
                "Deployment Lead-Time computed: {Hours}h (Commit={Commit}, Prod={Prod})",
                hours, commitTime, prodTime);

            return new ValueTask<TransformResult>(new TransformResult(
                context.DataSetId,
                metrics,
                DateTimeOffset.UtcNow));
        }
    }

    #endregion
}
```