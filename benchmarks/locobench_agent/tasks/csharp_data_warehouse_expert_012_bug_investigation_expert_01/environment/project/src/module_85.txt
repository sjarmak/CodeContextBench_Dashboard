```csharp
// ---------------------------------------------------------------------------------------------------------------------
//  File:        module_85.cs   (autogenerated — do not edit by hand)
//  Project:     PulseOps Warehouse — Serverless Productivity Intelligence Fabric
// ---------------------------------------------------------------------------------------------------------------------
//  Description:
//      Implements a Transformation-Strategy that calculates the “Meeting-Cost Index” KPI.  The index measures the
//      aggregate cost, per business-day, of all video/physical meetings by multiplying the meeting duration with the
//      fully-loaded hourly compensation of every attendee.
//
//      ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
//      │   KPI Formula                                                                                               │
//      │   ───────────                                                                                               │
//      │   cost(meeting)      =  duration_hours  ×  Σ attendees[ hourly_rate(attendee) ]                              │
//      │   cost(index, day)   =  Σ day_meetings[ cost(meeting) ]                                                      │
//      │   avg(attendee_cost) =  cost(index, day) ÷ Σ day_meetings[ attendee_count(meeting) ]                         │
//      └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
//      • Missing salary data is back-filled with the organisation’s median hourly rate.
//      • All calculations are performed in UTC.  Presentation layers are responsible for time-zone conversions.
//      • Uses asynchronous fan-out to the ICompensationProvider to maximise throughput when resolving salaries.
// ---------------------------------------------------------------------------------------------------------------------
//  Change-log:
//      2024-06-04  Initial version
// ---------------------------------------------------------------------------------------------------------------------

#pragma warning disable CS1998 // Async method lacks 'await' operators (some branches intentionally synchronous)
#pragma warning disable CA1031 // Do not catch general exception types

using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.KpiStrategies
{
    #region ----- Public Contracts -------------------------------------------------------------------------------

    /// <summary>
    /// Defines a single-input → single-output asynchronous transformation contract used throughout the warehouse.
    /// </summary>
    public interface ITransformationStrategy<in TInput, TOutput>
    {
        /// <summary>
        /// Transforms <paramref name="input"/> into <typeparamref name="TOutput"/> asynchronously.
        /// </summary>
        ValueTask<TOutput> TransformAsync(TInput input, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Abstracts the source-of-truth for employee compensation details (e.g., Workday, SAP, BambooHR, etc.).
    /// </summary>
    public interface ICompensationProvider
    {
        /// <summary>
        /// Retrieves the annual salary (in the organisation’s default currency) for <paramref name="employeeId"/>.
        /// Returns <c>null</c> when the record could not be found.
        /// </summary>
        Task<decimal?> GetAnnualSalaryAsync(string employeeId, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Lightweight, canonical representation of an individual calendared meeting.
    /// </summary>
    public sealed record MeetingEvent(
        string MeetingId,
        DateTimeOffset StartUtc,
        DateTimeOffset EndUtc,
        IReadOnlyCollection<string> AttendeeEmployeeIds
    );

    /// <summary>
    /// Captures the aggregate cost profile of all meetings that occurred on a particular day.
    /// </summary>
    public sealed record MeetingCostIndexAggregate
    (
        DateOnly BusinessDateUtc,
        decimal TotalCost,
        decimal AverageCostPerAttendee,
        int    TotalMeetings,
        int    TotalAttendees
    );

    #endregion

    #region ----- Strategy Implementation ------------------------------------------------------------------------

    /// <summary>
    /// Calculates the “Meeting-Cost Index” KPI over a batch of <see cref="MeetingEvent"/> instances.
    /// </summary>
    public sealed class MeetingCostIndexStrategy : ITransformationStrategy<IReadOnlyCollection<MeetingEvent>, MeetingCostIndexAggregate>
    {
        private const decimal AverageWorkingHoursPerYear = 2080m;          // 52 weeks × 40-hour week
        private readonly ICompensationProvider           _compProvider;
        private readonly ILogger<MeetingCostIndexStrategy> _logger;

        // Cache ensures we only resolve compensation once per execution context.
        private readonly ConcurrentDictionary<string, decimal?> _hourlyRateCache = new();

        // Fallback median hourly rate when compensation cannot be resolved.
        private volatile decimal? _medianHourlyRateCache;

        public MeetingCostIndexStrategy(
            ICompensationProvider compProvider,
            ILogger<MeetingCostIndexStrategy> logger)
        {
            _compProvider = compProvider  ?? throw new ArgumentNullException(nameof(compProvider));
            _logger       = logger        ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async ValueTask<MeetingCostIndexAggregate> TransformAsync(
            IReadOnlyCollection<MeetingEvent> input,
            CancellationToken                 cancellationToken = default)
        {
            if (input == null || input.Count == 0)
                throw new ArgumentException("Transformation input cannot be null or empty.", nameof(input));

            // Validate homogeneity of the business date.
            var businessDate = DateOnly.FromDateTime(input.First().StartUtc.UtcDateTime);
            if (input.Any(m => DateOnly.FromDateTime(m.StartUtc.UtcDateTime) != businessDate))
                throw new InvalidOperationException("Input collection must contain meetings for exactly one business date.");

            // Resolve hourly rates for all unique attendees (fan-out for concurrency).
            var uniqueEmployeeIds = input
               .SelectMany(m => m.AttendeeEmployeeIds)
               .Distinct()
               .ToList();

            await FanOutCompensationLookupAsync(uniqueEmployeeIds, cancellationToken).ConfigureAwait(false);

            // Compute KPI
            var kpi = ComputeAggregate(input, businessDate);

            _logger.LogInformation(
                CultureInfo.InvariantCulture,
                "Meeting-Cost Index computed for {BusinessDate} — TotalCost={TotalCost:C}, Meetings={TotalMeetings}",
                businessDate, kpi.TotalCost, kpi.TotalMeetings);

            return kpi;
        }

        #endregion

        #region ----- Private Helpers ------------------------------------------------------------------------------

        private async Task FanOutCompensationLookupAsync(
            IReadOnlyCollection<string> employeeIds,
            CancellationToken           cancellationToken)
        {
            var missingIds = employeeIds
                 .Where(id => !_hourlyRateCache.ContainsKey(id))
                 .ToList();

            // Nothing to do?  Bail early.
            if (missingIds.Count == 0)
                return;

            var tasks = missingIds.Select(async id =>
            {
                try
                {
                    var annualSalary = await _compProvider.GetAnnualSalaryAsync(id, cancellationToken)
                                                          .ConfigureAwait(false);

                    // Convert to fully-loaded hourly rate.
                    _hourlyRateCache[id] = annualSalary.HasValue
                        ? Math.Round(annualSalary.Value / AverageWorkingHoursPerYear, 2, MidpointRounding.AwayFromZero)
                        : null;
                }
                catch (OperationCanceledException) { throw; }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to resolve compensation for EmployeeId='{EmployeeId}'.", id);
                    _hourlyRateCache[id] = null;
                }
            });

            await Task.WhenAll(tasks).ConfigureAwait(false);

            // Compute/update median fallback if needed.
            var resolvedRates = _hourlyRateCache.Values
                                                .Where(r => r.HasValue)
                                                .Select(r => r!.Value)
                                                .OrderBy(r => r)
                                                .ToArray();

            if (resolvedRates.Length != 0)
            {
                var median = resolvedRates.Length % 2 == 0
                    ? (resolvedRates[resolvedRates.Length / 2 - 1] + resolvedRates[resolvedRates.Length / 2]) / 2
                    : resolvedRates[resolvedRates.Length / 2];

                _medianHourlyRateCache = Math.Round(median, 2, MidpointRounding.AwayFromZero);
            }
        }

        private MeetingCostIndexAggregate ComputeAggregate(
            IEnumerable<MeetingEvent> meetings,
            DateOnly                  businessDate)
        {
            decimal   totalCost       = 0m;
            int       totalAttendees  = 0;
            int       meetingCount    = 0;

            foreach (var meeting in meetings)
            {
                meetingCount++;

                // Meeting duration.
                var durationHours = (decimal)(meeting.EndUtc - meeting.StartUtc).TotalHours;
                if (durationHours <= 0) continue; // Skip invalid events.

                // Sum hourly rate for all attendees.
                decimal rateSum = 0m;
                foreach (var empId in meeting.AttendeeEmployeeIds)
                {
                    var rate = _hourlyRateCache.TryGetValue(empId, out var cached)
                        ? cached
                        : null;

                    rateSum += rate ?? _medianHourlyRateCache ?? 0m;
                }

                totalAttendees += meeting.AttendeeEmployeeIds.Count;
                totalCost      += rateSum * durationHours;
            }

            var averageCostPerAttendee = totalAttendees == 0
                ? 0m
                : totalCost / totalAttendees;

            return new MeetingCostIndexAggregate(
                BusinessDateUtc      : businessDate,
                TotalCost            : Math.Round(totalCost, 2, MidpointRounding.AwayFromZero),
                AverageCostPerAttendee: Math.Round(averageCostPerAttendee, 2, MidpointRounding.AwayFromZero),
                TotalMeetings        : meetingCount,
                TotalAttendees       : totalAttendees);
        }

        #endregion
    }
}
```