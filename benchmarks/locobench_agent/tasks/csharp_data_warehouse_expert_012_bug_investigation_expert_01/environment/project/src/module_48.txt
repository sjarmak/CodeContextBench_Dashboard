```csharp
// -----------------------------------------------------------------------------
// File: src/module_48.txt     (treated as .cs during build)
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
// -----------------------------------------------------------------------------
// Purpose
// -------
// Implements a pluggable Transformation-Strategy dispatcher that calculates
// actionable productivity KPIs (e.g., Focus-Time Ratio, Deployment Lead-Time).
// The dispatcher is designed for:
//   • DI friendliness (constructor injection)
//   • Thread-safety
//   • Resilience (structured error handling & logging)
//   • Runtime extensibility (strategies discoverable via ITransformationStrategy)
//
// This module participates in the overall ETL/Observer pipeline:
//     Kinesis ➜ Lambda (ingest) ➜ Validation ➜ TransformationDispatcher (*this*)
//     ➜ Glue Table Sink ➜ QuickSight dashboard
// -----------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Amazon.Lambda.Core;
using Microsoft.Extensions.Logging;

[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace PulseOps.Warehouse.Transformations
{
    #region Contracts / DTOs

    /// <summary>
    /// Generic KPI output produced by a strategy.
    /// Immutable record to simplify serialization.
    /// </summary>
    public sealed record ProductivityMetric(
        string Name,
        double Value,
        IDictionary<string, string> Dimensions,
        DateTime TimestampUtc);

    /// <summary>
    /// Envelope that accompanies every transform invocation.
    /// Allows strategies to make context-aware decisions
    /// (e.g., tenant-id, feature-flags, user-culture, etc.).
    /// </summary>
    public sealed record TransformationContext(
        string TenantId,
        string CorrelationId,
        DateTime IngestedAtUtc);

    /// <summary>
    /// A single calendar event emitted by SaaS providers (GSuite/O365).
    /// </summary>
    public sealed record CalendarEvent(
        DateTime StartUtc,
        DateTime EndUtc,
        string Subject,
        string[] Attendees,
        string EventSource);

    /// <summary>
    /// A single deployment life-cycle event pair (commit ➜ prod deploy).
    /// </summary>
    public sealed record DeploymentEvent(
        string CommitId,
        DateTime CommitTimeUtc,
        DateTime ProductionDeployTimeUtc,
        string Repository,
        string ServiceName);

    #endregion

    #region Strategy Pattern

    /// <summary>
    /// Marker interface for transformation strategies.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>
        /// Globally unique name for this strategy.  
        /// Used as lookup key in dispatcher and as 'metric name' prefix.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Attempts to perform the transformation asynchronously.
        /// Strategies must be PURE functions w.r.t. input; they may perform
        /// reads, but no writes (side-effect free).
        /// </summary>
        /// <param name="rawPayload">Raw event batch as deserialized object tree</param>
        /// <param name="context">Shared TransformationContext</param>
        /// <param name="cancellationToken">CancellationToken</param>
        /// <returns>Zero or more ProductivityMetrics</returns>
        Task<IReadOnlyCollection<ProductivityMetric>> TransformAsync(
            object rawPayload,
            TransformationContext context,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Calculates ratio of 'focus time' to total scheduled time.
    /// Focus time is any CalendarEvent whose subject contains tag
    /// "[focus]" (case-insensitive) or was created by the "FocusTime" app.
    /// </summary>
    public sealed class FocusTimeRatioStrategy : ITransformationStrategy
    {
        private readonly ILogger<FocusTimeRatioStrategy> _logger;

        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger) =>
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        public string Name => "focus_time_ratio";

        public Task<IReadOnlyCollection<ProductivityMetric>> TransformAsync(
            object rawPayload,
            TransformationContext ctx,
            CancellationToken cancellationToken = default)
        {
            if (rawPayload is not IEnumerable<CalendarEvent> events)
            {
                _logger.LogWarning("Payload is not a CalendarEvent collection, skipping {Strategy}", Name);
                return Task.FromResult<IReadOnlyCollection<ProductivityMetric>>(Array.Empty<ProductivityMetric>());
            }

            var totalMinutes = 0.0;
            var focusMinutes = 0.0;

            foreach (var ev in events)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var minutes = (ev.EndUtc - ev.StartUtc).TotalMinutes;
                totalMinutes += minutes;

                if (IsFocusEvent(ev))
                {
                    focusMinutes += minutes;
                }
            }

            if (totalMinutes <= 0.01)
            {
                _logger.LogDebug("No calendar time registered for tenant {Tenant}", ctx.TenantId);
                return Task.FromResult<IReadOnlyCollection<ProductivityMetric>>(Array.Empty<ProductivityMetric>());
            }

            var ratio = focusMinutes / totalMinutes;

            var metric = new ProductivityMetric(
                Name: "focus_time_ratio",
                Value: Math.Round(ratio, 4),
                Dimensions: new Dictionary<string, string>
                {
                    ["tenant"] = ctx.TenantId
                },
                TimestampUtc: ctx.IngestedAtUtc);

            return Task.FromResult<IReadOnlyCollection<ProductivityMetric>>(new[] { metric });
        }

        private static bool IsFocusEvent(CalendarEvent ev)
            => ev.Subject.Contains("[focus]", StringComparison.OrdinalIgnoreCase)
               || ev.EventSource.Equals("FocusTime", StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Calculates lead-time (in hours) between commit and production deployment.
    /// </summary>
    public sealed class DeploymentLeadTimeStrategy : ITransformationStrategy
    {
        private readonly ILogger<DeploymentLeadTimeStrategy> _logger;

        public DeploymentLeadTimeStrategy(ILogger<DeploymentLeadTimeStrategy> logger) =>
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        public string Name => "deployment_lead_time";

        public Task<IReadOnlyCollection<ProductivityMetric>> TransformAsync(
            object rawPayload,
            TransformationContext ctx,
            CancellationToken cancellationToken = default)
        {
            if (rawPayload is not IEnumerable<DeploymentEvent> events)
            {
                _logger.LogWarning("Payload is not a DeploymentEvent collection, skipping {Strategy}", Name);
                return Task.FromResult<IReadOnlyCollection<ProductivityMetric>>(Array.Empty<ProductivityMetric>());
            }

            var metrics = new List<ProductivityMetric>();

            foreach (var ev in events)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var leadTimeHours = (ev.ProductionDeployTimeUtc - ev.CommitTimeUtc).TotalHours;

                if (leadTimeHours < 0)
                {
                    _logger.LogWarning("Negative lead-time for commit {CommitId}", ev.CommitId);
                    continue; // Data quality safeguard
                }

                metrics.Add(new ProductivityMetric(
                    Name: "deployment_lead_time",
                    Value: Math.Round(leadTimeHours, 2),
                    Dimensions: new Dictionary<string, string>
                    {
                        ["tenant"]     = ctx.TenantId,
                        ["repository"] = ev.Repository,
                        ["service"]    = ev.ServiceName
                    },
                    TimestampUtc: ev.ProductionDeployTimeUtc));
            }

            return Task.FromResult<IReadOnlyCollection<ProductivityMetric>>(metrics);
        }
    }

    #endregion

    #region Dispatcher (Strategy Registry + Orchestrator)

    /// <summary>
    /// Resolves appropriate transformation strategies and fans-out processing.
    /// Observes the Observer Pattern by acting as an event sink for upstream
    /// validators and as an event source for downstream sinks (Glue writer).
    /// </summary>
    public sealed class TransformationStrategyDispatcher
    {
        private readonly IReadOnlyDictionary<string, ITransformationStrategy> _strategies;
        private readonly ILogger<TransformationStrategyDispatcher> _logger;

        public TransformationStrategyDispatcher(
            IEnumerable<ITransformationStrategy> strategies,
            ILogger<TransformationStrategyDispatcher> logger)
        {
            if (strategies == null) throw new ArgumentNullException(nameof(strategies));

            _strategies = strategies.ToDictionary(s => s.Name, StringComparer.OrdinalIgnoreCase);
            _logger     = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Executes one or many strategies against <paramref name="payload"/>.
        /// The strategy is looked up by <paramref name="strategyName"/>.
        /// </summary>
        public async Task<IReadOnlyCollection<ProductivityMetric>> DispatchAsync(
            string strategyName,
            object payload,
            TransformationContext context,
            CancellationToken cancellationToken = default)
        {
            if (!_strategies.TryGetValue(strategyName, out var strategy))
            {
                _logger.LogError("Strategy '{Strategy}' not registered.", strategyName);
                throw new InvalidOperationException($"Unknown strategy '{strategyName}'.");
            }

            try
            {
                _logger.LogDebug("Executing strategy {Strategy} for tenant {Tenant}",
                    strategyName, context.TenantId);

                var result = await strategy.TransformAsync(payload, context, cancellationToken)
                                           .ConfigureAwait(false);

                _logger.LogInformation("Strategy {Strategy} produced {MetricCount} metrics",
                    strategyName, result.Count);

                return result;
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("Strategy {Strategy} cancelled for tenant {Tenant}",
                    strategyName, context.TenantId);
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Strategy {Strategy} failed for tenant {Tenant}: {Message}",
                    strategyName, context.TenantId, ex.Message);
                throw; // Bubble up to DLQ handling
            }
        }

        /// <summary>
        /// Convenience fan-out across all registered strategies.
        /// Useful for batch off-line back-fills.
        /// </summary>
        public async Task<IReadOnlyCollection<ProductivityMetric>> DispatchAllAsync(
            object payload,
            TransformationContext context,
            CancellationToken cancellationToken = default)
        {
            var metricsBag = new ConcurrentBag<ProductivityMetric>();

            await Parallel.ForEachAsync(_strategies.Values, cancellationToken,
                async (strategy, token) =>
                {
                    var m = await strategy.TransformAsync(payload, context, token)
                                          .ConfigureAwait(false);
                    foreach (var metric in m)
                        metricsBag.Add(metric);
                });

            _logger.LogInformation("Dispatched {Count} strategies and produced {MetricTotal} metrics",
                _strategies.Count, metricsBag.Count);

            return metricsBag.ToArray();
        }
    }

    #endregion
}
```