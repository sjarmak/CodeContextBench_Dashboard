```csharp
// File: src/module_42.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//
// Purpose:
// --------
// Implements the Focus-Time Ratio KPI transformation using the Strategy pattern.
// The strategy consumes a heterogeneous event stream (calendar & activity events),
// derives the ratio between “focus” (non-meeting) time and total working hours
// for each knowledge worker, and emits an immutable KPI result set.
//
// NOTE: Although this lives in a .txt file per exercise constraints, the content
// is valid C# and can be compiled as-is.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace PulseOps.Warehouse.Transformations.Strategies
{
    #region Public Contracts ─────────────────────────────────────────────────────

    /// <summary>
    /// Generic contract for any KPI computation strategy within PulseOps Warehouse.
    /// </summary>
    public interface IKpiComputationStrategy
    {
        /// <summary>
        /// Computes a KPI for the supplied <paramref name="events"/> constrained to
        /// a <paramref name="range"/> window.
        /// </summary>
        /// <param name="events">The raw event stream (calendar, commits, etc.).</param>
        /// <param name="range">Window to which KPI computation is scoped.</param>
        /// <param name="token">Cancellation token for cooperative cancellation.</param>
        /// <returns>Computed KPI result set.</returns>
        Task<IReadOnlyCollection<KpiComputationResult>> ComputeAsync(
            IEnumerable<IEvent> events,
            TimeRange range,
            CancellationToken token = default);
    }

    /// <summary>
    /// Immutable KPI computation result.
    /// </summary>
    /// <param name="UserId">Knowledge worker identifier.</param>
    /// <param name="KpiName">Canonical KPI name.</param>
    /// <param name="Value">Computed KPI value (normalized 0-1 when applicable).</param>
    /// <param name="ComputedAtUtc">Timestamp when KPI got calculated.</param>
    public sealed record KpiComputationResult(
        string UserId,
        string KpiName,
        double Value,
        DateTimeOffset ComputedAtUtc);

    #endregion

    #region Domain Model ─────────────────────────────────────────────────────────

    /// <summary>
    /// Contract every ingested event implements.  The union of event sub-classes forms
    /// the event-stream schema for the PulseOps data lake.
    /// </summary>
    public interface IEvent
    {
        string UserId { get; }
        DateTimeOffset Timestamp { get; }
    }

    /// <summary>
    /// Calendar meeting event as synced via Graph/Google APIs.
    /// </summary>
    public sealed record MeetingEvent(
        string UserId,
        DateTimeOffset StartUtc,
        DateTimeOffset EndUtc,
        string Title) : IEvent
    {
        public DateTimeOffset Timestamp => StartUtc;

        public TimeSpan Duration => EndUtc - StartUtc;
    }

    /// <summary>
    /// Convenience value-object representing an inclusive time range.
    /// </summary>
    public readonly struct TimeRange
    {
        public TimeRange(DateTimeOffset startUtc, DateTimeOffset endUtc)
        {
            if (endUtc < startUtc)
                throw new ArgumentException(
                    "End must be greater than or equal to Start.", nameof(endUtc));

            StartUtc = startUtc;
            EndUtc = endUtc;
        }

        public DateTimeOffset StartUtc { get; }
        public DateTimeOffset EndUtc { get; }

        public TimeSpan Span => EndUtc - StartUtc;

        public override string ToString() =>
            FormattableString.Invariant($"[{StartUtc:u} – {EndUtc:u}]");
    }

    #endregion

    #region Strategy Implementation ──────────────────────────────────────────────

    /// <summary>
    /// Computes the Focus-Time Ratio KPI:
    ///     focusTime / totalWorkingTime
    ///
    /// Working-time is approximated as weekdays 08:00-18:00 in the user’s locale.
    /// Calendar meeting events subtract from focus time.  Remaining slice is considered
    /// “deep work / flow / focus” time.
    ///
    /// Assumes the incoming event stream is reasonably bounded (< ~10k events per user
    /// within the requested range); otherwise, pagination/stream-processing should be
    /// preferred.
    /// </summary>
    public sealed class FocusTimeRatioStrategy : IKpiComputationStrategy
    {
        public const string KpiName = "focus_time_ratio";

        private const int WorkdayStartHour = 8;
        private const int WorkdayEndHour   = 18;

        private readonly ITimeZoneProvider _timeZoneProvider;
        private readonly CultureInfo _culture = CultureInfo.InvariantCulture;

        public FocusTimeRatioStrategy(ITimeZoneProvider timeZoneProvider)
        {
            _timeZoneProvider = timeZoneProvider ??
                throw new ArgumentNullException(nameof(timeZoneProvider));
        }

        public async Task<IReadOnlyCollection<KpiComputationResult>> ComputeAsync(
            IEnumerable<IEvent> events,
            TimeRange range,
            CancellationToken token = default)
        {
            ArgumentNullException.ThrowIfNull(events);

            // Convert to materialized list only once since we need multi-pass enumeration.
            var materialized = events as IList<IEvent> ?? events.ToList();

            // Partition by user; PLINQ retains order-agnostic concurrency.
            var results = new ConcurrentBag<KpiComputationResult>();

            await Task.Run(() =>
            {
                materialized
                    .GroupBy(e => e.UserId)
                    .AsParallel()
                    .WithCancellation(token)
                    .ForAll(userGroup =>
                    {
                        var userId = userGroup.Key;
                        var tz = _timeZoneProvider.Resolve(userId);

                        var workIntervals =
                            BuildWorkIntervals(range, tz)
                                .ToList(); // usually small (days in range)

                        // Meeting events within range for the user.
                        var meetings = userGroup
                            .OfType<MeetingEvent>()
                            .Where(m => m.EndUtc >= range.StartUtc && m.StartUtc <= range.EndUtc)
                            .Select(m => new Interval(m.StartUtc, m.EndUtc))
                            .ToList();

                        var totalWorking = TimeSpan.Zero;
                        var totalMeeting = TimeSpan.Zero;

                        foreach (var work in workIntervals)
                        {
                            totalWorking += work.Duration;

                            // Overlap each work interval with all meetings.
                            foreach (var meet in meetings)
                            {
                                totalMeeting += work.Intersection(meet).Duration;
                            }
                        }

                        // Guard against negative or zero division.
                        if (totalWorking <= TimeSpan.Zero)
                            return;

                        var focusTime = totalWorking - totalMeeting;
                        var ratio = Clamp(focusTime.TotalSeconds / totalWorking.TotalSeconds);

                        results.Add(new KpiComputationResult(
                            userId,
                            KpiName,
                            ratio,
                            DateTimeOffset.UtcNow));
                    });
            }, token).ConfigureAwait(false);

            return results.ToArray();
        }

        #region Helper Logic ─────────────────────────────────────────────────────

        private static double Clamp(double value, double min = 0d, double max = 1d) =>
            value switch
            {
                < 0d => min,
                > 1d => max,
                _    => value
            };

        /// <summary>
        /// Emits one work-interval per business day, in UTC, for the specified user.
        /// Local daylight shifts are respected via <see cref="TimeZoneInfo"/>.
        /// </summary>
        private IEnumerable<Interval> BuildWorkIntervals(TimeRange range, TimeZoneInfo tz)
        {
            // Align to midnight of start date in user's timezone.
            var startLocal = TimeZoneInfo.ConvertTime(range.StartUtc, tz).Date;
            var endLocal   = TimeZoneInfo.ConvertTime(range.EndUtc,   tz).Date;

            for (var day = startLocal; day <= endLocal; day = day.AddDays(1))
            {
                // Skip weekends.
                if (day.DayOfWeek is DayOfWeek.Saturday or DayOfWeek.Sunday)
                    continue;

                var localWorkStart = day.AddHours(WorkdayStartHour);
                var localWorkEnd   = day.AddHours(WorkdayEndHour);

                var utcWorkStart = TimeZoneInfo.ConvertTimeToUtc(localWorkStart, tz);
                var utcWorkEnd   = TimeZoneInfo.ConvertTimeToUtc(localWorkEnd,   tz);

                var work = new Interval(utcWorkStart, utcWorkEnd);

                // Crop to global range.
                yield return work.Intersection(new Interval(range.StartUtc, range.EndUtc));
            }
        }

        #endregion
    }

    #endregion

    #region Utilities ────────────────────────────────────────────────────────────

    /// <summary>
    /// Value-object representing a half-open time interval [Start, End).
    /// </summary>
    internal readonly struct Interval
    {
        public Interval(DateTimeOffset startUtc, DateTimeOffset endUtc)
        {
            if (endUtc < startUtc)
                throw new ArgumentException("endUtc must be >= startUtc");

            StartUtc = startUtc;
            EndUtc = endUtc;
        }

        public DateTimeOffset StartUtc { get; }
        public DateTimeOffset EndUtc { get; }
        public TimeSpan Duration => EndUtc - StartUtc;

        /// <summary>
        /// Intersection between two intervals.  Returns <see cref="Interval.Empty"/>
        /// when no overlap exists.
        /// </summary>
        public Interval Intersection(in Interval other)
        {
            var start = StartUtc > other.StartUtc ? StartUtc : other.StartUtc;
            var end   = EndUtc   < other.EndUtc   ? EndUtc   : other.EndUtc;

            return end <= start ? Empty : new Interval(start, end);
        }

        public bool IsEmpty => Duration == TimeSpan.Zero;

        public static Interval Empty => new(DateTimeOffset.MinValue, DateTimeOffset.MinValue);

        public override string ToString() =>
            FormattableString.Invariant($"[{StartUtc:u} – {EndUtc:u}]");
    }

    /// <summary>
    /// Abstracts user-to-time-zone resolution (LDAP, HRIS, etc.).
    /// </summary>
    public interface ITimeZoneProvider
    {
        /// <summary>
        /// Resolves the preferred <see cref="TimeZoneInfo"/> for a user.
        /// Implementations should cache results aggressively—lookups can be expensive.
        /// </summary>
        TimeZoneInfo Resolve(string userId);
    }

    #endregion
}
```