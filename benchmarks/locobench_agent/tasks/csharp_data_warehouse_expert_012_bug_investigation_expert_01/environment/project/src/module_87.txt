```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Amazon;
using Amazon.DynamoDBv2;
using Amazon.DynamoDBv2.DocumentModel;
using Amazon.Kinesis;
using Amazon.Kinesis.Model;
using Amazon.Lambda.Core;
using Amazon.Lambda.KinesisEvents;
using Amazon.Runtime;
using Newtonsoft.Json;
using Serilog;

// Assembly attribute to enable the Lambda function's JSON input to be converted into a .NET class.
[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace PulseOpsWarehouse.Transformations
{
    /// <summary>
    /// Metric KPIs supported by the PulseOps Warehouse.  Each KPI has its own
    /// ITransformationStrategy implementation that can be discovered at runtime.
    /// </summary>
    public enum MetricType
    {
        FocusTimeRatio,
        DeploymentLeadTime,
        MeetingCostIndex
    }

    #region Models

    /// <summary>
    /// Untyped inbound recordâ€”raw material before any business logic is applied.
    /// May originate from Kinesis, S3, EventBridge, etc.
    /// </summary>
    public sealed class RawRecord
    {
        public string SourceSystem { get; init; } = default!;
        public DateTimeOffset Timestamp { get; init; }
        public string PayloadJson { get; init; } = default!;
        public MetricType MetricHint { get; init; }
    }

    /// <summary>
    /// Strongly-typed transformation output ready to be persisted downstream.
    /// </summary>
    public sealed class TransformedRecord
    {
        public string PartitionKey { get; init; } = default!;
        public DateTimeOffset EventDate { get; init; }
        public MetricType MetricType { get; init; }
        public IDictionary<string, object> CalculatedFields { get; init; } = new Dictionary<string, object>();
    }

    #endregion

    #region Strategy Pattern

    /// <summary>
    /// Contract for all metric-transformation strategies.
    /// A single-record-in, single-record-out functional abstraction facilitates
    /// pluggable business rules while keeping concurrency concerns outside.
    /// </summary>
    public interface ITransformationStrategy
    {
        Task<TransformedRecord> TransformAsync(RawRecord rawRecord, CancellationToken token = default);
    }

    /// <summary>
    /// Calculates focus-time ratio KPI from calendar/IDE activity signals.
    /// </summary>
    public sealed class FocusTimeRatioStrategy : ITransformationStrategy
    {
        public Task<TransformedRecord> TransformAsync(RawRecord rawRecord, CancellationToken token = default)
        {
            dynamic payload = JsonConvert.DeserializeObject(rawRecord.PayloadJson)!;
            double deepWorkMinutes = payload.deepWorkMinutes;
            double totalMinutes    = payload.totalMinutes;

            double ratio = totalMinutes == 0 ? 0 : deepWorkMinutes / totalMinutes;

            return Task.FromResult(new TransformedRecord
            {
                PartitionKey      = $"{payload.userId}_{rawRecord.Timestamp:yyyyMMdd}",
                EventDate         = rawRecord.Timestamp,
                MetricType        = MetricType.FocusTimeRatio,
                CalculatedFields  = new Dictionary<string, object>
                {
                    ["FocusTimeRatio"] = ratio,
                    ["DeepWorkMinutes"]= deepWorkMinutes,
                    ["TotalMinutes"]   = totalMinutes
                }
            });
        }
    }

    /// <summary>
    /// Calculates deployment lead-time KPI from CI/CD telemetry events.
    /// </summary>
    public sealed class DeploymentLeadTimeStrategy : ITransformationStrategy
    {
        public Task<TransformedRecord> TransformAsync(RawRecord rawRecord, CancellationToken token = default)
        {
            dynamic payload = JsonConvert.DeserializeObject(rawRecord.PayloadJson)!;
            DateTimeOffset commitTime = payload.commitTime;
            DateTimeOffset prodTime   = payload.prodDeployTime;

            return Task.FromResult(new TransformedRecord
            {
                PartitionKey     = $"{payload.repo}_{commitTime:yyyyMMdd}",
                EventDate        = prodTime,
                MetricType       = MetricType.DeploymentLeadTime,
                CalculatedFields = new Dictionary<string, object>
                {
                    ["LeadTimeHours"] = (prodTime - commitTime).TotalHours,
                    ["CommitSha"]     = payload.commitSha
                }
            });
        }
    }

    /// <summary>
    /// Calculates meeting cost index KPI from calendar & salary band metadata.
    /// </summary>
    public sealed class MeetingCostIndexStrategy : ITransformationStrategy
    {
        private const double AverageWorkingDaysPerYear = 235;
        private const int    MinutesPerDay             = 480;

        public Task<TransformedRecord> TransformAsync(RawRecord rawRecord, CancellationToken token = default)
        {
            dynamic payload   = JsonConvert.DeserializeObject(rawRecord.PayloadJson)!;
            double hourlyRate = payload.hourlyRate;
            int    attendees  = payload.attendees;
            double duration   = payload.durationMinutes;

            double cost = (hourlyRate / 60) * duration * attendees;

            return Task.FromResult(new TransformedRecord
            {
                PartitionKey     = $"{payload.organizer}_{rawRecord.Timestamp:yyyyMMddHHmm}",
                EventDate        = rawRecord.Timestamp,
                MetricType       = MetricType.MeetingCostIndex,
                CalculatedFields = new Dictionary<string, object>
                {
                    ["MeetingCostUsd"] = cost,
                    ["DurationMinutes"]= duration,
                    ["Attendees"]      = attendees
                }
            });
        }
    }

    /// <summary>
    /// Factory resolves correct strategy implementation at runtime.
    /// Thread-safe via lazy static initialization.
    /// </summary>
    public static class TransformationStrategyFactory
    {
        private static readonly ConcurrentDictionary<MetricType, ITransformationStrategy> Cache =
            new ConcurrentDictionary<MetricType, ITransformationStrategy>();

        public static ITransformationStrategy Resolve(MetricType metricType) =>
            Cache.GetOrAdd(metricType, t => t switch
            {
                MetricType.FocusTimeRatio      => new FocusTimeRatioStrategy(),
                MetricType.DeploymentLeadTime  => new DeploymentLeadTimeStrategy(),
                MetricType.MeetingCostIndex    => new MeetingCostIndexStrategy(),
                _                              => throw new NotSupportedException($"Unsupported metric {t}.")
            });
    }

    #endregion

    #region Persistence

    /// <summary>
    /// Responsible for persisting transformed records into DynamoDB.
    /// </summary>
    public interface IRecordRepository
    {
        Task SaveAsync(TransformedRecord record, CancellationToken token = default);
    }

    /// <summary>
    /// DynamoDB implementation of IRecordRepository.
    /// Uses single-table design (PK + SK) optimized for analytics access patterns.
    /// </summary>
    public sealed class DynamoRecordRepository : IRecordRepository, IDisposable
    {
        private readonly AmazonDynamoDBClient _client;
        private readonly Table                _table;

        public DynamoRecordRepository(string tableName, AWSCredentials? credentials = null, RegionEndpoint? region = null)
        {
            _client = credentials == null
                ? new AmazonDynamoDBClient(region ?? RegionEndpoint.USEast1)
                : new AmazonDynamoDBClient(credentials, region ?? RegionEndpoint.USEast1);

            _table = Table.LoadTable(_client, tableName);
        }

        public async Task SaveAsync(TransformedRecord record, CancellationToken token = default)
        {
            var doc = new Document
            {
                ["PK"]             = record.PartitionKey,
                ["SK"]             = $"{record.MetricType}_{record.EventDate:O}",
                ["MetricType"]     = record.MetricType.ToString(),
                ["EventDate"]      = record.EventDate.ToUniversalTime(),
                ["CalculatedJson"] = JsonConvert.SerializeObject(record.CalculatedFields),
                ["TTL"]            = DateTimeOffset.UtcNow.AddMonths(13).ToUnixTimeSeconds()
            };

            await _table.PutItemAsync(doc, token);
        }

        public void Dispose()
        {
            _client.Dispose();
        }
    }

    #endregion

    #region Lambda Entrypoint

    /// <summary>
    /// AWS Lambda entrypoint wired to a Kinesis stream (fan-out shards).
    /// Each record is processed individually to ensure partial failure isolation.
    /// Upstream Kinesis retry policy + DLQ will handle poison pills.
    /// </summary>
    public sealed class KinesisTransformationFunction : IDisposable
    {
        private readonly IRecordRepository _repository;
        private readonly ILogger           _logger;

        public KinesisTransformationFunction()
        {
            // Serilog configuration can be extended via environment variables at runtime.
            _logger = new LoggerConfiguration()
                      .Enrich.FromLogContext()
                      .WriteTo.Console()
                      .CreateLogger();

            var tableName = Environment.GetEnvironmentVariable("WAREHOUSE_TABLE_NAME")
                ?? throw new InvalidOperationException("WAREHOUSE_TABLE_NAME env-var is not set.");

            _repository = new DynamoRecordRepository(tableName);
            _logger.Information("KinesisTransformationFunction initialized for table {TableName}.", tableName);
        }

        /// <summary>
        /// Lambda handler automatically invoked by AWS Kinesis trigger.
        /// </summary>
        public async Task HandlerAsync(KinesisEvent kinesisEvent, ILambdaContext context)
        {
            var tasks = new List<Task>();

            foreach (var record in kinesisEvent.Records)
            {
                tasks.Add(ProcessRecordAsync(record, context.CancellationToken));
            }

            await Task.WhenAll(tasks);
        }

        private async Task ProcessRecordAsync(KinesisEvent.KinesisEventRecord record, CancellationToken token)
        {
            try
            {
                RawRecord raw = DeserializeRawRecord(record);
                _logger.Debug("Processing raw record {@RawRecord}.", raw);

                // Choose strategy & transform
                var strategy = TransformationStrategyFactory.Resolve(raw.MetricHint);
                TransformedRecord transformed = await strategy.TransformAsync(raw, token);

                // Persist
                await _repository.SaveAsync(transformed, token);
                _logger.Information("Successfully processed metric {MetricType} with PK={PK}.",
                                    transformed.MetricType, transformed.PartitionKey);
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Failed to process Kinesis record with sequence {Seq}.",
                              record.Kinesis.SequenceNumber);
                // Bubble up; Lambda + Kinesis will re-attempt or route to DLQ.
                throw;
            }
        }

        private static RawRecord DeserializeRawRecord(KinesisEvent.KinesisEventRecord record)
        {
            string json = Encoding.UTF8.GetString(record.Kinesis.Data.Span);
            return JsonConvert.DeserializeObject<RawRecord>(json)
                   ?? throw new InvalidDataException("Unable to deserialize RawRecord.");
        }

        public void Dispose()
        {
            (_repository as IDisposable)?.Dispose();
            ( _logger       as IDisposable)?.Dispose();
        }
    }

    #endregion
}
```