```csharp
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.KpiStrategies
{
    /// <summary>
    ///     Computes the Meeting Cost Index KPI – the total dollar amount a meeting series costs
    ///     the organization, normalized to the number of focus-hours it cannibalizes.
    ///     
    ///     Formula:
    ///         Index = ( Σ (durationHours × blendedHourlyRate) ) / focusHoursLost
    ///     
    ///     A value &gt; 1 indicates that people spend more money attending the meeting than the
    ///     focus-hours they lose, signalling possible inefficiency.
    ///
    ///     This strategy is invoked by the Strategy Pattern plugged in at runtime by the
    ///     KPI-Orchestrator Lambda.  All dependencies are injected through the ASP.NET‐
    ///     compatible DI container spun up by Lambdabot™ bootstrap.
    /// </summary>
    public sealed class MeetingCostIndexStrategy : IKpiComputationStrategy
    {
        private readonly ICalendarRepository      _calendarRepository;
        private readonly IUserSalaryProvider      _salaryProvider;
        private readonly IMetricsPublisher        _metricsPublisher;
        private readonly ILogger<MeetingCostIndexStrategy> _logger;

        public string KpiName => "meeting_cost_index";

        public MeetingCostIndexStrategy(
            ICalendarRepository calendarRepository,
            IUserSalaryProvider salaryProvider,
            IMetricsPublisher metricsPublisher,
            ILogger<MeetingCostIndexStrategy> logger)
        {
            _calendarRepository = calendarRepository  ?? throw new ArgumentNullException(nameof(calendarRepository));
            _salaryProvider     = salaryProvider      ?? throw new ArgumentNullException(nameof(salaryProvider));
            _metricsPublisher   = metricsPublisher    ?? throw new ArgumentNullException(nameof(metricsPublisher));
            _logger             = logger              ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<KpiResult> ComputeAsync(
            InputContext context,
            CancellationToken cancellationToken = default)
        {
            if (context == null) throw new ArgumentNullException(nameof(context));

            _logger.LogInformation("Starting KPI computation {Kpi} for tenant {TenantId} over window {Window}",
                KpiName, context.TenantId, context.Window);

            // 1. Fetch meeting events for the time window
            IReadOnlyCollection<MeetingEvent> meetings;
            try
            {
                meetings = await _calendarRepository
                    .GetMeetingsAsync(context.TenantId, context.Window, cancellationToken)
                    .ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Calendar repository threw while fetching meetings");
                throw;
            }

            // 2. Calculate blended hourly cost and focus-hours lost
            decimal totalCost          = 0m;
            double  focusHoursLost     = 0d;

            foreach (var meeting in meetings)
            {
                if (meeting.Attendees is null || meeting.Attendees.Count == 0)
                {
                    _logger.LogDebug("Skipping meeting {MeetingId} with zero attendees", meeting.Id);
                    continue;
                }

                var attendeeRates = await _salaryProvider
                    .GetHourlyRatesAsync(meeting.Attendees, cancellationToken)
                    .ConfigureAwait(false);

                var meetingDurationHours = meeting.Duration.TotalHours;
                focusHoursLost          += meetingDurationHours * meeting.Attendees.Count;

                foreach (var rate in attendeeRates)
                {
                    totalCost += (decimal)meetingDurationHours * rate.HourlyRateUsd;
                }
            }

            // 3. Guard against divide-by-zero
            if (focusHoursLost <= double.Epsilon)
            {
                _logger.LogWarning("No focus hours lost for tenant {TenantId} in window {Window}; returning 0 index",
                    context.TenantId, context.Window);

                return KpiResult.Zero(KpiName, context);
            }

            var index = (double)(totalCost) / focusHoursLost;

            var result = new KpiResult(
                kpiName:      KpiName,
                tenantId:     context.TenantId,
                windowStart:  context.Window.Start,
                windowEnd:    context.Window.End,
                value:        Math.Round(index, 4, MidpointRounding.AwayFromZero),
                computedAt:   DateTimeOffset.UtcNow);

            // 4. Publish for downstream consumers (QuickSight, anomaly detection, etc.)
            try
            {
                await _metricsPublisher.PublishAsync(result, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to publish KPI result {Kpi}", KpiName);
                // Continue – failing to publish should not break the pipeline; DLQ will handle.
            }

            _logger.LogInformation(
                "Computed KPI {Kpi}={Value} for tenant {TenantId} in {Elapsed}ms",
                KpiName,
                result.Value.ToString(CultureInfo.InvariantCulture),
                context.TenantId,
                result.ElapsedMilliseconds);

            return result;
        }
    }

    #region Supporting abstractions & models

    /// <summary>
    ///     Contract for pluggable KPI computation strategies.
    /// </summary>
    public interface IKpiComputationStrategy
    {
        string KpiName { get; }

        /// <summary>
        ///     Executes the KPI computation.
        /// </summary>
        Task<KpiResult> ComputeAsync(InputContext context, CancellationToken cancellationToken = default);
    }

    /// <summary>
    ///     Encapsulates tenant, time window, and additional metadata for KPI runs.
    /// </summary>
    public sealed record InputContext(
        string TenantId,
        TimeWindow Window,
        ImmutableDictionary<string, string>? Dimensions = null)
    {
        public static InputContext ForTodayUtc(string tenantId) =>
            new(tenantId, TimeWindow.TodayUtc, null);
    }

    /// <summary>
    ///     Simple value object representing a time window [Start, End)
    /// </summary>
    public sealed record TimeWindow(DateTimeOffset Start, DateTimeOffset End)
    {
        public static TimeWindow TodayUtc
        {
            get
            {
                var today = DateTime.UtcNow.Date;
                return new TimeWindow(today, today.AddDays(1));
            }
        }

        public override string ToString() => $"{Start:u} – {End:u}";
    }

    /// <summary>
    ///     Standard result object emitted by all KPI strategies.
    /// </summary>
    public sealed record KpiResult(
        string           KpiName,
        string           TenantId,
        DateTimeOffset   WindowStart,
        DateTimeOffset   WindowEnd,
        double           Value,
        DateTimeOffset   ComputedAt)
    {
        public static KpiResult Zero(string kpiName, InputContext ctx) =>
            new(kpiName, ctx.TenantId, ctx.Window.Start, ctx.Window.End, 0, DateTimeOffset.UtcNow);

        public long ElapsedMilliseconds =>
            (long)(ComputedAt - WindowEnd).Duration().TotalMilliseconds;
    }

    /// <summary>
    ///     Domain model for calendar meeting events.
    /// </summary>
    public sealed record MeetingEvent(
        string                Id,
        TimeSpan              Duration,
        IReadOnlyCollection<string> Attendees);

    /// <summary>
    ///     Provides meeting data from O365, Google Workspace, etc.
    /// </summary>
    public interface ICalendarRepository
    {
        Task<IReadOnlyCollection<MeetingEvent>> GetMeetingsAsync(
            string tenantId,
            TimeWindow window,
            CancellationToken ct = default);
    }

    /// <summary>
    ///     Supplies per-user hourly salary rates.
    ///     Implementations typically consult HRIS or a financial system of record.
    /// </summary>
    public interface IUserSalaryProvider
    {
        Task<IReadOnlyList<UserHourlyRate>> GetHourlyRatesAsync(
            IReadOnlyCollection<string> userIds,
            CancellationToken ct = default);
    }

    public sealed record UserHourlyRate(string UserId, decimal HourlyRateUsd);

    /// <summary>
    ///     Publishes KPI results to downstream systems – Kinesis, CloudWatch, QuickSight, etc.
    /// </summary>
    public interface IMetricsPublisher
    {
        Task PublishAsync(KpiResult result, CancellationToken ct = default);
    }

    #endregion
}
```