```csharp
// -------------------------------------------------------------------------------------------------
//  File:        module_51.cs
//  Project:     PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//  Description: Implements a pluggable Strategy-Pattern–based transformation that converts raw
//               calendar events into an analytical “Meeting-Cost Index” metric.  The component is
//               purposely stateless and therefore Lambda/Serverless-friendly.
//
//  NOTE: The file is self-contained for illustration purposes.  In the full PulseOps solution all
//        abstractions (ITransformationStrategy, domain records, etc.) live in dedicated shared
//        libraries and are wired up via Dependency-Injection.
//
//  Author:      PulseOps Engineering
//  -------------------------------------------------------------------------------------------------
#nullable enable
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.MeetingCost
{
    #region Domain Models

    /// <summary>
    /// Raw calendar event emitted by the <c>CalendarIngestionLambda</c>.
    /// </summary>
    /// <param name="Id">Globally unique identifier (GUID v4).</param>
    /// <param name="OrganizerEmail">E-mail of the meeting organizer; doubled as primary owner.</param>
    /// <param name="AttendeeEmails">All invited attendees including organizer.</param>
    /// <param name="StartUtc">Meeting start in UTC.</param>
    /// <param name="EndUtc">Meeting end in UTC.</param>
    /// <param name="IsExternal">True when at least one attendee has a non-corporate domain.</param>
    public sealed record MeetingEvent(
        Guid Id,
        string OrganizerEmail,
        IReadOnlyCollection<string> AttendeeEmails,
        DateTime StartUtc,
        DateTime EndUtc,
        bool IsExternal);

    /// <summary>
    /// Final KPI record that gets persisted to the data-lake parquet table
    /// <c>analytics.meeting_cost_index</c>.
    /// </summary>
    /// <param name="Id">Meeting GUID (source of truth) / partition key.</param>
    /// <param name="CostUsd">Aggregated estimated cost of the meeting expressed in USD.</param>
    /// <param name="DurationMinutes">Duration (EndUtc-StartUtc) in minutes.</param>
    /// <param name="CostModelVersion">Semantic version identifying the cost algorithm.</param>
    /// <param name="GeneratedAtUtc">Time at which the KPI was computed.</param>
    public sealed record MeetingCostRecord(
        Guid Id,
        decimal CostUsd,
        int DurationMinutes,
        string CostModelVersion,
        DateTime GeneratedAtUtc);

    #endregion

    #region Transformation Abstractions

    /// <summary>
    /// Generic contract for transformation strategies inside PulseOps.
    /// </summary>
    /// <typeparam name="TIn">Input record.</typeparam>
    /// <typeparam name="TOut">Output record.</typeparam>
    public interface ITransformationStrategy<in TIn, TOut>
    {
        /// <summary>
        /// Transforms a sequence of <typeparamref name="TIn"/> records into <typeparamref name="TOut"/> KPI
        /// records in a non-blocking fashion.  Implementations must be thread-safe.
        /// </summary>
        Task<IReadOnlyCollection<TOut>> TransformAsync(
            IReadOnlyCollection<TIn> input,
            CancellationToken cancellationToken = default);
    }

    #endregion

    #region Cost-Model Strategies

    /// <summary>
    /// Enumeration of supported meeting cost models.
    /// </summary>
    public enum CostModelType
    {
        SimpleAverage = 0,
        RoleBased = 1,
        GeoAdjusted = 2
    }

    /// <summary>
    /// Strategy for calculating the cost of a single meeting.
    /// </summary>
    internal interface ICostModelStrategy
    {
        string Version { get; }

        /// <summary>
        /// Computes cost in USD for the supplied <paramref name="meeting"/>.
        /// </summary>
        decimal CalculateCost(MeetingEvent meeting);
    }

    /// <summary>
    /// Calculates meeting cost using a company-wide flat hourly rate.
    /// </summary>
    internal sealed class SimpleAverageCostModelStrategy : ICostModelStrategy
    {
        // Flat hourly cost per participant (pulled from Finance KPI).
        private readonly decimal _hourlyRateUsd;

        public SimpleAverageCostModelStrategy(decimal hourlyRateUsd = 75m) =>
            _hourlyRateUsd = hourlyRateUsd;

        public string Version => "simple-average-v1.0.0";

        public decimal CalculateCost(MeetingEvent meeting)
        {
            var durationHours = (decimal)(meeting.EndUtc - meeting.StartUtc).TotalHours;
            if (durationHours <= 0)
                return 0m;

            var participants = meeting.AttendeeEmails.Count;
            return Math.Round(durationHours * participants * _hourlyRateUsd, 2);
        }
    }

    /// <summary>
    /// Calculates meeting cost by mapping an attendee’s role/seniority to a blended hourly rate.
    /// </summary>
    internal sealed class RoleBasedCostModelStrategy : ICostModelStrategy
    {
        private readonly IReadOnlyDictionary<string, decimal> _roleHourlyRateMap;

        public RoleBasedCostModelStrategy(IReadOnlyDictionary<string, decimal>? roleHourlyRateMap = null)
        {
            // Fallback defaults if none are supplied (USD).
            _roleHourlyRateMap = roleHourlyRateMap ?? new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase)
            {
                ["engineer"]       = 85m,
                ["senior engineer"] = 110m,
                ["manager"]        = 125m,
                ["director"]       = 175m,
                ["vp"]             = 235m,
            };
        }

        public string Version => "role-based-v2.1.3";

        // A naive mapping from e-mail alias to role. In production this would query Workday or
        // the company directory.  Kept simple for stand-alone compilation.
        private string ResolveRole(string email)
        {
            var alias = email.Split('@', StringSplitOptions.RemoveEmptyEntries)[0];
            return alias.Contains(".mgr", StringComparison.OrdinalIgnoreCase) ? "manager"
                 : alias.Contains(".dir", StringComparison.OrdinalIgnoreCase) ? "director"
                 : alias.Contains(".vp",  StringComparison.OrdinalIgnoreCase) ? "vp"
                 : "engineer";
        }

        public decimal CalculateCost(MeetingEvent meeting)
        {
            var durationHours = (decimal)(meeting.EndUtc - meeting.StartUtc).TotalHours;
            if (durationHours <= 0)
                return 0m;

            decimal total = 0m;
            foreach (var email in meeting.AttendeeEmails)
            {
                var role = ResolveRole(email);
                var rate = _roleHourlyRateMap.TryGetValue(role, out var val) ? val : _roleHourlyRateMap["engineer"];
                total += rate * durationHours;
            }

            return Math.Round(total, 2);
        }
    }

    /// <summary>
    /// Calculates cost leveraging the geographical location of each attendee (time-zone proxy).
    /// </summary>
    internal sealed class GeoAdjustedCostModelStrategy : ICostModelStrategy
    {
        private readonly IReadOnlyDictionary<string, decimal> _geoHourlyRateMultiplier;

        public GeoAdjustedCostModelStrategy(IReadOnlyDictionary<string, decimal>? geoHourlyRateMultiplier = null)
        {
            // Default multipliers relative to US base rate.
            _geoHourlyRateMultiplier = geoHourlyRateMultiplier ?? new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase)
            {
                ["us"] = 1.0m,
                ["eu"] = 0.9m,
                ["apac"] = 0.75m,
                ["latam"] = 0.6m
            };
        }

        public string Version => "geo-adjusted-v1.4.0";

        private static string ResolveRegion(string email)
        {
            // For demo purposes extract region from TLD (.us, .de, .sg, etc.)
            var domain = email.Split('@').Last();
            var tld = domain.Split('.').Last().ToLowerInvariant();
            return tld switch
            {
                "us" or "com" => "us",
                "de" or "fr" or "uk" => "eu",
                "sg" or "jp" or "au" => "apac",
                "br" or "mx" => "latam",
                _ => "us"
            };
        }

        public decimal CalculateCost(MeetingEvent meeting)
        {
            var durationHours = (decimal)(meeting.EndUtc - meeting.StartUtc).TotalHours;
            if (durationHours <= 0)
                return 0m;

            const decimal baseRateUsd = 75m;
            decimal total = 0m;
            foreach (var email in meeting.AttendeeEmails)
            {
                var region = ResolveRegion(email);
                var multiplier = _geoHourlyRateMultiplier.TryGetValue(region, out var m) ? m : 1.0m;
                total += baseRateUsd * multiplier * durationHours;
            }

            return Math.Round(total, 2);
        }
    }

    /// <summary>
    /// Factory that resolves a concrete cost model based on <see cref="CostModelType"/>.
    /// </summary>
    internal static class CostModelStrategyFactory
    {
        public static ICostModelStrategy Resolve(CostModelType type) =>
            type switch
            {
                CostModelType.SimpleAverage => new SimpleAverageCostModelStrategy(),
                CostModelType.RoleBased     => new RoleBasedCostModelStrategy(),
                CostModelType.GeoAdjusted   => new GeoAdjustedCostModelStrategy(),
                _                            => throw new ArgumentOutOfRangeException(nameof(type), type, null)
            };
    }

    #endregion

    #region Transformation Implementation

    /// <summary>
    /// Transforms <see cref="MeetingEvent"/> streams into <see cref="MeetingCostRecord"/> streams by
    /// delegating cost calculation to a pluggable strategy selected at run-time.
    /// </summary>
    public sealed class MeetingCostTransformationStrategy
        : ITransformationStrategy<MeetingEvent, MeetingCostRecord>
    {
        private readonly ILogger<MeetingCostTransformationStrategy> _logger;
        private readonly ICostModelStrategy _costModel;
        private readonly int _parallelismDegree;

        public MeetingCostTransformationStrategy(
            ILogger<MeetingCostTransformationStrategy> logger,
            CostModelType modelType,
            int parallelismDegree = 4)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _costModel = CostModelStrategyFactory.Resolve(modelType);
            _parallelismDegree = Math.Clamp(parallelismDegree, min: 1, max: Environment.ProcessorCount);
        }

        /// <inheritdoc/>
        public async Task<IReadOnlyCollection<MeetingCostRecord>> TransformAsync(
            IReadOnlyCollection<MeetingEvent> input,
            CancellationToken cancellationToken = default)
        {
            if (input == null) throw new ArgumentNullException(nameof(input));

            if (input.Count == 0)
            {
                _logger.LogDebug("No meeting events supplied, skipping transformation.");
                return Array.Empty<MeetingCostRecord>();
            }

            _logger.LogInformation(
                "Starting Meeting-Cost transformation for {Count} events using {StrategyVersion}.",
                input.Count, _costModel.Version);

            var bag = new ConcurrentBag<MeetingCostRecord>();

            // Use Task.Run with throttling to asynchronously compute costs.
            var throttler = new SemaphoreSlim(_parallelismDegree);
            var tasks = input.Select(async meeting =>
            {
                await throttler.WaitAsync(cancellationToken).ConfigureAwait(false);
                try
                {
                    var cost = _costModel.CalculateCost(meeting);
                    var record = new MeetingCostRecord(
                        Id: meeting.Id,
                        CostUsd: cost,
                        DurationMinutes: (int)(meeting.EndUtc - meeting.StartUtc).TotalMinutes,
                        CostModelVersion: _costModel.Version,
                        GeneratedAtUtc: DateTime.UtcNow);

                    bag.Add(record);

                    if (cost == 0m)
                    {
                        _logger.LogDebug(
                            "Meeting {MeetingId} produced zero cost (possibly invalid duration).", meeting.Id);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to calculate cost for meeting {MeetingId}.", meeting.Id);
                }
                finally
                {
                    throttler.Release();
                }
            }).ToArray();

            await Task.WhenAll(tasks).ConfigureAwait(false);

            var output = bag.ToArray();
            _logger.LogInformation(
                "Meeting-Cost transformation finished. Produced {Count} KPI records.", output.Length);

            return output;
        }
    }

    #endregion
}
```