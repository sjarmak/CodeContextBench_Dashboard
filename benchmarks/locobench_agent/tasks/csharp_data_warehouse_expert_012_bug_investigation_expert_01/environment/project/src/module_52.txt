```csharp
// -------------------------------------------------------------------------------------------------
// File: src/module_52.txt          (yes, text extension – still compiled as C# by the build script)
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
// Description:
//     Reflection-based transformation strategy registry/factory plus one concrete strategy example
// -------------------------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region Contracts & Infrastructure
    /// <summary>
    /// Marker attribute used to declare a class as a transformation strategy.  The <paramref name="id"/>
    /// is used at runtime to resolve the strategy via <see cref="TransformationStrategyFactory"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
    public sealed class TransformationStrategyAttribute : Attribute
    {
        public TransformationStrategyAttribute(string id) => Id = id ?? throw new ArgumentNullException(nameof(id));

        public string Id { get; }
    }

    /// <summary>
    /// Generic contract for a transformation strategy.
    /// </summary>
    /// <typeparam name="TIn">Input DTO type</typeparam>
    /// <typeparam name="TOut">Output DTO type</typeparam>
    public interface ITransformationStrategy<in TIn, TOut>
    {
        /// <summary>
        /// Unique, case-insensitive identifier.  Should match the value used in <see cref="TransformationStrategyAttribute"/>.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// Executes the transformation.
        /// </summary>
        Task<TOut> TransformAsync(TIn input, CancellationToken token = default);
    }

    /// <summary>
    /// Thread-safe factory/registry that resolves strategies by id.  Assemblies are scanned exactly once,
    /// and late-loaded assemblies (think: plug-ins via Lambda Layers) are hooked via <see cref="AppDomain.AssemblyLoad"/>.
    /// </summary>
    public sealed class TransformationStrategyFactory
    {
        private readonly ConcurrentDictionary<string, Lazy<object>> _strategies =
            new(StringComparer.OrdinalIgnoreCase);

        private readonly ILogger<TransformationStrategyFactory> _logger;

        #region Singleton plumbing
        private static readonly Lazy<TransformationStrategyFactory> _instance =
            new(() => new TransformationStrategyFactory(new NullLogger<TransformationStrategyFactory>()));

        /// <summary>
        ///     Singleton instance.  In tests or DI scenarios prefer <see cref="TransformationStrategyFactory(ILogger{TransformationStrategyFactory})"/>.
        /// </summary>
        public static TransformationStrategyFactory Instance => _instance.Value;
        #endregion

        public TransformationStrategyFactory(ILogger<TransformationStrategyFactory> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            LoadStrategiesFromAppDomain();
            AppDomain.CurrentDomain.AssemblyLoad += (_, e) => RegisterStrategiesFromAssembly(e.LoadedAssembly);
        }

        #region Public API
        /// <summary>
        /// Resolves the requested strategy.  Throws if the id does not exist or cannot be cast.
        /// </summary>
        public ITransformationStrategy<TIn, TOut> Resolve<TIn, TOut>(string id)
        {
            if (!_strategies.TryGetValue(id, out var lazy))
            {
                throw new KeyNotFoundException($"Transformation strategy with id '{id}' was not found.");
            }

            var instance = lazy.Value as ITransformationStrategy<TIn, TOut>;
            if (instance == null)
            {
                throw new InvalidCastException(
                    $"Strategy '{id}' does not implement the expected interface ITransformationStrategy<{typeof(TIn).Name}, {typeof(TOut).Name}>.");
            }

            return instance;
        }
        #endregion

        #region Registration internals
        private void LoadStrategiesFromAppDomain()
        {
            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                RegisterStrategiesFromAssembly(assembly);
            }
        }

        private void RegisterStrategiesFromAssembly(Assembly assembly)
        {
            if (assembly.IsDynamic) return; // skip dynamic proxies

            Type[] candidateTypes;
            try
            {
                candidateTypes = assembly.GetTypes();
            }
            catch (ReflectionTypeLoadException ex)
            {
                candidateTypes = ex.Types.Where(t => t != null).ToArray()!;
                _logger.LogWarning(
                    ex, "Partial type-load failure while scanning assembly {AssemblyName}. Some strategies may be missing.",
                    assembly.FullName);
            }

            foreach (var type in candidateTypes)
            {
                if (type!.IsAbstract || type.IsInterface) continue;

                var attrs = type.GetCustomAttributes<TransformationStrategyAttribute>();
                foreach (var attr in attrs)
                {
                    _strategies.AddOrUpdate(
                        attr.Id,
                        id => new Lazy<object>(() => Activator.CreateInstance(type)!),
                        (_, existing) =>
                        {
                            _logger.LogWarning(
                                "Duplicate transformation strategy id '{Id}' detected in assembly {Assembly}. Existing type {ExistingType} will be kept; duplicate {DuplicateType} is ignored.",
                                attr.Id, assembly.FullName, existing.Value.GetType().FullName, type.FullName);
                            return existing;
                        });
                }
            }
        }
        #endregion
    }
    #endregion

    #region DTOs
    /// <summary>
    /// Raw calendar event as ingested from the Calendar-ingestion Lambda.
    /// </summary>
    public record CalendarEvent(
        string Id,
        string UserId,
        DateTime Start,
        DateTime End,
        string Organizer,
        IReadOnlyList<string> Attendees);

    /// <summary>
    /// KPI representing a user's focus time for a given day.
    /// </summary>
    public record FocusTimeMetric(
        string UserId,
        DateOnly Date,
        TimeSpan FocusTime);
    #endregion

    #region Concrete strategy example
    /// <summary>
    /// Calculates focus time KPI from a batch of calendar events.  The definition of "focus time" is
    /// configurable through <see cref="FocusWindowStart"/> and <see cref="FocusWindowEnd"/>.
    /// </summary>
    [TransformationStrategy("focus-time-v1")]
    public sealed class FocusTimeTransformationStrategy :
        ITransformationStrategy<IEnumerable<CalendarEvent>, IEnumerable<FocusTimeMetric>>
    {
        public string Id => "focus-time-v1";

        internal TimeOnly FocusWindowStart { get; init; } = new(8, 0);  // 8:00 AM
        internal TimeOnly FocusWindowEnd   { get; init; } = new(18, 0); // 6:00 PM

        public async Task<IEnumerable<FocusTimeMetric>> TransformAsync(
            IEnumerable<CalendarEvent> input,
            CancellationToken token = default)
        {
            if (input == null) throw new ArgumentNullException(nameof(input));

            // Simulate async I/O for parity with other strategies that might call Databricks etc.
            await Task.Yield();

            // Normalize events per user/day.
            var eventsByUserDay = input
                .SelectMany(SplitMultiDayEvents) // split events crossing midnight
                .GroupBy(e => new { e.UserId, Date = DateOnly.FromDateTime(e.Start) });

            var result = new List<FocusTimeMetric>();

            foreach (var group in eventsByUserDay)
            {
                token.ThrowIfCancellationRequested();

                var focusWindow = BuildFocusWindow(group.Key.Date);
                var busyIntervals = group
                    .Select(e => (Start: e.Start, End: e.End))
                    .OrderBy(i => i.Start)
                    .ToList();

                var focusTime = CalculateFocusTime(focusWindow, busyIntervals);

                result.Add(new FocusTimeMetric(group.Key.UserId, group.Key.Date, focusTime));
            }

            return result;
        }

        /// <summary>
        /// Splits calendar events that span multiple days into day-bounded slices.
        /// </summary>
        private IEnumerable<CalendarEvent> SplitMultiDayEvents(CalendarEvent e)
        {
            var current = e.Start;
            while (current.Date < e.End.Date)
            {
                var slice = new CalendarEvent(
                    e.Id,
                    e.UserId,
                    current,
                    current.Date.AddDays(1).AddTicks(-1),
                    e.Organizer,
                    e.Attendees);

                yield return slice;
                current = current.Date.AddDays(1);
            }

            // final slice
            yield return e with { Start = current };
        }

        private (DateTime Start, DateTime End) BuildFocusWindow(DateOnly date)
        {
            var dayStart = date.ToDateTime(FocusWindowStart, DateTimeKind.Utc);
            var dayEnd   = date.ToDateTime(FocusWindowEnd,   DateTimeKind.Utc);
            return (dayStart, dayEnd);
        }

        private static TimeSpan CalculateFocusTime(
            (DateTime Start, DateTime End) focusWindow,
            IReadOnlyList<(DateTime Start, DateTime End)> busyIntervals)
        {
            var cursor = focusWindow.Start;
            var focusMinutes = 0.0;

            foreach (var interval in busyIntervals)
            {
                if (interval.End <= cursor) continue; // already past
                if (interval.Start > focusWindow.End) break; // outside focus window

                var gapStart = cursor;
                var gapEnd   = interval.Start;

                if (gapStart < focusWindow.Start) gapStart = focusWindow.Start;
                if (gapEnd   > focusWindow.End)   gapEnd   = focusWindow.End;

                if (gapEnd > gapStart)
                {
                    focusMinutes += (gapEnd - gapStart).TotalMinutes;
                }

                // move cursor forward
                if (interval.End > cursor) cursor = interval.End;
            }

            // tail end gap
            if (cursor < focusWindow.End)
            {
                focusMinutes += (focusWindow.End - cursor).TotalMinutes;
            }

            return TimeSpan.FromMinutes(focusMinutes);
        }
    }
    #endregion

    #region Misc – minimal Null-Logger for when DI is not set-up (e.g., local tools)
    /// <summary>
    /// Poor-man's <see cref="ILogger"/> implementation used when the factory is consumed outside DI.
    /// </summary>
    internal sealed class NullLogger<T> : ILogger<T>, IDisposable
    {
        public IDisposable BeginScope<TState>(TState state) => this;
        public void Dispose() { }
        public bool IsEnabled(LogLevel logLevel) => false;
        public void Log<TState>(
            LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter) { }
    }
    #endregion
}
```