```csharp
// File: src/module_53.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//
// Purpose:
//     Core transformation engine that applies pluggable transformation strategies
//     (Strategy Pattern) on incoming data batches—either invoked from a Kinesis
//     streaming Lambda or a Glue batch job.
//
// Dependencies:
//     - Microsoft.Extensions.Logging.Abstractions
//     - System.Text.Json
//     - Amazon.Lambda.Core
//     - (Other project-local strategy implementations in namespace
//       PulseOps.Warehouse.Transformations.Strategies)
//
// NOTE:
//     Although the file uses a “.txt” extension to satisfy the
//     cross-platform packaging constraints of the monorepo, it is compiled as C#.
//
// ---------------------------------------------------------------------------------------------------------------------

#nullable enable

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Amazon.Lambda.Core;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    /// <summary>
    ///     Encapsulates the incoming data payload and metadata required by the
    ///     transformation strategies.
    /// </summary>
    public sealed record TransformationContext(
        string SourceSystem,                    // E.g. "GitHub", "GoogleCalendar"
        string PayloadFormat,                   // E.g. "json", "csv", "parquet"
        IDictionary<string, string> Attributes) // Additional metadata
    {
        public T GetAttribute<T>(string key, T defaultValue = default!)
        {
            if (Attributes.TryGetValue(key, out var value) &&
                JsonSerializer.Deserialize<T>(value) is { } parsed)
            {
                return parsed;
            }

            return defaultValue;
        }
    }

    /// <summary>
    ///     Domain model passed between strategies and the engine.
    /// </summary>
    public sealed record DataBatch(
        IReadOnlyList<byte[]> RawRecords,      // Original payload slices
        TransformationContext Context,         // Associated metadata
        DateTimeOffset ReceivedAtUtc);         // Arrival timestamp

    /// <summary>
    ///     Standard contract for all transformation strategies.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>
        ///     Human-readable name of the strategy.
        /// </summary>
        string Name { get; }

        /// <summary>
        ///     Determines whether the strategy can process the specified context.
        /// </summary>
        /// <param name="context">The transformation context.</param>
        bool CanHandle(in TransformationContext context);

        /// <summary>
        ///     Executes the actual transformation.
        /// </summary>
        /// <param name="source">The raw data batch.</param>
        /// <param name="cancellationToken">Async cancellation token.</param>
        /// <returns>Transformed batch.</returns>
        ValueTask<DataBatch> TransformAsync(
            DataBatch source,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    ///     Thread-safe registry for discovering <see cref="ITransformationStrategy"/>
    ///     implementations at runtime.
    /// </summary>
    public sealed class TransformationStrategyRegistry
    {
        private readonly IEnumerable<ITransformationStrategy> _strategies;
        private readonly ILogger _logger;

        public TransformationStrategyRegistry(
            ILogger? logger = null,
            IEnumerable<ITransformationStrategy>? overrideStrategies = null)
        {
            _logger = logger ?? LoggerFactory.Create(b => b.AddConsole()).CreateLogger(GetType());

            // Either use dependency-injected strategies or perform reflection-based discovery.
            _strategies = overrideStrategies ?? DiscoverStrategies();
        }

        /// <summary>
        ///     Returns the first strategy capable of handling the specified context.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        ///     Thrown when no strategy can handle the context.
        /// </exception>
        public ITransformationStrategy ResolveStrategy(TransformationContext context)
        {
            var strategy = _strategies.FirstOrDefault(s => s.CanHandle(context));
            if (strategy is null)
            {
                throw new InvalidOperationException(
                    $"No transformation strategy registered for " +
                    $"SourceSystem='{context.SourceSystem}', Format='{context.PayloadFormat}'.");
            }

            _logger.LogDebug("Resolved transformation strategy '{Strategy}' for source '{Source}'",
                strategy.Name, context.SourceSystem);

            return strategy;
        }

        // ------------------------------- Private helpers -------------------------------------

        private static IEnumerable<ITransformationStrategy> DiscoverStrategies()
        {
            var strategyInterface = typeof(ITransformationStrategy);
            var assemblies        = AppDomain.CurrentDomain.GetAssemblies()
                                            .Where(a => !a.IsDynamic);

            foreach (var assembly in assemblies)
            {
                IEnumerable<Type> candidateTypes = Array.Empty<Type>();
                try
                {
                    candidateTypes = assembly
                        .GetTypes()
                        .Where(t => !t.IsAbstract &&
                                    !t.IsInterface &&
                                    strategyInterface.IsAssignableFrom(t));
                }
                catch (ReflectionTypeLoadException ex)
                {
                    candidateTypes = ex.Types.Where(t => t != null);
                }

                foreach (var type in candidateTypes)
                {
                    if (Activator.CreateInstance(type) is ITransformationStrategy instance)
                    {
                        yield return instance;
                    }
                }
            }
        }
    }

    /// <summary>
    ///     Core transformation engine used by Lambda handlers and Glue drivers.
    /// </summary>
    public sealed class TransformationEngine
    {
        private readonly TransformationStrategyRegistry _registry;
        private readonly ILogger                        _logger;

        // Maintain simple in-memory cache for strategy resolution, keyed by SourceSystem+Format.
        private readonly ConcurrentDictionary<(string src, string fmt), ITransformationStrategy>
            _strategyCache = new();

        public TransformationEngine(
            TransformationStrategyRegistry registry,
            ILogger<TransformationEngine>? logger = null)
        {
            _registry = registry;
            _logger   = logger ?? LoggerFactory.Create(b => b.AddConsole()).CreateLogger<TransformationEngine>();
        }

        /// <summary>
        ///     Entrypoint invoked by the external orchestrator (e.g. Lambda handler) to transform
        ///     an incoming batch.
        /// </summary>
        public async ValueTask<DataBatch> TransformAsync(
            DataBatch batch,
            CancellationToken cancellationToken = default)
        {
            var key = (batch.Context.SourceSystem, batch.Context.PayloadFormat);
            var strategy = _strategyCache.GetOrAdd(key, _ => _registry.ResolveStrategy(batch.Context));

            try
            {
                _logger.LogInformation("Applying strategy '{Strategy}' on batch of {RecordCount} records",
                    strategy.Name, batch.RawRecords.Count);

                var transformed = await strategy.TransformAsync(batch, cancellationToken);

                _logger.LogInformation(
                    "Transformation completed successfully using '{Strategy}'. {Original} ➜ {Transformed}",
                    strategy.Name, batch.RawRecords.Count, transformed.RawRecords.Count);

                return transformed;
            }
            catch (Exception ex) when (!ex.IsCritical())
            {
                _logger.LogError(ex,
                    "Failed to transform batch (Strategy='{Strategy}', Source='{SourceSystem}')",
                    strategy.Name, batch.Context.SourceSystem);

                // Optionally enrich the batch with error metadata or push to DLQ here.
                throw;
            }
        }
    }

    // -----------------------------------------------------------------------------------------------------------------
    //  Built-in sample strategy implementation
    // -----------------------------------------------------------------------------------------------------------------

    namespace Strategies
    {
        /// <summary>
        ///     Example strategy that transforms Google Calendar event export JSON into
        ///     strongly-typed meeting-focus KPI records (simplified for demo).
        /// </summary>
        public sealed class GoogleCalendarJsonStrategy : ITransformationStrategy
        {
            public string Name => nameof(GoogleCalendarJsonStrategy);

            public bool CanHandle(in TransformationContext context)
                => string.Equals(context.SourceSystem,  "GoogleCalendar", StringComparison.OrdinalIgnoreCase) &&
                   string.Equals(context.PayloadFormat, "json",          StringComparison.OrdinalIgnoreCase);

            public async ValueTask<DataBatch> TransformAsync(
                DataBatch source,
                CancellationToken cancellationToken = default)
            {
                // For demo, we simply filter out cancelled meetings and normalize to UTC.
                var filteredRaw = new List<byte[]>(capacity: source.RawRecords.Count);

                foreach (var record in source.RawRecords)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    // Deserialize the event; expected schema: { "status":"confirmed|cancelled", "start":"...", ... }
                    var json     = JsonDocument.Parse(record);
                    var root     = json.RootElement;
                    var status   = root.GetProperty("status").GetString();
                    var utcStart = root.GetProperty("start").GetDateTime();

                    if (!string.Equals(status, "cancelled", StringComparison.OrdinalIgnoreCase))
                    {
                        // Mutate the JSON to guarantee UTC date (naïve demo).
                        var normalized = new
                        {
                            status,
                            startUtc = utcStart.ToUniversalTime(),
                            root     // include original
                        };

                        var bytes = JsonSerializer.SerializeToUtf8Bytes(normalized);
                        filteredRaw.Add(bytes);
                    }

                    // Simulate async I/O
                    await Task.Yield();
                }

                var transformedBatch = source with
                {
                    RawRecords = filteredRaw
                };

                return transformedBatch;
            }
        }
    }

    // -----------------------------------------------------------------------------------------------------------------
    //  Utility extensions
    // -----------------------------------------------------------------------------------------------------------------

    internal static class ExceptionExtensions
    {
        /// <summary>
        ///     Allows the engine to re-throw truly fatal errors while handling
        ///     transient/business errors internally.
        /// </summary>
        public static bool IsCritical(this Exception ex) =>
            ex is OutOfMemoryException or StackOverflowException or AccessViolationException;
    }
}
```