```csharp
// -----------------------------------------------------------------------------
// File: src/module_5.txt   (intentionally kept *.txt for CDK asset auto-bundler)
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
// Description:
//     Implements the Strategy-Pattern–based transformation registry that converts
//     heterogeneous “raw” telemetry events into a normalized KPI envelope that
//     downstream Lambdas (storage, analytics, QuickSight feed) can safely consume.
//
//     The registry is instantiated through the .NET DI container in each Lambda
//     function.  New transformers can be added without touching the registry
//     itself—promoting open/closed principle and zero-downtime extensibility.
// -----------------------------------------------------------------------------

#nullable enable
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;

namespace PulseOps.Warehouse.Transformations
{
    /// <summary>
    /// Lightweight DTO representing the shape of an inbound event as it comes
    /// off Kinesis/Firehose/Step-Functions without any schema enforcement.
    /// </summary>
    public sealed record RawEvent(
        string  EventType,            // e.g. "calendar.invite", "cicd.pipeline"
        string  SourceSystem,         // e.g. "google-workspace", "github"
        string  PartitionKey,         // natural shard key
        DateTimeOffset IngestedAtUtc, // system timestamp
        JsonDocument Payload);        // arbitrary JSON

    /// <summary>
    /// Normalized envelope that every downstream service understands.
    /// </summary>
    public sealed record KpiEvent(
        string              KpiType,        // e.g. "focus_time_ratio"
        DateTimeOffset      ObservedAtUtc,  // when the original user action happened
        IReadOnlyDictionary<string, object> Dimensions,
        IReadOnlyDictionary<string, double> Metrics);

    /// <summary>
    /// Contract for a component that knows how to convert a RawEvent instance
    /// into a strongly-typed KPI event.
    /// </summary>
    public interface IEventTransformer
    {
        /// <summary>
        /// Returns true if this transformer is confident it can handle the event.
        /// </summary>
        bool CanTransform(RawEvent rawEvent);

        /// <summary>
        /// Executes the transformation.
        /// </summary>
        ValueTask<KpiEvent> TransformAsync(RawEvent rawEvent, CancellationToken token = default);
    }

    /// <summary>
    /// Exception thrown when no transformer can handle a given RawEvent.
    /// </summary>
    public sealed class UnsupportedEventTypeException : Exception
    {
        public UnsupportedEventTypeException(RawEvent raw)
            : base($"No transformer registered for event type '{raw.EventType}'.")
        { }
    }

    /// <summary>
    /// Registry that dispatches events to the correct transformer at runtime.
    /// </summary>
    public sealed class EventTransformerRegistry
    {
        private readonly ImmutableArray<IEventTransformer> _transformers;
        private readonly ILogger<EventTransformerRegistry> _logger;

        public EventTransformerRegistry(
            IEnumerable<IEventTransformer> transformers,
            ILogger<EventTransformerRegistry> logger)
        {
            _transformers = transformers.ToImmutableArray();
            _logger       = logger;
        }

        /// <summary>
        /// Transforms <paramref name="rawEvent"/> into a KPI envelope by delegating
        /// to one of the registered IEventTransformer strategies.
        /// </summary>
        public async ValueTask<KpiEvent> TransformAsync(RawEvent rawEvent, CancellationToken token = default)
        {
            foreach (var transformer in _transformers)
            {
                if (!transformer.CanTransform(rawEvent)) continue;

                try
                {
                    var result = await transformer.TransformAsync(rawEvent, token).ConfigureAwait(false);
                    _logger.LogDebug("Event {EventType} transformed by {Transformer}.",
                                     rawEvent.EventType, transformer.GetType().Name);
                    return result;
                }
                catch (Exception ex)
                {
                    // Surface structured logs to CloudWatch + Datadog for correlation.
                    _logger.LogError(ex, "Transformer {Transformer} failed for event {EventType}.",
                                     transformer.GetType().Name, rawEvent.EventType);
                    throw;  // Bubble up to Lambda error handler / DLQ.
                }
            }

            _logger.LogWarning("Unsupported event type {EventType}.", rawEvent.EventType);
            throw new UnsupportedEventTypeException(rawEvent);
        }
    }

    // -------------------------------------------------------------------------
    // Concrete Transformers
    // -------------------------------------------------------------------------

    /// <summary>
    /// Extracts “focus-time” KPI from Google Calendar data.
    /// </summary>
    internal sealed class CalendarEventTransformer : IEventTransformer
    {
        private const string SupportedType = "calendar.invite";
        private readonly ILogger<CalendarEventTransformer> _logger;

        public CalendarEventTransformer(ILogger<CalendarEventTransformer> logger) => _logger = logger;

        public bool CanTransform(RawEvent rawEvent)
            => string.Equals(rawEvent.EventType, SupportedType, StringComparison.OrdinalIgnoreCase);

        public ValueTask<KpiEvent> TransformAsync(RawEvent rawEvent, CancellationToken token = default)
        {
            try
            {
                var root = rawEvent.Payload.RootElement;

                // Example payload:
                // {
                //   "meetingId": "abc",
                //   "organizer": { "email": "john@corp.com", "timeZone": "EST" },
                //   "durationMinutes": 30,
                //   "startUtc": "2023-10-14T12:00:00Z",
                //   "attendees": [...]
                // }
                var duration = root.GetProperty("durationMinutes").GetDouble();
                var organizerTz = root.GetProperty("organizer").GetProperty("timeZone").GetString() ?? "UTC";

                var dims = new Dictionary<string, object>(4, StringComparer.OrdinalIgnoreCase)
                {
                    ["organizer_email"] = root.GetProperty("organizer").GetProperty("email").GetString(),
                    ["organizer_tz"]    = organizerTz
                };

                var metrics = new Dictionary<string, double>
                {
                    ["meeting_duration_minutes"] = duration,
                    ["meeting_cost_usd"]         = CalculateMeetingCost(root)
                };

                var observedAt = root.GetProperty("startUtc").GetDateTimeOffset();

                return new ValueTask<KpiEvent>(new KpiEvent(
                    KpiType: "meeting_cost_index",
                    ObservedAtUtc: observedAt,
                    Dimensions: dims,
                    Metrics: metrics));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to parse calendar.invite payload.");
                throw;
            }
        }

        private static double CalculateMeetingCost(JsonElement root)
        {
            // Placeholder algorithm: $1/minute/attendee
            var attendees = root.GetProperty("attendees").EnumerateArray();
            var attendeeCount = 0;
            foreach (var _ in attendees) attendeeCount++;
            var duration = root.GetProperty("durationMinutes").GetDouble();
            return attendeeCount * duration;
        }
    }

    /// <summary>
    /// Converts GitHub push events into deployment lead-time KPI.
    /// </summary>
    internal sealed class CodeRepoEventTransformer : IEventTransformer
    {
        private const string SupportedType = "code.push";
        private readonly ILogger<CodeRepoEventTransformer> _logger;

        public CodeRepoEventTransformer(ILogger<CodeRepoEventTransformer> logger) => _logger = logger;

        public bool CanTransform(RawEvent rawEvent)
            => string.Equals(rawEvent.EventType, SupportedType, StringComparison.OrdinalIgnoreCase);

        public ValueTask<KpiEvent> TransformAsync(RawEvent rawEvent, CancellationToken token = default)
        {
            var root = rawEvent.Payload.RootElement;

            // {
            //   "commitId": "...",
            //   "repo": "pulseops-warehouse",
            //   "author": "alice",
            //   "committedAtUtc": "2023-10-12T08:00:00Z"
            // }
            var committedAt = root.GetProperty("committedAtUtc").GetDateTimeOffset();

            var dims = new Dictionary<string, object>
            {
                ["repo"]   = root.GetProperty("repo").GetString()!,
                ["author"] = root.GetProperty("author").GetString()!
            };

            var metrics = new Dictionary<string, double>
            {
                ["code_commits"] = 1
            };

            return new ValueTask<KpiEvent>(new KpiEvent(
                KpiType: "deployment_lead_time",
                ObservedAtUtc: committedAt,
                Dimensions: dims,
                Metrics: metrics));
        }
    }

    /// <summary>
    /// Infers CI/CD pipeline throughput from build logs.
    /// </summary>
    internal sealed class CiCdLogEventTransformer : IEventTransformer
    {
        private const string SupportedType = "cicd.pipeline";
        private readonly ILogger<CiCdLogEventTransformer> _logger;

        public CiCdLogEventTransformer(ILogger<CiCdLogEventTransformer> logger) => _logger = logger;

        public bool CanTransform(RawEvent rawEvent)
            => rawEvent.EventType.Equals(SupportedType, StringComparison.OrdinalIgnoreCase);

        public ValueTask<KpiEvent> TransformAsync(RawEvent rawEvent, CancellationToken token = default)
        {
            var root = rawEvent.Payload.RootElement;

            var state    = root.GetProperty("status").GetString()!;
            var duration = root.GetProperty("durationSeconds").GetDouble();

            var dims = new Dictionary<string, object>
            {
                ["pipeline_id"] = root.GetProperty("pipelineId").GetString()!,
                ["branch"]      = root.GetProperty("branch").GetString()!,
                ["status"]      = state
            };
            var metrics = new Dictionary<string, double>
            {
                ["build_duration_seconds"] = duration,
                ["build_pass"]             = state.Equals("success", StringComparison.OrdinalIgnoreCase) ? 1 : 0
            };

            var observed = root.GetProperty("completedAtUtc").GetDateTimeOffset();

            return new ValueTask<KpiEvent>(new KpiEvent(
                KpiType: "deployment_frequency",
                ObservedAtUtc: observed,
                Dimensions: dims,
                Metrics: metrics));
        }
    }

    /// <summary>
    /// Built-in no-op transformer for “unknown” events that should never be
    /// stored.  Keeps DLQ noise low by gracefully dropping garbage data.
    /// </summary>
    internal sealed class BlackHoleEventTransformer : IEventTransformer
    {
        private readonly HashSet<string> _ignoredTypes = new(StringComparer.OrdinalIgnoreCase)
        {
            "health.ping", "diagnostic.tracer"
        };

        public bool CanTransform(RawEvent rawEvent) => _ignoredTypes.Contains(rawEvent.EventType);

        public ValueTask<KpiEvent> TransformAsync(RawEvent rawEvent, CancellationToken token = default)
            => throw new UnsupportedEventTypeException(rawEvent); // Should be filtered earlier.
    }

    // -------------------------------------------------------------------------
    // DI Extension Helpers
    // -------------------------------------------------------------------------

    public static class ServiceCollectionExtensions
    {
        /// <summary>
        /// Registers all known transformers plus the registry itself.
        /// Call this from Program.cs (Lambda bootstrap) or CDK’s container build.
        /// </summary>
        public static IServiceCollection AddEventTransformations(this IServiceCollection services)
        {
            // Add concrete transformers
            services.AddSingleton<IEventTransformer, CalendarEventTransformer>();
            services.AddSingleton<IEventTransformer, CodeRepoEventTransformer>();
            services.AddSingleton<IEventTransformer, CiCdLogEventTransformer>();
            services.AddSingleton<IEventTransformer, BlackHoleEventTransformer>();

            // Add the registry
            services.AddSingleton<EventTransformerRegistry>();

            return services;
        }
    }
}
```