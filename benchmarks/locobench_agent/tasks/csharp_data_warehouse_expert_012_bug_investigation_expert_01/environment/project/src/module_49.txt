```csharp
// ---------------------------------------------------------------------------------------------------------------------
// <copyright>
//   PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//   © 2024 PulseOps, Inc.  All rights reserved.
// </copyright>
// <author>PulseOps Warehouse Engineering Team</author>
// <summary>
//   DynamicTransformationCoordinator.cs
//
//   Purpose:
//     • Houses a concurrency-safe registry of transformation strategies.
//     • Dynamically composes ETL transformation pipelines at runtime based on metadata
//       stored in AWS Systems Manager Parameter Store or supplied via event payload.
//     • Demonstrates Strategy, Observer, and Pipeline patterns working in concert.
//
//   Notes:
//     • Other components (e.g., Lambda handlers) resolve ITransformationCoordinator via DI.
//     • Individual strategies live in separate files – only two sample implementations
//       are included here for brevity.
// </summary>
// ---------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Amazon.SimpleSystemsManagement;
using Amazon.SimpleSystemsManagement.Model;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region Contracts

    /// <summary>
    /// Defines the contract for any transformation strategy.
    /// </summary>
    /// <typeparam name="TIn">Input data type.</typeparam>
    /// <typeparam name="TOut">Output data type.</typeparam>
    public interface ITransformationStrategy<in TIn, TOut>
    {
        /// <summary>
        /// Friendly, globally unique identifier for the strategy. 
        /// Used for dynamic discovery and routing.
        /// </summary>
        string StrategyId { get; }

        /// <summary>
        /// Executes the transformation.
        /// </summary>
        Task<TOut> TransformAsync(TIn input, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Exposes a transformation coordination service that resolves and executes 
    /// registered <see cref="ITransformationStrategy{TIn,TOut}"/> implementations.
    /// </summary>
    public interface ITransformationCoordinator
    {
        /// <summary>
        /// Transforms <paramref name="payload"/> to <typeparamref name="TOut"/>
        /// using a strategy deduced from <paramref name="metadata"/> or 
        /// remote configuration (SSM Parameter Store).
        /// </summary>
        Task<TOut> ExecuteAsync<TIn, TOut>(
            TIn payload,
            TransformationMetadata metadata,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Lightweight DTO describing transformation routing metadata.
    /// </summary>
    public sealed record TransformationMetadata(
        string? StrategyId,
        string? ParameterStoreKey);

    #endregion

    #region Coordinator

    /// <summary>
    /// Runtime coordinator that discovers, caches, and invokes transformation strategies
    /// while guarding against thundering-herd through a concurrent dictionary.
    /// </summary>
    public sealed class DynamicTransformationCoordinator : ITransformationCoordinator
    {
        private readonly ConcurrentDictionary<string, Lazy<object>> _strategyCache = new();
        private readonly ILogger<DynamicTransformationCoordinator> _logger;
        private readonly IAmazonSimpleSystemsManagement _ssmClient;

        public DynamicTransformationCoordinator(
            ILogger<DynamicTransformationCoordinator> logger,
            IAmazonSimpleSystemsManagement ssmClient)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _ssmClient = ssmClient ?? throw new ArgumentNullException(nameof(ssmClient));
        }

        public async Task<TOut> ExecuteAsync<TIn, TOut>(
            TIn payload,
            TransformationMetadata metadata,
            CancellationToken cancellationToken = default)
        {
            if (payload is null) throw new ArgumentNullException(nameof(payload));
            if (metadata is null) throw new ArgumentNullException(nameof(metadata));

            // 1. Select strategyId
            var strategyId = await ResolveStrategyIdAsync(metadata, cancellationToken);
            _logger.LogDebug("Resolved strategyId={StrategyId}", strategyId);

            // 2. Resolve strategy instance
            var strategy = ResolveStrategy<TIn, TOut>(strategyId);

            // 3. Execute
            var sw = Stopwatch.StartNew();
            _logger.LogInformation(
                "Executing transformation strategy {StrategyId} ({StrategyType})",
                strategyId, strategy.GetType().Name);

            var result = await strategy.TransformAsync(payload, cancellationToken)
                                       .ConfigureAwait(false);

            sw.Stop();
            _logger.LogInformation(
                "Completed strategy {StrategyId} in {ElapsedMs}ms",
                strategyId, sw.ElapsedMilliseconds);

            return result;
        }

        #region Helpers

        private async Task<string> ResolveStrategyIdAsync(
            TransformationMetadata metadata,
            CancellationToken cancellationToken)
        {
            if (!string.IsNullOrWhiteSpace(metadata.StrategyId))
            {
                return metadata.StrategyId!;
            }

            if (string.IsNullOrWhiteSpace(metadata.ParameterStoreKey))
            {
                throw new InvalidOperationException(
                    "Neither StrategyId nor ParameterStoreKey was provided in metadata.");
            }

            var response = await _ssmClient.GetParameterAsync(
                new GetParameterRequest
                {
                    Name = metadata.ParameterStoreKey,
                    WithDecryption = true
                },
                cancellationToken
            ).ConfigureAwait(false);

            if (response.Parameter?.Value is { Length: > 0 } value)
            {
                return value.Trim();
            }

            throw new InvalidOperationException(
                $"ParameterStore key '{metadata.ParameterStoreKey}' did not return a valid value.");
        }

        private ITransformationStrategy<TIn, TOut> ResolveStrategy<TIn, TOut>(string strategyId)
        {
            try
            {
                var instance = _strategyCache.GetOrAdd(strategyId, id => new Lazy<object>(
                    () => InstantiateStrategy(id), LazyThreadSafetyMode.ExecutionAndPublication)).Value;

                if (instance is not ITransformationStrategy<TIn, TOut> typedInstance)
                {
                    // The requested strategyId exists but the generics do not align.
                    throw new InvalidCastException(
                        $"Strategy '{strategyId}' does not support requested generic " +
                        $"arguments: TIn={typeof(TIn).Name}, TOut={typeof(TOut).Name}");
                }

                return typedInstance;
            }
            catch (Exception ex) when (ex is InvalidOperationException or InvalidCastException)
            {
                _logger.LogError(ex, "Failed to resolve strategyId={StrategyId}", strategyId);
                throw;
            }
        }

        private static object InstantiateStrategy(string strategyId)
        {
            // Search for any ITransformationStrategy<TIn,TOut> that matches StrategyId
            var strategyType = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(a =>
                {
                    try
                    {
                        return a.GetTypes();
                    }
                    catch (ReflectionTypeLoadException rtlx)
                    {
                        return rtlx.Types.Where(t => t != null)!;
                    }
                })
                .FirstOrDefault(t =>
                    !t.IsAbstract &&
                    !t.IsInterface &&
                    typeof(ITransformationStrategy<,>).IsAssignableFromGeneric(t) &&
                    Activator.CreateInstance(t) is ITransformationStrategy<object, object> inst &&
                    inst.StrategyId.Equals(strategyId, StringComparison.OrdinalIgnoreCase));

            if (strategyType is null)
            {
                throw new InvalidOperationException(
                    $"No transformation strategy registered with StrategyId='{strategyId}'.");
            }

            return Activator.CreateInstance(strategyType)!;
        }

        #endregion
    }

    #endregion

    #region ExtensionHelpers

    internal static class TypeExtensions
    {
        /// <summary>
        /// Checks whether <paramref name="candidate"/> implements
        /// <see cref="ITransformationStrategy{TIn,TOut}"/> for any TIn/TOut.
        /// </summary>
        public static bool IsAssignableFromGeneric(this Type genericType, Type candidate)
        {
            return candidate.GetInterfaces()
                            .Any(i => i.IsGenericType &&
                                      i.GetGenericTypeDefinition() == typeof(ITransformationStrategy<,>));
        }
    }

    #endregion

    #region Sample Strategies (for illustration)

    /// <summary>
    /// Normalizes raw calendar event payloads into a canonical event dimension record.
    /// </summary>
    public sealed class CalendarEventNormalizationStrategy : ITransformationStrategy<JsonElement, CalendarEventDto>
    {
        public string StrategyId => "calendar-event-normalization@v1";

        public Task<CalendarEventDto> TransformAsync(JsonElement input, CancellationToken cancellationToken = default)
        {
            // Simulate expensive parsing/normalization.
            var dto = new CalendarEventDto
            {
                EventId = input.GetProperty("id").GetString()!,
                Title = input.GetProperty("summary").GetString()!,
                StartUtc = DateTime.Parse(input.GetProperty("start").GetProperty("dateTime").GetString()!)
                         .ToUniversalTime(),
                EndUtc = DateTime.Parse(input.GetProperty("end").GetProperty("dateTime").GetString()!)
                         .ToUniversalTime(),
                Organizer = input.GetProperty("organizer").GetProperty("email").GetString()!
            };

            return Task.FromResult(dto);
        }
    }

    /// <summary>
    /// Calculates the lead time for a deployment by flattening and diffing two commit identifiers.
    /// </summary>
    public sealed class DeploymentLeadTimeStrategy : ITransformationStrategy<JsonElement, DeploymentLeadTimeDto>
    {
        public string StrategyId => "deployment-lead-time@v2";

        public Task<DeploymentLeadTimeDto> TransformAsync(JsonElement input, CancellationToken cancellationToken = default)
        {
            var created = input.GetProperty("createdAt").GetDateTime();
            var deployed = input.GetProperty("deployedAt").GetDateTime();

            var dto = new DeploymentLeadTimeDto
            {
                LeadTime = deployed - created,
                CommitId = input.GetProperty("commit").GetString()!,
                PipelineId = input.GetProperty("pipeline").GetString()!
            };

            return Task.FromResult(dto);
        }
    }

    #endregion

    #region DTOs

    public sealed record CalendarEventDto
    {
        public string EventId { get; init; } = default!;
        public string Title { get; init; } = default!;
        public DateTime StartUtc { get; init; }
        public DateTime EndUtc { get; init; }
        public string Organizer { get; init; } = default!;
        public TimeSpan Duration => EndUtc - StartUtc;
    }

    public sealed record DeploymentLeadTimeDto
    {
        public string CommitId { get; init; } = default!;
        public string PipelineId { get; init; } = default!;
        public TimeSpan LeadTime { get; init; }
    }

    #endregion
}
```