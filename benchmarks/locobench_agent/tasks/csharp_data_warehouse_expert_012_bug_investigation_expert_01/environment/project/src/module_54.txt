```csharp
// src/module_54.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//
// NOTE: Although the file has a .txt extension in the repository metadata,
//       it is treated as C# source by the build pipeline (see Directory.Build.props).

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.KpiCalculators
{
    #region Domain Models

    /// <summary>
    /// Light-weight representation of a calendar event flowing through the lake.
    /// </summary>
    public sealed record CalendarEvent(
        Guid   Id,
        string Subject,
        DateTimeOffset StartUtc,
        DateTimeOffset EndUtc,
        EventCategory  Category,
        string         OrganizerEmail);

    /// <summary>
    /// Logical category assigned during classification.
    /// </summary>
    public enum EventCategory
    {
        DeepWork,
        Meeting,
        Break,
        AdminOverhead,
        Unknown
    }

    /// <summary>
    /// Standardised KPI result model emitted by strategies.
    /// </summary>
    public sealed record FocusTimeKpiResult(
        string  IsoWeek,            // e.g. "2024-W23"
        string  Principal,          // e.g. jane.doe@corp.com
        double  Ratio,              // 0.0 – 1.0
        TimeSpan FocusTime,
        TimeSpan TotalWorkTime,
        DateTimeOffset CalculatedAtUtc);
    
    #endregion

    #region Contracts & Errors

    /// <summary>
    /// Strategy Pattern contract for KPI calculators.
    /// </summary>
    public interface IKpiCalculationStrategy
    {
        /// <summary>
        /// Descriptive name used for wiring strategies through configuration
        /// (e.g. "simple", "weighted", "ml_gen2").
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Calculates Focus-Time KPI for a homogeneous (user, week) cohort.
        /// </summary>
        /// <exception cref="KpiCalculationException">
        /// Thrown when data is insufficient or corrupted.
        /// </exception>
        Task<FocusTimeKpiResult> CalculateAsync(
            IReadOnlyCollection<CalendarEvent> events,
            CancellationToken                   cancellationToken = default);
    }

    /// <summary>
    /// Domain specific error raised when a KPI cannot be calculated.
    /// </summary>
    public sealed class KpiCalculationException : Exception
    {
        public KpiCalculationException(string message, Exception? inner = null)
            : base(message, inner) { }
    }

    #endregion

    #region Strategy Implementations

    /// <summary>
    /// Naïve implementation: ratio = deep-work minutes / total meeting + deep-work minutes.
    /// </summary>
    public sealed class SimpleFocusTimeStrategy : IKpiCalculationStrategy
    {
        public const string StrategyNameConst = "simple";
        public string Name => StrategyNameConst;

        private readonly ILogger<SimpleFocusTimeStrategy> _logger;

        public SimpleFocusTimeStrategy(ILogger<SimpleFocusTimeStrategy> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public Task<FocusTimeKpiResult> CalculateAsync(
            IReadOnlyCollection<CalendarEvent> events,
            CancellationToken                   cancellationToken = default)
        {
            if (events == null || events.Count == 0)
            {
                throw new KpiCalculationException("No calendar events supplied.");
            }

            // Assumption: All events belong to single principal + ISO week
            var principal = events.First().OrganizerEmail;
            var isoWeek   = IsoWeekFromDate(events.First().StartUtc);

            var deepWork   = TimeSpan.Zero;
            var workTotal  = TimeSpan.Zero;

            foreach (var ev in events)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var duration = ev.EndUtc - ev.StartUtc;
                if (duration < TimeSpan.Zero)
                {
                    _logger.LogWarning("Event {EventId} has negative duration – skipping.", ev.Id);
                    continue;
                }

                switch (ev.Category)
                {
                    case EventCategory.DeepWork:
                        deepWork += duration;
                        workTotal += duration;
                        break;
                    case EventCategory.Meeting:
                    case EventCategory.AdminOverhead:
                        workTotal += duration;
                        break;
                    default:
                        // Break, Unknown, etc. ignored for KPI
                        break;
                }
            }

            if (workTotal <= TimeSpan.Zero)
            {
                throw new KpiCalculationException("Total work time evaluated to zero.");
            }

            var ratio = deepWork.TotalMinutes / workTotal.TotalMinutes;

            return Task.FromResult(new FocusTimeKpiResult(
                isoWeek,
                principal,
                Math.Round(ratio, 4),
                deepWork,
                workTotal,
                DateTimeOffset.UtcNow));
        }

        private static string IsoWeekFromDate(DateTimeOffset date)
        {
            // Uses ISO-8601 week rules
            var week = ISOWeek.GetWeekOfYear(date.DateTime);
            var year = ISOWeek.GetYear(date.DateTime);
            return $"{year}-W{week:D2}";
        }
    }

    /// <summary>
    /// More sophisticated implementation that applies empirical
    /// weights to each category (e.g. meeting = 0.25 productivity).
    /// </summary>
    public sealed class WeightedFocusTimeStrategy : IKpiCalculationStrategy
    {
        public const string StrategyNameConst = "weighted";
        public string Name => StrategyNameConst;

        private readonly IReadOnlyDictionary<EventCategory, double> _weights;
        private readonly ILogger<WeightedFocusTimeStrategy>         _logger;

        public WeightedFocusTimeStrategy(
            ILogger<WeightedFocusTimeStrategy> logger,
            IReadOnlyDictionary<EventCategory, double>? weights = null)
        {
            _logger  = logger ?? throw new ArgumentNullException(nameof(logger));
            _weights = weights ?? new Dictionary<EventCategory, double>
            {
                [EventCategory.DeepWork]      = 1.0,
                [EventCategory.Meeting]       = 0.25,
                [EventCategory.AdminOverhead] = 0.15,
                [EventCategory.Break]         = 0.0,
                [EventCategory.Unknown]       = 0.0
            };
        }

        public Task<FocusTimeKpiResult> CalculateAsync(
            IReadOnlyCollection<CalendarEvent> events,
            CancellationToken                   cancellationToken = default)
        {
            if (events == null || events.Count == 0)
            {
                throw new KpiCalculationException("No calendar events supplied.");
            }

            var principal = events.First().OrganizerEmail;
            var isoWeek   = IsoWeekFromDate(events.First().StartUtc);

            double weightedProductivityMinutes = 0;
            double scheduledMinutes            = 0;

            foreach (var ev in events)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var durationMinutes = (ev.EndUtc - ev.StartUtc).TotalMinutes;
                if (durationMinutes < 0)
                {
                    _logger.LogWarning("Event {EventId} has negative duration – skipping.", ev.Id);
                    continue;
                }

                scheduledMinutes += durationMinutes;

                if (_weights.TryGetValue(ev.Category, out var weight))
                {
                    weightedProductivityMinutes += durationMinutes * weight;
                }
                else
                {
                    // Unknown categories count as zero productivity
                    _logger.LogDebug("Event {EventId} category {Category} has no configured weight.",
                        ev.Id, ev.Category);
                }
            }

            if (scheduledMinutes <= 0)
            {
                throw new KpiCalculationException("Total scheduled minutes evaluated to zero.");
            }

            var ratio = weightedProductivityMinutes / scheduledMinutes;

            return Task.FromResult(new FocusTimeKpiResult(
                isoWeek,
                principal,
                Math.Round(ratio, 4),
                TimeSpan.FromMinutes(weightedProductivityMinutes),
                TimeSpan.FromMinutes(scheduledMinutes),
                DateTimeOffset.UtcNow));
        }

        private static string IsoWeekFromDate(DateTimeOffset date)
        {
            var week = ISOWeek.GetWeekOfYear(date.DateTime);
            var year = ISOWeek.GetYear(date.DateTime);
            return $"{year}-W{week:D2}";
        }
    }

    #endregion

    #region Factory & Coordinator

    /// <summary>
    /// Resolves KPI calculation strategy based on configuration or
    /// message-level override (open for dependency-injection).
    /// </summary>
    public sealed class KpiStrategyFactory
    {
        private readonly IReadOnlyDictionary<string, IKpiCalculationStrategy> _strategies;
        private readonly ILogger<KpiStrategyFactory>                          _logger;

        public KpiStrategyFactory(
            IEnumerable<IKpiCalculationStrategy> strategies,
            ILogger<KpiStrategyFactory>          logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            _strategies = strategies.ToDictionary(s => s.Name, StringComparer.OrdinalIgnoreCase);
            if (_strategies.Count == 0)
            {
                throw new ArgumentException("At least one strategy must be registered.", nameof(strategies));
            }
        }

        /// <summary>
        /// Retrieves strategy by name (case-insensitive).
        /// Falls back to first registered strategy when not found.
        /// </summary>
        public IKpiCalculationStrategy Resolve(string? name)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                _logger.LogInformation("No strategy hint provided. Using default strategy {Name}.",
                    _strategies.First().Key);
                return _strategies.First().Value;
            }

            if (_strategies.TryGetValue(name, out var strategy))
            {
                return strategy;
            }

            _logger.LogWarning("Strategy {Name} not found. Using default {Default}.",
                name, _strategies.First().Key);

            return _strategies.First().Value;
        }
    }

    /// <summary>
    /// Orchestrates KPI calculations in parallel across cohorts,
    /// utilising the Strategy Factory and ensuring thread-safe logging.
    /// </summary>
    public sealed class FocusTimeKpiEngine
    {
        private readonly KpiStrategyFactory _factory;
        private readonly ILogger<FocusTimeKpiEngine> _logger;

        // Parallelism guard: avoid exhausting Lambda ephemeral storage / memory pressures.
        private readonly SemaphoreSlim _parallelismGate;

        public FocusTimeKpiEngine(
            KpiStrategyFactory         factory,
            ILogger<FocusTimeKpiEngine> logger,
            int                         maxDegreeOfParallelism = 4)
        {
            _factory    = factory ?? throw new ArgumentNullException(nameof(factory));
            _logger     = logger  ?? throw new ArgumentNullException(nameof(logger));
            _parallelismGate = new SemaphoreSlim(Math.Max(1, maxDegreeOfParallelism));
        }

        /// <summary>
        /// Calculates Focus-Time KPI in parallel for the supplied cohorts.
        /// </summary>
        /// <param name="cohorts">
        /// Key = (principal, isoWeek), Value = all events for that cohort.
        /// </param>
        public async Task<IReadOnlyCollection<FocusTimeKpiResult>> CalculateAsync(
            IReadOnlyDictionary<(string Principal, string IsoWeek), IReadOnlyCollection<CalendarEvent>> cohorts,
            string?                                          strategyOverride   = null,
            CancellationToken                                cancellationToken = default)
        {
            if (cohorts == null) throw new ArgumentNullException(nameof(cohorts));
            if (cohorts.Count == 0) return Array.Empty<FocusTimeKpiResult>();

            var resultsBag = new ConcurrentBag<FocusTimeKpiResult>();
            var strategy   = _factory.Resolve(strategyOverride);

            var tasks = cohorts.Select(async pair =>
            {
                await _parallelismGate.WaitAsync(cancellationToken).ConfigureAwait(false);
                try
                {
                    var result = await strategy.CalculateAsync(pair.Value, cancellationToken)
                                               .ConfigureAwait(false);
                    resultsBag.Add(result);
                }
                catch (KpiCalculationException ex)
                {
                    _logger.LogError(ex,
                        "Failed calculating KPI for {Principal} {Week}.", pair.Key.Principal, pair.Key.IsoWeek);
                }
                catch (Exception ex)
                {
                    _logger.LogCritical(ex,
                        "Unhandled exception calculating KPI for {Principal} {Week}.",
                        pair.Key.Principal, pair.Key.IsoWeek);
                }
                finally
                {
                    _parallelismGate.Release();
                }
            }).ToArray();

            await Task.WhenAll(tasks).ConfigureAwait(false);
            return resultsBag.ToArray();
        }
    }

    #endregion
}
```