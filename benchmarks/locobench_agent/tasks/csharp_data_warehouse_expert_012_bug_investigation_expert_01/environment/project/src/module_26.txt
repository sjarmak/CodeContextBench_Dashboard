```csharp
// File: src/module_26.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//
// This module defines an in-memory transformation pipeline that is leveraged by
// multiple Lambda micro-components to turn raw calendar-event payloads into
// actionable KPI artefacts (e.g., Focus-Time Ratio).
//
// The implementation purposefully mirrors the ASP.NET Core middleware pattern,
// giving engineers a familiar, highly-composable model while remaining
// framework-agnostic and entirely serverless-friendly.
//
// NOTE: The pipeline deals exclusively with memory streams and therefore plays
// nicely inside Lambda’s “no /tmp writes” constrained runtime.
// ------------------------------------------------------------------------------------------------------------------

#nullable enable
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region Contracts & DTOs

    /// <summary>
    /// Represents the canonical envelope that every incoming event is wrapped in
    /// once it lands inside the warehouse fabric.
    /// </summary>
    public sealed record RecordEnvelope(
        Guid Id,
        string SourceSystem,
        string EventType,
        Stream Payload,
        DateTimeOffset IngestedAtUtc);

    /// <summary>
    /// Output artefact produced by a transformation pipeline run.
    /// </summary>
    public sealed record TransformationResult(
        Guid Id,
        bool Success,
        DateTimeOffset ProducedAtUtc,
        string? FailureReason,
        JsonElement? Data);

    /// <summary>
    /// Pipeline context object that is threaded through each transformation step.
    /// </summary>
    public sealed class TransformationContext
    {
        public TransformationContext(RecordEnvelope envelope, ILogger logger)
        {
            Envelope = envelope ?? throw new ArgumentNullException(nameof(envelope));
            Logger   = logger   ?? throw new ArgumentNullException(nameof(logger));
            Items    = new Dictionary<string, object>(StringComparer.Ordinal);
        }

        public RecordEnvelope Envelope { get; }

        public ILogger Logger { get; }

        /// <summary>
        /// A shared bag for passing data between steps without tight coupling.
        /// </summary>
        public IDictionary<string, object> Items { get; }

        /// <summary>
        /// Convenience helper for strongly-typed item retrieval.
        /// </summary>
        public T GetItem<T>(string key) => (T)Items[key];

        /// <summary>
        /// Convenience helper for item upsert.
        /// </summary>
        public void SetItem<T>(string key, T value) => Items[key] = value!;
    }

    #endregion

    #region Pipeline Core

    /// <summary>
    /// Signature of a transformation delegate (i.e., a pipeline step).
    /// </summary>
    /// <param name="context">Current pipeline context.</param>
    /// <param name="cancellationToken">Task cancellation token.</param>
    public delegate Task<TransformationResult> TransformationDelegate(
        TransformationContext context,
        CancellationToken cancellationToken);

    /// <summary>
    /// Interface that each transformation step must implement.
    /// </summary>
    public interface ITransformationStep
    {
        Task<TransformationResult> InvokeAsync(
            TransformationContext context,
            TransformationDelegate next,
            CancellationToken cancellationToken);
    }

    /// <summary>
    /// Configurable pipeline that executes registered <see cref="ITransformationStep"/> instances
    /// in the order they were added.
    /// </summary>
    public sealed class TransformationPipeline
    {
        private readonly IList<Func<TransformationDelegate, TransformationDelegate>> _components =
            new List<Func<TransformationDelegate, TransformationDelegate>>();

        /// <summary>
        /// Registers a transformation step.
        /// </summary>
        public TransformationPipeline Use<TStep>() where TStep : ITransformationStep, new()
        {
            _components.Add(next =>
            {
                var step = new TStep();
                return (ctx, token) => step.InvokeAsync(ctx, next, token);
            });

            return this;
        }

        /// <summary>
        /// Registers an inline transformation step via delegate (syntactic sugar).
        /// </summary>
        public TransformationPipeline Use(Func<TransformationContext, CancellationToken, Task> step)
        {
            if (step == null) throw new ArgumentNullException(nameof(step));

            _components.Add(next => async (ctx, token) =>
            {
                await step(ctx, token).ConfigureAwait(false);
                return await next(ctx, token).ConfigureAwait(false);
            });

            return this;
        }

        /// <summary>
        /// Builds a <see cref="TransformationDelegate"/> that can be executed.
        /// </summary>
        public TransformationDelegate Build()
        {
            TransformationDelegate app = async (ctx, token) =>
            {
                // Terminal delegate (runs if every preceding step succeeded)
                ctx.Logger.LogDebug("Transformation pipeline terminated successfully for event {EventId}.",
                    ctx.Envelope.Id);

                return new TransformationResult(
                    ctx.Envelope.Id,
                    Success: true,
                    ProducedAtUtc: DateTimeOffset.UtcNow,
                    FailureReason: null,
                    Data: ctx.Items.TryGetValue(WellKnownContextKeys.Output, out var data)
                        ? (JsonElement?)data
                        : null);
            };

            // Build pipeline backwards.
            for (var i = _components.Count - 1; i >= 0; i--)
            {
                app = _components[i](app);
            }

            return app;
        }

        private static class WellKnownContextKeys
        {
            public const string Output = "OUTPUT_JSON";
        }
    }

    #endregion

    #region Built-In Steps

    /// <summary>
    /// Performs basic sanity checks on the incoming envelope.
    /// </summary>
    public sealed class ValidationStep : ITransformationStep
    {
        public Task<TransformationResult> InvokeAsync(
            TransformationContext context,
            TransformationDelegate next,
            CancellationToken cancellationToken)
        {
            var env = context.Envelope;

            if (env.Payload is null || env.Payload.Length == 0)
            {
                context.Logger.LogWarning(
                    "Validation failed for event {EventId}: payload missing.",
                    env.Id);

                return Task.FromResult(new TransformationResult(
                    env.Id,
                    Success: false,
                    ProducedAtUtc: DateTimeOffset.UtcNow,
                    FailureReason: "PayloadMissing",
                    Data: null));
            }

            return next(context, cancellationToken);
        }
    }

    /// <summary>
    /// Deserializes the raw payload into a typed <see cref="CalendarEventBatch"/>.
    /// </summary>
    public sealed class CalendarEventDeserializationStep : ITransformationStep
    {
        private static readonly JsonSerializerOptions _options = new()
        {
            PropertyNameCaseInsensitive = true,
            Converters = { new JsonStringEnumConverter() }
        };

        public async Task<TransformationResult> InvokeAsync(
            TransformationContext context,
            TransformationDelegate next,
            CancellationToken cancellationToken)
        {
            try
            {
                using var reader = new StreamReader(context.Envelope.Payload, leaveOpen: true);
                var json = await reader.ReadToEndAsync().ConfigureAwait(false);

                var batch = JsonSerializer.Deserialize<CalendarEventBatch>(json, _options)
                            ?? throw new InvalidDataException("Unable to deserialize calendar payload.");

                context.SetItem(ContextKeys.CalendarBatch, batch);

                return await next(context, cancellationToken).ConfigureAwait(false);
            }
            catch (JsonException jx)
            {
                context.Logger.LogError(jx,
                    "Failed to deserialize calendar payload for event {EventId}.",
                    context.Envelope.Id);

                return new TransformationResult(
                    context.Envelope.Id,
                    Success: false,
                    ProducedAtUtc: DateTimeOffset.UtcNow,
                    FailureReason: "InvalidJson",
                    Data: null);
            }
        }
    }

    /// <summary>
    /// Computes the Focus-Time ratio KPI for the given <see cref="CalendarEventBatch"/>.
    /// </summary>
    public sealed class FocusTimeComputationStep : ITransformationStep
    {
        private const int MinutesPerDay = 60 * 24;

        public Task<TransformationResult> InvokeAsync(
            TransformationContext context,
            TransformationDelegate next,
            CancellationToken cancellationToken)
        {
            var batch = context.GetItem<CalendarEventBatch>(ContextKeys.CalendarBatch);

            var totalMeetingMinutes = 0;
            foreach (var ev in batch.Events)
            {
                if (ev.IsMeeting)
                {
                    totalMeetingMinutes += ev.DurationMinutes;
                }
            }

            var focusTimeRatio = (double)(MinutesPerDay - totalMeetingMinutes) / MinutesPerDay;

            var output = new
            {
                batch.UserId,
                batch.Date,
                MeetingsMinutes   = totalMeetingMinutes,
                FocusTimeRatio    = Math.Round(focusTimeRatio, 4),
                SourceEventId     = context.Envelope.Id
            };

            var json = JsonSerializer.SerializeToElement(output);
            context.SetItem(TransformationPipeline.WellKnownContextKeys.Output, json);

            return next(context, cancellationToken);
        }
    }

    /// <summary>
    /// Persists the computed KPI artefact to downstream storage (e.g., Data Lake).
    /// In this sample implementation we simply emit to an <c>ILogger</c>; real
    /// deployments would inject IAmazonS3, IAmazonKinesis, etc.
    /// </summary>
    public sealed class PersistenceStep : ITransformationStep
    {
        public Task<TransformationResult> InvokeAsync(
            TransformationContext context,
            TransformationDelegate next,
            CancellationToken cancellationToken)
        {
            var output = context.GetItem<JsonElement>(TransformationPipeline.WellKnownContextKeys.Output);

            context.Logger.LogInformation(
                "Persisting Focus-Time KPI for event {EventId}: {Payload}",
                context.Envelope.Id,
                output.GetRawText());

            // NOP persistence. Replace with actual I/O in production.
            return next(context, cancellationToken);
        }
    }

    #endregion

    #region Model Definitions

    public static class ContextKeys
    {
        public const string CalendarBatch = "CALENDAR_BATCH";
    }

    /// <summary>
    /// Root object representing a batch of calendar events for a single user/day.
    /// </summary>
    public sealed record CalendarEventBatch(
        string UserId,
        DateOnly Date,
        IReadOnlyList<CalendarEvent> Events);

    /// <summary>
    /// A single calendar entry.
    /// </summary>
    public sealed record CalendarEvent(
        string Id,
        string Title,
        DateTimeOffset StartUtc,
        DateTimeOffset EndUtc,
        bool IsMeeting)
    {
        public int DurationMinutes => (int)(EndUtc - StartUtc).TotalMinutes;
    }

    #endregion

    #region Pipeline Builder Helper

    /// <summary>
    /// Static helper that assembles the default Focus-Time computation pipeline.
    /// </summary>
    public static class DefaultFocusTimePipeline
    {
        public static TransformationDelegate Create(ILogger logger)
        {
            return new TransformationPipeline()
                .Use<ValidationStep>()
                .Use<CalendarEventDeserializationStep>()
                .Use<FocusTimeComputationStep>()
                .Use<PersistenceStep>()
                .Build()
                .WithLogger(logger);
        }

        private static TransformationDelegate WithLogger(
            this TransformationDelegate delegateToWrap,
            ILogger logger) =>
            (ctx, token) =>
            {
                // Enforce logger injection so that steps relying on ILogger are never null.
                var contextWithLogger = new TransformationContext(ctx.Envelope, logger);
                foreach (var kvp in ctx.Items)
                {
                    contextWithLogger.Items[kvp.Key] = kvp.Value;
                }

                return delegateToWrap(contextWithLogger, token);
            };
    }

    #endregion
}
```