```rust
//! module_73 – Metric Monitoring & Automated Retraining Trigger
//!
//! This module implements an asynchronous, _Observer-pattern_ driven
//! metric-monitoring channel.  It is responsible for
//!   • Collecting real-time model metrics coming from Serving-Ops  
//!   • Detecting distribution drift & performance regression
//!   • Emitting retraining triggers or hyper-parameter tuning events
//!
//! The code purposefully lives in its own file so it can be compiled as an
//! independent crate feature while still integrating with the broader
//! `VisuTility-Orchestrator` architecture.
//!
//! # Highlights
//! * Thread-safe, `tokio`-powered, non-blocking event fan-out  
//! * Trait-based Observer/Subject abstraction (Open-Closed Principle)  
//! * Minimal allocations & lock contention via `RwLock` + `VecDeque`  
//! * Idiomatic error handling using `thiserror` + `anyhow`
//!
//! # Public Entry-Points
//! * [`MetricMonitor`]  –  Event loop & subscription API
//! * [`MetricObserver`] –  User-implemented observer callbacks
//!
//! ```text
//!                          +----------------+
//!                          | Model Serving  |
//!                          +-------+--------+
//!                                  | MetricEvent (mpsc)
//!                                  v
//! +-------------------------------------------------------------+
//! |                    MetricMonitor (subject)                  |
//! |      +----------------------------------------------+       |
//! |      | MetricChannel (fan-out to observers)         |       |
//! |      +----------------------------------------------+       |
//! +-------------+--------------------+------------------+-------+
//!               |                    |                  |
//!      +--------v-------+  +---------v--------+ +-------v-------+
//!      | DriftDetector  |  | SLAAlertObserver | | …            |
//!      +----------------+  +------------------+ +---------------+
//! ```
//!
//! The module purposefully avoids depending on the larger code-base except for
//! `log` so it can be re-used in downstream micro-services.

use std::{
    collections::{HashMap, VecDeque},
    sync::Arc,
};

use anyhow::{Context, Result};
use chrono::{DateTime, Utc};
use log::{debug, error, info, warn};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::{
    sync::{mpsc, Mutex, RwLock},
    task::JoinHandle,
};
use uuid::Uuid;

/* -------------------------------------------------------------------------- */
/*                               Domain Models                                */
/* -------------------------------------------------------------------------- */

/// Different camera stream modalities supported by VisuTility.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub enum CameraModality {
    Rgb,
    Thermal,
    Depth,
}

/// High-level metric categories emitted by Serving-Ops.
#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub enum MetricKind {
    Accuracy,
    Precision,
    Recall,
    DriftScore,
    LatencyMs,
}

/// Real-time metric envelope.
///
/// This struct is intentionally `Clone` because it may be fanned-out to many
/// observers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricEvent {
    pub id: Uuid,
    pub timestamp: DateTime<Utc>,
    pub camera_id: String,
    pub modality: CameraModality,
    pub metric: MetricKind,
    pub value: f64,
}

impl MetricEvent {
    pub fn new<S: Into<String>>(
        camera_id: S,
        modality: CameraModality,
        metric: MetricKind,
        value: f64,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            timestamp: Utc::now(),
            camera_id: camera_id.into(),
            modality,
            metric,
            value,
        }
    }
}

/* -------------------------------------------------------------------------- */
/*                                   Errors                                   */
/* -------------------------------------------------------------------------- */

#[derive(Debug, Error)]
pub enum MonitorError {
    #[error("observer registration failed: {0}")]
    ObserverRegistration(String),

    #[error("observer not found")]
    ObserverNotFound,

    #[error("internal channel closed")]
    ChannelClosed,

    #[error("processing error: {0}")]
    Processing(String),
}

/* -------------------------------------------------------------------------- */
/*                              Observer Pattern                              */
/* -------------------------------------------------------------------------- */

/// Callback trait to be implemented by concrete observers.
///
/// Implementations **must** be thread-safe (`Send + Sync`) because they will be
/// called from a multi-producer, single-consumer event loop.
pub trait MetricObserver: Send + Sync {
    /// Unique identifier for bookkeeping.
    fn id(&self) -> Uuid;

    /// Process a new [`MetricEvent`].
    fn on_metric(&self, event: &MetricEvent) -> Result<()>;
}

/// Subject/fan-out responsible for holding observer weak-references and
/// dispatching events in _O(n)_.
#[derive(Debug, Default)]
pub struct MetricChannel {
    observers: RwLock<HashMap<Uuid, Arc<dyn MetricObserver>>>,
}

impl MetricChannel {
    pub fn new() -> Self {
        Self {
            observers: RwLock::new(HashMap::new()),
        }
    }

    /// Subscribe an observer.  Existing observers with same `Uuid` are replaced.
    pub async fn subscribe(&self, observer: Arc<dyn MetricObserver>) -> Result<()> {
        let mut write = self.observers.write().await;
        let id = observer.id();
        debug!("Registering observer {}", id);
        write.insert(id, observer);
        Ok(())
    }

    /// Unsubscribe an observer by its ID.
    pub async fn unsubscribe(&self, id: Uuid) -> Result<()> {
        let mut write = self.observers.write().await;
        write
            .remove(&id)
            .ok_or(MonitorError::ObserverNotFound)
            .map(|_| ())
            .context("unsubscribe failed")
    }

    /// Broadcast a metric to every listener. Observers are invoked
    /// sequentially to keep state-mutations predictable.
    pub async fn broadcast(&self, event: &MetricEvent) {
        let read = self.observers.read().await;
        for (_, obs) in read.iter() {
            if let Err(e) = obs.on_metric(event) {
                error!("observer {} failed: {:?}", obs.id(), e);
            }
        }
    }
}

/* -------------------------------------------------------------------------- */
/*                        Concrete Observer – DriftDetector                   */
/* -------------------------------------------------------------------------- */

/// Basic drift detector implementing a sliding-window mean check.
///
/// When the average drift-score over `sliding_window` exceeds `threshold`,
/// a retraining alert is logged (in production this would integrate with the
/// internal Model-Registry & Pipeline-Ops to schedule retraining).
pub struct DriftDetector {
    id: Uuid,
    threshold: f64,
    sliding_window: usize,
    history: Mutex<VecDeque<f64>>,
}

impl DriftDetector {
    pub fn new(threshold: f64, sliding_window: usize) -> Self {
        Self {
            id: Uuid::new_v4(),
            threshold,
            sliding_window,
            history: Mutex::new(VecDeque::with_capacity(sliding_window)),
        }
    }

    fn push_value(&self, v: f64) -> f64 {
        let mut history = self.history.blocking_lock();
        history.push_back(v);
        if history.len() > self.sliding_window {
            history.pop_front();
        }
        let mean: f64 = history.iter().copied().sum::<f64>() / history.len() as f64;
        mean
    }
}

impl MetricObserver for DriftDetector {
    fn id(&self) -> Uuid {
        self.id
    }

    fn on_metric(&self, event: &MetricEvent) -> Result<()> {
        if event.metric != MetricKind::DriftScore {
            return Ok(()); // ignore non-drift metrics
        }

        let avg = self.push_value(event.value);
        debug!(
            "DriftDetector[{}] camera={} value={} rolling_avg={}",
            self.id, event.camera_id, event.value, avg
        );
        if avg > self.threshold {
            warn!(
                "[DriftDetector] drift score {:.4} exceeded threshold {:.4} – \
                 queuing retraining for camera '{}'",
                avg, self.threshold, event.camera_id
            );
            // TODO: integrate with Pipeline-Ops retraining queue
        }
        Ok(())
    }
}

/* -------------------------------------------------------------------------- */
/*                    Metric Monitor Public Orchestration API                 */
/* -------------------------------------------------------------------------- */

/// High-level façade combining channel fan-out with an async event loop.
///
/// Clones are cheap; they only clone the `mpsc::Sender`.
#[derive(Clone)]
pub struct MetricMonitor {
    tx: mpsc::Sender<MetricEvent>,
    channel: Arc<MetricChannel>,
}

impl MetricMonitor {
    /// Spawn the monitor background task. The call returns immediately.
    pub fn new(buffer: usize) -> (Self, JoinHandle<Result<()>>) {
        let (tx, mut rx) = mpsc::channel::<MetricEvent>(buffer);
        let channel = Arc::new(MetricChannel::new());
        let subject_clone = Arc::clone(&channel);

        let handle = tokio::spawn(async move {
            while let Some(event) = rx.recv().await {
                subject_clone.broadcast(&event).await;
            }
            Ok(())
        });

        (
            Self {
                tx,
                channel,
            },
            handle,
        )
    }

    /// Send a new metric into the system.
    pub async fn publish(&self, event: MetricEvent) -> Result<()> {
        self.tx
            .send(event)
            .await
            .map_err(|_| MonitorError::ChannelClosed)
            .context("publish failed")
    }

    /// Register a new observer.
    pub async fn register<O>(&self, observer: O) -> Result<()>
    where
        O: MetricObserver + 'static,
    {
        self.channel.subscribe(Arc::new(observer)).await
    }

    /// Remove an existing observer.
    pub async fn unregister(&self, id: Uuid) -> Result<()> {
        self.channel.unsubscribe(id).await
    }
}

/* -------------------------------------------------------------------------- */
/*                                   Tests                                    */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::{sleep, Duration};

    struct TestObserver {
        id: Uuid,
        counter: Mutex<u32>,
    }

    impl TestObserver {
        fn new() -> Self {
            Self {
                id: Uuid::new_v4(),
                counter: Mutex::new(0),
            }
        }
    }

    impl MetricObserver for TestObserver {
        fn id(&self) -> Uuid {
            self.id
        }

        fn on_metric(&self, _event: &MetricEvent) -> Result<()> {
            let mut cnt = self.counter.blocking_lock();
            *cnt += 1;
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_broadcast_and_unregister() -> Result<()> {
        let (monitor, _handle) = MetricMonitor::new(16);
        let obs = TestObserver::new();
        let id = obs.id();

        monitor.register(obs).await?;

        // Send three events
        for _ in 0..3 {
            monitor
                .publish(MetricEvent::new(
                    "cam01",
                    CameraModality::Rgb,
                    MetricKind::Accuracy,
                    0.9,
                ))
                .await?;
        }

        // Allow some time for fan-out
        sleep(Duration::from_millis(50)).await;

        // Unregister and send another event that should be ignored
        monitor.unregister(id).await?;
        monitor
            .publish(MetricEvent::new(
                "cam01",
                CameraModality::Rgb,
                MetricKind::Accuracy,
                0.8,
            ))
            .await?;

        sleep(Duration::from_millis(50)).await;
        Ok(())
    }

    #[tokio::test]
    async fn test_drift_detector_triggers() -> Result<()> {
        let (monitor, _handle) = MetricMonitor::new(16);
        let detector = DriftDetector::new(0.7, 3);
        monitor.register(detector).await?;

        let scores = [0.2, 0.3, 0.9, 0.95, 0.8];
        for s in scores.into_iter() {
            monitor
                .publish(MetricEvent::new(
                    "cam99",
                    CameraModality::Rgb,
                    MetricKind::DriftScore,
                    s,
                ))
                .await?;
        }

        sleep(Duration::from_millis(50)).await;
        Ok(())
    }
}
```