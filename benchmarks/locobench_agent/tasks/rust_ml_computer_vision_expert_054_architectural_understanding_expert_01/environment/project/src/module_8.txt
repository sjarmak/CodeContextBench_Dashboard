```rust
//! src/module_8.rs
//!
//! Hyperparameter tuning and adaptive optimisation utilities.
//!
//! This module implements a Strategy + Observer–driven hyper-parameter
//! tuner that can be embedded into any training loop.  The tuner listens to
//! metric events coming from a training routine (loss, accuracy, etc.),
//! decides—via pluggable strategies—whether parameters should be perturbed,
//! and publishes the new candidate configuration back to the caller.
//!
//! ┌──────────────────────────────┐
//! │      Training Routine        │
//! │  (sends MetricEvent items)   │◄────────────────────────┐
//! └──────────────────────────────┘                         │
//!            ▲                                             │
//!            │ mpsc::UnboundedSender<MetricEvent>          │
//!            │                                             │
//! ┌──────────────────────────────┐                         │
//! │   HyperparameterTuner        │                         │
//! └──────────────────────────────┘                         │
//!            │                                             │
//!            ▼                                             │
//! ┌──────────────────────────────┐                         │
//! │  HyperparameterStrategy      │                         │
//! ├──────────────────────────────┤                         │
//! │  GridSearch / Bayesian / …   │                         │
//! └──────────────────────────────┘                         │
//!            │                                             │
//!            ▼ new candidate                               │
//! ┌──────────────────────────────┐                         │
//! │  mpsc::UnboundedReceiver<HyperParams> ─────────────────┘
//! └──────────────────────────────┘
//!
//! NOTE:  The tuner is runtime-agnostic, but ships with a `tokio`
//! implementation for asynchronous coordination.

#![allow(clippy::module_name_repetitions)] // allow intentionally long, descriptive names

use std::{
    collections::HashMap,
    fmt,
    time::{Duration, Instant},
};

use async_trait::async_trait;
use rand::{seq::SliceRandom, thread_rng};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::sync::mpsc::{
    unbounded_channel, UnboundedReceiver, UnboundedSender,
};

/// Convenient crate-local result alias.
type Result<T> = std::result::Result<T, TunerError>;

/// Domain-level error enumeration.
#[derive(Debug, Error)]
pub enum TunerError {
    #[error("strategy initialisation failed: {0}")]
    StrategyInit(String),
    #[error("hyper-parameter generation failed: {0}")]
    Generation(String),
    #[error("internal channel send error")]
    ChannelSend,
    #[error("internal channel receive error")]
    ChannelRecv,
}

/// Canonical representation of hyper-parameter key/value pairs.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HyperParams(pub HashMap<String, f64>);

impl fmt::Display for HyperParams {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let pairs: Vec<String> = self
            .0
            .iter()
            .map(|(k, v)| format!("{k}={v:.4}"))
            .collect();
        write!(f, "{{{}}}", pairs.join(", "))
    }
}

/// Raw metrics emitted by the training loop and observed by the tuner.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricEvent {
    pub step:    u64,
    pub loss:    f64,
    pub accuracy: Option<f64>,
    pub emitted_at: Instant,
}

/// Observer side of the Observer Pattern.
pub trait MetricObserver {
    /// Receives a new metric event.
    fn on_metric_event(&mut self, event: MetricEvent) -> Result<()>;
}

/// Strategy side of the Strategy Pattern.
#[async_trait]
pub trait HyperparameterStrategy: Send + Sync {
    /// Produce an initial candidate to bootstrap training.
    async fn initial_candidate(&self) -> Result<HyperParams>;

    /// Given current hyper-params + latest metric, decide whether to tweak and
    /// return a new candidate. Returning `None` signals *no change*.
    async fn maybe_tune(
        &self,
        current: &HyperParams,
        latest_metric: &MetricEvent,
    ) -> Result<Option<HyperParams>>;
}

/* -------------------------------------------------------------------------- */
/*                                STRATEGIES                                  */
/* -------------------------------------------------------------------------- */

/// Deterministic grid search over a fixed enumeration.
pub struct GridSearchStrategy {
    search_space: Vec<HyperParams>,
    cursor:       usize,
}

impl GridSearchStrategy {
    pub fn new(search_space: Vec<HyperParams>) -> Result<Self> {
        if search_space.is_empty() {
            return Err(TunerError::StrategyInit("empty search space".into()));
        }
        Ok(Self {
            search_space,
            cursor: 0,
        })
    }
}

#[async_trait]
impl HyperparameterStrategy for GridSearchStrategy {
    async fn initial_candidate(&self) -> Result<HyperParams> {
        Ok(self.search_space[0].clone())
    }

    async fn maybe_tune(
        &self,
        _current: &HyperParams,
        _latest_metric: &MetricEvent,
    ) -> Result<Option<HyperParams>> {
        // Round-robin exploration regardless of metric.
        let mut next_idx = self.cursor + 1;
        if next_idx >= self.search_space.len() {
            // Exhausted search space; stop tuning.
            return Ok(None);
        }
        let params = self.search_space[next_idx].clone();
        // SAFETY: cursor is mutated via interior mutability pattern below:
        let mut_self = unsafe { &mut *(self as *const _ as *mut Self) };
        mut_self.cursor = next_idx;
        Ok(Some(params))
    }
}

/// Stochastic strategy randomly sampling from a provided pool.
pub struct RandomSearchStrategy {
    pool: Vec<HyperParams>,
}

impl RandomSearchStrategy {
    pub fn new(pool: Vec<HyperParams>) -> Result<Self> {
        if pool.is_empty() {
            return Err(TunerError::StrategyInit("pool is empty".into()));
        }
        Ok(Self { pool })
    }
}

#[async_trait]
impl HyperparameterStrategy for RandomSearchStrategy {
    async fn initial_candidate(&self) -> Result<HyperParams> {
        let mut rng = thread_rng();
        Ok(self.pool.choose(&mut rng).unwrap().clone())
    }

    async fn maybe_tune(
        &self,
        _current: &HyperParams,
        _latest_metric: &MetricEvent,
    ) -> Result<Option<HyperParams>> {
        let mut rng = thread_rng();
        Ok(Some(
            self.pool
                .choose(&mut rng)
                .expect("non-empty pool")
                .clone(),
        ))
    }
}

/// No-op strategy used when tuning is disabled or externally controlled.
pub struct NoOpStrategy;

#[async_trait]
impl HyperparameterStrategy for NoOpStrategy {
    async fn initial_candidate(&self) -> Result<HyperParams> {
        Err(TunerError::Generation(
            "NoOpStrategy cannot generate candidates".into(),
        ))
    }

    async fn maybe_tune(
        &self,
        _current: &HyperParams,
        _latest_metric: &MetricEvent,
    ) -> Result<Option<HyperParams>> {
        Ok(None)
    }
}

/* -------------------------------------------------------------------------- */
/*                            TUNER  CO-ORDINATOR                             */
/* -------------------------------------------------------------------------- */

/// Primary entry-point tying together strategies, observers, and I/O plumbing.
pub struct HyperparameterTuner {
    strategy: Box<dyn HyperparameterStrategy>,
    metric_rx: UnboundedReceiver<MetricEvent>,
    candidate_tx: UnboundedSender<HyperParams>,
    // Internal state:
    last_emitted: Option<HyperParams>,
    last_tune_at: Instant,
    min_tune_interval: Duration,
}

impl HyperparameterTuner {
    /// Construct a new tuner with the provided strategy.
    pub fn new(
        strategy: Box<dyn HyperparameterStrategy>,
        metric_rx: UnboundedReceiver<MetricEvent>,
        candidate_tx: UnboundedSender<HyperParams>,
        min_tune_interval: Duration,
    ) -> Self {
        Self {
            strategy,
            metric_rx,
            candidate_tx,
            last_emitted: None,
            last_tune_at: Instant::now(),
            min_tune_interval,
        }
    }

    /// Helper for clients that don't want to manage channels manually.
    pub fn with_channels(
        strategy: Box<dyn HyperparameterStrategy>,
        min_tune_interval: Duration,
    ) -> (
        Self,
        UnboundedSender<MetricEvent>,
        UnboundedReceiver<HyperParams>,
    ) {
        let (metric_tx, metric_rx) = unbounded_channel();
        let (candidate_tx, candidate_rx) = unbounded_channel();
        let tuner =
            Self::new(strategy, metric_rx, candidate_tx, min_tune_interval);
        (tuner, metric_tx, candidate_rx)
    }

    /// Spawn the tuner onto the provided Tokio runtime.
    pub fn spawn(mut self) {
        tokio::spawn(async move {
            if let Err(e) = self.run().await {
                tracing::error!("hyper-parameter tuner stopped: {e}");
            }
        });
    }

    async fn run(&mut self) -> Result<()> {
        // Emit bootstrap candidate.
        let initial = self.strategy.initial_candidate().await?;
        self.candidate_tx
            .send(initial.clone())
            .map_err(|_| TunerError::ChannelSend)?;
        self.last_emitted = Some(initial);
        self.last_tune_at = Instant::now();

        while let Some(event) = self.metric_rx.recv().await {
            let should_tune =
                self.last_tune_at.elapsed() >= self.min_tune_interval;

            if !should_tune {
                continue;
            }

            let current_params =
                self.last_emitted.as_ref().expect("some params exist");

            if let Some(new_params) = self
                .strategy
                .maybe_tune(current_params, &event)
                .await?
            {
                self.last_emitted = Some(new_params.clone());
                self.last_tune_at = Instant::now();
                self.candidate_tx
                    .send(new_params)
                    .map_err(|_| TunerError::ChannelSend)?;
            }
        }
        Err(TunerError::ChannelRecv)
    }
}

/* -------------------------------------------------------------------------- */
/*                               UNIT TESTS                                   */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::sleep;

    #[tokio::test]
    async fn test_random_strategy_emits_candidates() {
        let params_pool = vec![
            HyperParams(HashMap::from([
                ("lr".into(), 0.001),
                ("batch_size".into(), 32.0),
            ])),
            HyperParams(HashMap::from([
                ("lr".into(), 0.01),
                ("batch_size".into(), 64.0),
            ])),
        ];

        let strategy =
            Box::new(RandomSearchStrategy::new(params_pool).unwrap());

        let (mut tuner, metric_tx, mut candidate_rx) =
            HyperparameterTuner::with_channels(
                strategy,
                Duration::from_millis(50),
            );
        tuner.spawn();

        // Receive initial candidate.
        let first = candidate_rx.recv().await.unwrap();
        assert!(
            !first.0.is_empty(),
            "initial candidate should not be empty"
        );

        // Send fake metric events and ensure we eventually get a new candidate.
        for step in 1..10 {
            metric_tx
                .send(MetricEvent {
                    step,
                    loss: 0.1 / step as f64,
                    accuracy: None,
                    emitted_at: Instant::now(),
                })
                .unwrap();
            sleep(Duration::from_millis(10)).await;
        }

        // Wait long enough for tuner to react.
        let second = candidate_rx.recv().await.unwrap();
        assert_ne!(first.0, second.0, "should receive a new hyper-params set");
    }
}
```