```rust
//! src/module_11.rs
//!
//! Module 11: Online‐Performance Monitor & Automated‐Retraining Trigger
//! --------------------------------------------------------------------
//! This module sits in the “Model-Ops” layer and implements an online,
//! windowed-metrics monitor that listens to inference events produced by
//! downstream Serving-Ops components.  Whenever the sliding-window metric
//! (e.g. F1‐score) drops below a configurable threshold for a
//! user-defined number of consecutive windows, an automatic retraining
//! request is dispatched through the same event bus.
//!
//! Architectural Patterns Demonstrated
//! -----------------------------------
//! • Observer Pattern   – The monitor *observes* prediction events.
//! • Strategy Pattern   – Any windowed metric that implements
//!   `WindowedMetric` can be plugged in at runtime.
//! • MLOps Integration – Emits a `RetrainingRequest` payload that can be
//!   handled by the project’s retraining‐orchestrator.
//!
//! External Crates (add to Cargo.toml)
//! -----------------------------------
//! crossbeam-channel  = "0.5"
//! serde              = { version = "1.0", features = ["derive"] }
//! thiserror          = "1.0"
//!
//! # Example
//! ````no_run
//! use visu_tility_orchestrator::module_11::*;
//!
//! // Build a shared event bus
//! let bus = EventBus::default();
//!
//! // Spawn a performance monitor with an F1 metric
//! let cfg = MonitorConfig::default();
//! let monitor = PerformanceMonitor::spawn(
//!     bus.clone(),
//!     Box::new(F1Score::default()),
//!     cfg,
//! );
//!
//! // Somewhere else in the code base, publish prediction events
//! let publisher = bus.publisher();
//! publisher
//!     .send(MonitorEvent::Prediction(PredictionEvent::mock_positive()))
//!     .unwrap();
//! ````

use std::{
    fmt,
    thread,
    time::{Duration, Instant},
};

use crossbeam_channel::{select, unbounded, Receiver, Sender};
use serde::{Deserialize, Serialize};
use thiserror::Error;

/// Public re-exports
pub use metric::*;
pub use monitor::*;
pub use bus::*;

mod bus {
    use super::*;

    /// Thread-safe fan-out event bus using crossbeam channels
    #[derive(Clone, Default)]
    pub struct EventBus {
        tx: Sender<MonitorEvent>,
        rx: Receiver<MonitorEvent>,
    }

    impl EventBus {
        pub fn new(buffer: usize) -> Self {
            let (tx, rx) = unbounded();
            // `buffer` kept for future bounded impl
            let _ = buffer;
            Self { tx, rx }
        }

        pub fn publisher(&self) -> Sender<MonitorEvent> {
            self.tx.clone()
        }

        pub fn subscribe(&self) -> Receiver<MonitorEvent> {
            self.rx.clone()
        }
    }

    impl Default for EventBus {
        fn default() -> Self {
            Self::new(1024)
        }
    }

    /// Events flowing through the EventBus.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum MonitorEvent {
        Prediction(PredictionEvent),
        RetrainingRequest(RetrainingRequest),
        // Reserved for future events
    }
}

mod metric {
    use super::*;

    /// Errors specific to metric calculations
    #[derive(Debug, Error)]
    pub enum MetricError {
        #[error("division by zero in metric computation")]
        DivisionByZero,
    }

    /// Strategy Pattern – Plug-and-play sliding-window metrics.
    pub trait WindowedMetric: Send + Sync + 'static {
        /// Update internal state with a new observation.
        fn update(&mut self, obs: &PredictionEvent) -> Result<(), MetricError>;

        /// Current metric over the window.
        fn value(&self) -> f64;

        /// Human-readable metric name
        fn name(&self) -> &'static str;
    }

    /// Classic F1-Score over a rolling window of the last *N* predictions.
    #[derive(Clone)]
    pub struct F1Score {
        pub window: usize,
        buffer: Vec<PredictionEvent>,
        tp: usize,
        fp: usize,
        fn_: usize,
    }

    impl Default for F1Score {
        fn default() -> Self {
            Self::new(128)
        }
    }

    impl F1Score {
        pub fn new(window: usize) -> Self {
            Self {
                window,
                buffer: Vec::with_capacity(window),
                tp: 0,
                fp: 0,
                fn_: 0,
            }
        }

        fn push(&mut self, evt: PredictionEvent) {
            if self.buffer.len() == self.window {
                // Pop oldest and update counters
                let oldest = self.buffer.remove(0);
                self.decrement_counters(&oldest);
            }
            self.increment_counters(&evt);
            self.buffer.push(evt);
        }

        fn increment_counters(&mut self, evt: &PredictionEvent) {
            match (evt.prediction, evt.ground_truth) {
                (Label::Positive, Some(Label::Positive)) => self.tp += 1,
                (Label::Positive, Some(Label::Negative)) => self.fp += 1,
                (Label::Negative, Some(Label::Positive)) => self.fn_ += 1,
                _ => {}
            }
        }

        fn decrement_counters(&mut self, evt: &PredictionEvent) {
            match (evt.prediction, evt.ground_truth) {
                (Label::Positive, Some(Label::Positive)) => self.tp -= 1,
                (Label::Positive, Some(Label::Negative)) => self.fp -= 1,
                (Label::Negative, Some(Label::Positive)) => self.fn_ -= 1,
                _ => {}
            }
        }
    }

    impl WindowedMetric for F1Score {
        fn update(&mut self, obs: &PredictionEvent) -> Result<(), MetricError> {
            self.push(obs.clone());
            Ok(())
        }

        fn value(&self) -> f64 {
            let precision_den = self.tp + self.fp;
            let recall_den = self.tp + self.fn_;
            if precision_den == 0 || recall_den == 0 {
                return 0.0;
            }
            let precision = self.tp as f64 / precision_den as f64;
            let recall = self.tp as f64 / recall_den as f64;
            if precision + recall == 0.0 {
                0.0
            } else {
                2.0 * precision * recall / (precision + recall)
            }
        }

        fn name(&self) -> &'static str {
            "f1-score"
        }
    }
}

mod monitor {
    use super::*;

    /// Configuration for the online monitor
    #[derive(Debug, Clone)]
    pub struct MonitorConfig {
        /// Metric alert threshold (e.g. F1 < 0.75 triggers alert)
        pub threshold: f64,
        /// Number of consecutive windows below threshold before raising flag
        pub patience: usize,
        /// Polling interval for internal loop
        pub tick_interval: Duration,
        /// Duration after which monitor exits if bus is disconnected
        pub max_idle: Duration,
    }

    impl Default for MonitorConfig {
        fn default() -> Self {
            Self {
                threshold: 0.75,
                patience: 3,
                tick_interval: Duration::from_millis(500),
                max_idle: Duration::from_secs(30),
            }
        }
    }

    /// Handle to the monitor thread
    pub struct PerformanceMonitor {
        handle: thread::JoinHandle<()>,
    }

    impl PerformanceMonitor {
        #[allow(clippy::too_many_arguments)]
        pub fn spawn(
            bus: EventBus,
            mut metric: Box<dyn WindowedMetric>,
            cfg: MonitorConfig,
        ) -> Self {
            let rx = bus.subscribe();
            let tx = bus.publisher();

            let handle = thread::Builder::new()
                .name("performance-monitor".into())
                .spawn(move || {
                    let mut below_threshold_counter = 0usize;
                    let mut last_activity = Instant::now();

                    loop {
                        select! {
                            recv(rx) -> msg => {
                                match msg {
                                    Ok(MonitorEvent::Prediction(evt)) => {
                                        metric.update(&evt).ok(); // ignore metric errors
                                        last_activity = Instant::now();
                                    }
                                    Ok(other) => {
                                        // Other event types are ignored for metric
                                        tracing::debug!("Monitor received other event: {:?}", other);
                                    }
                                    Err(_) => {
                                        tracing::warn!("EventBus channel closed; monitor exiting");
                                        break;
                                    }
                                }
                            }

                            default(cfg.tick_interval) => {
                                // periodic evaluation
                                let current_score = metric.value();
                                tracing::debug!(
                                    "Windowed {} = {:.3}",
                                    metric.name(),
                                    current_score
                                );

                                if current_score < cfg.threshold {
                                    below_threshold_counter += 1;
                                    tracing::warn!(
                                        "{} {:.3} below threshold {:.3} ({} / {})",
                                        metric.name(),
                                        current_score,
                                        cfg.threshold,
                                        below_threshold_counter,
                                        cfg.patience
                                    );
                                } else {
                                    below_threshold_counter = 0;
                                }

                                if below_threshold_counter >= cfg.patience {
                                    let request = RetrainingRequest::new(
                                        metric.name(),
                                        current_score,
                                        cfg.threshold,
                                    );

                                    if tx.send(MonitorEvent::RetrainingRequest(request)).is_ok() {
                                        tracing::info!("RetrainingRequest dispatched");
                                    } else {
                                        tracing::error!("Failed to dispatch RetrainingRequest");
                                    }
                                    below_threshold_counter = 0; // reset after trigger
                                }

                                // Check idle timeout
                                if last_activity.elapsed() > cfg.max_idle {
                                    tracing::info!("No events for {:?}; monitor shutting down", cfg.max_idle);
                                    break;
                                }
                            }
                        }
                    }
                })
                .expect("failed to spawn performance monitor thread");

            Self { handle }
        }
    }

    impl Drop for PerformanceMonitor {
        fn drop(&mut self) {
            if let Err(e) = self.handle.join() {
                tracing::error!("Monitor thread panicked: {:?}", e);
            }
        }
    }
}

/// Ground-truth / prediction label
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum Label {
    Positive,
    Negative,
}

/// Event emitted for every single prediction
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PredictionEvent {
    pub model_version: String,
    pub prediction: Label,
    pub ground_truth: Option<Label>,
    pub timestamp: Instant,
}

impl PredictionEvent {
    #[allow(dead_code)]
    pub fn new(
        model_version: impl Into<String>,
        prediction: Label,
        ground_truth: Option<Label>,
    ) -> Self {
        Self {
            model_version: model_version.into(),
            prediction,
            ground_truth,
            timestamp: Instant::now(),
        }
    }

    /// Convenience constructor for tests / examples
    pub fn mock_positive() -> Self {
        Self::new("v0.0.0-mock", Label::Positive, Some(Label::Positive))
    }
}

/// Payload sent whenever automated retraining is requested
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RetrainingRequest {
    pub triggered_by_metric: &'static str,
    pub observed_value: f64,
    pub threshold_value: f64,
    pub created_at: Instant,
}

impl RetrainingRequest {
    pub fn new(metric: &'static str, observed_value: f64, threshold_value: f64) -> Self {
        Self {
            triggered_by_metric: metric,
            observed_value,
            threshold_value,
            created_at: Instant::now(),
        }
    }
}

impl fmt::Display for RetrainingRequest {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "RetrainingRequest(metric={}, observed={:.3}, threshold={:.3})",
            self.triggered_by_metric, self.observed_value, self.threshold_value
        )
    }
}
```