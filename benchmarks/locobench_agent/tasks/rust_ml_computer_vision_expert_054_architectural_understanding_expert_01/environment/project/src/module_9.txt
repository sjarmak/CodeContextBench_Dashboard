```rust
//! module_9.rs
//!
//! Model-Monitoring & Automated-Retraining orchestration component for
//! VisuTility Orchestrator.  This module wires together the Observer,
//! Strategy, and Factory patterns to continuously watch inference-time
//! metrics, detect model-drift / data-drift, and emit retraining
//! signals that upstream MLOps daemons can consume.
//!
//! Production-quality concerns addressed:
//!   • Asynchronous, back-pressure aware channels (tokio mpsc)
//!   • Strong, expressive error typing (thiserror + anyhow)
//!   • Extensibility via trait objects + Factory pattern
//!   • Configurability by Serde-deserializable structs
//!   • Metrics aggregated through generic observer pipeline
//!   • Unit-level logging (tracing)
//!
//! External dependencies expected in Cargo.toml:
//
//! [dependencies]
//! tokio          = { version = "1", features = ["full"] }
//! async-trait    = "0.1"
//! serde          = { version = "1.0", features = ["derive"] }
//! serde_json     = "1.0"
//! thiserror      = "1.0"
//! anyhow         = "1.0"
//! tracing        = "0.1"
//!
//! Optional integration with the project’s feature-gated crates (not shown).

use std::sync::Arc;
use std::time::{Duration, Instant};

use anyhow::Result;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::sync::{mpsc, watch, Mutex};
use tokio::task;
use tracing::{debug, error, info, instrument, warn};

/// ---------------------------------------------------------------------
/// Error Handling
/// ---------------------------------------------------------------------

#[derive(Debug, Error)]
pub enum MonitorError {
    #[error("metric channel closed unexpectedly")]
    ChannelClosed,

    #[error("collector {0} failed: {1}")]
    CollectorFailure(String, anyhow::Error),

    #[error("configuration error: {0}")]
    Config(String),
}

/// ---------------------------------------------------------------------
/// Event Model
/// ---------------------------------------------------------------------

/// High-level metric signals observed in real-time.
#[derive(Debug, Clone)]
pub enum MetricEvent {
    /// Model inference latency (milliseconds).
    Latency {
        model_id: String,
        value_ms: f64,
        timestamp: Instant,
    },
    /// Online accuracy or delta (0.0–1.0 inclusive).
    Accuracy {
        model_id: String,
        value: f64,
        timestamp: Instant,
    },
    /// Custom user-provided metric (extensible).
    Custom {
        model_id: String,
        name: String,
        value: f64,
        timestamp: Instant,
    },
}

/// Retraining reason enumerated for audit trail.
#[derive(Debug, Clone, Serialize)]
pub enum RetrainReason {
    LatencyDegradation { observed_ms: f64, threshold_ms: f64 },
    AccuracyDrop { observed: f64, threshold: f64 },
    Custom(String),
}

/// Event emitted when monitor decides to schedule a retraining job.
#[derive(Debug, Clone, Serialize)]
pub struct RetrainSignal {
    pub model_id: String,
    pub reason: RetrainReason,
    pub triggered_at: Instant,
}

/// ---------------------------------------------------------------------
/// Metric Collector Trait (Factory Product)
/// ---------------------------------------------------------------------

#[async_trait]
pub trait MetricCollector: Send + Sync {
    /// Human-friendly name used by factory + logging.
    fn name(&self) -> &'static str;

    /// Runs the collector loop; pushes MetricEvent downstream.
    async fn run(
        &self,
        mut shutdown: watch::Receiver<bool>,
        tx: mpsc::Sender<MetricEvent>,
    ) -> Result<()>;
}

/// ---------------------------------------------------------------------
/// Concrete Collectors
/// ---------------------------------------------------------------------

/// Simple latency collector that receives inference latency samples from
/// a provided async stream (simulated here via a channel).
pub struct LatencyCollector {
    model_id: String,
    mut_rx: Mutex<mpsc::Receiver<f64>>,
}

impl LatencyCollector {
    pub fn new(model_id: impl Into<String>, rx: mpsc::Receiver<f64>) -> Self {
        Self {
            model_id: model_id.into(),
            mut_rx: Mutex::new(rx),
        }
    }
}

#[async_trait]
impl MetricCollector for LatencyCollector {
    fn name(&self) -> &'static str {
        "LatencyCollector"
    }

    #[instrument(skip_all, name = "LatencyCollector::run")]
    async fn run(
        &self,
        mut shutdown: watch::Receiver<bool>,
        tx: mpsc::Sender<MetricEvent>,
    ) -> Result<()> {
        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    info!("LatencyCollector received shutdown");
                    break;
                }
                Some(latency_ms) = self.mut_rx.lock().await.recv() => {
                    let evt = MetricEvent::Latency {
                        model_id: self.model_id.clone(),
                        value_ms: latency_ms,
                        timestamp: Instant::now(),
                    };
                    if let Err(e) = tx.send(evt).await {
                        error!("LatencyCollector unable to send metric: {e}");
                        return Err(MonitorError::ChannelClosed.into());
                    }
                }
                else => {
                    warn!("LatencyCollector inbound channel closed");
                    break;
                }
            }
        }
        Ok(())
    }
}

/// Stubbed accuracy collector: in real deployment uses sliding-window
/// inference label comparison.
pub struct AccuracyCollector {
    model_id: String,
    mut_rx: Mutex<mpsc::Receiver<f64>>,
}

impl AccuracyCollector {
    pub fn new(model_id: impl Into<String>, rx: mpsc::Receiver<f64>) -> Self {
        Self {
            model_id: model_id.into(),
            mut_rx: Mutex::new(rx),
        }
    }
}

#[async_trait]
impl MetricCollector for AccuracyCollector {
    fn name(&self) -> &'static str {
        "AccuracyCollector"
    }

    #[instrument(skip_all, name = "AccuracyCollector::run")]
    async fn run(
        &self,
        mut shutdown: watch::Receiver<bool>,
        tx: mpsc::Sender<MetricEvent>,
    ) -> Result<()> {
        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    info!("AccuracyCollector received shutdown");
                    break;
                }
                Some(acc) = self.mut_rx.lock().await.recv() => {
                    let evt = MetricEvent::Accuracy {
                        model_id: self.model_id.clone(),
                        value: acc,
                        timestamp: Instant::now(),
                    };
                    tx.send(evt).await.map_err(|_| MonitorError::ChannelClosed)?;
                }
                else => {
                    warn!("AccuracyCollector inbound channel closed");
                    break;
                }
            }
        }
        Ok(())
    }
}

/// ---------------------------------------------------------------------
/// Collector Factory
/// ---------------------------------------------------------------------

/// Blueprint describing which metric to collect.
#[derive(Debug, Clone, Deserialize)]
#[serde(tag = "type")]
pub enum CollectorConfig {
    #[serde(rename = "latency")]
    Latency { model_id: String },

    #[serde(rename = "accuracy")]
    Accuracy { model_id: String },

    // Placeholder for user-defined collector types.
    #[serde(other)]
    Unsupported,
}

/// Factory that converts configs into running collectors.
pub struct CollectorFactory;

impl CollectorFactory {
    pub fn build(
        cfg: CollectorConfig,
        rx: mpsc::Receiver<f64>,
    ) -> Result<Arc<dyn MetricCollector>> {
        match cfg {
            CollectorConfig::Latency { model_id } => Ok(Arc::new(LatencyCollector::new(
                model_id, rx,
            ))),
            CollectorConfig::Accuracy { model_id } => Ok(Arc::new(AccuracyCollector::new(
                model_id, rx,
            ))),
            CollectorConfig::Unsupported => Err(MonitorError::Config(
                "Unsupported collector type".into(),
            )
            .into()),
        }
    }
}

/// ---------------------------------------------------------------------
/// Monitor Strategy Configuration
/// ---------------------------------------------------------------------

#[derive(Debug, Clone, Deserialize)]
pub struct MonitorConfig {
    pub latency_threshold_ms: Option<f64>,
    pub accuracy_threshold: Option<f64>,
    #[serde(default = "default_window")]
    pub evaluation_window: Duration,
}

fn default_window() -> Duration {
    Duration::from_secs(30)
}

/// ---------------------------------------------------------------------
/// Model Monitor (Observer) Implementation
/// ---------------------------------------------------------------------

pub struct ModelMonitor {
    cfg: MonitorConfig,
    rx: Mutex<mpsc::Receiver<MetricEvent>>,
    retrain_tx: mpsc::Sender<RetrainSignal>,
}

impl ModelMonitor {
    pub fn new(
        cfg: MonitorConfig,
        rx: mpsc::Receiver<MetricEvent>,
        retrain_tx: mpsc::Sender<RetrainSignal>,
    ) -> Self {
        Self {
            cfg,
            rx: Mutex::new(rx),
            retrain_tx,
        }
    }

    /// Spawn monitor loop; returns a handle to join on.
    #[instrument(skip_all, name = "ModelMonitor::spawn")]
    pub fn spawn(self: Arc<Self>, mut shutdown: watch::Receiver<bool>) -> task::JoinHandle<()> {
        task::spawn(async move {
            if let Err(e) = self.run(&mut shutdown).await {
                error!("ModelMonitor terminated with error: {e:?}");
            }
            info!("ModelMonitor shutdown finished");
        })
    }

    #[instrument(skip_all)]
    async fn run(&self, shutdown: &mut watch::Receiver<bool>) -> Result<()> {
        let mut window_start = Instant::now();
        let mut latency_acc: Vec<f64> = Vec::new();
        let mut acc_acc: Vec<f64> = Vec::new();

        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    debug!("Monitor received shutdown");
                    break;
                }
                Some(evt) = self.rx.lock().await.recv() => {
                    match evt {
                        MetricEvent::Latency { value_ms, .. } => latency_acc.push(value_ms),
                        MetricEvent::Accuracy { value, .. } => acc_acc.push(value),
                        MetricEvent::Custom { .. } => {
                            // TODO: custom metric evaluation rules
                        }
                    }
                }
                _ = tokio::time::sleep(Duration::from_millis(250)) => {
                    // periodic evaluation
                }
            }

            if window_start.elapsed() >= self.cfg.evaluation_window {
                self.evaluate_window(&latency_acc, &acc_acc).await?;
                latency_acc.clear();
                acc_acc.clear();
                window_start = Instant::now();
            }
        }
        Ok(())
    }

    #[instrument(skip_all, level = "debug")]
    async fn evaluate_window(&self, latencies: &[f64], accuracies: &[f64]) -> Result<()> {
        // ---------------- Latency Check ----------------
        if let Some(threshold) = self.cfg.latency_threshold_ms {
            if let Some(avg_latency) = mean(latencies) {
                debug!("Average latency in window {:.2}ms", avg_latency);
                if avg_latency > threshold {
                    let reason = RetrainReason::LatencyDegradation {
                        observed_ms: avg_latency,
                        threshold_ms: threshold,
                    };
                    self.signal_retrain("unknown_model", reason).await?;
                }
            }
        }

        // ---------------- Accuracy Check ----------------
        if let Some(threshold) = self.cfg.accuracy_threshold {
            if let Some(avg_acc) = mean(accuracies) {
                debug!("Average accuracy in window {:.4}", avg_acc);
                if avg_acc < threshold {
                    let reason = RetrainReason::AccuracyDrop {
                        observed: avg_acc,
                        threshold,
                    };
                    self.signal_retrain("unknown_model", reason).await?;
                }
            }
        }

        Ok(())
    }

    #[instrument(skip_all, level = "debug")]
    async fn signal_retrain(&self, model_id: &str, reason: RetrainReason) -> Result<()> {
        let signal = RetrainSignal {
            model_id: model_id.into(),
            reason,
            triggered_at: Instant::now(),
        };
        info!(?signal, "RetrainSignal generated");
        self.retrain_tx
            .send(signal)
            .await
            .map_err(|_| MonitorError::ChannelClosed.into())
    }
}

/// ---------------------------------------------------------------------
/// Helper Utilities
/// ---------------------------------------------------------------------

fn mean(vals: &[f64]) -> Option<f64> {
    if vals.is_empty() {
        None
    } else {
        Some(vals.iter().sum::<f64>() / vals.len() as f64)
    }
}

/// ---------------------------------------------------------------------
/// Integration Test / Example (feature-gated to avoid production compile)
/// ---------------------------------------------------------------------
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::sync::mpsc;

    #[tokio::test]
    async fn monitor_triggers_latency_retrain() {
        let (lat_tx, lat_rx) = mpsc::channel(16);
        let (metric_tx, metric_rx) = mpsc::channel(32);
        let (retrain_tx, mut retrain_rx) = mpsc::channel(8);
        let (shutdown_tx, shutdown_rx) = watch::channel(false);

        // Build collector and spawn.
        let collector = LatencyCollector::new("model_X", lat_rx);
        tokio::spawn(async move {
            collector.run(shutdown_rx.clone(), metric_tx).await.unwrap();
        });

        // Build monitor
        let cfg = MonitorConfig {
            latency_threshold_ms: Some(10.0),
            accuracy_threshold: None,
            evaluation_window: Duration::from_millis(500),
        };
        let monitor = Arc::new(ModelMonitor::new(cfg, metric_rx, retrain_tx));
        monitor.spawn(shutdown_rx.clone());

        // send some latency samples
        for _ in 0..5 {
            lat_tx.send(25.0).await.unwrap(); // exceeds threshold
        }

        // Wait for signal
        let signal = tokio::time::timeout(Duration::from_secs(3), retrain_rx.recv())
            .await
            .expect("timeout")
            .expect("no signal");
        match signal.reason {
            RetrainReason::LatencyDegradation { .. } => {}
            _ => panic!("unexpected reason"),
        }

        // Shutdown
        shutdown_tx.send_replace(true);
    }
}
```