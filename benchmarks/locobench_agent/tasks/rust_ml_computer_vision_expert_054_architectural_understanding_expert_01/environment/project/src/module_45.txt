```rust
//! src/module_45.txt
//!
//! Model-Monitoring sub-system implementing an Observer Pattern on top of a
//! lightweight, thread-safe event bus.  The bus is used by the different
//! VisuTility pipeline layers to emit operational events such as inference
//! completions, training jobs, or anomaly detections.  Down-stream observers
//! (metrics collectors, drift detectors, alert dispatchers, â€¦) can subscribe
//! to specific [`EventKind`]s and react without introducing tight coupling or
//! cyclic dependencies.
//
//! # Design Highlights
//!
//! â€¢   Thread-safe, lock-free read-optimised `RwLock` guarding the subscription
//!     registry.  Most traffic is in the `publish` path, so reads should be
//!     as cheap as possible.
//! â€¢   Observers are kept behind `Arc<dyn EventObserver + Send + Sync>`â€”they
//!     can be shared across threads, tasks, or even processes via `ipc-channel`
//!     if necessary.
//! â€¢   Uses structured logging (`log` crate) and automatic time-stamping
//!     (`chrono` crate).
//! â€¢   Error handling follows the `thiserror` pattern. All observer failures
//!     are bubble-upped as `MonitoringError` but do **not** short-circuit the
//!     publish path; the bus keeps dispatching other observers.
//
//! # Compile-Time Feature Flags
//!
//! The module is completely self-contained and does **not** rely on crate-level
//! feature flags.  Optional dependencies (e.g. `metrics`) are hidden behind
//! their own Cargo features in `Cargo.toml` and are therefore safe to pull
//! even if the root crate does not enable them.
//
//! ---------------------------------------------------------------------------

use std::{
    collections::HashMap,
    fmt,
    sync::{Arc, RwLock},
};

use chrono::{DateTime, Utc};
use log::{debug, error, info, warn};
use serde::{Deserialize, Serialize};
use thiserror::Error;

/// A lightweight, serialisable wrapper for any event emitted by the system.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct EventEnvelope {
    pub kind: EventKind,
    pub severity: Severity,
    pub timestamp: DateTime<Utc>,
    /// Semi-structured JSON metadata.  Prefer small payloads; if you need to
    /// ship large objects, store them in object storage and reference them.
    pub metadata: serde_json::Value,
}

impl EventEnvelope {
    pub fn new<K: Into<EventKind>, S: Into<Severity>>(
        kind: K,
        severity: S,
        metadata: serde_json::Value,
    ) -> Self {
        Self {
            kind: kind.into(),
            severity: severity.into(),
            timestamp: Utc::now(),
            metadata,
        }
    }
}

/// Taxonomy of events that can be observed in the platform.  Enumeration is
/// non-exhaustive and can be extended without breaking semantics.
#[derive(
    Clone, Copy, Debug, Hash, Eq, PartialEq, Serialize, Deserialize, Ord, PartialOrd,
)]
pub enum EventKind {
    InferenceCompleted,
    InferenceFailed,
    TrainingStarted,
    TrainingCompleted,
    RetrainingTriggered,
    DataDriftDetected,
    /// A catch-all user defined event.
    Custom(&'static str),
}

impl From<&'static str> for EventKind {
    fn from(s: &'static str) -> Self {
        EventKind::Custom(s)
    }
}

/// Severity levels are intentionally close to _syslog_ semantics.
#[derive(
    Clone, Copy, Debug, Hash, Eq, PartialEq, Serialize, Deserialize, Ord, PartialOrd,
)]
pub enum Severity {
    Trace,
    Debug,
    Info,
    Warn,
    Error,
    Critical,
}

impl From<log::Level> for Severity {
    fn from(level: log::Level) -> Self {
        match level {
            log::Level::Trace => Severity::Trace,
            log::Level::Debug => Severity::Debug,
            log::Level::Info => Severity::Info,
            log::Level::Warn => Severity::Warn,
            log::Level::Error => Severity::Error,
        }
    }
}

impl fmt::Display for Severity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            Severity::Trace => "TRACE",
            Severity::Debug => "DEBUG",
            Severity::Info => "INFO",
            Severity::Warn => "WARN",
            Severity::Error => "ERROR",
            Severity::Critical => "CRITICAL",
        };
        write!(f, "{s}")
    }
}

/// Observer trait; implementors register with the [`EventBus`] and receive
/// callbacks whenever a subscribed [`EventKind`] is published.
pub trait EventObserver: Send + Sync {
    fn on_event(&self, envelope: &EventEnvelope) -> Result<(), MonitoringError>;
}

/// Thread-safe, multi-producer multi-consumer event bus.
#[derive(Default)]
pub struct EventBus {
    /// Map: `EventKind` â†’ list of observers. The `RwLock` favours concurrent
    /// reads (`publish`) over writes (`subscribe`/`unsubscribe`).
    observers: RwLock<HashMap<EventKind, Vec<Arc<dyn EventObserver>>>>,
}

impl EventBus {
    /// Create a new, empty bus.
    pub fn new() -> Self {
        Self::default()
    }

    /// Subscribe an observer to a specific `EventKind`.
    pub fn subscribe<O>(&self, kind: EventKind, observer: O)
    where
        O: EventObserver + 'static,
    {
        let mut guard = self
            .observers
            .write()
            .expect("poisoned EventBus::observers lock");
        let list = guard.entry(kind).or_default();
        list.push(Arc::new(observer));
        info!("Observer subscribed to {kind:?}; total={}", list.len());
    }

    /// Publish an event to all observers.  Will never panicâ€”individual observer
    /// failures are logged and aggregated.
    pub fn publish(&self, envelope: EventEnvelope) -> PublishReport {
        // Snapshot the observer list to minimise the critical section.
        let subscriptions = {
            let guard = self
                .observers
                .read()
                .expect("poisoned EventBus::observers lock");
            guard
                .get(&envelope.kind)
                .cloned()
                .unwrap_or_else(Vec::new)
        };

        if subscriptions.is_empty() {
            warn!(
                "No observers found for {:?}. Discarding event.",
                envelope.kind
            );
            return PublishReport::no_subscribers();
        }

        let mut report = PublishReport::with_capacity(subscriptions.len());

        for observer in subscriptions {
            match observer.on_event(&envelope) {
                Ok(()) => report.success += 1,
                Err(e) => {
                    report.failures.push(e);
                }
            }
        }
        report
    }
}

/// Result object returned by `EventBus::publish`.
#[derive(Debug)]
pub struct PublishReport {
    pub attempted: usize,
    pub success: usize,
    pub failures: Vec<MonitoringError>,
}

impl PublishReport {
    fn with_capacity(capacity: usize) -> Self {
        Self {
            attempted: capacity,
            success: 0,
            failures: Vec::with_capacity(capacity),
        }
    }

    fn no_subscribers() -> Self {
        Self {
            attempted: 0,
            success: 0,
            failures: Vec::new(),
        }
    }
}

/// Base error type for the monitoring subsystem.
#[derive(Debug, Error)]
pub enum MonitoringError {
    #[error("metrics collection failure: {0}")]
    Metrics(#[source] anyhow::Error),

    #[error("drift detector error: {0}")]
    DriftDetector(#[source] anyhow::Error),

    #[error("alert dispatch failure: {0}")]
    Alert(#[source] anyhow::Error),

    #[error("observer internal error: {0}")]
    Internal(#[from] anyhow::Error),
}

// ---------------------------------------------------------------------------
// Example Observers
// ---------------------------------------------------------------------------

/// Dummy metrics collector.  In production this would talk to `metrics` or
/// Prometheus histogram buckets.
pub struct MetricsCollector;

impl MetricsCollector {
    pub fn new() -> Self {
        Self
    }
}

impl EventObserver for MetricsCollector {
    fn on_event(&self, envelope: &EventEnvelope) -> Result<(), MonitoringError> {
        debug!("MetricsCollector received event: {:?}", envelope.kind);
        // Simulate possible error.
        if envelope.kind == EventKind::InferenceFailed {
            return Err(MonitoringError::Metrics(anyhow::anyhow!(
                "failed inference counter increment"
            )));
        }
        // Pretend to record some value.
        info!(
            "Incrementing counter for {:?} severity={} ts={}",
            envelope.kind, envelope.severity, envelope.timestamp
        );
        Ok(())
    }
}

/// NaÃ¯ve data-drift detector.
pub struct DriftDetector {
    window_size: usize,
}

impl DriftDetector {
    pub fn sliding(window_size: usize) -> Self {
        Self { window_size }
    }
}

impl EventObserver for DriftDetector {
    fn on_event(&self, envelope: &EventEnvelope) -> Result<(), MonitoringError> {
        if envelope.kind != EventKind::InferenceCompleted {
            return Ok(()); // only interested in completed inferences
        }

        debug!(
            "DriftDetector analysing metadata; window_size={}",
            self.window_size
        );

        // Extract fake feature for demonstration.
        let feature_val = envelope
            .metadata
            .get("prediction_confidence")
            .and_then(|v| v.as_f64())
            .unwrap_or(0.5);

        if feature_val < 0.2 {
            // Drift threshold breached
            warn!("Potential drift detected (confidence {feature_val})");
            return Err(MonitoringError::DriftDetector(anyhow::anyhow!(
                "confidence below threshold"
            )));
        }
        Ok(())
    }
}

/// Alert dispatcher that would normally integrate with PagerDuty, OpsGenie, â€¦
pub struct AlertDispatcher;

impl AlertDispatcher {
    pub fn new() -> Self {
        Self
    }
}

impl EventObserver for AlertDispatcher {
    fn on_event(&self, envelope: &EventEnvelope) -> Result<(), MonitoringError> {
        if envelope.severity >= Severity::Error {
            error!(
                "ðŸš¨ ALERT: {:?} occurred at {}. metadata={}",
                envelope.kind, envelope.timestamp, envelope.metadata
            );
            // Simulate an outbound HTTP call.
            if envelope.kind == EventKind::TrainingStarted {
                return Err(MonitoringError::Alert(anyhow::anyhow!(
                    "pager duty API timeout"
                )));
            }
        }
        Ok(())
    }
}

// ---------------------------------------------------------------------------
// Unit Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn smoke_test_event_flow() {
        let bus = EventBus::new();

        bus.subscribe(EventKind::InferenceCompleted, MetricsCollector::new());
        bus.subscribe(
            EventKind::InferenceCompleted,
            DriftDetector::sliding(128),
        );
        bus.subscribe(EventKind::InferenceCompleted, AlertDispatcher::new());

        let envelope = EventEnvelope::new(
            EventKind::InferenceCompleted,
            Severity::Info,
            json!({ "prediction_confidence": 0.95 }),
        );

        let report = bus.publish(envelope);

        assert_eq!(report.attempted, 3);
        assert_eq!(report.success, 3);
        assert!(report.failures.is_empty());
    }

    #[test]
    fn errors_do_not_break_the_bus() {
        let bus = EventBus::new();

        bus.subscribe(EventKind::InferenceFailed, MetricsCollector::new());
        bus.subscribe(EventKind::InferenceFailed, AlertDispatcher::new());

        let envelope = EventEnvelope::new(
            EventKind::InferenceFailed,
            Severity::Error,
            serde_json::json!({ "reason": "model panicked" }),
        );

        let report = bus.publish(envelope);

        // One observer intentionally fails (MetricsCollector).
        assert_eq!(report.attempted, 2);
        assert_eq!(report.success, 1);
        assert_eq!(report.failures.len(), 1);
    }
}
```