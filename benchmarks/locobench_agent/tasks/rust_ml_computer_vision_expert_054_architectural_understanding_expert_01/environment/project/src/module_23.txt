```rust
//! src/module_23.rs
//!
//! Automated Retraining Orchestrator
//! ---------------------------------
//! This module wires‐up an Observer that listens to model–monitoring events
//! (data drift, concept drift, performance degradation, etc.) and, when the
//! pre-configured criteria are met, kicks off a retraining pipeline.
//!
//! Patterns showcased:
//!   • Observer Pattern        – event subscription & dispatch
//!   • Strategy Pattern        – pluggable hyper-parameter tuning
//!   • Factory Pattern         – dynamic trainer instantiation based on modality
//!
//! The code is intended to be embedded in the wider “VisuTility Orchestrator”
//! project, but it is fully functional and unit-testable in isolation.

use std::{
    collections::HashMap,
    fmt,
    sync::{Arc, Mutex},
    time::Duration,
};

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use log::{debug, error, info, warn};
use thiserror::Error;
use tokio::{
    select,
    sync::mpsc::{self, Receiver, Sender},
    task::JoinHandle,
    time::sleep,
};

/// Version of the crate (kept in sync via Cargo build script).
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

/// Numeric identifier of a Vision model (e.g. “object_detection/v5.4”).
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct ModelId(pub String);

/// Identifier for a camera stream or dataset slice.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct StreamId(pub String);

/// An enum capturing different types of monitoring signals.
#[derive(Clone, Debug)]
pub enum MetricEvent {
    DataDrift {
        stream_id: StreamId,
        p_value: f32,
        timestamp: DateTime<Utc>,
    },
    ConceptDrift {
        model_id: ModelId,
        kl_divergence: f32,
        timestamp: DateTime<Utc>,
    },
    PerformanceDrop {
        model_id: ModelId,
        mAP_change: f32,
        timestamp: DateTime<Utc>,
    },
}

/// Outcome of an Observer’s decision.
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum RetrainAction {
    NoAction,
    SoftRetrain, // Continue fine-tuning on recent data
    FullRetrain, // Re-build from scratch
}

/// Standardized error type for this module.
#[derive(Error, Debug)]
pub enum RetrainError {
    #[error("trainer unavailable: {0}")]
    TrainerUnavailable(String),
    #[error("registry error: {0}")]
    Registry(String),
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
    #[error("internal: {0}")]
    Internal(String),
}

/// Observer trait – receives events and responds with an action.
#[async_trait]
pub trait Observer: Send + Sync {
    async fn on_event(&self, event: MetricEvent) -> Result<RetrainAction, RetrainError>;
}

/// Central dispatcher that holds a list of observers and pushes events to them.
pub struct Observable {
    observers: Vec<Arc<dyn Observer>>,
}

impl Observable {
    pub fn new() -> Self {
        Self {
            observers: Vec::new(),
        }
    }

    pub fn subscribe(&mut self, observer: Arc<dyn Observer>) {
        self.observers.push(observer);
    }

    /// Push an event to all observers, returning the most severe action
    /// requested (FullRetrain > SoftRetrain > NoAction).
    pub async fn dispatch(&self, event: MetricEvent) -> RetrainAction {
        let mut highest = RetrainAction::NoAction;

        for obs in &self.observers {
            match obs.on_event(event.clone()).await {
                Ok(action) => {
                    highest = severity_merge(highest, action);
                }
                Err(err) => error!("observer error: {err:?}"),
            }
        }
        highest
    }
}

/// Helper that merges two actions, keeping the highest severity.
fn severity_merge(a: RetrainAction, b: RetrainAction) -> RetrainAction {
    use RetrainAction::*;
    match (a, b) {
        (FullRetrain, _) | (_, FullRetrain) => FullRetrain,
        (SoftRetrain, _) | (_, SoftRetrain) => SoftRetrain,
        _ => NoAction,
    }
}

/// -------------------------------------------------------------------------
/// Strategy Pattern – Hyper-parameter Tuning
/// -------------------------------------------------------------------------
#[async_trait]
pub trait Tuner: Send + Sync {
    async fn tune(&self, dataset: &str) -> Result<HashMap<String, f32>, RetrainError>;
}

pub struct GridSearch;
pub struct RandomSearch;

#[async_trait]
impl Tuner for GridSearch {
    async fn tune(&self, _dataset: &str) -> Result<HashMap<String, f32>, RetrainError> {
        info!("GridSearch: performing exhaustive grid search");
        Ok(HashMap::from_iter([
            ("lr".into(), 0.0003),
            ("batch_size".into(), 32.0),
        ]))
    }
}

#[async_trait]
impl Tuner for RandomSearch {
    async fn tune(&self, _dataset: &str) -> Result<HashMap<String, f32>, RetrainError> {
        info!("RandomSearch: sampling random hyper-parameters");
        Ok(HashMap::from_iter([
            ("lr".into(), 0.00017),
            ("batch_size".into(), 24.0),
        ]))
    }
}

/// Factory for choosing a Tuner based on environment variables or defaults.
pub struct TunerFactory;

impl TunerFactory {
    pub fn make() -> Arc<dyn Tuner> {
        match std::env::var("VTY_TUNER")
            .unwrap_or_else(|_| "grid".into())
            .to_lowercase()
            .as_str()
        {
            "random" => Arc::new(RandomSearch),
            _ => Arc::new(GridSearch),
        }
    }
}

/// -------------------------------------------------------------------------
/// Traits that represent external services within VisuTility.
/// -------------------------------------------------------------------------

#[async_trait]
pub trait ModelRegistry: Send + Sync {
    async fn latest_model(&self, stream_id: &StreamId) -> Result<ModelId, RetrainError>;
    async fn register_new_version(
        &self,
        base_model: &ModelId,
        metadata: &HashMap<String, String>,
    ) -> Result<ModelId, RetrainError>;
}

#[async_trait]
pub trait ModelTrainer: Send + Sync {
    async fn soft_retrain(
        &self,
        base_model: &ModelId,
        dataset: &str,
        tuner: Arc<dyn Tuner>,
    ) -> Result<ModelId, RetrainError>;

    async fn full_retrain(
        &self,
        stream_id: &StreamId,
        dataset: &str,
        tuner: Arc<dyn Tuner>,
    ) -> Result<ModelId, RetrainError>;
}

/// -------------------------------------------------------------------------
/// Concrete Observer – RetrainController
/// -------------------------------------------------------------------------

pub struct RetrainController<R, T>
where
    R: ModelRegistry,
    T: ModelTrainer,
{
    registry: Arc<R>,
    trainer: Arc<T>,
    tuner_factory: fn() -> Arc<dyn Tuner>,
    /// Cool-down prevents retraining loops: (model_id → last_retrain_ts)
    cool_downs: Arc<Mutex<HashMap<ModelId, DateTime<Utc>>>>,
    min_cooldown: Duration,
}

impl<R, T> RetrainController<R, T>
where
    R: ModelRegistry,
    T: ModelTrainer,
{
    pub fn new(registry: Arc<R>, trainer: Arc<T>) -> Self {
        Self {
            registry,
            trainer,
            tuner_factory: TunerFactory::make,
            cool_downs: Arc::new(Mutex::new(HashMap::new())),
            min_cooldown: Duration::from_secs(60 * 30), // 30 min
        }
    }

    fn cooling(&self, model_id: &ModelId) -> bool {
        self.cool_downs
            .lock()
            .expect("poisoned")
            .get(model_id)
            .map(|ts| Utc::now().signed_duration_since(*ts).to_std().unwrap() < self.min_cooldown)
            .unwrap_or(false)
    }

    fn mark_retrain(&self, model_id: ModelId) {
        self.cool_downs
            .lock()
            .expect("poisoned")
            .insert(model_id, Utc::now());
    }
}

#[async_trait]
impl<R, T> Observer for RetrainController<R, T>
where
    R: ModelRegistry + 'static,
    T: ModelTrainer + 'static,
{
    async fn on_event(&self, event: MetricEvent) -> Result<RetrainAction, RetrainError> {
        match event {
            MetricEvent::DataDrift { stream_id, .. } => {
                let base_model = self.registry.latest_model(&stream_id).await?;
                if self.cooling(&base_model) {
                    debug!("Skipping retrain (cool-down) for {:?}", base_model);
                    return Ok(RetrainAction::NoAction);
                }
                let tuner = (self.tuner_factory)();
                let new_model = self
                    .trainer
                    .full_retrain(&stream_id, "dataset/path", tuner)
                    .await?;
                self.registry
                    .register_new_version(&base_model, &HashMap::from_iter([(
                        "parent".to_string(),
                        base_model.0.clone(),
                    )]))
                    .await?;
                self.mark_retrain(new_model.clone());
                Ok(RetrainAction::FullRetrain)
            }
            MetricEvent::ConceptDrift { model_id, .. } | MetricEvent::PerformanceDrop { model_id, .. } =>
            {
                if self.cooling(&model_id) {
                    debug!("Skipping retrain (cool-down) for {:?}", model_id);
                    return Ok(RetrainAction::NoAction);
                }
                let tuner = (self.tuner_factory)();
                let new_model = self
                    .trainer
                    .soft_retrain(&model_id, "dataset/path", tuner)
                    .await?;
                self.registry
                    .register_new_version(&model_id, &HashMap::from_iter([(
                        "parent".to_string(),
                        model_id.0.clone(),
                    )]))
                    .await?;
                self.mark_retrain(new_model.clone());
                Ok(RetrainAction::SoftRetrain)
            }
        }
    }
}

/// -------------------------------------------------------------------------
/// Asynchronous Event Loop
/// -------------------------------------------------------------------------

/// Handle that keeps the background loop alive.
pub struct RetrainServiceHandle {
    join: JoinHandle<()>,
    tx: Sender<MetricEvent>,
}

impl RetrainServiceHandle {
    pub fn sender(&self) -> Sender<MetricEvent> {
        self.tx.clone()
    }

    /// Graceful shutdown.
    pub async fn stop(self) -> Result<(), RetrainError> {
        drop(self.tx); // close channel
        self.join.await.map_err(|e| {
            RetrainError::Internal(format!("join error: {e:?}"))
        })
    }
}

/// Spawn a background task that consumes MetricEvents and coordinates retraining.
pub fn spawn_retrain_service(
    observable: Arc<Observable>,
    buffer: usize,
) -> RetrainServiceHandle {
    let (tx, mut rx): (Sender<MetricEvent>, Receiver<MetricEvent>) = mpsc::channel(buffer);

    let join = tokio::spawn(async move {
        loop {
            select! {
                maybe_event = rx.recv() => {
                    match maybe_event {
                        Some(event) => {
                            let action = observable.dispatch(event).await;
                            match action {
                                RetrainAction::NoAction => debug!("No retraining required."),
                                RetrainAction::SoftRetrain => info!("Soft retraining triggered."),
                                RetrainAction::FullRetrain => warn!("Full retraining initiated!"),
                            }
                        }
                        None => {
                            info!("RetrainService channel closed; shutting down.");
                            break;
                        }
                    }
                }
                _ = sleep(Duration::from_secs(1)) => {
                    // idle – could perform scheduled tasks here
                }
            }
        }
    });

    RetrainServiceHandle { join, tx }
}

/// -------------------------------------------------------------------------
/// Mock Implementations & Tests
/// -------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use once_cell::sync::Lazy;
    use std::sync::atomic::{AtomicUsize, Ordering};

    static CALL_COUNTER: Lazy<AtomicUsize> = Lazy::new(|| AtomicUsize::new(0));

    struct MockRegistry;

    #[async_trait]
    impl ModelRegistry for MockRegistry {
        async fn latest_model(&self, _stream_id: &StreamId) -> Result<ModelId, RetrainError> {
            Ok(ModelId("mock_model_v1".into()))
        }

        async fn register_new_version(
            &self,
            _base_model: &ModelId,
            _metadata: &HashMap<String, String>,
        ) -> Result<ModelId, RetrainError> {
            Ok(ModelId("mock_model_v2".into()))
        }
    }

    struct MockTrainer;

    #[async_trait]
    impl ModelTrainer for MockTrainer {
        async fn soft_retrain(
            &self,
            _base_model: &ModelId,
            _dataset: &str,
            _tuner: Arc<dyn Tuner>,
        ) -> Result<ModelId, RetrainError> {
            CALL_COUNTER.fetch_add(1, Ordering::SeqCst);
            Ok(ModelId("mock_model_soft".into()))
        }

        async fn full_retrain(
            &self,
            _stream_id: &StreamId,
            _dataset: &str,
            _tuner: Arc<dyn Tuner>,
        ) -> Result<ModelId, RetrainError> {
            CALL_COUNTER.fetch_add(1, Ordering::SeqCst);
            Ok(ModelId("mock_model_full".into()))
        }
    }

    #[tokio::test]
    async fn test_retrain_flow() {
        let registry = Arc::new(MockRegistry);
        let trainer = Arc::new(MockTrainer);

        let controller = Arc::new(RetrainController::new(registry, trainer));

        let mut observable = Observable::new();
        observable.subscribe(controller);

        let observable = Arc::new(observable);
        let service = spawn_retrain_service(observable, 16);
        let tx = service.sender();

        tx.send(MetricEvent::PerformanceDrop {
            model_id: ModelId("mock_model_v1".into()),
            mAP_change: -0.12,
            timestamp: Utc::now(),
        })
        .await
        .unwrap();

        sleep(Duration::from_millis(100)).await;

        assert_eq!(CALL_COUNTER.load(Ordering::SeqCst), 1);

        service.stop().await.unwrap();
    }
}
```