```rust
//! module_36.rs
//! -------------------------------------------------------------
//! Model Monitoring & Adaptive Retraining Event Bus
//!
//! This module implements a lightweight, asynchronous Observer
//! pattern used across VisuTility Orchestrator to surface metrics
//! emitted by running pipelines (e.g. training / inference) and
//! automatically react to drift or resource anomalies.
//!
//! High-level flow
//! 1. Producers create `ModelEvent`s and push them to the `EventBus`.
//! 2. `EventBus` fan-outs the events to every `EventObserver` that
//!    registered interest.
//! 3. Observers (accuracy drift, latency spike, resource watchdog,
//!    etc.) inspect the event and, when a rule is violated, trigger
//!    mitigation actions (e.g. schedule retraining, scale-out,
//!    alert via webhook).
//!
//! This design is self-contained and can be embedded inside both
//! synchronous and Tokio asynchronous contexts.
//!
//! -------------------------------------------------------------

use std::{
    collections::HashMap,
    fmt,
    sync::{Arc, RwLock},
};

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use thiserror::Error;
use tokio::{
    select,
    sync::broadcast,
    task::JoinHandle,
    time::{sleep, Duration},
};

/// Represents different kinds of telemetry emitted by a model pipeline.
#[derive(Debug, Clone)]
pub enum MetricKind {
    InferenceLatencyMs,
    ValidationAccuracy,
    CpuUtilizationPct,
    MemoryUtilizationPct,
}

/// A single telemetry data-point.
#[derive(Debug, Clone)]
pub struct ModelEvent {
    pub model_id: String,
    pub timestamp: DateTime<Utc>,
    pub metric: MetricKind,
    pub value: f64,
}

impl ModelEvent {
    pub fn new(model_id: impl Into<String>, metric: MetricKind, value: f64) -> Self {
        Self {
            model_id: model_id.into(),
            timestamp: Utc::now(),
            metric,
            value,
        }
    }
}

/// Errors emitted by the event bus.
#[derive(Debug, Error)]
pub enum EventBusError {
    #[error("cannot register observer: channel capacity exeeded")]
    ObserverRegistrationFailed,
    #[error("send failed: {0}")]
    SendFailed(#[from] broadcast::error::SendError<ModelEvent>),
}

/// Trait that observers must implement.
#[async_trait]
pub trait EventObserver: Send + Sync + 'static {
    /// Human-readable observer name—used in logs & dashboards.
    fn name(&self) -> &'static str;

    /// Whether the observer is interested in the incoming event.
    fn accept(&self, event: &ModelEvent) -> bool;

    /// React to the event (may be async).
    async fn on_event(&self, event: &ModelEvent) -> anyhow::Result<()>;
}

/// Thread-safe, clonable event bus for telemetry broadcasting.
#[derive(Clone)]
pub struct EventBus {
    tx: broadcast::Sender<ModelEvent>,
    /// List of spawned observer tasks so we can cancel them on drop.
    handles: Arc<RwLock<Vec<JoinHandle<()>>>>,
}

impl EventBus {
    /// Creates a new event bus with a bounded channel.
    pub fn new(capacity: usize) -> Self {
        let (tx, _) = broadcast::channel(capacity);
        Self {
            tx,
            handles: Arc::default(),
        }
    }

    /// Register an observer and start listening in a background task.
    pub fn register<O>(&self, observer: O) -> Result<(), EventBusError>
    where
        O: EventObserver,
    {
        let mut rx = self.tx.subscribe();

        let handle = tokio::spawn(async move {
            loop {
                select! {
                    msg = rx.recv() => {
                        match msg {
                            Ok(event) if observer.accept(&event) => {
                                if let Err(e) = observer.on_event(&event).await {
                                    tracing::error!(observer=%observer.name(), error=%e, "observer failed");
                                }
                            }
                            Ok(_) => {}, // uninterested
                            Err(broadcast::error::RecvError::Lagged(skipped)) => {
                                tracing::warn!(observer=%observer.name(), %skipped, "lagging behind");
                            }
                            Err(broadcast::error::RecvError::Closed) => break,
                        }
                    }
                }
            }
            tracing::info!(observer=%observer.name(), "shutting down");
        });

        self.handles.write().unwrap().push(handle);
        Ok(())
    }

    /// Push a new event to the bus.
    pub fn emit(&self, event: ModelEvent) -> Result<usize, EventBusError> {
        Ok(self.tx.send(event)?)
    }
}

impl fmt::Debug for EventBus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EventBus").finish()
    }
}

impl Drop for EventBus {
    fn drop(&mut self) {
        // Cancel all observer tasks gracefully.
        for handle in self.handles.write().unwrap().drain(..) {
            handle.abort();
        }
    }
}

// ---------------------------------------------------------------------------
// Concrete observers
// ---------------------------------------------------------------------------

/// Flags accuracy drift and schedules retraining jobs.
pub struct AccuracyDriftObserver {
    /// Minimum acceptable accuracy (percentage, e.g. 0.93 ⇒ 93%).
    threshold: f64,
    /// How many consecutive breaches before action.
    patience: u8,
    violations: Arc<RwLock<HashMap<String, u8>>>,
}

impl AccuracyDriftObserver {
    pub fn new(threshold: f64, patience: u8) -> Self {
        Self {
            threshold,
            patience,
            violations: Arc::default(),
        }
    }

    async fn schedule_retraining(model_id: &str) -> anyhow::Result<()> {
        // Simulate expensive work; replace with real job-queue call.
        tracing::info!(%model_id, "scheduling retraining");
        sleep(Duration::from_secs(1)).await;
        Ok(())
    }
}

#[async_trait]
impl EventObserver for AccuracyDriftObserver {
    fn name(&self) -> &'static str {
        "accuracy_drift"
    }

    fn accept(&self, event: &ModelEvent) -> bool {
        matches!(event.metric, MetricKind::ValidationAccuracy)
    }

    async fn on_event(&self, event: &ModelEvent) -> anyhow::Result<()> {
        let mut map = self.violations.write().unwrap();
        let entry = map.entry(event.model_id.clone()).or_default();

        if event.value < self.threshold {
            *entry += 1;
            tracing::warn!(
                model_id=%event.model_id,
                val=%event.value,
                threshold=%self.threshold,
                count=*entry,
                "accuracy drift detected"
            );

            if *entry >= self.patience {
                Self::schedule_retraining(&event.model_id).await?;
                *entry = 0; // reset
            }
        } else {
            *entry = 0; // healthy again
        }

        Ok(())
    }
}

/// Detects inference latency spikes.
pub struct LatencySpikeObserver {
    p95_budget_ms: f64,
}

impl LatencySpikeObserver {
    pub fn new(p95_budget_ms: f64) -> Self {
        Self { p95_budget_ms }
    }

    async fn scale_out(model_id: &str) -> anyhow::Result<()> {
        tracing::info!(%model_id, "scaling out deployment");
        sleep(Duration::from_millis(500)).await;
        Ok(())
    }
}

#[async_trait]
impl EventObserver for LatencySpikeObserver {
    fn name(&self) -> &'static str {
        "latency_spike"
    }

    fn accept(&self, event: &ModelEvent) -> bool {
        matches!(event.metric, MetricKind::InferenceLatencyMs)
    }

    async fn on_event(&self, event: &ModelEvent) -> anyhow::Result<()> {
        if event.value > self.p95_budget_ms {
            tracing::warn!(
                model_id=%event.model_id,
                latency_ms=%event.value,
                budget_ms=%self.p95_budget_ms,
                "latency budget violated"
            );
            Self::scale_out(&event.model_id).await?;
        }
        Ok(())
    }
}

/// Simple resource watchdog.
pub struct ResourceWatchdog {
    cpu_budget_pct: f64,
    mem_budget_pct: f64,
}

impl ResourceWatchdog {
    pub fn new(cpu_budget_pct: f64, mem_budget_pct: f64) -> Self {
        Self {
            cpu_budget_pct,
            mem_budget_pct,
        }
    }
}

#[async_trait]
impl EventObserver for ResourceWatchdog {
    fn name(&self) -> &'static str {
        "resource_watchdog"
    }

    fn accept(&self, event: &ModelEvent) -> bool {
        matches!(
            event.metric,
            MetricKind::CpuUtilizationPct | MetricKind::MemoryUtilizationPct
        )
    }

    async fn on_event(&self, event: &ModelEvent) -> anyhow::Result<()> {
        match event.metric {
            MetricKind::CpuUtilizationPct if event.value > self.cpu_budget_pct => {
                tracing::warn!(
                    model_id=%event.model_id,
                    cpu_pct=%event.value,
                    budget=%self.cpu_budget_pct,
                    "CPU budget violated"
                );
            }
            MetricKind::MemoryUtilizationPct if event.value > self.mem_budget_pct => {
                tracing::error!(
                    model_id=%event.model_id,
                    mem_pct=%event.value,
                    budget=%self.mem_budget_pct,
                    "memory budget violated"
                );
            }
            _ => {}
        }
        Ok(())
    }
}

// ---------------------------------------------------------------------------
// Example bootstrap (only compiled on tests & benches)
// ---------------------------------------------------------------------------
#[cfg(test)]
mod tests {
    use super::*;
    use tracing_subscriber::fmt::Subscriber;

    #[tokio::test(flavor = "current_thread")]
    async fn smoke_test_eventbus() {
        // Enable logs for debugging the example:
        let _ = Subscriber::builder().with_env_filter("info").try_init();

        let bus = EventBus::new(16);

        bus.register(AccuracyDriftObserver::new(0.90, 3))
            .expect("observer register");
        bus.register(LatencySpikeObserver::new(150.0))
            .expect("observer register");
        bus.register(ResourceWatchdog::new(85.0, 80.0))
            .expect("observer register");

        // Send a few events to verify we don't panic.
        bus.emit(ModelEvent::new(
            "model-abc",
            MetricKind::ValidationAccuracy,
            0.89,
        ))
        .unwrap();

        bus.emit(ModelEvent::new(
            "model-abc",
            MetricKind::InferenceLatencyMs,
            200.0,
        ))
        .unwrap();

        bus.emit(ModelEvent::new(
            "model-abc",
            MetricKind::CpuUtilizationPct,
            92.0,
        ))
        .unwrap();

        // Allow observers to process.
        sleep(Duration::from_millis(100)).await;
    }
}
```