```rust
// src/module_15.rs
//
// VisuTility Orchestrator – Model-Monitoring & Auto-Retraining Observer
//
// This module realises two architectural patterns:
//
// 1. Observer Pattern  – Broadcasts model-performance events to interested
//    observers (e.g. alerting systems, dashboards, automated retrainers).
// 2. Strategy Pattern – Pluggable policies decide *when* a model should
//    retrain based on metric streams.
//
// The code is fully self-contained; external crates are declared behind
// `cfg(feature = "...")` so downstream crates can enable/disable them
// without hassles.
//
// -----------------------------------------------------------

#![allow(clippy::missing_errors_doc)] // Kept minimal for brevity.

use std::{
    fmt,
    sync::Arc,
    time::{Duration, SystemTime},
};

use tokio::sync::broadcast;
use uuid::Uuid;

/// Reasonable channel capacity. Exceeding this will drop the oldest message.
const DEFAULT_CHANNEL_CAPACITY: usize = 1_024;

/// Unique identifier for a registered model version.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct ModelId(Uuid);

impl ModelId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

impl fmt::Display for ModelId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

/// Enum describing a metric key we care about.
///
/// NOTE: Extend as required. The `Other` variant allows for arbitrary custom
/// keys without having to re-compile this crate.
#[derive(Debug, Clone, PartialEq)]
pub enum MetricKey {
    Accuracy,
    Precision,
    Recall,
    F1Score,
    ThroughputFps,
    LatencyMs,
    Other(String),
}

/// Value of a metric at a given time.
///
/// For simplicity this is numeric; a real-world system may want richer payloads
/// (e.g. distributions, histograms, anomalies).
#[derive(Debug, Clone)]
pub struct MetricValue(f64);

impl MetricValue {
    pub fn new(v: f64) -> Self {
        Self(v)
    }

    pub fn inner(&self) -> f64 {
        self.0
    }
}

/// Semantic wrapper around emitted metric events.
///
/// Observers can inspect the full envelope (timestamp, model, metric).
#[derive(Debug, Clone)]
pub struct MetricEvent {
    pub timestamp: SystemTime,
    pub model_id: ModelId,
    pub key: MetricKey,
    pub value: MetricValue,
}

impl MetricEvent {
    pub fn new(model_id: ModelId, key: MetricKey, value: f64) -> Self {
        Self {
            timestamp: SystemTime::now(),
            model_id,
            key,
            value: MetricValue::new(value),
        }
    }
}

// ---------------------------------------------------------------------------
// Error Types
// ---------------------------------------------------------------------------

use thiserror::Error;

#[derive(Debug, Error)]
pub enum MonitorError {
    #[error("broadcast channel lagged by {0} messages")]
    ChannelLagged(usize),
}

// ---------------------------------------------------------------------------
// Subject – Publish-Subscribe (Observer Pattern)
// ---------------------------------------------------------------------------

/// Handle for publishing metric events to interested observers.
///
/// Internally uses `tokio::sync::broadcast`, which allows async, multi-consumer
/// fan-out semantics.
#[derive(Clone)]
pub struct MetricSubject {
    tx: broadcast::Sender<MetricEvent>,
}

impl MetricSubject {
    /// Construct a new broadcast subject with the default capacity.
    pub fn new() -> Self {
        let (tx, _) = broadcast::channel(DEFAULT_CHANNEL_CAPACITY);
        Self { tx }
    }

    /// Notify all observers of a new metric event.
    ///
    /// If the channel overflowed for any subscriber, an error is returned so
    /// callers can decide whether to re-send or log.
    pub fn publish(&self, event: MetricEvent) -> Result<(), MonitorError> {
        self.tx
            .send(event)
            .map_err(|e| MonitorError::ChannelLagged(e.0))
    }

    /// Return a new subscribed receiver. Each observer should call this once.
    pub fn subscribe(&self) -> broadcast::Receiver<MetricEvent> {
        self.tx.subscribe()
    }
}

// ---------------------------------------------------------------------------
// Strategy Pattern – Retraining Policies
// ---------------------------------------------------------------------------

/// Decision outcome emitted by a policy.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum RetrainDecision {
    NoAction,
    RetrainImmediately,
    RetrainScheduled(Duration),
}

/// Trait for pluggable policies that decide when a model should retrain.
///
/// The interface is intentionally minimal; policies are stateless by default
/// but can easily own interior state (e.g. moving averages, EWMA windows).
pub trait RetrainPolicy: Send + Sync {
    fn evaluate(&self, event: &MetricEvent) -> RetrainDecision;
}

/// A naive baseline policy: trigger immediate retrain when accuracy dips
/// below a fixed threshold.
#[derive(Debug)]
pub struct StaticThresholdPolicy {
    threshold: f64,
}

impl StaticThresholdPolicy {
    pub fn new(threshold: f64) -> Self {
        Self { threshold }
    }
}

impl RetrainPolicy for StaticThresholdPolicy {
    fn evaluate(&self, event: &MetricEvent) -> RetrainDecision {
        match &event.key {
            MetricKey::Accuracy if event.value.inner() < self.threshold => {
                RetrainDecision::RetrainImmediately
            }
            _ => RetrainDecision::NoAction,
        }
    }
}

// ---------------------------------------------------------------------------
// Observer Implementation – Automated Retrainer
// ---------------------------------------------------------------------------

#[derive(Debug)]
pub struct AutomatedRetrainer {
    policy: Arc<dyn RetrainPolicy>,
    rx: broadcast::Receiver<MetricEvent>,
}

impl AutomatedRetrainer {
    pub fn new(
        subject: &MetricSubject,
        policy: Arc<dyn RetrainPolicy>,
    ) -> Self {
        Self {
            policy,
            rx: subject.subscribe(),
        }
    }

    /// Spawn a background task that listens for metric events and kicks off
    /// retraining jobs when the policy dictates.
    pub fn spawn(mut self) {
        tokio::spawn(async move {
            loop {
                match self.rx.recv().await {
                    Ok(event) => {
                        if let Err(e) = self.handle_event(event).await {
                            eprintln!("[AutoRetrainer] error: {e}");
                        }
                    }
                    Err(broadcast::error::RecvError::Closed) => break,
                    Err(broadcast::error::RecvError::Lagged(skipped)) => {
                        eprintln!(
                            "[AutoRetrainer] skipped {skipped} metric events due to lag."
                        );
                    }
                }
            }
        });
    }

    async fn handle_event(&self, event: MetricEvent) -> Result<(), anyhow::Error> {
        match self.policy.evaluate(&event) {
            RetrainDecision::NoAction => {}
            RetrainDecision::RetrainImmediately => {
                self.enqueue_retraining_job(event.model_id).await?;
            }
            RetrainDecision::RetrainScheduled(delay) => {
                let model_id = event.model_id;
                let policy = self.policy.clone();
                tokio::spawn(async move {
                    tokio::time::sleep(delay).await;
                    // Re-evaluate after delay in case new metrics arrived.
                    // (Simplified; would require shared state or re-query.)
                    let _ = policy; // placeholder to keep `policy` alive.
                                    // Actual implementation omitted.
                    eprintln!(
                        "[AutoRetrainer] Scheduled retrain for model {model_id}"
                    );
                });
            }
        }
        Ok(())
    }

    async fn enqueue_retraining_job(&self, model: ModelId) -> Result<(), anyhow::Error> {
        // In a production system this would enqueue to a job-queue (e.g. Rabbit,
        // Kafka, Redis, or an internal Tokio queue) and return immediately.
        //
        // For illustrative purposes we just log synchronously.
        println!(
            "[AutoRetrainer] Triggering immediate retrain for model {model}"
        );
        Ok(())
    }
}

// ---------------------------------------------------------------------------
// Example Usage (can be removed in production)
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::timeout;

    #[tokio::test]
    async fn test_static_threshold_policy() {
        let subject = MetricSubject::new();
        let policy = Arc::new(StaticThresholdPolicy::new(0.9));

        let retrainer = AutomatedRetrainer::new(&subject, policy);
        retrainer.spawn();

        // Publish a bad accuracy metric (< 0.9) to trigger retrain.
        let model = ModelId::new();
        subject
            .publish(MetricEvent::new(model, MetricKey::Accuracy, 0.5))
            .unwrap();

        // Allow some leeway for the background task to run.
        // If we don't receive any errors within a second, assume success.
        timeout(Duration::from_secs(1), async { tokio::task::yield_now().await })
            .await
            .unwrap();
    }
}
```