```rust
//! module_60.rs
//!
//! Model Monitoring & Automated Retraining Trigger
//! ------------------------------------------------
//! This module glues together the `Observer` and `Strategy` patterns to perform
//! real–time model–performance monitoring.  Incoming prediction/ground–truth
//! tuples are converted into streaming metrics; when a statistically–significant
//! drop in performance is detected (drift), an asynchronous retraining job is
//! triggered through the `RetrainOrchestrator`.
//!
//! The implementation relies on `tokio` for lightweight concurrency and
//! `dashmap` for lock–free, shard–based metric aggregation.  All public items
//! are intentionally generic and trait-based so that other pipeline layers may
//! swap implementations (e.g. replace the default `F1Scorer` with a
//! domain-specific scorer).

use std::{
    sync::Arc,
    time::{Duration, Instant},
};

use anyhow::{Context, Result};
use dashmap::DashMap;
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::{
    select,
    sync::{broadcast, mpsc, oneshot},
    task::JoinHandle,
    time,
};

/// Maximum number of versions we track concurrently (per tenant).
const MAX_MODEL_VERSIONS: usize = 4;
/// Default window size (in samples) for metric estimation.
const DEFAULT_SLIDING_WINDOW: usize = 5_000;
/// Default performance threshold below which a model is considered degraded.
const DEFAULT_F1_THRESHOLD: f32 = 0.82;

/// Error variants emitted by the monitoring subsystem.
#[derive(Debug, Error)]
pub enum MonitorError {
    #[error("Channel closed unexpectedly")]
    ChannelClosed,
    #[error("Failed to compute metric: {0}")]
    MetricComputation(String),
    #[error(transparent)]
    Other(#[from] anyhow::Error),
}

/// A prediction + ground-truth pair delivered by the inference engine.
#[derive(Debug, Clone)]
pub struct LabeledPrediction {
    pub model_version: String,
    pub prediction: bool,
    pub ground_truth: bool,
    pub ts: Instant,
}

/// Broadcast event generated by the [`MetricAggregator`].
#[derive(Debug, Clone)]
pub enum MonitorEvent {
    /// A new, point-estimate F1 score is available.
    F1Update {
        model_version: String,
        window_size: usize,
        f1_score: f32,
    },
    /// A model is considered degraded and should be retrained.
    DriftDetected {
        model_version: String,
        current_f1: f32,
    },
}

/// Observer trait (Strategy Pattern) for reacting to [`MonitorEvent`]s.
pub trait Observer: Send + Sync + 'static {
    fn on_event(&self, event: &MonitorEvent) -> Result<()>;
}

/// Subject trait.  Allows **dynamic** registration of observers at runtime.
pub trait Subject: Send + Sync {
    fn register_observer(&self, observer: Arc<dyn Observer>);
}

/// Thread-safe container that tracks sliding-window metrics per model version.
struct SlidingMetricStore {
    windows: DashMap<String, Vec<LabeledPrediction>>,
    window_size: usize,
}

impl SlidingMetricStore {
    fn new(window_size: usize) -> Self {
        Self {
            windows: DashMap::new(),
            window_size,
        }
    }

    /// Insert a point and return an iterator to the current window for the
    /// associated model version.
    fn push(
        &self,
        model_version: &str,
        prediction: LabeledPrediction,
    ) -> Vec<LabeledPrediction> {
        let mut window = self
            .windows
            .entry(model_version.to_owned())
            .or_insert_with(Vec::new);
        window.push(prediction);
        // Keep window bounded.
        if window.len() > self.window_size {
            let excess = window.len() - self.window_size;
            window.drain(0..excess);
        }
        window.clone()
    }
}

/// Computes F1 score given a set of labeled predictions.
fn compute_f1(samples: &[LabeledPrediction]) -> Result<f32> {
    if samples.is_empty() {
        return Ok(1.0);
    }

    let mut tp = 0f32;
    let mut fp = 0f32;
    let mut fn_ = 0f32;

    for p in samples {
        match (p.prediction, p.ground_truth) {
            (true, true) => tp += 1.0,
            (true, false) => fp += 1.0,
            (false, true) => fn_ += 1.0,
            _ => {}
        }
    }

    let precision = tp / (tp + fp + f32::EPSILON);
    let recall = tp / (tp + fn_ + f32::EPSILON);

    Ok(2.0 * (precision * recall) / (precision + recall + f32::EPSILON))
}

/// Aggregates metrics from a channel of [`LabeledPrediction`]s and notifies
/// observers when thresholds are crossed.
pub struct MetricAggregator {
    predictions_rx: mpsc::UnboundedReceiver<LabeledPrediction>,
    observers: DashMap<usize, Arc<dyn Observer>>,
    metric_store: SlidingMetricStore,
    f1_threshold: f32,
}

impl MetricAggregator {
    pub fn new(predictions_rx: mpsc::UnboundedReceiver<LabeledPrediction>) -> Self {
        Self {
            predictions_rx,
            observers: DashMap::new(),
            metric_store: SlidingMetricStore::new(DEFAULT_SLIDING_WINDOW),
            f1_threshold: DEFAULT_F1_THRESHOLD,
        }
    }

    /// Spawn the aggregation loop on a background task.
    pub fn spawn(mut self) -> JoinHandle<()> {
        tokio::spawn(async move {
            while let Some(sample) = self.predictions_rx.recv().await {
                let window =
                    self.metric_store
                        .push(&sample.model_version, sample.clone());

                if let Ok(f1) = compute_f1(&window) {
                    let f1_event = MonitorEvent::F1Update {
                        model_version: sample.model_version.clone(),
                        window_size: window.len(),
                        f1_score: f1,
                    };
                    self.notify(&f1_event);

                    if f1 < self.f1_threshold {
                        let drift_event = MonitorEvent::DriftDetected {
                            model_version: sample.model_version.clone(),
                            current_f1: f1,
                        };
                        self.notify(&drift_event);
                    }
                }
            }
        })
    }
}

impl Subject for MetricAggregator {
    fn register_observer(&self, observer: Arc<dyn Observer>) {
        let key = observer.as_ref() as *const _ as usize;
        self.observers.insert(key, observer);
    }
}

impl MetricAggregator {
    fn notify(&self, event: &MonitorEvent) {
        for observer in self.observers.iter() {
            // Intentionally ignore observer errors; log instead.
            if let Err(e) = observer.value().on_event(event) {
                tracing::error!("observer error: {e:?}");
            }
        }
    }
}

/// Wire protocol for interacting with the `RetrainOrchestrator`.
#[derive(Debug, Serialize, Deserialize)]
pub struct RetrainRequest {
    pub model_version: String,
    pub reason: String,
    pub requested_at: chrono::DateTime<chrono::Utc>,
}

/// Public interface for triggering model retraining.
pub trait RetrainOrchestrator: Send + Sync {
    fn submit_job(&self, req: RetrainRequest) -> Result<()>;
}

/// Basic implementation that publishes a message on a Tokio broadcast channel.
/// A production implementation would instead enqueue onto Kafka or a work-queue
/// like AWS SQS.
pub struct ChannelRetrainOrchestrator {
    tx: broadcast::Sender<RetrainRequest>,
}

impl ChannelRetrainOrchestrator {
    pub fn new(tx: broadcast::Sender<RetrainRequest>) -> Self {
        Self { tx }
    }
}

impl RetrainOrchestrator for ChannelRetrainOrchestrator {
    fn submit_job(&self, req: RetrainRequest) -> Result<()> {
        self.tx
            .send(req)
            .map_err(|_| MonitorError::ChannelClosed)
            .context("failed to broadcast retrain request")?;
        Ok(())
    }
}

/// Watches for drift events and, if sustained over a configurable debounce
/// window, triggers retraining.
pub struct DriftWatcher {
    orchestrator: Arc<dyn RetrainOrchestrator>,
    debounce: Duration,
    last_trigger: DashMap<String, Instant>,
}

impl DriftWatcher {
    pub fn new(orchestrator: Arc<dyn RetrainOrchestrator>, debounce: Duration) -> Self {
        Self {
            orchestrator,
            debounce,
            last_trigger: DashMap::new(),
        }
    }
}

impl Observer for DriftWatcher {
    fn on_event(&self, event: &MonitorEvent) -> Result<()> {
        if let MonitorEvent::DriftDetected {
            model_version,
            current_f1,
        } = event
        {
            let now = Instant::now();
            let should_trigger = self
                .last_trigger
                .entry(model_version.clone())
                .and_modify(|instant| {
                    if now.duration_since(*instant) > self.debounce {
                        *instant = now;
                    }
                })
                .or_insert_with(|| now)
                .elapsed()
                > self.debounce;

            if should_trigger {
                let req = RetrainRequest {
                    model_version: model_version.clone(),
                    reason: format!(
                        "F1 score dropped below threshold: current={current_f1:.3}",
                    ),
                    requested_at: chrono::Utc::now(),
                };
                self.orchestrator.submit_job(req)?;
            }
        }
        Ok(())
    }
}

/// Spawns the entire monitoring pipeline and returns handles to feed
/// predictions as well as to listen for retraining requests.
///
/// # Example
///
/// ```no_run
/// use visu_tility::module_60::{
///     spawn_monitoring_pipeline, LabeledPrediction,
/// };
///
/// # tokio::main
/// # async fn main() -> anyhow::Result<()> {
/// let (pred_tx, mut retrain_rx) = spawn_monitoring_pipeline();
///
/// pred_tx.send(LabeledPrediction { /* .. */ })?;
///
/// if let Ok(req) = retrain_rx.recv().await {
///     println!("retraining triggered: {req:?}");
/// }
/// # Ok(())
/// # }
/// ```
pub fn spawn_monitoring_pipeline(
) -> (
    mpsc::UnboundedSender<LabeledPrediction>,
    broadcast::Receiver<RetrainRequest>,
) {
    let (pred_tx, pred_rx) = mpsc::unbounded_channel();
    let (retrain_tx, retrain_rx) = broadcast::channel(32);

    let retrain_orchestrator =
        Arc::new(ChannelRetrainOrchestrator::new(retrain_tx.clone()));

    let aggregator = Arc::new(MetricAggregator::new(pred_rx));
    let drift_watcher = Arc::new(DriftWatcher::new(
        retrain_orchestrator,
        Duration::from_secs(60 * 5), // 5-minute debounce
    ));

    aggregator.register_observer(drift_watcher);
    aggregator.spawn();

    (pred_tx, retrain_tx.subscribe())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::timeout;

    #[tokio::test]
    async fn drift_triggers_retrain() -> Result<()> {
        let (tx, mut rx) = spawn_monitoring_pipeline();

        // Force low F1 by sending many fp/fn.
        for _ in 0..DEFAULT_SLIDING_WINDOW {
            tx.send(LabeledPrediction {
                model_version: "v1".into(),
                prediction: true,
                ground_truth: false,
                ts: Instant::now(),
            })?;
        }

        let req = timeout(Duration::from_secs(2), rx.recv()).await??;
        assert_eq!(req.model_version, "v1");
        Ok(())
    }
}
```