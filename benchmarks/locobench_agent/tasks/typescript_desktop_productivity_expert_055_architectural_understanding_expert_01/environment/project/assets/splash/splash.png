```typescript
/**
 * PaletteFlow Studio – Splash Screen Helper
 * -----------------------------------------
 * This helper is an adapter that bootstraps an Electron `BrowserWindow`
 * displaying the static PNG located at `assets/splash/splash.png`.
 *
 * It is purposely placed in `assets/splash/` next to the PNG so that
 * bundlers (webpack / Vite / electron-builder) can easily pick-up the
 * resource when packaging the application or shipping differential
 * auto-updates.
 *
 * Responsibility:
 *  • Show a lightweight, non-interactive splash screen as soon as the
 *    app starts.
 *  • Accept progress updates (e.g. while loading plugins / workspaces).
 *  • Fade-out and dispose itself once the main UI is ready.
 *
 * This is purely an infrastructure concern; therefore it lives in the
 * “adapter” layer and stays free of any domain-level code.
 */

import { BrowserWindow, nativeTheme, nativeImage, ipcMain, app } from 'electron';
import { join } from 'path';
import { existsSync } from 'fs';
import { EventEmitter } from 'events';

const SPLASH_MIN_VISIBLE_MS = 900;      // guarantees a perceptible splash
const SPLASH_FADE_OUT_MS    = 300;      // match CSS transition in HTML
const CHANNEL_PROGRESS      = 'splash/progress';
const CHANNEL_CLOSE         = 'splash/close';

type SplashProgress = { percent: number; message?: string };

export class SplashScreen extends EventEmitter {
  private browser?: BrowserWindow;
  private openedAt = 0;
  private isClosing = false;

  /**
   * Creates the splash screen window but does *not* close it—call
   * `dispose()` when main window has finished bootstrapping.
   */
  async show(): Promise<void> {
    if (this.browser) { return; }

    this.openedAt = Date.now();
    const splashURL = this.buildSplashURL();
    const preload   = join(__dirname, 'splash.preload.js');

    this.browser = new BrowserWindow({
      width: 480,
      height: 320,
      show: false,                   // wait until ready-to-show
      transparent: true,
      frame: false,
      alwaysOnTop: true,
      resizable: false,
      fullscreenable: false,
      skipTaskbar: true,
      title: 'PaletteFlow Studio – Loading…',
      backgroundColor: nativeTheme.shouldUseDarkColors ? '#22222200' : '#ffffffff',
      webPreferences: {
        preload,
        contextIsolation: true,
        sandbox: true,
      },
    });

    // IPC listeners for renderer -> main
    this.registerIPC();

    this.browser.on('ready-to-show', () => this.browser?.showInactive());
    this.browser.on('closed',        () => this.browser = undefined);

    await this.browser.loadURL(splashURL);
  }

  /**
   * Forward progress updates to the splash renderer.
   */
  updateProgress(payload: SplashProgress): void {
    if (!this.browser || this.isClosing) { return; }
    this.browser.webContents.send(CHANNEL_PROGRESS, payload);
  }

  /**
   * Guarantees that the splash is visible for at least
   * `SPLASH_MIN_VISIBLE_MS` then fades out gracefully.
   */
  async dispose(): Promise<void> {
    if (!this.browser || this.isClosing) { return; }
    this.isClosing = true;

    const elapsed = Date.now() - this.openedAt;
    if (elapsed < SPLASH_MIN_VISIBLE_MS) {
      await new Promise(r => setTimeout(r, SPLASH_MIN_VISIBLE_MS - elapsed));
    }

    this.browser.webContents.send(CHANNEL_CLOSE);

    // Wait for the fade-out transition, then destroy
    setTimeout(() => {
      this.browser?.destroy();
      this.browser = undefined;
      this.emit('closed');
    }, SPLASH_FADE_OUT_MS);
  }

  /* -------------------------------------------------------------
   * Private helpers
   * ----------------------------------------------------------- */

  private buildSplashURL(): string {
    const htmlPath = join(__dirname, 'splash.html');
    if (!existsSync(htmlPath)) {
      // Fallback to data-URL with barebone HTML if file missing
      const pngPath  = this.resolveSplashPng();
      const png      = nativeImage.createFromPath(pngPath).toDataURL();
      const htmlData = encodeURIComponent(`
        <!DOCTYPE html>
        <html><head><style>
          html,body{margin:0;height:100%;display:flex;align-items:center;justify-content:center;background:transparent;}
          img{max-width:90%;max-height:90%;}
        </style></head><body><img src="${png}"/></body></html>
      `);
      return `data:text/html;charset=utf-8,${htmlData}`;
    }
    return `file://${htmlPath.replace(/\\/g, '/')}`;
  }

  private resolveSplashPng(): string {
    // Works both in dev (cwd = project root) and production (app.asar)
    const candidate = join(app.getAppPath(), 'assets', 'splash', 'splash.png');
    if (existsSync(candidate)) { return candidate; }

    // Development fallback (when running from sources via ts-node)
    const devPath = join(__dirname, '../../../assets/splash/splash.png');
    if (existsSync(devPath)) { return devPath; }

    throw new Error('[SplashScreen] splash.png not found');
  }

  private registerIPC(): void {
    // The splash renderer never sends anything but we still
    // attach channels defensively to avoid warnings.
    ipcMain.handle(CHANNEL_PROGRESS, () => {/* noop */});
  }
}

/* ------------------------------------------------------------------
 * Example bootstrap usage from `main.ts`:
 * ------------------------------------------------------------------

import { app } from 'electron';
import { createMainWindow } from './ui/main-window';
import { SplashScreen } from './assets/splash/SplashScreen';

(async () => {
  await app.whenReady();

  const splash = new SplashScreen();
  await splash.show();

  // Heavy bootstrap work: settings, plugins, workspace, etc.
  await loadUserPlugins(progress => splash.updateProgress(progress));
  const mainWindow = await createMainWindow();

  await splash.dispose();
})();

------------------------------------------------------------------- */
```