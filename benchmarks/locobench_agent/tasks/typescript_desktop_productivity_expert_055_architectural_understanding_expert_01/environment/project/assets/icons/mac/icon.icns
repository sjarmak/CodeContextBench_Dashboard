```typescript
/**
 * PaletteFlow Studio – Icon Pipeline
 * ----------------------------------
 * Despite living under `assets/icons/mac/icon.icns`, this file is in fact a
 * TypeScript build-time helper that _generates_ the real `icon.icns` file
 * required by electron-builder for macOS packaging.
 *
 * Why an “.icns” extension for code?
 * (1) Keeps the source script colocated with its output so asset pipelines
 *     (e.g. Vite, webpack, esbuild) don’t need extra config.
 * (2) Electron-builder conventionally points to “icon.icns”; by shipping a
 *     script that materialises the binary when missing/out-of-date, we avoid
 *     accidental releases with stale artwork.
 *
 * This script is executed automatically:
 *   • `npm run build` hooks → `pnpm exec ts-node assets/icons/mac/icon.icns`
 *   • as a CLI utility: `pnpm icon`
 *
 * It converts either an SVG **or** a 1024×1024 PNG master asset into a proper
 * .icns bundle using the `icon-gen` package.
 */

import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import { stat, mkdir } from 'fs/promises';
import iconGen from 'icon-gen';
import kleur from 'kleur';
import yargs from 'yargs/yargs';
import { hideBin } from 'yargs/helpers';

type CliOptions = {
  source: string;
  force: boolean;
};

(async () => {
  // ---------------------------------------------------------------------------
  // 1. Parse CLI flags
  // ---------------------------------------------------------------------------
  const argv = yargs(hideBin(process.argv))
    .option('source', {
      alias: 's',
      describe: 'Absolute or relative path to master icon (SVG/PNG)',
      type: 'string',
      default: '../../master/icon.svg',
    })
    .option('force', {
      alias: 'f',
      describe: 'Always rebuild even when up-to-date',
      type: 'boolean',
      default: false,
    })
    .help()
    .parseSync() as unknown as CliOptions;

  // ---------------------------------------------------------------------------
  // 2. Resolve paths
  // ---------------------------------------------------------------------------
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);

  const SOURCE_ICON = resolve(__dirname, argv.source);
  const OUT_DIR = resolve(__dirname);
  const OUT_FILE = resolve(__dirname, 'icon.icns');

  // ---------------------------------------------------------------------------
  // 3. Helper: check if rebuild is required
  // ---------------------------------------------------------------------------
  const needsRebuild = async (): Promise<boolean> => {
    if (argv.force) return true;

    try {
      const srcStat = await stat(SOURCE_ICON);
      const outStat = await stat(OUT_FILE);
      return srcStat.mtime > outStat.mtime;
    } catch (_) {
      // Output doesn’t exist → build required
      return true;
    }
  };

  // ---------------------------------------------------------------------------
  // 4. Perform build if necessary
  // ---------------------------------------------------------------------------
  if (!(await needsRebuild())) {
    console.log(kleur.gray(`icon.icns is up-to-date → skip`));
    return;
  }

  try {
    console.log(kleur.cyan(`Generating macOS icon from ${SOURCE_ICON}`));
    await mkdir(OUT_DIR, { recursive: true });
    await iconGen(SOURCE_ICON, OUT_DIR, {
      report: false,
      modes: ['icns'],
      icns: {
        compress: true,
      },
    });
    console.log(kleur.green(`✔ icon.icns generated at ${OUT_FILE}`));
  } catch (err) {
    console.error(
      kleur.red(`✖ Failed to generate macOS icon: ${String(err)}`),
    );
    process.exit(1);
  }
})();
```