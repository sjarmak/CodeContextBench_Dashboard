/**
 * PaletteFlow Studio — Icon Registry
 *
 * Centralises access to operating-system specific application icons.
 * Although the physical asset (a PNG for Linux, ICO for Windows, ICNS for
 * macOS) lives under `assets/icons/<platform>/`, many different parts of the
 * Electron runtime need to reference it (window creation, tray icon, update
 * notifications, crash reporter, etc.).  Rather than scattering `path.join`
 * calls throughout the code-base, we resolve and cache icons here.
 *
 * This module is **runtime-agnostic**: it can be imported safely from both the
 * Electron `main` process and a renderer process that has `nodeIntegration`
 * enabled.  At runtime it will attempt to load the binary into an
 * `Electron.NativeImage`; when executed in a pure Node.js context (e.g. CLI
 * tools or unit tests) it falls back to returning a string path.
 */

import { existsSync } from 'fs';
import path from 'path';

/* eslint-disable @typescript-eslint/no-var-requires */
let electron: typeof import('electron') | undefined;
try {
  // Dynamically require to avoid hard dependency when running in pure Node
  // (for example when executing shared Jest tests).
  // eslint-disable-next-line global-require, import/no-extraneous-dependencies
  electron = require('electron');
} catch {
  /* no-op */
}

export type SupportedPlatform = 'linux' | 'win32' | 'darwin';

/**
 * Descriptor of where an icon file lives relative to the project root.
 */
interface IconDescriptor {
  /** Folder containing the asset for the given platform. */
  readonly folder: string;
  /** File name of the icon within its folder.               */
  readonly fileName: string;
  /** Optional list of fall-back file names, tried in order. */
  readonly fallbacks?: readonly string[];
}

const ICONS: Record<SupportedPlatform, IconDescriptor> = {
  linux: {
    folder: 'assets/icons/linux',
    fileName: 'icon.png',
    fallbacks: ['icon@512x512.png', 'icon@256x256.png'],
  },
  win32: { folder: 'assets/icons/win', fileName: 'icon.ico' },
  darwin: { folder: 'assets/icons/mac', fileName: 'icon.icns' },
};

/**
 * Caches already-loaded icons (keyed by absolute file path) to avoid
 * re-hydrating `NativeImage` objects and redundant disk IO.
 */
const nativeCache = new Map<string, unknown /* Electron.NativeImage */>();

const platform = process.platform as SupportedPlatform;

/**
 * Resolve the absolute on-disk path of the icon asset for a target platform.
 *
 * The function is aware of the following build/runtime scenarios:
 *   1. Development mode (`npm start`)         – resources relative to repo root
 *   2. Electron packager / electron-builder   – resources inside `app.asar`
 *   3. AppImage / Snap (Linux)                – resources next to executable
 *   4. Jest unit tests (pure Node runtime)    – returns string path only
 *
 * If an override path is supplied through the `PALETTEFLOW_ICON_PATH`
 * environment variable (useful for white-labelling), that is always preferred.
 */
export function resolveIconPath(
  target: SupportedPlatform = platform,
): string {
  // 1. External override — highest priority
  const envOverride = process.env.PALETTEFLOW_ICON_PATH;
  if (envOverride && existsSync(envOverride)) {
    return envOverride;
  }

  const descriptor = ICONS[target];
  const candidateRoots: string[] = [];

  // 2. Development UNC path (repo root)
  candidateRoots.push(path.resolve(__dirname, '..', '..', '..'));

  // 3. Inside ASAR when packaged (e.g. `resources/app.asar/…`)
  candidateRoots.push(path.resolve(process.resourcesPath, 'app.asar'));

  // 4. Unpacked resources (Electron-Builder `extraResources`)
  candidateRoots.push(process.resourcesPath);

  // Try every combination of root + file name + fallbacks
  for (const root of candidateRoots) {
    const trivial = path.join(root, descriptor.folder, descriptor.fileName);
    if (existsSync(trivial)) return trivial;

    for (const fb of descriptor.fallbacks ?? []) {
      const fbPath = path.join(root, descriptor.folder, fb);
      if (existsSync(fbPath)) return fbPath;
    }
  }

  throw new Error(
    `Icon asset for platform "${target}" could not be located. ` +
      'Checked: ' +
      candidateRoots
        .map((root) => `[${descriptor.folder}] under "${root}"`)
        .join(', '),
  );
}

/**
 * Return an Electron `NativeImage` representing the application icon for the
 * requested platform.  If the current runtime does not have access to the
 * `electron` module (e.g. unit tests), a string path is returned instead.
 */
export function getAppIcon(
  target: SupportedPlatform = platform,
):
  | import('electron').NativeImage
  | string {
  const iconPath = resolveIconPath(target);

  // If Electron is not in scope, return raw path (caller may handle it).
  if (!electron) return iconPath;

  // Return cached instance if already created.
  const cached = nativeCache.get(iconPath);
  if (cached) return cached as import('electron').NativeImage;

  const { nativeImage } = electron;
  const img = nativeImage.createFromPath(iconPath);

  if (img.isEmpty()) {
    throw new Error(
      `Failed to create Electron.NativeImage from "${iconPath}"`,
    );
  }

  nativeCache.set(iconPath, img);
  return img;
}

/**
 * Convenience accessor for *this* platform's icon.
 *
 * Example (in Electron main process):
 *   mainWindow = new BrowserWindow({ icon: getLocalIcon() })
 */
export function getLocalIcon():
  | import('electron').NativeImage
  | string {
  return getAppIcon(platform);
}
