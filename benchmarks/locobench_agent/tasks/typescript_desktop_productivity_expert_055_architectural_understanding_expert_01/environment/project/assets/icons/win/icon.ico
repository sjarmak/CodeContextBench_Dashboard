```typescript
/**
 * PaletteFlow Studio – Dynamic Windows Icon Module
 * ------------------------------------------------
 * This module lives in a path that ends in `.ico`, yet it is *TypeScript* code.
 * The unconventional extension is intentional: it lets bundlers such as
 * Webpack/Vite treat the module as a binary asset in production, while during
 * development we can generate the icon on-the-fly from an SVG source.
 *
 * The default export is an async function that resolves to the absolute path of
 * a Windows-compatible `.ico` file.  If the file does not exist (or if the
 * caller explicitly requests a rebuild) we create it using the `sharp` and
 * `png-to-ico` libraries.  When neither library is available we gracefully
 * fall back to a pre-baked “safety” icon shipped with the source tree.
 *
 * Usage from the Electron main process:
 *
 *    import getWinIconPath from '@/assets/icons/win/icon.ico'
 *
 *    const mainWindow = new BrowserWindow({
 *      icon: await getWinIconPath({ accentColor: '#ff9500' }),
 *      ...
 *    })
 */

import fs from 'node:fs'
import path from 'node:path'
import os from 'node:os'
import crypto from 'node:crypto'

/* eslint-disable @typescript-eslint/no-var-requires -- dynamic requires */

/**
 * Public options supported by {@link getWinIconPath}.
 */
export interface WinIconOptions {
  /**
   * Hex color to tint the glyph with.  Supports shorthand (#abc) and full
   * (#aabbcc) formats *with* or *without* the leading “#”.
   * Defaults to PaletteFlow’s brand violet.
   */
  accentColor?: string

  /**
   * Forces a rebuild even if a cached icon already exists.
   */
  forceRebuild?: boolean
}

/**
 * Absolute path to the on-disk fallback icon that is always present in source.
 * (This file is committed to the repo and redistributed inside the asar.)
 */
const STATIC_FALLBACK_PATH = path.resolve(
  __dirname,
  'win-icon-fallback.ico',
)

/**
 * SVG template used as the canonical source for themed icons.  The “ACCENT”
 * string is replaced with the caller-supplied accentColor at generation time.
 *
 * NOTE: Keep the viewBox square (1:1) so that all exported PNGs are crisp.
 */
const SVG_TEMPLATE = (accent: string) => `<?xml version="1.0" encoding="UTF-8"?>
<svg width="512" height="512" viewBox="0 0 512 512"
     xmlns="http://www.w3.org/2000/svg" fill="${accent}">
  <rect x="64" y="64" width="384" height="384" rx="96" ry="96"/>
  <path d="M192 144h128v48H192zM144 240h224v48H144zM192 336h128v48H192z"
        fill="#ffffff"/>
</svg>`

/**
 * List of PNG sizes required by Windows icons.  We include high-DPI sizes so
 * apps look sharp even on 4K displays.
 */
const PNG_SIZES = [16, 24, 32, 48, 64, 128, 256] as const

/**
 * Resolve PaletteFlow’s per-user cache directory.  We prefer Electron’s
 * `app.getPath('userData')` when available, otherwise we fall back to a tmpdir.
 */
function resolveCacheDir(): string {
  try {
    // Will throw if not in the Electron main process.
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const { app } = require('electron') as { app: Electron.App }
    return path.join(app.getPath('userData'), 'icon-cache')
  } catch {
    return path.join(os.tmpdir(), 'paletteflow-icon-cache')
  }
}

/**
 * Normalize hex colors into #rrggbb format so that we can hash them
 * consistently.
 */
function normalizeHexColor(hex?: string): string {
  const DEFAULT = '#5d5dfd'
  if (!hex) return DEFAULT

  let h = hex.trim().toLowerCase()
  if (!h.startsWith('#')) h = `#${h}`
  if (/^#[0-9a-f]{3}$/.test(h)) {
    // Expand shorthand, e.g., #abc → #aabbcc
    h = `#${[...h.slice(1)].map((c) => `${c}${c}`).join('')}`
  }
  if (!/^#[0-9a-f]{6}$/.test(h)) return DEFAULT
  return h
}

/**
 * Build an .ico file for the given accent color and return its absolute path.
 * The function caches the result for the remainder of the session.
 */
async function buildIcon(accentColor: string, targetPath: string): Promise<void> {
  // Lazy-load heavyweight dependencies so we don’t slow down startup.
  let sharp: typeof import('sharp')
  let pngToIco: typeof import('png-to-ico')

  try {
    sharp = require('sharp')
    pngToIco = require('png-to-ico')
  } catch (err) {
    throw new Error(
      'sharp and/or png-to-ico are not installed. ' +
        'Run `npm install sharp png-to-ico` or use the fallback icon.',
    )
  }

  // Prepare a temporary directory to hold intermediate PNGs.
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'pf-icon-'))

  try {
    // Generate PNG variants.
    const svgBuffer = Buffer.from(SVG_TEMPLATE(accentColor))
    const pngBuffers: Buffer[] = []

    for (const size of PNG_SIZES) {
      const png = await sharp(svgBuffer)
        .resize(size, size)
        .png()
        .toBuffer()
      const pngPath = path.join(tmpDir, `icon-${size}.png`)
      fs.writeFileSync(pngPath, png)
      pngBuffers.push(png)
    }

    // `png-to-ico` accepts paths or buffers.
    const icoBuffer = await pngToIco(pngBuffers as never)
    fs.mkdirSync(path.dirname(targetPath), { recursive: true })
    fs.writeFileSync(targetPath, icoBuffer)
  } finally {
    // Best-effort cleanup.
    fs.rmSync(tmpDir, { recursive: true, force: true })
  }
}

/**
 * Resolve (and optionally build) the themed Windows icon for PaletteFlow.
 *
 * @returns Absolute path to a `.ico` file, ready to be passed to Electron.
 */
export default async function getWinIconPath(
  opts: WinIconOptions = {},
): Promise<string> {
  const accentColor = normalizeHexColor(opts.accentColor)
  const hash = crypto
    .createHash('md5')
    .update(accentColor)
    .digest('hex')
    .slice(0, 8) // shorten to keep filenames tidy

  const cacheDir = resolveCacheDir()
  const targetPath = path.join(cacheDir, `icon-${hash}.ico`)

  if (!opts.forceRebuild && fs.existsSync(targetPath)) {
    return targetPath
  }

  try {
    await buildIcon(accentColor, targetPath)
    return targetPath
  } catch (err) {
    console.error(
      '[paletteflow/icon] Failed to build themed Windows icon –',
      (err as Error).message,
    )
    return STATIC_FALLBACK_PATH
  }
}

/**
 * For convenience we also provide a synchronous helper that blocks execution
 * while ensuring the icon exists.  This is useful in CLI contexts.
 */
export function getWinIconPathSync(opts: WinIconOptions = {}): string {
  const accentColor = normalizeHexColor(opts.accentColor)
  const hash = crypto
    .createHash('md5')
    .update(accentColor)
    .digest('hex')
    .slice(0, 8)

  const cacheDir = resolveCacheDir()
  const targetPath = path.join(cacheDir, `icon-${hash}.ico`)

  if (!opts.forceRebuild && fs.existsSync(targetPath)) {
    return targetPath
  }

  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const sharp: typeof import('sharp') = require('sharp')
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const pngToIco: typeof import('png-to-ico') = require('png-to-ico')

    const svgBuffer = Buffer.from(SVG_TEMPLATE(accentColor))
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'pf-icon-'))
    const pngBuffers: Buffer[] = []

    for (const size of PNG_SIZES) {
      const png = sharp(svgBuffer).resize(size, size).png().toBufferSync()
      pngBuffers.push(png)
    }

    const icoBuffer = pngToIco.sync(pngBuffers as never)
    fs.mkdirSync(path.dirname(targetPath), { recursive: true })
    fs.writeFileSync(targetPath, icoBuffer)
    fs.rmSync(tmpDir, { recursive: true, force: true })
    return targetPath
  } catch (err) {
    console.error(
      '[paletteflow/icon] Failed to build themed Windows icon (sync) –',
      (err as Error).message,
    )
    return STATIC_FALLBACK_PATH
  }
}

/**
 * Convert Sharp’s async API to a blocking call for the synchronous helper.
 * We attach it to `sharp.Prototype` via declaration merging to avoid ts-errors.
 */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore – we’re monkey-patching a missing sync API for convenience only.
declare module 'sharp' {
  interface Sharp {
    toBufferSync(): Buffer
  }
}

try {
  // Monkey-patch only if sharp is available.
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const sharp: typeof import('sharp') = require('sharp')
  if (!sharp.prototype.toBufferSync) {
    sharp.prototype.toBufferSync = function toBufferSync(): Buffer {
      // This is *not* truly synchronous, but we cheat by blocking the event
      // loop using `Atomics.wait`.  Acceptable only because it is used by CLI
      // tooling where UI responsiveness is irrelevant.
      let buffer: Buffer | undefined
      let error: unknown
      let done = false
      this.toBuffer()
        .then((b) => {
          buffer = b
          done = true
        })
        .catch((e) => {
          error = e
          done = true
        })

      // Block until the promise settles.
      const sab = new SharedArrayBuffer(4)
      const ia = new Int32Array(sab)
      while (!done) {
        Atomics.wait(ia, 0, 0, 50) // 50 ms jitter to prevent 100% CPU
      }
      if (error) throw error
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return buffer!
    }
  }
} catch {
  /* sharp not installed – nothing to patch */
}
```
