```typescript
/**
 * PaletteFlow Studio – macOS icon generator
 *
 * This script is executed by the root-level “build” npm script and is responsible for
 * generating a `.icns` file that will be embedded into the final Electron binary.
 *
 * Why TypeScript for an “icns” file?
 * ----------------------------------
 * The actual binary icon is obviously *not* TypeScript.  However, having a typed,
 * self-documenting build-time script that programmatically creates the icon ensures:
 *   • repeatable builds in CI/CD,
 *   • automatic regeneration when the source SVG/PNG changes,
 *   • meaningful diagnostics instead of silent failures.
 *
 * Prerequisites:
 *   • macOS (iconutil is only available on Darwin),
 *   • Xcode Command Line Tools installed (for `/usr/bin/iconutil`),
 *   • The `sharp` npm package (image processing),
 *   • The `tmp` npm package (cross-platform temp dir management).
 *
 * Usage:
 *   $ ts-node build/icon.icns.ts --src ./assets/logo.svg --out ./build/icon.icns
 */

import { spawnSync } from 'child_process';
import { promises as fsp } from 'fs';
import os from 'os';
import path from 'path';
import { file as tmpFile, dir as tmpDir } from 'tmp-promise';
import sharp from 'sharp';

interface CliArgs {
  src: string;
  out: string;
}

const APPLE_ICON_SIZES = [
  16,
  32,
  64,
  128,
  256,
  512,
  1024, // Human-readable sizes (points)
];

/**
 * Parse minimal CLI flags. We avoid heavy deps like yargs for quicker cold-starts
 * during CI. Throws on missing required flags.
 */
function parseArgs(argv: string[] = process.argv.slice(2)): CliArgs {
  const args: Record<string, string | undefined> = {};
  for (let i = 0; i < argv.length; i += 2) {
    const key = argv[i];
    const val = argv[i + 1];
    if (!key?.startsWith('--') || !val) {
      throw new Error(
        `Malformed CLI flags. Example:\n  ts-node build/icon.icns.ts --src ./logo.svg --out ./icon.icns`
      );
    }
    args[key.slice(2)] = val;
  }

  if (!args.src || !args.out) {
    throw new Error('Both --src and --out flags are required.');
  }

  return { src: args.src, out: args.out };
}

/**
 * Ensure we are running on macOS, otherwise iconutil will fail.
 * We still allow CI on Linux/Windows to pass gracefully by creating
 * an empty placeholder to not break packaging flows that don’t
 * actually ship macOS builds.
 */
function assertPlatformOrCreatePlaceholder(outPath: string): boolean {
  if (os.platform() === 'darwin') return true;

  // Create a zero-byte placeholder .icns so downstream steps don’t explode.
  console.warn(
    '[icon.icns] Non-macOS host detected. Skipping .icns generation and writing placeholder.'
  );
  fsp.writeFile(outPath, '');
  return false;
}

/**
 * Renders PNG images for every required Apple icon size into a temporary `.iconset`
 * directory. On macOS we will later feed this folder to `iconutil --convert icns`.
 */
async function generateIconset(srcPath: string, tmpIconsetDir: string): Promise<void> {
  const renderPromises = APPLE_ICON_SIZES.flatMap(async (size) => {
    // Apple requires both @1x and @2x (retina) versions for each point size.
    const targets = [
      { suffix: '', scale: 1 },
      { suffix: '@2x', scale: 2 },
    ];

    return Promise.all(
      targets.map(async ({ suffix, scale }) => {
        const dest = path.join(tmpIconsetDir, `icon_${size}x${size}${suffix}.png`);
        const pixel = size * scale;

        await sharp(srcPath)
          .resize(pixel, pixel, { fit: 'contain' })
          .png()
          .toFile(dest);
      })
    );
  });

  await Promise.all(renderPromises);
}

/**
 * Runs `/usr/bin/iconutil` to convert the generated `.iconset` folder into a single
 * `.icns` binary. Because iconutil is a sync CLI, we can block until completion.
 */
function convertIconsetToIcns(iconsetDir: string, outPath: string): void {
  const result = spawnSync('/usr/bin/iconutil', ['--convert', 'icns', iconsetDir, '--output', outPath], {
    stdio: 'inherit',
  });

  if (result.status !== 0) {
    throw new Error(`iconutil failed with exit code ${result.status}`);
  }
}

/**
 * Entrypoint wrapper that orchestrates temp directory management and teardown.
 */
async function main(): Promise<void> {
  const { src, out } = parseArgs();

  // Short-circuit on non-macOS
  if (!assertPlatformOrCreatePlaceholder(out)) return;

  // Validate source asset exists
  try {
    await fsp.access(src);
  } catch {
    throw new Error(`Source file "${src}" does not exist or cannot be read.`);
  }

  // Create a tmp directory for the .iconset bundle
  const { path: iconsetDir, cleanup } = await tmpDir({ prefix: 'paletteflow-icon-', unsafeCleanup: true });

  try {
    await generateIconset(src, iconsetDir);
    convertIconsetToIcns(iconsetDir, out);
    console.info(`[icon.icns] Successfully generated ${path.relative(process.cwd(), out)}`);
  } finally {
    // Ensure we clean up temp dir no matter what
    await cleanup().catch(() => {
      console.warn(`[icon.icns] Failed to clean up temporary directory: ${iconsetDir}`);
    });
  }
}

// When executed directly via ts-node / node, run main()
if (require.main === module) {
  main().catch((err) => {
    console.error('[icon.icns] Build failed:', err);
    process.exit(1);
  });
}

// Exported API so other build scripts (e.g., Gulp, Webpack) can reuse programmatically.
export async function buildIcns(src: string, out: string): Promise<void> {
  await generateIconset(src, path.dirname(out));
  convertIconsetToIcns(path.dirname(out), out);
}
```