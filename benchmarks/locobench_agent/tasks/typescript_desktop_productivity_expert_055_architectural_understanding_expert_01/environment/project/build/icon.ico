```typescript
/**
 * PaletteFlow Studio â€“ Icon Builder
 * ---------------------------------
 * Although the file extension is â€œ.icoâ€ (to match the output artefact expected
 * by downstream Electron tooling), the file is actually a TypeScript source file
 * that builds the real Windows `.ico` (and macOS/Linux `.icns` / `.png`)
 * application icons at compile-time.
 *
 * Rationale:
 *   â€¢ Keeps icon generation in-repo and reproducible (CI/CD friendly)
 *   â€¢ Allows dynamic theming (brand colour changes, pluginâ€“provided badges, etc.)
 *   â€¢ Ensures the Electron builder never ships stale icon assets
 *
 * Usage (package.json scripts):
 *   "build:icons": "ts-node build/icon.ico"
 *
 * Dependencies (add to devDependencies):
 *   - sharp          (image rasterisation & resizing)
 *   - to-ico         (ICO multi-resolution bundler)
 *   - png-to-icns    (ICNS generator for macOS)
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import sharp from 'sharp';
import toIco from 'to-ico';
import pngToIcns from 'png-to-icns';

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* Constants                                                                 */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * Source vector file.  Designers maintain this single SVG; everything else is
 * generated automatically.
 */
const SOURCE_SVG = path.join(__dirname, 'assets', 'icon-template.svg');

/**
 * Sub-directories where final assets will be emitted.
 * Distinguishing them avoids accidental shipping of platform-specific artefacts
 * where they are not needed.
 */
const DIST_DIR = path.join(__dirname, '..', 'dist', 'icons');
const DIST_WINDOWS = path.join(DIST_DIR, 'win');
const DIST_MAC     = path.join(DIST_DIR, 'mac');
const DIST_LINUX   = path.join(DIST_DIR, 'linux');

/**
 * Target PNG sizes required by each platform.
 * Windows ICO: 16, 24, 32, 48, 64, 128, 256
 * macOS ICNS: 16, 32, 64, 128, 256, 512, 1024
 * Linux (freedesktop): 16, 32, 48, 64, 96, 128, 256, 512
 */
const WINDOWS_SIZES = [16, 24, 32, 48, 64, 128, 256];
const MAC_SIZES     = [16, 32, 64, 128, 256, 512, 1024];
const LINUX_SIZES   = [16, 32, 48, 64, 96, 128, 256, 512];

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* Helper Utilities                                                           */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

type RGB = [number, number, number];

/**
 * Rudimentary CLI logger to keep build output readable in CI/CD logs.
 */
const log = {
  info:  (msg: string) => console.log(`â„¹ï¸  [icon-builder] ${msg}`),
  warn:  (msg: string) => console.warn(`âš ï¸  [icon-builder] ${msg}`),
  error: (msg: string) => console.error(`âŒ [icon-builder] ${msg}`),
};

/**
 * Reads brand colour override from paletteflow.config.json if present.
 * Plugins or theme packages can set `"brandColor": "#ff5500"` to recolour the
 * app icon without touching the SVG.  We naively recolour by replacing the
 * first fill attribute found in the SVG template (good enough for now).
 */
async function readBrandColor(): Promise<string | undefined> {
  try {
    const cfgPath = path.join(__dirname, '..', 'paletteflow.config.json');
    const buf = await fs.readFile(cfgPath, 'utf8');
    const json = JSON.parse(buf);
    if (typeof json.brandColor === 'string') {
      log.info(`Using brand colour override: ${json.brandColor}`);
      return json.brandColor;
    }
  } catch {
    /* ignore missing config */
  }
  return undefined;
}

/**
 * Ensures that all output directories exist.
 */
async function ensureDirs(): Promise<void> {
  const dirs = [DIST_DIR, DIST_WINDOWS, DIST_MAC, DIST_LINUX];
  await Promise.all(
    dirs.map(dir => fs.mkdir(dir, { recursive: true }))
  );
}

/**
 * Simple colour parser converting hex (#rrggbb) to RGB tuple.
 */
function hexToRgb(hex: string): RGB {
  const clean = hex.replace('#', '');
  if (!/^[0-9a-fA-F]{6}$/.test(clean)) {
    throw new Error(`Invalid hex colour "${hex}"`);
  }
  const intVal = parseInt(clean, 16);
  return [
    (intVal >> 16) & 255,
    (intVal >> 8) & 255,
    intVal & 255,
  ];
}

/**
 * Recolour SVG template on-the-fly by replacing `fill="#XXXXXX"` occurrences.
 * NOTE: Assumes the template uses a single solid colour. A more robust solution
 * would parse the SVG XML properly.
 */
async function loadRecolouredSvg(brandColor?: string): Promise<Buffer> {
  let svg = await fs.readFile(SOURCE_SVG, 'utf8');

  if (brandColor) {
    svg = svg.replace(/fill="[^"]+"/, `fill="${brandColor}"`);
  }

  return Buffer.from(svg);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* Core Build Pipeline                                                        */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

async function buildPngs(sizes: number[], targetDir: string, svgBuf: Buffer) {
  await Promise.all(
    sizes.map(async (size) => {
      const file = path.join(targetDir, `${size}x${size}.png`);
      await sharp(svgBuf)
        .resize(size, size)
        .png()
        .toFile(file);
      log.info(`Generated ${path.relative(__dirname, file)}`);
    })
  );
}

async function buildWindowsIco(targetDir: string): Promise<void> {
  const pngPaths = WINDOWS_SIZES.map(size =>
    path.join(targetDir, `${size}x${size}.png`)
  );

  const icoBuffer = await toIco(
    await Promise.all(
      pngPaths.map(async p => fs.readFile(p))
    )
  );

  const out = path.join(targetDir, '..', 'paletteflow.ico');
  await fs.writeFile(out, icoBuffer);
  log.info(`Bundled ${path.relative(__dirname, out)}`);
}

async function buildMacIcns(targetDir: string): Promise<void> {
  const largest = path.join(targetDir, '1024x1024.png');
  const icnsPath = path.join(targetDir, '..', 'paletteflow.icns');
  await pngToIcns(largest, icnsPath);
  log.info(`Bundled ${path.relative(__dirname, icnsPath)}`);
}

/**
 * Entry-point orchestrating the entire icon generation process.
 */
export async function buildIcons(): Promise<void> {
  try {
    log.info('Starting icon build...');
    const brandColor = await readBrandColor();
    await ensureDirs();
    const svgBuf = await loadRecolouredSvg(brandColor);

    /* Build individual PNGs */
    await Promise.all([
      buildPngs(WINDOWS_SIZES, DIST_WINDOWS, svgBuf),
      buildPngs(MAC_SIZES,     DIST_MAC,     svgBuf),
      buildPngs(LINUX_SIZES,   DIST_LINUX,   svgBuf),
    ]);

    /* Bundle container formats */
    await Promise.all([
      buildWindowsIco(DIST_WINDOWS),
      buildMacIcns(DIST_MAC),
      // Linux typically consumes raw PNGs directly; nothing to bundle.
    ]);

    log.info('ğŸ‰ Icon build completed with success.');
  } catch (err) {
    log.error(err instanceof Error ? err.message : String(err));
    process.exitCode = 1; // indicate failure to CI
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* CLI Execution                                                              */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

if (import.meta.url === `file://${process.argv[1]}`) {
  // Executed directly (`ts-node build/icon.ico`)
  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  buildIcons();
}
```