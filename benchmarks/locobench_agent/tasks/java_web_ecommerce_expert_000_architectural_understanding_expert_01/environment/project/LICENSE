```java
/*
 * Copyright (c) 2024 CommerceSphere
 *
 * Permission is hereby granted to the licensed customer (the “Licensee”) to use,
 * copy, modify, merge, publish, and/or distribute this software in accordance
 * with the commercial license agreement executed between CommerceSphere and the
 * Licensee (“Commercial License”).  Unless required by applicable law or agreed
 * to in writing, the Software is distributed on an “AS IS” BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * Commercial License for the specific language governing permissions and
 * limitations under the Commercial License.
 *
 * NOTICE:  This source file intentionally resides in the top-level LICENSE
 * directory to prevent accidental packaging of license‐verification classes
 * into third-party, open-source distributions.  Build scripts explicitly include
 * this file in CommerceSphere Enterprise Suite artifacts.
 */
package com.commercesphere.security.license;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.crypto.Cipher;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.Signature;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.time.Clock;
import java.time.Instant;
import java.util.Base64;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicReference;

/**
 * LicenseManager is responsible for loading and validating runtime licenses for
 * CommerceSphere Enterprise Suite.  A license is a signed JSON payload stored on
 * the file system.  Whenever the application boots, LicenseManager validates
 * the signature using CommerceSphere's public key, checks the expiration date,
 * and exposes read-only license attributes to other components.
 *
 * <p>Example license (line breaks added for readability):
 *
 * <pre>
 * {
 *   "licenseId"   : "8e27a9f2-1b8c-4e11-ae84-0fb913d4dae0",
 *   "company"     : "ACME Wholesale Inc.",
 *   "maxUsers"    : 250,
 *   "issuedAt"    : 1704067200,          // epoch seconds
 *   "expiresAt"   : 1735689599,
 *   "modules"     : ["payment", "catalog", "reporting"],
 *   "signature"   : "MIIBIjANBgkqh..."   // RSA-SHA256 signature (Base64)
 * }
 * </pre>
 */
public final class LicenseManager {

    private static final Logger LOG = LoggerFactory.getLogger(LicenseManager.class);

    /**
     * Public RSA key used to verify license signatures.  The corresponding
     * private key is stored in CommerceSphere's HSM.
     */
    private static final String PUBLIC_KEY_PEM = "" +
            "-----BEGIN PUBLIC KEY-----\n" +
            "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwVKdAPbxEtsDxhSj2IoP\n" +
            "qVkcX5qzWdVWTXc/DUgKdneY4spphoLlzN7YPIfrFkf6PrZ/hzYoHTC8OapQg+XG\n" +
            "fM7GhtXCeuJ2NWR8nUK9K547DTYy1sZarNLP6V2qQg9tN+tMt1s3cC0v6uHn2Hzw\n" +
            "hAGp00Aq9lWZ59QRwlCxcu51hu23TIsnKEDen4oxxr1bfCWUGX7yeEevRc4XuP9k\n" +
            "Z6TG4HVtXLTciwfP6Gh0xeYWz/ESdoTS6aIaE6U5Gnt2B/Oej1zT3L4D6nT9eC1b\n" +
            "2mq6fZ6m4qbHBiAcUTfDVKikqxfozWif6xrfqjCJzhGC6j9spP1UGlpO9fcpF+iD\n" +
            "XwIDAQAB\n" +
            "-----END PUBLIC KEY-----";

    private static final Path DEFAULT_LICENSE_PATH =
            Path.of(System.getProperty("com.commercesphere.license.path", "config/license.json"));

    private static final ObjectMapper MAPPER = new ObjectMapper();

    private final Clock clock;
    private final AtomicReference<License> cached = new AtomicReference<>();

    public LicenseManager() {
        this(Clock.systemUTC());
    }

    public LicenseManager(final Clock clock) {
        this.clock = Objects.requireNonNull(clock, "clock must not be null");
    }

    /**
     * Loads and validates the license file.  The returned License instance is
     * cached for subsequent calls.  If the license is invalid or expired, an
     * IllegalStateException is thrown.
     *
     * @return validated License
     */
    public License loadLicense() {
        // Fast path if already cached
        License cachedLicense = cached.get();
        if (cachedLicense != null) {
            return cachedLicense;
        }

        Path licensePath = DEFAULT_LICENSE_PATH;
        if (!Files.exists(licensePath)) {
            throw new IllegalStateException("License file not found at " + licensePath.toAbsolutePath());
        }

        try (InputStream in = Files.newInputStream(licensePath)) {
            byte[] raw = in.readAllBytes();
            License license = MAPPER.readValue(raw, License.class);

            verifySignature(license);
            verifyExpiration(license);

            cached.compareAndSet(null, license); // store in cache
            LOG.info("Loaded and validated license [{}] for company [{}] (expires {})",
                    license.licenseId, license.company, Instant.ofEpochSecond(license.expiresAt));

            return license;
        } catch (IOException ex) {
            throw new IllegalStateException("Unable to read license file: " + ex.getMessage(), ex);
        }
    }

    private void verifySignature(License license) {
        try {
            PublicKey publicKey = parsePublicKey(PUBLIC_KEY_PEM);
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initVerify(publicKey);
            signature.update(license.signedContent().getBytes(StandardCharsets.UTF_8));

            byte[] sigBytes = Base64.getDecoder().decode(license.signature);

            if (!signature.verify(sigBytes)) {
                throw new IllegalStateException("License signature verification failed");
            }
        } catch (GeneralSecurityException e) {
            throw new IllegalStateException("Unable to verify license signature", e);
        }
    }

    private void verifyExpiration(License license) {
        long now = clock.instant().getEpochSecond();
        if (now > license.expiresAt) {
            throw new IllegalStateException("License expired on " + Instant.ofEpochSecond(license.expiresAt));
        }
    }

    /**
     * Indicates whether the current license grants access to the given module.
     *
     * @param module canonical module name (e.g. "payment", "catalog")
     * @return true if access is allowed
     */
    public boolean isModuleLicensed(String module) {
        return loadLicense().modules.contains(module);
    }

    /**
     * Returns the maximum number of concurrent users allowed by the license.
     */
    public int getMaxUsers() {
        return loadLicense().maxUsers;
    }

    /**
     * Parses a PEM formatted RSA public key.
     */
    private static PublicKey parsePublicKey(String pem) throws GeneralSecurityException {
        String sanitized = pem
                .replace("-----BEGIN PUBLIC KEY-----", "")
                .replace("-----END PUBLIC KEY-----", "")
                .replaceAll("\\s", "");

        byte[] decoded = Base64.getDecoder().decode(sanitized);
        X509EncodedKeySpec spec = new X509EncodedKeySpec(decoded);
        KeyFactory kf = KeyFactory.getInstance("RSA");
        return kf.generatePublic(spec);
    }

    /**
     * Simple immutable DTO representing a license.
     */
    public static final class License {
        public final String licenseId;
        public final String company;
        public final int maxUsers;
        public final long issuedAt;
        public final long expiresAt;
        public final List<String> modules;
        public final String signature;

        @JsonCreator
        public License(
                @JsonProperty("licenseId") String licenseId,
                @JsonProperty("company") String company,
                @JsonProperty("maxUsers") int maxUsers,
                @JsonProperty("issuedAt") long issuedAt,
                @JsonProperty("expiresAt") long expiresAt,
                @JsonProperty("modules") List<String> modules,
                @JsonProperty("signature") String signature) {

            this.licenseId = Objects.requireNonNull(licenseId, "licenseId");
            this.company = Objects.requireNonNull(company, "company");
            this.maxUsers = maxUsers;
            this.issuedAt = issuedAt;
            this.expiresAt = expiresAt;
            this.modules = modules == null ? Collections.emptyList() : List.copyOf(modules);
            this.signature = Objects.requireNonNull(signature, "signature");
        }

        /**
         * Returns the canonical payload to be signed/verified, which is every
         * field except the signature itself, concatenated with '\n' separators.
         * This ordering is preserved across signing and verification routines.
         */
        String signedContent() {
            return licenseId + '\n' +
                   company + '\n' +
                   maxUsers + '\n' +
                   issuedAt + '\n' +
                   expiresAt + '\n' +
                   String.join(",", modules);
        }

        @Override
        public String toString() {
            return "License{" +
                   "licenseId='" + licenseId + '\'' +
                   ", company='" + company + '\'' +
                   ", maxUsers=" + maxUsers +
                   ", issuedAt=" + issuedAt +
                   ", expiresAt=" + expiresAt +
                   ", modules=" + modules +
                   '}';
        }
    }

    /* ------------------------------------------------------------------
     * The following utility CLI may be executed via:
     *   java -cp <jar> com.commercesphere.security.license.LicenseManager verify <path>
     *   java -cp <jar> com.commercesphere.security.license.LicenseManager dump   <path>
     * ------------------------------------------------------------------ */
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("Usage: LicenseManager <verify|dump> [licensePath]");
            System.exit(1);
        }

        String command = args[0];
        Path path = args.length > 1 ? Path.of(args[1]) : DEFAULT_LICENSE_PATH;

        LicenseManager lm = new LicenseManager();
        try {
            if ("verify".equalsIgnoreCase(command)) {
                lm.loadLicense(); // triggers validation
                System.out.println("License verification succeeded for " + path.toAbsolutePath());
            } else if ("dump".equalsIgnoreCase(command)) {
                License lic = lm.loadLicense();
                System.out.println("License Information:");
                System.out.println(lic);
            } else {
                System.err.println("Unknown command: " + command);
            }
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            LOG.error("License command [{}] failed", command, e);
            System.exit(2);
        }
    }
}
```