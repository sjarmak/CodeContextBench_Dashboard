```java
/*
 * CommerceSphere Enterprise Suite — Internal Maven Wrapper
 *
 * This class is a pure-Java alternative to the traditional shell-based
 * “mvnw” script that normally lives at the project root.  It guarantees that
 * the exact Maven distribution required by the build is downloaded,
 * verified and executed, even on build agents that have no Maven pre-installed
 * or where shell execution is restricted.
 *
 * NOTE: The code purposefully avoids any third-party dependencies so that it
 * can be launched directly through a bare JRE:                 ──
 *
 *     $ java -cp mvnw.jar com.commercesphere.build.wrapper.MavenWrapperCli
 *
 * The implementation is thread-safe and idempotent; multiple parallel
 * invocations will not corrupt the shared Maven installation directory.
 */
package com.commercesphere.build.wrapper;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.PosixFilePermissions;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Duration;
import java.util.Locale;
import java.util.Objects;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * Programmatic Maven Wrapper entry-point.
 *
 * Responsibilities:
 *  1. Read <project>/.mvn/wrapper/maven-wrapper.properties.
 *  2. Download the pinned Maven distribution if it is not yet installed.
 *  3. Verify the SHA-256 checksum (if configured).
 *  4. Delegate build execution to the downloaded {@code mvn} binary.
 */
public final class MavenWrapperCli {

    /* -----------------  Configuration ------------------ */

    private static final String WRAPPER_PROPS = ".mvn/wrapper/maven-wrapper.properties";
    private static final String PROP_DIST_URL = "distributionUrl";
    private static final String PROP_SHA256   = "distributionSha256Sum";

    private static final String DEFAULT_TOOL_ROOT =
            ".commercesphere/tools/maven";        // stored in user.home

    private static final int CONNECT_TIMEOUT_MS = (int) Duration.ofSeconds(10).toMillis();
    private static final int READ_TIMEOUT_MS    = (int) Duration.ofMinutes(5).toMillis();
    private static final int BUFFER_SIZE        = 16 * 1024;

    /* ---------------------------------------------------- */

    private static final Logger LOG = Logger.getLogger(MavenWrapperCli.class.getName());

    private MavenWrapperCli() {
        /* no-op – utility class */
    }

    public static void main(String[] args) {
        try {
            new MavenWrapperCli().execute(args);
        } catch (Exception ex) {
            LOG.log(Level.SEVERE, "Failed to execute Maven wrapper", ex);
            System.exit(1);
        }
    }

    /* ==================================================== */
    /* ==                 Core Workflow                   == */
    /* ==================================================== */

    private void execute(String[] argv) throws Exception {
        Properties props          = loadWrapperProperties();
        Path        installDir    = determineInstallDir(props);
        Path        mvnExecutable = ensureAndLocateMaven(props, installDir);

        runMaven(mvnExecutable, argv);
    }

    /* -----------------  Stage 1: Read Props ------------- */

    private Properties loadWrapperProperties() throws IOException {
        Properties props = new Properties();
        Path propsPath   = Paths.get(WRAPPER_PROPS);

        if (Files.exists(propsPath)) {
            try (InputStream in = Files.newInputStream(propsPath)) {
                props.load(in);
            }
        } else {
            // Fallback to classpath for shaded JAR executions
            try (InputStream in = MavenWrapperCli.class
                    .getClassLoader()
                    .getResourceAsStream(WRAPPER_PROPS)) {

                if (in == null) {
                    throw new IllegalStateException("Unable to locate " + WRAPPER_PROPS);
                }
                props.load(in);
            }
        }
        return props;
    }

    /* ---------------  Stage 2: Resolve Dir -------------- */

    private Path determineInstallDir(Properties props) {
        // Respect M2_HOME if user explicitly set it
        String m2Home = System.getenv("M2_HOME");
        if (m2Home != null && !m2Home.isBlank()) {
            LOG.log(Level.INFO, "Using Maven from M2_HOME={0}", m2Home);
            return Paths.get(m2Home).toAbsolutePath();
        }

        // Otherwise install under ~/.commercesphere/tools/maven/apache-maven-x.y.z
        String distUrl = Objects.requireNonNull(
                props.getProperty(PROP_DIST_URL),
                "Property '" + PROP_DIST_URL + "' missing in wrapper properties");

        String versionFolder = extractArtifactFolderName(distUrl);

        Path homeDir    = Paths.get(System.getProperty("user.home"));
        Path installDir = homeDir.resolve(DEFAULT_TOOL_ROOT).resolve(versionFolder);

        return installDir.toAbsolutePath();
    }

    private String extractArtifactFolderName(String distUrl) {
        int begin = distUrl.lastIndexOf("apache-maven-");
        int end   = distUrl.indexOf(".zip", begin);
        if (begin < 0 || end < 0) {
            throw new IllegalArgumentException(
                    "Malformed distribution URL, cannot derive folder name: " + distUrl);
        }
        return distUrl.substring(begin, end);
    }

    /* ---------------  Stage 3: Download / Verify -------- */

    private Path ensureAndLocateMaven(Properties props, Path installDir)
            throws IOException, NoSuchAlgorithmException {

        Path mvnBinary = installDir
                .resolve("bin")
                .resolve(isWindows() ? "mvn.cmd" : "mvn");

        if (Files.exists(mvnBinary)) {
            return mvnBinary;
        }

        LOG.log(Level.INFO,
                "Local Maven distribution not found — triggering download to {0}",
                installDir);

        Files.createDirectories(installDir.getParent());

        String distUrl     = props.getProperty(PROP_DIST_URL);
        String expectedSha = props.getProperty(PROP_SHA256, "").trim();

        Path zipFile = download(distUrl);

        if (!expectedSha.isEmpty()) {
            verifySha256(zipFile, expectedSha);
        }

        extractZip(zipFile, installDir.getParent());

        Files.deleteIfExists(zipFile);

        if (!Files.exists(mvnBinary)) {
            throw new IllegalStateException(
                    "Extraction completed, but mvn executable not found at " + mvnBinary);
        }
        return mvnBinary;
    }

    private Path download(String urlStr) throws IOException {
        URL url = new URL(urlStr);
        Path tempFile = Files.createTempFile("maven-dist-", ".zip");

        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setInstanceFollowRedirects(true);
        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);
        conn.setReadTimeout(READ_TIMEOUT_MS);

        try (InputStream  in  = new BufferedInputStream(conn.getInputStream());
             OutputStream out = Files.newOutputStream(
                     tempFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {

            byte[] buffer = new byte[BUFFER_SIZE];
            int    read;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
        }

        LOG.log(Level.INFO, "Downloaded Maven archive to {0} ({1} bytes)",
                new Object[]{tempFile, Files.size(tempFile)});
        return tempFile;
    }

    private void verifySha256(Path file, String expectedHex)
            throws IOException, NoSuchAlgorithmException {

        MessageDigest sha = MessageDigest.getInstance("SHA-256");

        try (DigestInputStream dis =
                     new DigestInputStream(Files.newInputStream(file), sha)) {

            byte[] buffer = new byte[BUFFER_SIZE];
            // Read entire file to compute digest
            while (dis.read(buffer) >= 0) { /* no-op */ }
        }

        byte[] digest = sha.digest();
        StringBuilder hex = new StringBuilder(digest.length * 2);
        for (byte b : digest) {
            hex.append(String.format("%02x", b));
        }

        if (!hex.toString().equalsIgnoreCase(expectedHex)) {
            throw new SecurityException(
                    "SHA-256 mismatch for " + file +
                    " – expected=" + expectedHex +
                    " actual=" + hex);
        }
        LOG.info("SHA-256 checksum verified successfully");
    }

    /* ---------------  Stage 4: Extract Archive ---------- */

    private void extractZip(Path zipFile, Path destDir) throws IOException {
        // Using java.util.zip for broad JRE compatibility
        try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zipFile))) {

            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                Path target = destDir.resolve(entry.getName()).normalize();

                // Avoid Zip-Slip vulnerability
                if (!target.startsWith(destDir)) {
                    throw new IOException("Zip entry escapes target dir: " + entry.getName());
                }

                if (entry.isDirectory()) {
                    Files.createDirectories(target);
                } else {
                    Files.createDirectories(target.getParent());
                    try (OutputStream out = Files.newOutputStream(target)) {
                        byte[] buf = new byte[BUFFER_SIZE];
                        int len;
                        while ((len = zis.read(buf)) > 0) {
                            out.write(buf, 0, len);
                        }
                    }
                    // Ensure executable flag for *nix scripts
                    if (!isWindows() && entry.getName().endsWith("mvn")) {
                        Files.setPosixFilePermissions(
                                target, PosixFilePermissions.fromString("rwxr-xr-x"));
                    }
                }
            }
        }
        LOG.log(Level.INFO, "Extracted Maven distribution to {0}", destDir);
    }

    /* ---------------  Stage 5: Execute Build ------------ */

    private void runMaven(Path mvnExecutable, String[] argv)
            throws IOException, InterruptedException {

        String[] cmd = new String[argv.length + 1];
        cmd[0] = mvnExecutable.toString();
        System.arraycopy(argv, 0, cmd, 1, argv.length);

        ProcessBuilder pb = new ProcessBuilder(cmd)
                .inheritIO()              // forward stdout/stderr to current process
                .redirectErrorStream(true);

        LOG.log(Level.INFO, "Executing: {0}", String.join(" ", cmd));

        Process proc = pb.start();
        boolean finished = proc.waitFor(1, TimeUnit.HOURS); // guard against runaway builds

        if (!finished) {
            proc.destroyForcibly();
            throw new IllegalStateException("Maven build timed-out and was terminated.");
        }

        if (proc.exitValue() != 0) {
            throw new IllegalStateException(
                    "Maven exited with non-zero status: " + proc.exitValue());
        }
    }

    /* -----------------  Helpers ------------------------- */

    private boolean isWindows() {
        return System.getProperty("os.name")
                     .toLowerCase(Locale.US)
                     .contains("win");
    }
}
```