```go
// File: src/module_5.go
//
// EchoPulse – Real-Time Social Signal Processing Platform (ml_nlp)
// -----------------------------------------------------------------
// Module 5: Online Feature-Drift Detection & Alerting
//
// This module contains a generic, online drift–detection component
// that consumes live feature vectors, compares their distributions
// against a (versioned) training baseline, and emits `DriftEvent`s
// to the platform event-bus when statistically significant drift is
// observed.  The implementation demonstrates several architectural
// patterns used across EchoPulse:
//
//   • Strategy Pattern      – interchangeable statistical tests
//   • Factory  Pattern      – test constructor registry
//   • Observer Pattern      – subscription to a live feature stream
//   • Pipeline  Pattern     – windowed aggregation + decision stage
//
// It is intentionally self-contained and uses only light external
// dependencies (gonum for statistics and segmentio/kafka-go for the
// message bus publisher).  The code can be dropped into a larger
// code-base or run standalone for demonstration purposes.
//
// -----------------------------------------------------------------

package monitor // import "github.com/echopulse/ep/monitor"

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"math"
	"sort"
	"sync"
	"time"

	kafka "github.com/segmentio/kafka-go"
	"gonum.org/v1/gonum/stat"
)

// ----------------------------------------------------------------------------
// Public Domain Types
// ----------------------------------------------------------------------------

// FeatureVector represents a canonicalised, numeric feature vector
// generated by an upstream pipeline stage.  Non-numeric features
// should be pre-encoded before reaching the detector.
type FeatureVector map[string]float64

// DriftEvent is raised whenever the detector concludes that the
// distribution of a feature in the live stream has drifted away from
// the baseline with statistical significance lower than Alpha.
type DriftEvent struct {
	Timestamp    time.Time `json:"timestamp"`
	Feature      string    `json:"feature"`
	Test         string    `json:"test"`
	PValue       float64   `json:"p_value"`
	WindowSize   int       `json:"window_size"`
	BaselineSize int       `json:"baseline_size"`
	ModelVer     string    `json:"model_version"`
}

// ----------------------------------------------------------------------------
// Strategy Pattern → Statistical Test Interface
// ----------------------------------------------------------------------------

// StatisticalTest abstracts a two-sample test that returns the
// p-value for the null-hypothesis "samples originate from the same
// distribution".
type StatisticalTest interface {
	PValue(sampleA, sampleB []float64) (float64, error)
	Name() string
}

// registry maps symbolic names onto factory functions so that tests
// can be configured in TOML/YAML/etc. at runtime.
var registry = map[string]func() StatisticalTest{
	"ks":     func() StatisticalTest { return &KSTest{} },
	"mannwh": func() StatisticalTest { return &MannWhitneyUTest{} },
}

// GetTest returns an initialised StatisticalTest by name.
func GetTest(name string) (StatisticalTest, error) {
	f, ok := registry[name]
	if !ok {
		return nil, fmt.Errorf("unknown statistical test %q", name)
	}
	return f(), nil
}

// ----------------------------------------------------------------------------
// Concrete Strategies
// ----------------------------------------------------------------------------

// KSTest – two-sample Kolmogorov-Smirnov (continuous features).
type KSTest struct{}

func (KSTest) Name() string { return "ks" }

func (KSTest) PValue(a, b []float64) (float64, error) {
	if len(a) < 2 || len(b) < 2 {
		return 1.0, errors.New("insufficient sample size for ks test")
	}
	statistic := ksStatistic(a, b)
	p := ksAsymptoticP(statistic, len(a), len(b))
	return p, nil
}

// Mann-Whitney-U (a.k.a. Wilcoxon Rank-Sum) – robust to outliers.
type MannWhitneyUTest struct{}

func (MannWhitneyUTest) Name() string { return "mannwh" }

func (MannWhitneyUTest) PValue(a, b []float64) (float64, error) {
	if len(a) < 2 || len(b) < 2 {
		return 1.0, errors.New("insufficient sample size for mann-whitney test")
	}
	p := stat.MannWhitneyUTest(a, b, nil)
	return p, nil
}

// ksStatistic computes the two-sample KS-D statistic.
func ksStatistic(x, y []float64) float64 {
	xs := append([]float64(nil), x...)
	ys := append([]float64(nil), y...)
	sort.Float64s(xs)
	sort.Float64s(ys)

	nx, ny := len(xs), len(ys)
	i, j := 0, 0
	var dMax float64
	for i < nx && j < ny {
		vx, vy := xs[i], ys[j]
		switch {
		case vx <= vy:
			i++
		case vy < vx:
			j++
		}
		cdfX := float64(i) / float64(nx)
		cdfY := float64(j) / float64(ny)
		diff := math.Abs(cdfX - cdfY)
		if diff > dMax {
			dMax = diff
		}
	}
	return dMax
}

// ksAsymptoticP calculates the asymptotic KS p-value.
func ksAsymptoticP(d float64, n, m int) float64 {
	ne := float64(n*m) / float64(n+m)
	lambda := (math.Sqrt(ne) + 0.12 + 0.11/math.Sqrt(ne)) * d
	// 2 * Σ (-1)^{k-1} exp(-2 k² λ²)  (k from 1..∞).  Truncate at 5 terms.
	var sum float64
	for k := 1; k <= 5; k++ {
		term := math.Exp(-2 * float64(k*k) * lambda * lambda)
		if k%2 == 1 {
			sum += term
		} else {
			sum -= term
		}
	}
	return math.Max(math.Min(2*sum, 1.0), 0.0)
}

// ----------------------------------------------------------------------------
// EventBus Abstraction + Kafka Publisher Implementation
// ----------------------------------------------------------------------------

// EventBus is deliberately minimal.  In production EchoPulse uses a
// richer contract (ACKS, partitions, JetStream, etc.).
type EventBus interface {
	Publish(ctx context.Context, topic string, msg []byte) error
}

type KafkaBus struct {
	w *kafka.Writer
}

func NewKafkaBus(brokers []string) *KafkaBus {
	return &KafkaBus{
		w: &kafka.Writer{
			Addr:         kafka.TCP(brokers...),
			RequiredAcks: kafka.RequireAll,
			Async:        true,
		},
	}
}

func (k *KafkaBus) Publish(ctx context.Context, topic string, msg []byte) error {
	return k.w.WriteMessages(ctx, kafka.Message{
		Topic: topic,
		Value: msg,
		Time:  time.Now().UTC(),
	})
}

func (k *KafkaBus) Close() error { return k.w.Close() }

// ----------------------------------------------------------------------------
// DriftDetector – Core Online Detection Engine
// ----------------------------------------------------------------------------

// DriftDetector is goroutine-safe.
type DriftDetector struct {
	baseline   map[string][]float64 // immutable after init
	window     []FeatureVector
	maxWindow  int
	alpha      float64
	modelVer   string
	test       StatisticalTest
	bus        EventBus
	busTopic   string
	mu         sync.Mutex
	cancelLoop context.CancelFunc
}

// DriftDetectorConfig provides dependency-injection hooks.
type DriftDetectorConfig struct {
	Baseline    map[string][]float64 // e.g. pulled from feature store
	Test        string               // "ks" or "mannwh" …
	WindowSize  int                  // sliding window N
	Alpha       float64              // significance threshold
	ModelVer    string               // baseline model version
	Bus         EventBus
	BusTopic    string
}

// NewDriftDetector validates the config and builds a detector.
func NewDriftDetector(cfg DriftDetectorConfig) (*DriftDetector, error) {
	if cfg.WindowSize < 10 {
		return nil, errors.New("window size must be ≥ 10")
	}
	if cfg.Alpha <= 0 || cfg.Alpha >= 1 {
		return nil, errors.New("alpha must lie in (0,1)")
	}
	test, err := GetTest(cfg.Test)
	if err != nil {
		return nil, err
	}
	if cfg.Bus == nil {
		return nil, errors.New("event-bus may not be nil")
	}
	return &DriftDetector{
		baseline:  cfg.Baseline,
		maxWindow: cfg.WindowSize,
		alpha:     cfg.Alpha,
		modelVer:  cfg.ModelVer,
		test:      test,
		bus:       cfg.Bus,
		busTopic:  cfg.BusTopic,
	}, nil
}

// Observe enqueues a new FeatureVector and (asynchronously) performs
// drift checks when the sliding window is full.
func (d *DriftDetector) Observe(vec FeatureVector) {
	d.mu.Lock()
	defer d.mu.Unlock()

	// Append sample
	d.window = append(d.window, vec)
	if len(d.window) > d.maxWindow {
		d.window = d.window[1:] // pop front
	}

	// Spawn test in a worker-go-routine so Observe stays low-latency
	if len(d.window) == d.maxWindow {
		snapshot := make([]FeatureVector, len(d.window))
		copy(snapshot, d.window)

		go d.checkWindow(snapshot)
	}
}

// checkWindow aggregates by feature & applies the selected test.
func (d *DriftDetector) checkWindow(window []FeatureVector) {
	// Aggregate incoming window into per-feature slices
	buffers := map[string][]float64{}
	for _, vec := range window {
		for k, v := range vec {
			buffers[k] = append(buffers[k], v)
		}
	}

	// Run tests for each feature
	for feat, sample := range buffers {
		base, ok := d.baseline[feat]
		if !ok || len(base) < 10 {
			// No/bad baseline – skip; in prod log a warning
			continue
		}
		p, err := d.test.PValue(sample, base)
		if err != nil {
			continue
		}
		if p < d.alpha {
			d.emit(feat, p, len(sample), len(base))
		}
	}
}

// emit publishes a DriftEvent as JSON to the bus.
func (d *DriftDetector) emit(feature string, p float64, win, base int) {
	evt := DriftEvent{
		Timestamp:    time.Now().UTC(),
		Feature:      feature,
		Test:         d.test.Name(),
		PValue:       p,
		WindowSize:   win,
		BaselineSize: base,
		ModelVer:     d.modelVer,
	}
	payload, _ := json.Marshal(evt) // cannot fail for serialisable struct
	_ = d.bus.Publish(context.TODO(), d.busTopic, payload)
}

// Run starts a background watchdog that periodically rotates the
// baseline from an injected callback (stubbed here for brevity).
// This demonstrates how the detector can be kept fresh without
// tearing down producers/consumers.
//
//	c := detector.Run(ctx, 24*time.Hour, fetchNewBaseline)
//
// The returned channel is closed once the rotation loop ends.
func (d *DriftDetector) Run(
	parent context.Context,
	interval time.Duration,
	refresh func() (map[string][]float64, string, error),
) <-chan struct{} {
	ctx, cancel := context.WithCancel(parent)
	d.cancelLoop = cancel
	done := make(chan struct{})

	go func() {
		defer close(done)
		ticker := time.NewTicker(interval)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				if err := d.rotateBaseline(refresh); err != nil {
					// In production log to observability stack
				}
			}
		}
	}()

	return done
}

// rotateBaseline atomically swaps in a new baseline distribution.
func (d *DriftDetector) rotateBaseline(
	refresh func() (map[string][]float64, string, error),
) error {
	base, ver, err := refresh()
	if err != nil {
		return err
	}
	d.mu.Lock()
	defer d.mu.Unlock()
	d.baseline = base
	d.modelVer = ver
	return nil
}

// Stop terminates the background refresh loop (if started).
func (d *DriftDetector) Stop() { // nolint: revive
	if d.cancelLoop != nil {
		d.cancelLoop()
	}
}

// ----------------------------------------------------------------------------
// Example Integration
// ----------------------------------------------------------------------------

/*
func main() {
	// --- startup wiring -----------------------------------------------------
	bus := NewKafkaBus([]string{"kafka-broker-1:9092", "kafka-broker-2:9092"})
	defer bus.Close()

	// Baseline could be fetched from feature-store / S3 / DB
	baseline := loadBaselineFromFS("features.json")

	detector, err := NewDriftDetector(DriftDetectorConfig{
		Baseline:   baseline,
		Test:       "ks",
		WindowSize: 500,
		Alpha:      0.01,
		ModelVer:   "sentiment-v42",
		Bus:        bus,
		BusTopic:   "ml.drift.events",
	})
	if err != nil {
		log.Fatal(err)
	}

	// Example: subscribe to live feature stream (pseudo-code)
	stream := MakeFeatureStream()
	for vec := range stream {
		detector.Observe(vec)
	}
}
*/

// ---------------------------------------------------------------------------
// EOF
// ---------------------------------------------------------------------------
```