```go
// Code generated by EchoPulse platform scaffolder. DO NOT EDIT.
//
// File:        src/module_47.go
// Description: Real-time feature‐drift watcher that listens on the event bus for
//              FeatureStatEvent messages and emits DriftAlert events whenever
//              population statistics deviate significantly from their baseline.
//              Demonstrates Observer, Strategy, and Pipeline patterns in action.
//
//                ┌────────┐             ┌───────────┐
//        stats ► │ JetStream│ ► watcher ►│ DriftAlert│ ► downstream handlers
//                └────────┘             └───────────┘
package monitoring

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"math"
	"sync"
	"time"

	"github.com/nats-io/nats.go"
)

// FeatureStatEvent represents statistics for a single feature calculated over
// an aggregation window upstream (e.g., every minute).
type FeatureStatEvent struct {
	FeatureName string    `json:"feature_name"`
	WindowSize  int       `json:"window_size"` // count of samples in window
	Mean        float64   `json:"mean"`
	Std         float64   `json:"std"`
	Timestamp   time.Time `json:"timestamp"`
}

// DriftAlert is emitted when a statistically significant drift is detected.
type DriftAlert struct {
	FeatureName   string    `json:"feature_name"`
	BaselineMean  float64   `json:"baseline_mean"`
	CurrentMean   float64   `json:"current_mean"`
	PValue        float64   `json:"p_value"`
	WindowSize    int       `json:"window_size"`
	DetectedAt    time.Time `json:"detected_at"`
	RecommendedOp string    `json:"recommended_op"` // e.g., "retrain", "investigate"
	Version       string    `json:"version"`
}

// BaselineStore defines how baselines are persisted/loaded.
// In production, this could be backed by Redis, S3, a Feature Store, etc.
type BaselineStore interface {
	Load(ctx context.Context, feature string) (mean, std float64, err error)
	Store(ctx context.Context, feature string, mean, std float64) error
}

// inMemoryBaselineStore is a thread-safe, in-memory implementation useful for
// tests and single-process deployments.
type inMemoryBaselineStore struct {
	mu   sync.RWMutex
	data map[string]struct{ mean, std float64 }
}

func NewInMemoryBaselineStore() BaselineStore {
	return &inMemoryBaselineStore{data: map[string]struct{ mean, std float64 }{}}
}

func (s *inMemoryBaselineStore) Load(_ context.Context, feature string) (float64, float64, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	v, ok := s.data[feature]
	if !ok {
		return 0, 0, errors.New("baseline not found")
	}
	return v.mean, v.std, nil
}

func (s *inMemoryBaselineStore) Store(_ context.Context, feature string, mean, std float64) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.data[feature] = struct{ mean, std float64 }{mean: mean, std: std}
	return nil
}

// StatisticalTest abstracts a hypothesis test used to decide drift.
type StatisticalTest interface {
	// Test returns the p-value comparing baseline and current window.
	Test(baselineMean, baselineStd, currentMean, currentStd float64, windowSize int) float64
}

// welchsTTest implements a Welch’s t-test which is robust to unequal variances.
type welchsTTest struct{}

func (welchsTTest) Test(bMean, bStd, cMean, cStd float64, n int) float64 {
	if n < 2 || bStd == 0 || cStd == 0 {
		return 1.0 // Insufficient evidence
	}
	// Simplified t-statistic for demonstration purposes.
	t := math.Abs(bMean-cMean) / math.Sqrt((bStd*bStd+ cStd*cStd)/float64(n))
	// Convert t-statistic to p-value (two-tailed) using survival function
	// approximation. In real code, use a stats library.
	df := float64(2*n - 2)
	p := 2 * (1 - studentsTCDF(t, df))
	return p
}

// studentsTCDF computes an approximate CDF of Student's t distribution using
// the incomplete beta function approximation (Abramowitz & Stegun 26.7.1).
// For brevity, we use a very rough approximation sufficient for alerting.
// DO NOT use in scientific applications.
func studentsTCDF(t, df float64) float64 {
	x := df / (df + t*t)
	a := 0.5 * df
	b := 0.5
	// Regularized incomplete beta approximation via continued fraction.
	return 0.5 * betai(a, b, x)
}

// betai computes the regularized incomplete beta function using continued
// fraction expansion (Algorithm 26.5.8 from Abramowitz & Stegun).
func betai(a, b, x float64) float64 {
	const iter = 50
	const eps = 1e-10

	beta := math.Exp(lgamma(a) + lgamma(b) - lgamma(a+b))
	if x == 0 || x == 1 {
		return x
	}

	cf := 1.0
	d := 1.0 - (a+b)*x/(a+1)
	if math.Abs(d) < eps {
		d = eps
	}
	d = 1 / d
	h := d
	for m := 2; m <= iter; m++ {
		m2 := float64(m - 1)
		aa := m2 * (b - m2) * x / ((a - 1 + m2) * (a + m2))
		d = 1 + aa*d
		if math.Abs(d) < eps {
			d = eps
		}
		cf = 1 + aa/cf
		if math.Abs(cf) < eps {
			cf = eps
		}
		d = 1 / d
		h *= d * cf
		aa = -(a + m2) * (a + b + m2) * x / ((a + m2) * (a + m2 + 1))
		d = 1 + aa*d
		if math.Abs(d) < eps {
			d = eps
		}
		cf = 1 + aa/cf
		if math.Abs(cf) < eps {
			cf = eps
		}
		d = 1 / d
		del := d * cf
		h *= del
	}
	return beta * h / a
}

// lgamma is a helper alias to math.Lgamma that returns the logarithm only.
func lgamma(x float64) float64 {
	l, _ := math.Lgamma(x)
	return l
}

// DriftWatcher orchestrates drift detection end-to-end.
type DriftWatcher struct {
	baselines    BaselineStore          // persistent store
	test         StatisticalTest        // strategy
	js           nats.JetStreamContext  // event bus
	sourceSubj   string                 // e.g. "stats.features"
	alertSubj    string                 // e.g. "alerts.drift"
	pThreshold   float64                // significance level
	coolDown     time.Duration          // min time between alerts per feature
	cancel       context.CancelFunc
	wg           sync.WaitGroup
	lastAlert    sync.Map // feature -> time.Time
	log          *log.Logger
}

// DriftWatcherConfig is used to create a watcher with sensible defaults.
type DriftWatcherConfig struct {
	JetStream    nats.JetStreamContext
	SourceSubj   string
	AlertSubj    string
	PThreshold   float64
	CoolDown     time.Duration
	Logger       *log.Logger
	Baselines    BaselineStore
	Test         StatisticalTest
}

// NewDriftWatcher validates cfg and returns a ready-to-start DriftWatcher.
func NewDriftWatcher(cfg DriftWatcherConfig) (*DriftWatcher, error) {
	if cfg.JetStream == nil {
		return nil, errors.New("JetStream context is nil")
	}
	if cfg.SourceSubj == "" || cfg.AlertSubj == "" {
		return nil, errors.New("subjects not specified")
	}
	if cfg.PThreshold <= 0 || cfg.PThreshold >= 1 {
		cfg.PThreshold = 0.01
	}
	if cfg.CoolDown == 0 {
		cfg.CoolDown = 10 * time.Minute
	}
	if cfg.Logger == nil {
		cfg.Logger = log.Default()
	}
	if cfg.Baselines == nil {
		cfg.Baselines = NewInMemoryBaselineStore()
	}
	if cfg.Test == nil {
		cfg.Test = welchsTTest{}
	}
	return &DriftWatcher{
		baselines:  cfg.Baselines,
		test:       cfg.Test,
		js:         cfg.JetStream,
		sourceSubj: cfg.SourceSubj,
		alertSubj:  cfg.AlertSubj,
		pThreshold: cfg.PThreshold,
		coolDown:   cfg.CoolDown,
		log:        cfg.Logger,
	}, nil
}

// Start begins processing until the provided context is cancelled.
func (w *DriftWatcher) Start(ctx context.Context) error {
	if w.cancel != nil {
		return errors.New("watcher already started")
	}
	ctx, cancel := context.WithCancel(ctx)
	w.cancel = cancel

	sub, err := w.js.Subscribe(w.sourceSubj, w.handleMsg,
		nats.DeliverNew(), nats.ManualAck())
	if err != nil {
		return fmt.Errorf("subscribe: %w", err)
	}
	w.log.Printf("[drift] watching %q → %q (p≤%.3f)", w.sourceSubj, w.alertSubj, w.pThreshold)

	// Ensure subscription is drained on shutdown.
	w.wg.Add(1)
	go func() {
		defer w.wg.Done()
		<-ctx.Done()
		sub.Drain()
	}()
	return nil
}

// Stop gracefully cancels the processing loop and waits for cleanup.
func (w *DriftWatcher) Stop() {
	if w.cancel == nil {
		return
	}
	w.cancel()
	w.wg.Wait()
	w.cancel = nil
}

// handleMsg carries out the processing chain for a single message.
func (w *DriftWatcher) handleMsg(m *nats.Msg) {
	defer m.Ack()
	var evt FeatureStatEvent
	if err := json.Unmarshal(m.Data, &evt); err != nil {
		w.log.Printf("[drift] unmarshal error: %v", err)
		return
	}

	ctx := context.TODO()
	bMean, bStd, err := w.baselines.Load(ctx, evt.FeatureName)
	if err != nil {
		// Baseline missing; initialize then skip detection.
		_ = w.baselines.Store(ctx, evt.FeatureName, evt.Mean, evt.Std)
		w.log.Printf("[drift] baseline initialised for %q (μ=%.4f, σ=%.4f)", evt.FeatureName, evt.Mean, evt.Std)
		return
	}

	p := w.test.Test(bMean, bStd, evt.Mean, evt.Std, evt.WindowSize)
	if p > w.pThreshold {
		return // No significant drift.
	}

	// Cool-down enforcement.
	now := time.Now()
	if last, ok := w.lastAlert.Load(evt.FeatureName); ok {
		if now.Sub(last.(time.Time)) < w.coolDown {
			return
		}
	}
	w.lastAlert.Store(evt.FeatureName, now)

	alert := DriftAlert{
		FeatureName:  evt.FeatureName,
		BaselineMean: bMean,
		CurrentMean:  evt.Mean,
		PValue:       p,
		WindowSize:   evt.WindowSize,
		DetectedAt:   now.UTC(),
		RecommendedOp: func() string {
			if p < w.pThreshold/10 {
				return "retrain"
			}
			return "investigate"
		}(),
		Version: "v1",
	}

	data, _ := json.Marshal(&alert)
	if _, err := w.js.Publish(w.alertSubj, data); err != nil {
		w.log.Printf("[drift] publish alert error: %v", err)
	} else {
		w.log.Printf("[drift] ALERT feature=%q p=%.5f op=%s", alert.FeatureName, alert.PValue, alert.RecommendedOp)
	}
}
```