```go
// File: src/module_68.go
// Package processing contains real-time signal processors that sit on the
// event-bus and publish higher-level social telemetry.
package processing

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/Shopify/sarama"
	"github.com/cenkalti/backoff/v4"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

// ----------------------------------------------------------------------------
// Domain models
// ----------------------------------------------------------------------------

// SocialEvent is the canonical representation of any user-generated activity
// emitted by upstream ingestion services.
//
// Only the subset of fields required by this module are declared here.
// In the real project this would live in a shared protobuf/avro schema.
type SocialEvent struct {
	ChannelID   string    `json:"channel_id"`
	UserID      string    `json:"user_id"`
	Text        string    `json:"text"`
	Sentiment   float64   `json:"sentiment"` // Pre-computed sentiment score (-1..1)
	CreatedAt   time.Time `json:"created_at"`
	EventID     string    `json:"event_id"`
	ContentType string    `json:"content_type"` // text/emoji/audio/…
}

// CommunityHealthEvent is a higher-level signal generated by this module and
// fanned-out to downstream services/dashboards.
type CommunityHealthEvent struct {
	ChannelID string    `json:"channel_id"`
	Score     float64   `json:"score"` // EWMA sentiment score.
	Window    string    `json:"window"`
	CreatedAt time.Time `json:"created_at"`
}

// ----------------------------------------------------------------------------
// Configuration
// ----------------------------------------------------------------------------

// Config is resolved from environment variables so the binary can be
// containerised and scheduled without additional configuration management.
type Config struct {
	Brokers        []string
	IncomingTopic  string
	OutgoingTopic  string
	ConsumerGroup  string
	Alpha          float64 // Smoothing factor for EWMA.
	MetricsAddress string  // e.g. ":2112"
}

// NewConfigFromEnv reads & validates configuration from environment variables.
func NewConfigFromEnv() (Config, error) {
	cfg := Config{
		Brokers:        strings.Split(os.Getenv("EP_BROKERS"), ","),
		IncomingTopic:  getenvDefault("EP_IN_TOPIC", "social.events"),
		OutgoingTopic:  getenvDefault("EP_OUT_TOPIC", "community.health"),
		ConsumerGroup:  getenvDefault("EP_GROUP_ID", "sentiment-aggregator"),
		Alpha:          getenvFloatDefault("EP_ALPHA", 0.3),
		MetricsAddress: getenvDefault("EP_METRICS_ADDR", ":2112"),
	}

	if len(cfg.Brokers) == 0 || cfg.Brokers[0] == "" {
		return Config{}, errors.New("EP_BROKERS cannot be empty")
	}
	if cfg.Alpha <= 0.0 || cfg.Alpha >= 1.0 {
		return Config{}, errors.New("EP_ALPHA must be in (0,1)")
	}
	return cfg, nil
}

// Helpers --------------------------------------------------------------------

func getenvDefault(key, def string) string {
	if v := strings.TrimSpace(os.Getenv(key)); v != "" {
		return v
	}
	return def
}

func getenvFloatDefault(key string, def float64) float64 {
	if v := strings.TrimSpace(os.Getenv(key)); v != "" {
		var f float64
		_, err := fmt.Sscan(v, &f)
		if err == nil {
			return f
		}
	}
	return def
}

// ----------------------------------------------------------------------------
// Sentiment Aggregator
// ----------------------------------------------------------------------------

// SentimentAggregator consumes raw SocialEvents, maintains a per-channel
// exponential moving average of sentiment, and publishes CommunityHealthEvents.
type SentimentAggregator struct {
	cfg      Config
	producer sarama.SyncProducer
	consumer sarama.ConsumerGroup

	// state protects the rolling score for each channel.
	state   map[string]*channelState
	stateMu sync.RWMutex

	// metrics
	metricScore     *prometheus.GaugeVec
	metricMessages  prometheus.Counter
	metricPublished prometheus.Counter
}

// channelState tracks the EWMA sentiment for a channel.
type channelState struct {
	Score float64
}

// NewSentimentAggregator constructs the service wiring but does not start
// consuming. All heavy resources are initialised here so that Start can remain
// context-cancellable without side-effects.
func NewSentimentAggregator(cfg Config) (*SentimentAggregator, error) {
	// Producer config ----------------------------------------------------------------
	prodCfg := sarama.NewConfig()
	prodCfg.Producer.Return.Successes = true
	prodCfg.Producer.Idempotent = true
	prodCfg.Version = sarama.V3_4_0_0

	producer, err := sarama.NewSyncProducer(cfg.Brokers, prodCfg)
	if err != nil {
		return nil, fmt.Errorf("create producer: %w", err)
	}

	// Consumer config ----------------------------------------------------------------
	consCfg := sarama.NewConfig()
	consCfg.Consumer.Group.Rebalance.Strategy = sarama.BalanceStrategyRange
	consCfg.Consumer.Offsets.Initial = sarama.OffsetNewest
	consCfg.Version = sarama.V3_4_0_0

	consumer, err := sarama.NewConsumerGroup(cfg.Brokers, cfg.ConsumerGroup, consCfg)
	if err != nil {
		_ = producer.Close()
		return nil, fmt.Errorf("create consumer group: %w", err)
	}

	// Prometheus metrics --------------------------------------------------------------
	registry := prometheus.DefaultRegisterer
	metricScore := prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace: "echopulse",
			Subsystem: "sentiment_aggregator",
			Name:      "ewma_score",
			Help:      "Smoothed sentiment score per channel",
		},
		[]string{"channel_id"},
	)
	registry.MustRegister(metricScore)

	metricMessages := prometheus.NewCounter(
		prometheus.CounterOpts{
			Namespace: "echopulse",
			Subsystem: "sentiment_aggregator",
			Name:      "messages_ingested_total",
			Help:      "Number of SocialEvents processed",
		},
	)
	registry.MustRegister(metricMessages)

	metricPublished := prometheus.NewCounter(
		prometheus.CounterOpts{
			Namespace: "echopulse",
			Subsystem: "sentiment_aggregator",
			Name:      "messages_published_total",
			Help:      "Number of CommunityHealthEvents published",
		},
	)
	registry.MustRegister(metricPublished)

	return &SentimentAggregator{
		cfg:            cfg,
		producer:       producer,
		consumer:       consumer,
		state:          make(map[string]*channelState),
		metricScore:    metricScore,
		metricMessages: metricMessages,
		metricPublished: metricPublished,
	}, nil
}

// Start begins consuming messages and blocks until context cancellation or fatal error.
func (sa *SentimentAggregator) Start(ctx context.Context) error {
	// Expose /metrics -----------------------------------------------------------
	go func() {
		http.Handle("/metrics", promhttp.Handler())
		if err := http.ListenAndServe(sa.cfg.MetricsAddress, nil); err != nil {
			log.Printf("metrics server exited: %v", err)
		}
	}()

	wg := &sync.WaitGroup{}
	wg.Add(1)

	go func() {
		defer wg.Done()
		backoffCfg := backoff.NewExponentialBackOff()
		for {
			// Consume() is blocking, returning only on error or ctx cancel.
			if err := sa.consumer.Consume(ctx, []string{sa.cfg.IncomingTopic}, &consumerGroupHandler{agg: sa}); err != nil {
				// Transient errors (e.g. broker down) are back-off retried.
				if ctx.Err() != nil {
					// context cancelled -> graceful shutdown
					return
				}
				next := backoffCfg.NextBackOff()
				log.Printf("consume error: %v; retrying in %s", err, next)
				select {
				case <-time.After(next):
				case <-ctx.Done():
					return
				}
				continue
			}
			// Reached here if Consume exited without error -> context cancelled.
			return
		}
	}()

	<-ctx.Done() // Wait for caller.
	wg.Wait()
	return nil
}

// Stop gracefully closes the Kafka clients.
func (sa *SentimentAggregator) Stop() {
	_ = sa.consumer.Close()
	_ = sa.producer.Close()
}

// processSocialEvent updates EWMA state and publishes a CommunityHealthEvent.
func (sa *SentimentAggregator) processSocialEvent(ev *SocialEvent) error {
	sa.metricMessages.Inc()

	sa.stateMu.Lock()
	st, ok := sa.state[ev.ChannelID]
	if !ok {
		st = &channelState{}
		sa.state[ev.ChannelID] = st
	}
	// EWMA update: S_t = α*x_t + (1-α)*S_{t-1}
	st.Score = sa.cfg.Alpha*ev.Sentiment + (1.0-sa.cfg.Alpha)*st.Score
	sa.stateMu.Unlock()

	sa.metricScore.WithLabelValues(ev.ChannelID).Set(st.Score)

	health := CommunityHealthEvent{
		ChannelID: ev.ChannelID,
		Score:     st.Score,
		Window:    fmt.Sprintf("EWMA(α=%.2f)", sa.cfg.Alpha),
		CreatedAt: time.Now().UTC(),
	}

	payload, err := json.Marshal(health)
	if err != nil {
		return fmt.Errorf("marshal health event: %w", err)
	}

	msg := &sarama.ProducerMessage{
		Topic: sa.cfg.OutgoingTopic,
		Value: sarama.ByteEncoder(payload),
		Key:   sarama.StringEncoder(ev.ChannelID),
	}

	_, _, err = sa.producer.SendMessage(msg)
	if err != nil {
		return fmt.Errorf("publish health event: %w", err)
	}
	sa.metricPublished.Inc()
	return nil
}

// ----------------------------------------------------------------------------
// Sarama ConsumerGroup handler implementation
// ----------------------------------------------------------------------------

type consumerGroupHandler struct {
	agg *SentimentAggregator
}

func (h *consumerGroupHandler) Setup(_ sarama.ConsumerGroupSession) error   { return nil }
func (h *consumerGroupHandler) Cleanup(_ sarama.ConsumerGroupSession) error { return nil }

func (h *consumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	for msg := range claim.Messages() {
		var ev SocialEvent
		if err := json.Unmarshal(msg.Value, &ev); err != nil {
			log.Printf("invalid SocialEvent: %v", err)
			continue // Skip but mark offset to avoid poison pill loops.
		}
		if err := h.agg.processSocialEvent(&ev); err != nil {
			log.Printf("process error (ack skipped): %v", err)
			continue
		}
		session.MarkMessage(msg, "")
	}
	return nil
}

// ----------------------------------------------------------------------------
// Main (stand-alone service entry point)
// ----------------------------------------------------------------------------

// For package reuse we keep main in the same file, guarded by build tags.
//
//go:build sentiment_aggregator
// +build sentiment_aggregator

func main() {
	cfg, err := NewConfigFromEnv()
	if err != nil {
		log.Fatalf("invalid configuration: %v", err)
	}

	agg, err := NewSentimentAggregator(cfg)
	if err != nil {
		log.Fatalf("initialise aggregator: %v", err)
	}
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Respond to SIGINT/SIGTERM for graceful shutdown.
	go handleSignals(cancel)

	log.Println("Sentiment Aggregator starting …")
	if err := agg.Start(ctx); err != nil {
		log.Fatalf("aggregator stopped with error: %v", err)
	}
	agg.Stop()
	log.Println("Sentiment Aggregator shut down gracefully.")
}

// handleSignals listens for termination signals and cancels the context.
func handleSignals(cancel context.CancelFunc) {
	sigCh := make(chan os.Signal, 1)
	// Refresh to import the package only on this build tag.
	//nolint:staticcheck
	signal.Notify(sigCh, os.Interrupt, os.Kill)
	<-sigCh
	cancel()
}
```
