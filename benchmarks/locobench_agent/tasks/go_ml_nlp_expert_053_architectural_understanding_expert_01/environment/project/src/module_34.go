```go
// Code generated by EchoPulse Platform. DO NOT EDIT.
//
// File:        src/module_34.go
// Description: Drift monitoring & automated re-training coordinator.
// ──────────────────────────────────────────────────────────────────────────────
// This module is part of the EchoPulse real-time social signal processing stack.
// It consumes model-monitoring metric events from the event bus, applies
// statistical drift-detection algorithms, notifies registered observers, and
// triggers automated re-training jobs via gRPC when significant drift is
// detected.
//
// Architectural patterns demonstrated:
//   • Observer Pattern        – external components can subscribe to drift alerts
//   • Strategy Pattern        – plug-gable drift-detection algorithms
//   • Pipeline / Concurrency  – high-throughput, non-blocking event pipeline
//
// Author: EchoPulse ML Engineering Team
// SPDX-License-Identifier: Apache-2.0
package driftmonitor

import (
	"context"
	"encoding/json"
	"errors"
	"log"
	"math"
	"sync"
	"time"

	"google.golang.org/grpc"
)

//───────────────────────────────────────────────────────────────────────────────
// Domain models
//───────────────────────────────────────────────────────────────────────────────

// MetricEvent represents a single monitoring datapoint emitted by live model
// inference services.
type MetricEvent struct {
	ModelID    string    `json:"model_id"`    // unique model identifier
	MetricType string    `json:"metric_type"` // e.g. "accuracy", "f1", "loss"
	Value      float64   `json:"value"`       // numeric metric value
	Timestamp  time.Time `json:"ts"`          // event production time
}

// DriftAlert is published to observers when drift is detected.
type DriftAlert struct {
	ModelID        string    // the affected model
	MetricType     string    // metric that triggered the alert
	WindowMean     float64   // mean of evaluation window
	BaselineMean   float64   // stored baseline
	Threshold      float64   // configured threshold
	WindowSize     int       // number of datapoints evaluated
	DetectedAt     time.Time // time of detection
	TriggerRetrain bool      // whether an automatic retrain was requested
}

//───────────────────────────────────────────────────────────────────────────────
// Event Bus Abstraction
//───────────────────────────────────────────────────────────────────────────────

// BusConsumer provides an abstraction over streaming systems (Kafka, NATS,
// Google Pub/Sub, …) so that we can unit-test without external dependencies.
type BusConsumer interface {
	// Subscribe returns a channel carrying raw JSON messages for the requested
	// topics/subjects. The implementer owns the goroutine that writes to the
	// channel and MUST close the channel once ctx is canceled or an unrecoverable
	// error occurs.
	Subscribe(ctx context.Context, topics ...string) (<-chan []byte, error)
}

//───────────────────────────────────────────────────────────────────────────────
// Drift-detection Strategy
//───────────────────────────────────────────────────────────────────────────────

// DriftDetector applies a statistical test on a sliding window of MetricEvents.
type DriftDetector interface {
	Evaluate(window []MetricEvent) (driftDetected bool, windowMean float64, err error)
}

// ThresholdDetector is a simple strategy that checks if the mean of the sliding
// window deviates from a predefined baseline by more than ±threshold.
type ThresholdDetector struct {
	BaselineMean float64 // reference value from training/validation
	Threshold    float64 // allowed absolute deviation
}

// Evaluate implements the DriftDetector interface.
func (t *ThresholdDetector) Evaluate(window []MetricEvent) (bool, float64, error) {
	if len(window) == 0 {
		return false, 0, errors.New("empty window")
	}
	var sum float64
	for _, ev := range window {
		sum += ev.Value
	}
	mean := sum / float64(len(window))
	// absolute deviation
	deviation := math.Abs(mean - t.BaselineMean)
	return deviation >= t.Threshold, mean, nil
}

//───────────────────────────────────────────────────────────────────────────────
// Observer pattern
//───────────────────────────────────────────────────────────────────────────────

// DriftObserver can register with a DriftMonitor to get callbacks.
type DriftObserver interface {
	OnDrift(alert DriftAlert)
}

//───────────────────────────────────────────────────────────────────────────────
// Training service client
//───────────────────────────────────────────────────────────────────────────────

// TrainServiceClient abstracts the model-training micro-service (gRPC).
type TrainServiceClient interface {
	TriggerRetrain(ctx context.Context, modelID string) error
}

// trainServiceGRPC is a minimal gRPC client; in production this would be
// generated from protobuf definitions.
type trainServiceGRPC struct {
	cc     *grpc.ClientConn
	logger *log.Logger
}

// NewTrainServiceClient dials the training service.
func NewTrainServiceClient(addr string, logger *log.Logger) (TrainServiceClient, error) {
	conn, err := grpc.Dial(addr, grpc.WithInsecure(), grpc.WithBlock())
	if err != nil {
		return nil, err
	}
	return &trainServiceGRPC{cc: conn, logger: logger}, nil
}

func (c *trainServiceGRPC) TriggerRetrain(ctx context.Context, modelID string) error {
	// Placeholder RPC – replace with generated client call:
	c.logger.Printf("[trainSvc] requesting retrain for model=%s", modelID)
	// Simulate network call
	select {
	case <-ctx.Done():
		return ctx.Err()
	case <-time.After(250 * time.Millisecond):
	}
	return nil
}

//───────────────────────────────────────────────────────────────────────────────
// Drift monitor core
//───────────────────────────────────────────────────────────────────────────────

// Config holds runtime settings for the DriftMonitor.
type Config struct {
	WindowSize       int           // number of most recent events to consider
	MinEvents        int           // minimum required to start evaluation
	RetrainCooldown  time.Duration // minimum duration between successive retrains
	EventTopic       string        // topic/subject to subscribe to
	ModelMetric      string        // metric to monitor (e.g. "accuracy")
	MaxBufferAge     time.Duration // purge events older than this
	Logger           *log.Logger   // application-level logger
}

// DriftMonitor consumes metric events and performs drift detection.
type DriftMonitor struct {
	cfg        Config
	bus        BusConsumer
	detector   DriftDetector
	trainSvc   TrainServiceClient

	mu          sync.RWMutex
	observers   map[DriftObserver]struct{}
	buffers     map[string][]MetricEvent          // per-model sliding windows
	lastRetrain map[string]time.Time              // per-model cooldown tracking
}

// NewDriftMonitor wires up a new monitor.
func NewDriftMonitor(
	cfg Config,
	bus BusConsumer,
	detector DriftDetector,
	trainSvc TrainServiceClient,
) *DriftMonitor {
	if cfg.WindowSize == 0 {
		cfg.WindowSize = 100
	}
	if cfg.MinEvents == 0 {
		cfg.MinEvents = 30
	}
	if cfg.RetrainCooldown == 0 {
		cfg.RetrainCooldown = 24 * time.Hour
	}
	if cfg.MaxBufferAge == 0 {
		cfg.MaxBufferAge = 6 * time.Hour
	}
	if cfg.Logger == nil {
		cfg.Logger = log.Default()
	}

	return &DriftMonitor{
		cfg:         cfg,
		bus:         bus,
		detector:    detector,
		trainSvc:    trainSvc,
		observers:   map[DriftObserver]struct{}{},
		buffers:     map[string][]MetricEvent{},
		lastRetrain: map[string]time.Time{},
	}
}

// Register allows external components to subscribe for drift alerts.
func (m *DriftMonitor) Register(obs DriftObserver) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.observers[obs] = struct{}{}
}

// Unregister removes a previously registered observer.
func (m *DriftMonitor) Unregister(obs DriftObserver) {
	m.mu.Lock()
	defer m.mu.Unlock()
	delete(m.observers, obs)
}

// Start launches the monitoring loop. It returns when ctx is canceled or
// subscription errors occur.
func (m *DriftMonitor) Start(ctx context.Context) error {
	rawCh, err := m.bus.Subscribe(ctx, m.cfg.EventTopic)
	if err != nil {
		return err
	}

	for {
		select {
		case <-ctx.Done():
			m.cfg.Logger.Println("[driftMonitor] shutting down:", ctx.Err())
			return nil
		case msg, ok := <-rawCh:
			if !ok {
				return errors.New("event stream closed")
			}
			if err := m.handleMessage(ctx, msg); err != nil {
				m.cfg.Logger.Printf("[driftMonitor] handleMessage error: %v", err)
			}
		}
	}
}

// handleMessage unmarshals a JSON message and dispatches it for evaluation.
func (m *DriftMonitor) handleMessage(ctx context.Context, raw []byte) error {
	var ev MetricEvent
	if err := json.Unmarshal(raw, &ev); err != nil {
		return err
	}

	// Filter unrelated metric types early
	if ev.MetricType != m.cfg.ModelMetric {
		return nil
	}

	m.mu.Lock()
	defer m.mu.Unlock()

	buffer := append(m.buffers[ev.ModelID], ev)
	// Purge stale events
	cutoff := time.Now().Add(-m.cfg.MaxBufferAge)
	var sanitized []MetricEvent
	for i := len(buffer) - 1; i >= 0; i-- { // iterate backwards to break early
		if buffer[i].Timestamp.After(cutoff) {
			sanitized = append([]MetricEvent{buffer[i]}, sanitized...)
		}
	}
	if len(sanitized) > m.cfg.WindowSize {
		sanitized = sanitized[len(sanitized)-m.cfg.WindowSize:]
	}
	m.buffers[ev.ModelID] = sanitized

	// Wait until enough datapoints accumulated
	if len(sanitized) < m.cfg.MinEvents {
		return nil
	}

	drift, mean, err := m.detector.Evaluate(sanitized)
	if err != nil {
		return err
	}
	if !drift {
		return nil
	}

	now := time.Now()
	last := m.lastRetrain[ev.ModelID]
	cooldownPassed := now.Sub(last) >= m.cfg.RetrainCooldown

	alert := DriftAlert{
		ModelID:        ev.ModelID,
		MetricType:     ev.MetricType,
		WindowMean:     mean,
		BaselineMean:   m.detector.(*ThresholdDetector).BaselineMean,
		Threshold:      m.detector.(*ThresholdDetector).Threshold,
		WindowSize:     len(sanitized),
		DetectedAt:     now,
		TriggerRetrain: cooldownPassed,
	}

	go m.notifyObservers(alert)

	// Attempt automated retrain if cooldown elapsed
	if cooldownPassed {
		m.lastRetrain[ev.ModelID] = now
		go func(id string) {
			ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
			defer cancel()
			if err := m.trainSvc.TriggerRetrain(ctx, id); err != nil {
				m.cfg.Logger.Printf("[driftMonitor] failed to trigger retrain: %v", err)
			}
		}(ev.ModelID)
	}

	return nil
}

// notifyObservers sends alerts asynchronously.
func (m *DriftMonitor) notifyObservers(alert DriftAlert) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	for obs := range m.observers {
		obs := obs // capture loop variable
		go func() {
			defer func() {
				if r := recover(); r != nil {
					m.cfg.Logger.Printf("[driftMonitor] recovered in observer: %v", r)
				}
			}()
			obs.OnDrift(alert)
		}()
	}
}

//───────────────────────────────────────────────────────────────────────────────
// In-memory bus consumer for unit testing / local dev
//───────────────────────────────────────────────────────────────────────────────

// MemoryBus is a lightweight pub/sub bus useful for tests.
type MemoryBus struct {
	topics map[string][]chan []byte
	mu     sync.RWMutex
}

// NewMemoryBus creates an empty MemoryBus.
func NewMemoryBus() *MemoryBus {
	return &MemoryBus{
		topics: make(map[string][]chan []byte),
	}
}

// Publish pushes a raw message onto a topic.
func (b *MemoryBus) Publish(topic string, msg []byte) {
	b.mu.RLock()
	defer b.mu.RUnlock()
	for _, ch := range b.topics[topic] {
		// non-blocking send
		select {
		case ch <- msg:
		default:
		}
	}
}

// Subscribe registers a listener for the given topics.
func (b *MemoryBus) Subscribe(ctx context.Context, topics ...string) (<-chan []byte, error) {
	out := make(chan []byte, 1024)
	b.mu.Lock()
	for _, t := range topics {
		b.topics[t] = append(b.topics[t], out)
	}
	b.mu.Unlock()

	go func() {
		<-ctx.Done()
		// Unregister & close channel
		b.mu.Lock()
		for _, t := range topics {
			subs := b.topics[t]
			for i, c := range subs {
				if c == out {
					b.topics[t] = append(subs[:i], subs[i+1:]...)
					break
				}
			}
		}
		b.mu.Unlock()
		close(out)
	}()
	return out, nil
}
```