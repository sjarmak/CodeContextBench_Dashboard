```csharp
// File: src/module_18.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//
// PURPOSE
// -----------------------------------------------------------------------------
// Provides a pluggable, Strategy-pattern–driven validation engine for raw
// streaming events entering the Productivity Intelligence Fabric.  The engine
// leverages an Observer pattern to surface ValidationResults to downstream
// consumers (e.g., metrics, DLQ publishers, alerting Lambdas).
//
// NOTE
// -----------------------------------------------------------------------------
// ‑ Targets .NET 6 or later
// ‑ Assumes dependency injection (Microsoft.Extensions.*) is configured by the
//   host Lambda runner or ASP.NET Core container.
// ‑ No third-party packages required beyond Microsoft.Extensions.*
//
// -----------------------------------------------------------------------------
// © PulseOps 2024.  All rights reserved.
//

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Validation
{
    #region Domain – Event Typing & Results

    /// <summary>
    /// Canonical event type identifiers used across the warehouse.
    /// </summary>
    public enum EventType
    {
        Unknown             = 0,
        CalendarEvent       = 1,
        CodeRepositoryHook  = 2,
        CdpLog              = 3,
        EmailMetadata       = 4,
        SaasTelemetry       = 5
    }

    /// <summary>
    /// Outcome of a single validation pass for a streaming payload.
    /// </summary>
    /// <param name="IsValid">True if validation succeeded.</param>
    /// <param name="EventId">Correlation identifier found or generated.</param>
    /// <param name="EventType">Underlying domain event type.</param>
    /// <param name="Errors">Detailed error list (empty on success).</param>
    public sealed record ValidationResult(
        bool                       IsValid,
        string                     EventId,
        EventType                  EventType,
        IReadOnlyCollection<string> Errors);

    #endregion

    #region Strategy Pattern – Validation Interface & Registry

    /// <summary>
    /// Contract for an event validation implementation.
    /// </summary>
    public interface IValidationStrategy
    {
        /// <summary>
        /// The event type that the strategy validates.
        /// </summary>
        EventType SupportedEventType { get; }

        /// <summary>
        /// Performs validation on the provided payload.
        /// </summary>
        /// <param name="payload">Full JSON payload root element.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>Structured validation result.</returns>
        ValueTask<ValidationResult> ValidateAsync(
            JsonElement       payload,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Simple read-only registry for available validation strategies.
    /// </summary>
    public interface IValidationStrategyRegistry
    {
        /// <summary>
        /// Retrieves a validation strategy by <see cref="EventType"/>.
        /// </summary>
        /// <exception cref="KeyNotFoundException">
        /// Thrown when no strategy is registered for the requested type.
        /// </exception>
        IValidationStrategy Get(EventType eventType);
    }

    internal sealed class ValidationStrategyRegistry : IValidationStrategyRegistry
    {
        private readonly IReadOnlyDictionary<EventType, IValidationStrategy> _strategies;

        public ValidationStrategyRegistry(IEnumerable<IValidationStrategy> strategies)
        {
            _strategies = strategies.ToImmutableDictionary(s => s.SupportedEventType);
        }

        public IValidationStrategy Get(EventType eventType)
        {
            if (!_strategies.TryGetValue(eventType, out var strategy))
            {
                throw new KeyNotFoundException(
                    $"No validation strategy registered for event type '{eventType}'.");
            }

            return strategy;
        }
    }

    #endregion

    #region Observer Pattern – Validation Event Stream

    /// <summary>
    /// Hot observable stream that dispatches all validation results.
    /// Thread-safe and lightweight; designed for in-process pub-sub fan-out.
    /// </summary>
    internal sealed class ValidationEventStream : IObservable<ValidationResult>, IObserver<ValidationResult>
    {
        private readonly ConcurrentDictionary<IObserver<ValidationResult>, byte> _observers = new();

        public IDisposable Subscribe(IObserver<ValidationResult> observer)
        {
            _observers.TryAdd(observer, 0);
            return new Unsubscriber(_observers, observer);
        }

        public void OnCompleted()
        {
            foreach (var observer in _observers.Keys)
            {
                observer.OnCompleted();
            }
        }

        public void OnError(Exception error)
        {
            foreach (var observer in _observers.Keys)
            {
                observer.OnError(error);
            }
        }

        public void OnNext(ValidationResult value)
        {
            foreach (var observer in _observers.Keys)
            {
                observer.OnNext(value);
            }
        }

        private sealed class Unsubscriber : IDisposable
        {
            private readonly ConcurrentDictionary<IObserver<ValidationResult>, byte> _bag;
            private readonly IObserver<ValidationResult>                              _observer;

            public Unsubscriber(
                ConcurrentDictionary<IObserver<ValidationResult>, byte> bag,
                IObserver<ValidationResult> observer)
            {
                _bag      = bag;
                _observer = observer;
            }

            public void Dispose() => _bag.TryRemove(_observer, out _);
        }
    }

    #endregion

    #region Service – Event Validation Orchestrator

    /// <summary>
    /// Facade service that binds together JSON deserialization, strategy
    /// selection, error handling, and event dispatch into a single unit of work.
    /// </summary>
    public interface IEventValidator
    {
        /// <summary>
        /// Validates an incoming raw JSON payload string.
        /// </summary>
        /// <returns>Structured validation result.</returns>
        Task<ValidationResult> ValidateAsync(
            string           jsonPayload,
            CancellationToken cancellationToken = default);
    }

    internal sealed class EventValidator : IEventValidator
    {
        private readonly IValidationStrategyRegistry _registry;
        private readonly ValidationEventStream       _eventStream;
        private readonly ILogger<EventValidator>     _logger;

        public EventValidator(
            IValidationStrategyRegistry registry,
            ValidationEventStream       eventStream,
            ILogger<EventValidator>     logger)
        {
            _registry    = registry;
            _eventStream = eventStream;
            _logger      = logger;
        }

        public async Task<ValidationResult> ValidateAsync(
            string            jsonPayload,
            CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrWhiteSpace(jsonPayload))
            {
                throw new ArgumentException("Incoming payload cannot be null/empty.", nameof(jsonPayload));
            }

            JsonDocument doc;
            try
            {
                doc = JsonDocument.Parse(jsonPayload);
            }
            catch (JsonException jex)
            {
                // Malformed JSON – bail early.
                var malformedResult = new ValidationResult(
                    IsValid: false,
                    EventId: Guid.NewGuid().ToString("N"),
                    EventType.Unknown,
                    new[] { $"JSON parsing failure: {jex.Message}" });

                _logger.LogWarning(jex, "Malformed JSON payload encountered.");
                _eventStream.OnNext(malformedResult);

                return malformedResult;
            }

            // Detect event type from metadata block; fallback to Unknown.
            var eventType = ResolveEventType(doc.RootElement);

            ValidationResult result;
            try
            {
                var strategy = _registry.Get(eventType);
                result = await strategy.ValidateAsync(doc.RootElement, cancellationToken)
                                       .ConfigureAwait(false);
            }
            catch (Exception ex) when (!ex.IsFatal())
            {
                // Any strategy failure counts as invalid (but continue pipeline).
                result = new ValidationResult(
                    IsValid: false,
                    EventId: ExtractEventId(doc.RootElement) ?? Guid.NewGuid().ToString("N"),
                    EventType: eventType,
                    Errors: new[] { $"Validation engine error: {ex.Message}" });

                _logger.LogError(ex, "Validation strategy threw unhandled exception.");
            }

            _eventStream.OnNext(result);

            return result;
        }

        private static EventType ResolveEventType(in JsonElement root)
        {
            if (!root.TryGetProperty("eventType", out var typeProp))
            {
                return EventType.Unknown;
            }

            return typeProp.GetString() switch
            {
                "calendar"   => EventType.CalendarEvent,
                "code_hook"  => EventType.CodeRepositoryHook,
                "ci_cd_log"  => EventType.CdpLog,
                "email_meta" => EventType.EmailMetadata,
                "saas_tel"   => EventType.SaasTelemetry,
                _            => EventType.Unknown
            };
        }

        private static string? ExtractEventId(in JsonElement root)
            => root.TryGetProperty("eventId", out var idProp) ? idProp.GetString() : null;
    }

    internal static class ExceptionExtensions
    {
        /// <summary>
        /// Determines whether the exception represents a fatal CLR error where
        /// catch-and-continue would be inappropriate.
        /// </summary>
        public static bool IsFatal(this Exception ex)
            => ex is OutOfMemoryException
            || ex is StackOverflowException
            || ex is ThreadAbortException;
    }

    #endregion

    #region Strategy Implementations

    /// <summary>
    /// Validates calendar event payloads (Google Workspace, Outlook, etc.).
    /// </summary>
    internal sealed class CalendarEventValidationStrategy : IValidationStrategy
    {
        private readonly ILogger<CalendarEventValidationStrategy> _logger;

        public CalendarEventValidationStrategy(
            ILogger<CalendarEventValidationStrategy> logger) => _logger = logger;

        public EventType SupportedEventType => EventType.CalendarEvent;

        public ValueTask<ValidationResult> ValidateAsync(
            JsonElement payload,
            CancellationToken cancellationToken = default)
        {
            var errors  = new List<string>(capacity: 4);
            var eventId = payload.TryGetProperty("eventId", out var idProp)
                        ? idProp.GetString() ?? string.Empty
                        : string.Empty;

            // Required: startTime, endTime, organizer.email
            if (!payload.TryGetProperty("startTime", out _))
                errors.Add("Missing 'startTime'.");
            if (!payload.TryGetProperty("endTime", out _))
                errors.Add("Missing 'endTime'.");
            if (!payload.TryGetProperty("organizer", out var orgProp) ||
                !orgProp.TryGetProperty("email", out _))
                errors.Add("Missing 'organizer.email'.");

            var result = new ValidationResult(
                IsValid : errors.Count == 0,
                EventId : string.IsNullOrEmpty(eventId) ? Guid.NewGuid().ToString("N") : eventId,
                EventType.CalendarEvent,
                errors);

            if (!result.IsValid)
            {
                _logger.LogDebug(
                    "Calendar event validation failed {@Errors} for EventId={EventId}",
                    errors,
                    result.EventId);
            }

            return ValueTask.FromResult(result);
        }
    }

    /// <summary>
    /// Validates repository hook payloads (GitHub, GitLab, Bitbucket, etc.).
    /// </summary>
    internal sealed class CodeRepoValidationStrategy : IValidationStrategy
    {
        private readonly ILogger<CodeRepoValidationStrategy> _logger;

        public CodeRepoValidationStrategy(
            ILogger<CodeRepoValidationStrategy> logger) => _logger = logger;

        public EventType SupportedEventType => EventType.CodeRepositoryHook;

        public ValueTask<ValidationResult> ValidateAsync(
            JsonElement payload,
            CancellationToken cancellationToken = default)
        {
            var errors  = new List<string>(capacity: 3);
            var eventId = payload.TryGetProperty("deliveryId", out var idProp)
                        ? idProp.GetString() ?? string.Empty
                        : string.Empty;

            if (!payload.TryGetProperty("repository", out var repoProp) ||
                !repoProp.TryGetProperty("full_name", out _))
                errors.Add("Missing 'repository.full_name'.");

            if (!payload.TryGetProperty("pusher", out var pusherProp) ||
                !pusherProp.TryGetProperty("name", out _))
                errors.Add("Missing 'pusher.name'.");

            if (!payload.TryGetProperty("commits", out var commitsProp) ||
                commitsProp.ValueKind != JsonValueKind.Array ||
                commitsProp.GetArrayLength() == 0)
                errors.Add("Payload contains no commits.");

            var result = new ValidationResult(
                IsValid : errors.Count == 0,
                EventId : string.IsNullOrEmpty(eventId) ? Guid.NewGuid().ToString("N") : eventId,
                EventType.CodeRepositoryHook,
                errors);

            if (!result.IsValid)
            {
                _logger.LogInformation(
                    "Repository hook validation failed {ErrorCount} errors for EventId={EventId}",
                    errors.Count,
                    result.EventId);
            }

            return ValueTask.FromResult(result);
        }
    }

    #endregion
}
```