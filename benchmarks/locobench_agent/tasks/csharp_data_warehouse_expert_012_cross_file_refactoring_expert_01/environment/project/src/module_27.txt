```csharp
// -----------------------------------------------------------------------------
// File:    src/module_27.cs  (was src/module_27.txt)
// Project: PulseOps Warehouse ‚Äî Serverless Productivity Intelligence Fabric
// Author:  CopilotGPT
// -----------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    /// <summary>
    ///     Identifies a class as a Transformation Strategy for <see cref="TransformationEnvelope.EventType" />.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public sealed class TransformationStrategyAttribute : Attribute
    {
        public TransformationStrategyAttribute(string eventType)
        {
            if (string.IsNullOrWhiteSpace(eventType))
                throw new ArgumentException("Event type must be a non-empty string.", nameof(eventType));

            EventType = eventType.Trim();
        }

        public string EventType { get; }
    }

    /// <summary>
    ///     Runtime envelope passed through the ETL pipeline.  Pluggable transformation strategies
    ///     consume the strongly-typed <typeparamref name="TInput"/> and emit <typeparamref name="TOutput"/>.
    /// </summary>
    public record TransformationEnvelope(string EventType, string Payload);

    /// <summary>
    ///     Contract for all transformation strategies.
    ///     TInput  ‚Äì source dto (deserialized from <see cref="TransformationEnvelope.Payload"/>)
    ///     TOutput ‚Äì canonical warehouse entity persisted downstream.
    /// </summary>
    public interface ITransformationStrategy<in TInput, out TOutput>
    {
        /// <summary>
        ///     Performs business transformation.
        /// </summary>
        /// <exception cref="TransformationException">Threw when transformation failed.</exception>
        TOutput Transform(TInput input);
    }

    /// <summary>
    ///     Base exception for transformation‚Äìrelated errors.
    /// </summary>
    public sealed class TransformationException : Exception
    {
        public TransformationException(string message, Exception? inner = null) : base(message, inner) { }

        public string? CorrelationId { get; init; }
    }

    /// <summary>
    ///     Discovers and resolves applicable transformation strategies.
    ///     Keeps a process-wide in-memory cache for lightning-fast lookup.
    /// </summary>
    public sealed class TransformationStrategyRegistry
    {
        private readonly IReadOnlyDictionary<string, StrategyRegistration> _lookup;
        private readonly ILogger<TransformationStrategyRegistry> _logger;

        private static readonly Lazy<ConcurrentDictionary<Assembly, IReadOnlyDictionary<string, StrategyRegistration>>> Cache =
            new(() => new ConcurrentDictionary<Assembly, IReadOnlyDictionary<string, StrategyRegistration>>());

        private TransformationStrategyRegistry(IReadOnlyDictionary<string, StrategyRegistration> lookup,
                                                ILogger<TransformationStrategyRegistry> logger)
        {
            _lookup = lookup;
            _logger = logger;
        }

        public static TransformationStrategyRegistry FromAssemblies(IEnumerable<Assembly> assemblies,
                                                                    ILogger<TransformationStrategyRegistry> logger)
        {
            if (assemblies is null) throw new ArgumentNullException(nameof(assemblies));

            var registrations = new Dictionary<string, StrategyRegistration>(StringComparer.OrdinalIgnoreCase);

            foreach (var assembly in assemblies)
            {
                var cached = Cache.Value.GetOrAdd(assembly, asm => ScanAssembly(asm, logger));
                foreach (var kv in cached)
                    registrations[kv.Key] = kv.Value; // Last-one-wins (enables hot-swap)
            }

            return new TransformationStrategyRegistry(registrations, logger);
        }

        /// <summary>
        ///     Resolve strategy for given event type.
        /// </summary>
        /// <exception cref="KeyNotFoundException">If strategy not found.</exception>
        public StrategyRegistration Resolve(string eventType)
        {
            if (!_lookup.TryGetValue(eventType, out var registration))
            {
                _logger.LogWarning("No transformation strategy registered for event type '{EventType}'", eventType);
                throw new KeyNotFoundException($"No transformation strategy registered for event type '{eventType}'.");
            }

            return registration;
        }

        private static IReadOnlyDictionary<string, StrategyRegistration> ScanAssembly(Assembly assembly,
                                                                                      ILogger logger)
        {
            var candidates = assembly.GetTypes()
                                     .Where(t => t.IsClass && !t.IsAbstract)
                                     .Select(t => new
                                     {
                                         Type = t,
                                         Attrs = t.GetCustomAttributes<TransformationStrategyAttribute>()
                                     })
                                     .Where(x => x.Attrs.Any());

            var result = new Dictionary<string, StrategyRegistration>(StringComparer.OrdinalIgnoreCase);

            foreach (var candidate in candidates)
            {
                var interfaces = candidate.Type.GetInterfaces()
                                               .Where(i => i.IsGenericType &&
                                                           i.GetGenericTypeDefinition() ==
                                                           typeof(ITransformationStrategy<,>))
                                               .ToArray();

                if (interfaces.Length != 1)
                {
                    logger.LogWarning(
                        "Strategy {Strategy} must implement exactly one ITransformationStrategy<,> interface. Skipping.",
                        candidate.Type.FullName);
                    continue;
                }

                var iface = interfaces.Single();
                var inputType  = iface.GetGenericArguments()[0];
                var outputType = iface.GetGenericArguments()[1];

                var registration = new StrategyRegistration(candidate.Type, inputType, outputType);

                foreach (var attr in candidate.Attrs)
                    result[attr.EventType] = registration;
            }

            return result;
        }
    }

    /// <summary>
    ///     Immutable descriptor for a strategy implementation.
    /// </summary>
    public sealed record StrategyRegistration(Type ImplementationType,
                                              Type InputDtoType,
                                              Type OutputDtoType);

    /// <summary>
    ///     Orchestrates transformation execution w/ structured observability and failure handling.
    /// </summary>
    public sealed class TransformationExecutor
    {
        private readonly TransformationStrategyRegistry _registry;
        private readonly ILogger<TransformationExecutor> _logger;

        public TransformationExecutor(TransformationStrategyRegistry registry,
                                      ILogger<TransformationExecutor> logger)
        {
            _registry = registry;
            _logger = logger;
        }

        /// <summary>
        ///     Performs transformation end-to-end in an asynchronous, cancel-aware manner.
        /// </summary>
        public async Task<object?> ExecuteAsync(TransformationEnvelope envelope,
                                                IServiceProvider scopeProvider,
                                                CancellationToken cancellationToken = default)
        {
            if (envelope is null) throw new ArgumentNullException(nameof(envelope));
            cancellationToken.ThrowIfCancellationRequested();

            var correlationId = Guid.NewGuid().ToString("N");

            try
            {
                _logger.LogInformation("‚è≥ Starting transformation {CorrelationId}, EventType={EventType}",
                                        correlationId, envelope.EventType);

                var registration = _registry.Resolve(envelope.EventType);

                // Create scoped DI container so that strategy can request scoped resources
                using var scope = scopeProvider.CreateScope();
                var strategy = (ITransformationStrategy<object, object>)scope.ServiceProvider
                                                                             .GetRequiredService(registration.ImplementationType);

                // Deserialize
                var input = JsonSerializer.Deserialize(envelope.Payload, registration.InputDtoType)
                             ?? throw new TransformationException("Failed to deserialize input.")
                                { CorrelationId = correlationId };

                // Transform (execute on thread-pool to avoid blocking Lambda dispatcher)
                var result = await Task.Run(() => strategy.Transform(input), cancellationToken);

                _logger.LogInformation("‚úÖ Transformation succeeded {CorrelationId}. OutputType={OutputType}",
                                        correlationId, result.GetType().Name);

                return result;
            }
            catch (TransformationException)
            {
                throw; // bubble up known exceptions
            }
            catch (Exception ex)
            {
                // Wrap & decorate before rethrowing so that upper layer can decide DLQ vs retry
                var failure = new TransformationException("Unhandled error while transforming payload.", ex)
                {
                    CorrelationId = correlationId
                };

                _logger.LogError(ex,
                                 "üî• Transformation failed {CorrelationId}. Will be routed to DLQ.",
                                 correlationId);

                throw failure;
            }
        }
    }

    // -------------------------------------------------------------------------
    // Example Strategies
    // -------------------------------------------------------------------------

    #region Calendar Events

    public record CalendarEventDto(string MeetingId, DateTimeOffset Start, DateTimeOffset End, string[] Participants);

    public record CalendarMetricsEntity(string MeetingId,
                                        double DurationMinutes,
                                        int ParticipantCount,
                                        double EstimatedCostUsd);

    [TransformationStrategy("com.pulseops.calendar")]
    public sealed class CalendarEventTransformationStrategy
        : ITransformationStrategy<CalendarEventDto, CalendarMetricsEntity>
    {
        private readonly ILogger<CalendarEventTransformationStrategy> _logger;

        public CalendarEventTransformationStrategy(ILogger<CalendarEventTransformationStrategy> logger)
        {
            _logger = logger;
        }

        public CalendarMetricsEntity Transform(CalendarEventDto input)
        {
            if (input is null) throw new ArgumentNullException(nameof(input));

            var duration = (input.End - input.Start).TotalMinutes;
            if (duration <= 0)
                throw new TransformationException($"End must be after Start for Meeting {input.MeetingId}");

            var participantCount = input.Participants.Length;
            var costUsd = EstimateMeetingCost(participantCount, duration);

            _logger.LogDebug("Transformed Meeting {MeetingId} -> Duration={Duration} min, Cost={Cost}",
                             input.MeetingId, duration, costUsd);

            return new CalendarMetricsEntity(input.MeetingId, duration, participantCount, costUsd);
        }

        private static double EstimateMeetingCost(int participants, double minutes)
        {
            // Simple heuristic: average loaded rate $90/h
            const double ratePerMinuteUsd = 90.0 / 60.0;
            return Math.Round(participants * minutes * ratePerMinuteUsd, 2);
        }
    }

    #endregion

    #region CI/CD Logs

    public record CiCdExecutionDto(string PipelineId,
                                   string CommitSha,
                                   DateTimeOffset StartedAt,
                                   DateTimeOffset? CompletedAt,
                                   string Status);

    public record DeploymentLeadTimeEntity(string PipelineId,
                                           string CommitSha,
                                           double LeadTimeMinutes,
                                           string Status);

    [TransformationStrategy("com.pulseops.cicd")]
    public sealed class CiCdLogTransformationStrategy
        : ITransformationStrategy<CiCdExecutionDto, DeploymentLeadTimeEntity>
    {
        private readonly ILogger<CiCdLogTransformationStrategy> _logger;

        public CiCdLogTransformationStrategy(ILogger<CiCdLogTransformationStrategy> logger)
        {
            _logger = logger;
        }

        public DeploymentLeadTimeEntity Transform(CiCdExecutionDto input)
        {
            if (input is null) throw new ArgumentNullException(nameof(input));

            if (input.CompletedAt is null)
                throw new TransformationException($"Pipeline {input.PipelineId} is still running.");

            var lead = (input.CompletedAt.Value - input.StartedAt).TotalMinutes;
            lead = Math.Round(lead, 2);

            _logger.LogInformation("Pipeline {PipelineId}/{Sha} completed in {Lead} min. Status={Status}",
                                   input.PipelineId, input.CommitSha, lead, input.Status);

            return new DeploymentLeadTimeEntity(input.PipelineId,
                                                input.CommitSha,
                                                lead,
                                                input.Status);
        }
    }

    #endregion
}

// -----------------------------------------------------------------------------
// Extension methods & helpers
// -----------------------------------------------------------------------------
internal static class ServiceProviderExtensions
{
    public static IServiceScope CreateScope(this IServiceProvider provider) =>
        provider is IServiceScopeFactory factory
            ? factory.CreateScope()
            : throw new InvalidOperationException("IServiceProvider does not implement IServiceScopeFactory.");
}
```