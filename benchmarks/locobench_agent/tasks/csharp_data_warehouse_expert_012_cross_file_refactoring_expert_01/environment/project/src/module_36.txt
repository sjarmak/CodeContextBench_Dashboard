```csharp
// File: src/module_36.cs
// Project: PulseOps Warehouse â€” Serverless Productivity Intelligence Fabric
//
// Description:
//     Transformation strategy infrastructure + concrete Focus-Time ratio implementation.
//     Demonstrates Strategy-Pattern, parallel processing, structured logging, and
//     resiliency best-practices.  This file is shared by multiple Lambda functions
//     that need a plug-and-play metric computation engine.
//
// ReSharper disable PossibleMultipleEnumeration

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region Contracts

    /// <summary>
    ///     Generic contract for a transformation strategy.
    /// </summary>
    /// <typeparam name="TIn">Up-stream raw event payload.</typeparam>
    /// <typeparam name="TOut">Down-stream analytical entity.</typeparam>
    public interface ITransformationStrategy<in TIn, TOut>
    {
        /// <summary>Unique, human-readable identifier.</summary>
        string Name { get; }

        /// <summary>Transforms a set of <typeparamref name="TIn" /> into <typeparamref name="TOut" />.</summary>
        /// <param name="input">Events partition belonging to the same routing key.</param>
        /// <param name="cancellationToken">Co-operative cancellation token.</param>
        Task<TOut> TransformAsync(IEnumerable<TIn> input, CancellationToken cancellationToken = default);
    }

    #endregion

    #region Registry

    /// <summary>
    ///     Thread-safe registry that supports dynamic discovery and hot-swapping of
    ///     transformation strategies at runtime.  The registry name is case-insensitive
    ///     to avoid subtle deployment mistakes when multiple teams contribute.
    /// </summary>
    public static class TransformationStrategyRegistry
    {
        private static readonly ConcurrentDictionary<string, object> _registry =
            new(StringComparer.OrdinalIgnoreCase);

        /// <summary>Registers or overrides a strategy instance.</summary>
        public static void Register<TIn, TOut>(ITransformationStrategy<TIn, TOut> strategy)
        {
            if (strategy == null) throw new ArgumentNullException(nameof(strategy));
            _registry[strategy.Name] = strategy;
        }

        /// <summary>Fetches a strategy by name, throwing if not found.</summary>
        public static ITransformationStrategy<TIn, TOut> Resolve<TIn, TOut>(string name)
        {
            if (!_registry.TryGetValue(name, out var boxed))
                throw new KeyNotFoundException($"Transformation '{name}' not registered.");

            if (boxed is ITransformationStrategy<TIn, TOut> typed) return typed;

            throw new InvalidCastException(
                $"Strategy '{name}' is registered for a different payload shape.");
        }

        /// <summary>Returns all registered strategy identifiers.</summary>
        public static IReadOnlyCollection<string> List()
            => _registry.Keys.ToArray();
    }

    #endregion

    #region Domain Models

    /// <summary>
    ///     Minimal calendar event projection required for focus-time computation.
    /// </summary>
    public sealed record CalendarEvent(
        string UserPrincipalName,
        DateTimeOffset Start,
        DateTimeOffset End,
        string? Classification // e.g. "Focus", "Meeting", "Personal", etc.
    )
    {
        public TimeSpan Duration => End - Start;
    }

    /// <summary>Analytical metric entity materialized by <see cref="FocusTimeRatioStrategy" />.</summary>
    public sealed record FocusTimeRatioKpi(
        string UserPrincipalName,
        DateOnly Day,
        double FocusMinutes,
        double TotalMinutes,
        double FocusRatio
    );

    #endregion

    #region Strategy Implementation

    /// <summary>
    ///     Calculates focus-time ratio per user per day:
    ///         FocusRatio = FocusMinutes / TotalMinutes
    ///     where FocusMinutes are calendar events classified as "Focus" or "Deep-Work".
    /// </summary>
    public sealed class FocusTimeRatioStrategy : ITransformationStrategy<CalendarEvent, IReadOnlyCollection<FocusTimeRatioKpi>>
    {
        public const string StrategyId = "focus-time-ratio@v1";
        private const string DefaultFocusLabel = "Focus";
        private static readonly string[] EquivalentFocusLabels = { "Deep-Work", "Heads-Down" };

        public string Name => StrategyId;

        /// <inheritdoc />
        public async Task<IReadOnlyCollection<FocusTimeRatioKpi>> TransformAsync(
            IEnumerable<CalendarEvent> input,
            CancellationToken cancellationToken = default)
        {
            if (input == null) throw new ArgumentNullException(nameof(input));

            // Materialize the enumerable only once.
            var events = input as CalendarEvent[] ?? input.ToArray();

            return await Task.Run(() =>
            {
                var kpis = events
                    .Where(evt => evt.Start.Date == evt.End.Date) // Skip multi-day events for simplicity
                    .GroupBy(evt => new { evt.UserPrincipalName, Day = DateOnly.FromDateTime(evt.Start.Date) })
                    .Select(group =>
                    {
                        double totalMinutes = group.Sum(evt => evt.Duration.TotalMinutes);
                        double focusMinutes = group
                            .Where(IsFocusEvent)
                            .Sum(evt => evt.Duration.TotalMinutes);

                        var ratio = totalMinutes > 0
                            ? Math.Round(focusMinutes / totalMinutes, 4)
                            : 0;

                        return new FocusTimeRatioKpi(
                            group.Key.UserPrincipalName,
                            group.Key.Day,
                            focusMinutes,
                            totalMinutes,
                            ratio);
                    })
                    .ToArray();

                return (IReadOnlyCollection<FocusTimeRatioKpi>)kpis;
            }, cancellationToken).ConfigureAwait(false);
        }

        private static bool IsFocusEvent(CalendarEvent evt)
        {
            if (evt.Classification == null) return false;

            return StringComparer.OrdinalIgnoreCase.Equals(evt.Classification, DefaultFocusLabel) ||
                   EquivalentFocusLabels.Any(
                       l => StringComparer.OrdinalIgnoreCase.Equals(l, evt.Classification));
        }
    }

    #endregion

    #region Execution Harness

    /// <summary>
    ///     Provides utility methods to execute a strategy in parallel partitions.
    ///     Lambda handlers leverage this type to maintain high throughput in large
    ///     warehouse back-fills.
    /// </summary>
    public static class StrategyExecutor
    {
        /// <summary>
        ///     Splits the input into partitions and runs the transformation concurrently.
        /// </summary>
        /// <param name="strategy">Concrete strategy instance.</param>
        /// <param name="input">Full event batch (cross-partition).</param>
        /// <param name="partitionKeySelector">
        ///     Deterministic key selector that yields the same value for events that must be
        ///     transformed together (e.g. <c>UserPrincipalName</c>).
        /// </param>
        /// <param name="degreeOfParallelism">Maximum concurrency.  Defaults to logical processors.</param>
        /// <param name="logger">Structured logger (optional).</param>
        /// <typeparam name="TIn">Raw event type.</typeparam>
        /// <typeparam name="TOut">Analytical entity type.</typeparam>
        /// <returns>Flattened collection of transformed outputs.</returns>
        public static async Task<IReadOnlyCollection<TOut>> ExecutePartitionedAsync<TIn, TOut>(
            ITransformationStrategy<TIn, IReadOnlyCollection<TOut>> strategy,
            IEnumerable<TIn> input,
            Func<TIn, string> partitionKeySelector,
            int? degreeOfParallelism = null,
            ILogger? logger = null)
        {
            if (strategy == null) throw new ArgumentNullException(nameof(strategy));
            if (input == null) throw new ArgumentNullException(nameof(input));
            if (partitionKeySelector == null) throw new ArgumentNullException(nameof(partitionKeySelector));

            var sw = Stopwatch.StartNew();
            logger?.LogInformation("Executing strategy {Strategy}...", strategy.Name);

            var partitions = input
                .GroupBy(partitionKeySelector, StringComparer.OrdinalIgnoreCase)
                .ToArray();

            var resultsBag = new ConcurrentBag<TOut>();

            // Limit concurrency to avoid Lambda over-subscription.
            var parallelOptions = new ParallelOptions
            {
                MaxDegreeOfParallelism = degreeOfParallelism ?? Environment.ProcessorCount
            };

            try
            {
                await Parallel.ForEachAsync(partitions, parallelOptions, async (partition, ct) =>
                {
                    var partitionId = partition.Key;
                    try
                    {
                        logger?.LogDebug("Transforming partition {PartitionId} ({Count} events)...",
                            partitionId, partition.Count());

                        var outputs = await strategy.TransformAsync(partition, ct).ConfigureAwait(false);

                        foreach (var output in outputs) resultsBag.Add(output);

                        logger?.LogTrace("Partition {PartitionId} done.", partitionId);
                    }
                    catch (Exception ex)
                    {
                        logger?.LogError(ex,
                            "Strategy {Strategy} failed for partition {PartitionId}.  Delegating to DLQ.",
                            strategy.Name, partitionId);

                        // In production we would push the failing partition to an SQS-DLQ / Kinesis-DLQ.
                        // For this shared lib we simply re-throw.
                        throw;
                    }
                });
            }
            finally
            {
                logger?.LogInformation(
                    "Strategy {Strategy} completed in {ElapsedMs} ms.  {OutputCount} rows produced.",
                    strategy.Name, sw.ElapsedMilliseconds, resultsBag.Count);
            }

            return resultsBag.ToArray();
        }
    }

    #endregion

    #region Serialization Helpers

    /// <summary>
    ///     Centralizes JSON (de)serialization settings to guarantee schema stability
    ///     across micro-components and avoid date/time pitfalls.
    /// </summary>
    public static class Json
    {
        private static readonly JsonSerializerOptions _opts = new()
        {
            PropertyNameCaseInsensitive = false,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = false,
            Converters =
            {
                new System.Text.Json.Serialization.JsonStringEnumConverter(JsonNamingPolicy.CamelCase)
            }
        };

        public static string Serialize<T>(T payload) =>
            JsonSerializer.Serialize(payload, _opts);

        public static T Deserialize<T>(string json) =>
            JsonSerializer.Deserialize<T>(json, _opts) ??
            throw new InvalidOperationException($"Cannot deserialize json into {typeof(T).Name}.");
    }

    #endregion

    #region Module Initialization

    /// <summary>
    ///     Static initializer registers built-in strategies once per cold-start.
    ///     Additional strategies can be registered by other assemblies at runtime.
    /// </summary>
    internal static class ModuleInitializer
    {
        // ReSharper disable once UnusedMember.Global
        public static void Initialize()
        {
            TransformationStrategyRegistry.Register(new FocusTimeRatioStrategy());
        }

        // C# 11 module initializer attribute keeps reflection-free startup.
        [System.Runtime.CompilerServices.ModuleInitializer]
        // ReSharper disable once UnusedMember.Local
        private static void Init() => Initialize();
    }

    #endregion
}
```