```csharp
// File: src/module_15.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//
// This file implements the `MeetingCostIndexStrategy`, a pluggable transformation
// that calculates the Meeting-Cost-Index (MCI) from raw calendar events.
// The strategy is compatible with the Strategy_Pattern used throughout the
// PulseOps Warehouse transformation layer.
//
// Author: PulseOps Engineering
// Copyright © 2024

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.MeetingCost
{
    #region Public Contracts

    /// <summary>
    /// A minimal contract for any transformation strategy in the PulseOps fabric.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>Friendly name for downstream observability.</summary>
        string Name { get; }

        /// <summary>
        /// Executes the transformation asynchronously.
        /// </summary>
        /// <param name="context">The incoming, un-modelled data plus auxiliary metadata.</param>
        /// <param name="token">Cancellation token propagated from upstream orchestration.</param>
        /// <returns>Transformation result that can be further processed or persisted.</returns>
        Task<TransformationResult> TransformAsync(TransformationContext context, CancellationToken token = default);
    }

    /// <summary>
    /// A DTO wrapper around arbitrary transformation output.
    /// </summary>
    public sealed record TransformationResult(string StrategyName, IReadOnlyCollection<object> Records);

    /// <summary>
    /// A lightweight context bag passed to all transformation strategies.
    /// </summary>
    public sealed record TransformationContext(IDictionary<string, object> Items);

    /// <summary>
    /// Contract for fetching an hourly cost for a given employee role/department.
    /// Implementations may pull from DynamoDB, SSM, or an in-memory cache.
    /// </summary>
    public interface ISalaryBandProvider
    {
        decimal GetHourlyRate(string role, string department);
    }

    #endregion

    #region Domain Model

    /// <summary>
    /// A single calendar entry as captured by the ingestion Lambda.
    /// </summary>
    public sealed record CalendarEvent(
        string           Id,
        DateTime         StartUtc,
        DateTime         EndUtc,
        IReadOnlyList<Participant> Participants);

    /// <summary>
    /// A person (internal or external) participating in a calendar event.
    /// </summary>
    public sealed record Participant(string Email, string Role, string Department);

    /// <summary>
    /// Output schema: one row per day with rolled-up meeting cost metadata.
    /// </summary>
    public sealed record MeetingCostIndexRow(
        DateTime  Date,
        int       MeetingCount,
        decimal   TotalCost,
        decimal   AverageCostPerMeeting)
    {
        public string FiscalWeek => ISOWeek.GetWeekOfYear(Date).ToString(CultureInfo.InvariantCulture);
    }

    #endregion

    /// <summary>
    /// Calculates Meeting-Cost-Index (MCI) by summing the pro-rated hourly cost of
    /// each participant for every meeting within the transformation batch.
    /// </summary>
    public sealed class MeetingCostIndexStrategy : ITransformationStrategy
    {
        private const int SecondsPerHour = 3600;
        private readonly ILogger<MeetingCostIndexStrategy> _logger;
        private readonly ISalaryBandProvider               _salaryBands;

        public string Name => nameof(MeetingCostIndexStrategy);

        public MeetingCostIndexStrategy(
            ILogger<MeetingCostIndexStrategy> logger,
            ISalaryBandProvider salaryBands)
        {
            _logger      = logger  ?? throw new ArgumentNullException(nameof(logger));
            _salaryBands = salaryBands ?? throw new ArgumentNullException(nameof(salaryBands));
        }

        /// <inheritdoc />
        public async Task<TransformationResult> TransformAsync(
            TransformationContext context,
            CancellationToken token = default)
        {
            if (context is null) throw new ArgumentNullException(nameof(context));

            if (!context.Items.TryGetValue("CALENDAR_EVENTS", out var rawEvents) ||
                rawEvents is not IReadOnlyCollection<CalendarEvent> events)
            {
                throw new ArgumentException(
                    "TransformationContext missing key 'CALENDAR_EVENTS' with required payload.",
                    nameof(context));
            }

            _logger.LogInformation(
                "[{Strategy}] Starting Meeting-Cost-Index calculation for {Count} events.",
                Name,
                events.Count);

            var dailyCostBuckets = new ConcurrentDictionary<DateTime, (decimal cost, int meetingCount)>();

            await Parallel.ForEachAsync(
                events,
                new ParallelOptions { CancellationToken = token, MaxDegreeOfParallelism = Environment.ProcessorCount },
                async (calendarEvent, ct) =>
                {
                    try
                    {
                        ct.ThrowIfCancellationRequested();

                        var durationHours = (decimal)(calendarEvent.EndUtc - calendarEvent.StartUtc).TotalSeconds
                                            / SecondsPerHour;

                        if (durationHours <= 0)
                        {
                            _logger.LogWarning(
                                "[{Strategy}] Event {EventId} has non-positive duration. Skipping.",
                                Name,
                                calendarEvent.Id);
                            return;
                        }

                        decimal meetingCost = 0;

                        foreach (var p in calendarEvent.Participants)
                        {
                            var hourlyRate = _salaryBands.GetHourlyRate(p.Role, p.Department);
                            meetingCost += hourlyRate * durationHours;
                        }

                        var meetingDate = calendarEvent.StartUtc.Date; // roll-up by UTC day

                        dailyCostBuckets.AddOrUpdate(
                            meetingDate,
                            _ => (meetingCost, 1),
                            (_, tuple) =>
                            {
                                tuple.cost        += meetingCost;
                                tuple.meetingCount = checked(tuple.meetingCount + 1);
                                return tuple;
                            });
                    }
                    catch (Exception ex) when (!ex.IsCritical())
                    {
                        // Non-fatal: continue processing remaining events
                        _logger.LogError(
                            ex,
                            "[{Strategy}] Error while processing event {EventId}. Continuing with next.",
                            Name,
                            calendarEvent.Id);
                    }

                    // Simulate async workload for demonstration; in real world call downstream services here.
                    await Task.Yield();
                });

            var results = dailyCostBuckets
                .Select(kvp =>
                {
                    var (cost, meetingCount) = kvp.Value;
                    return new MeetingCostIndexRow(
                        kvp.Key,
                        meetingCount,
                        Math.Round(cost,  2, MidpointRounding.AwayFromZero),
                        Math.Round(cost / meetingCount, 2, MidpointRounding.AwayFromZero));
                })
                .OrderBy(r => r.Date)
                .Cast<object>() // Keep output untyped for engine polymorphism
                .ToArray();

            _logger.LogInformation(
                "[{Strategy}] Meeting-Cost-Index calculation complete. Generated {RowCount} rows.",
                Name,
                results.Length);

            return new TransformationResult(Name, results);
        }
    }

    #region Helper Extensions

    internal static class ExceptionExtensions
    {
        /// <summary>
        /// Determines if an exception is critical and should fail the Lambda entirely.
        /// </summary>
        public static bool IsCritical(this Exception ex) =>
            ex is OutOfMemoryException or
                 StackOverflowException or
                 ThreadAbortException;
    }

    #endregion
}
```