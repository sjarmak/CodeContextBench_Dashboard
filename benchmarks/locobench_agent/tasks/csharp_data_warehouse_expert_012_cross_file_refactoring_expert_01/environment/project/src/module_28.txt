```csharp
// -----------------------------------------------------------------------------
//  PulseOps Warehouse â€” Serverless Productivity Intelligence Fabric
//  ---------------------------------------------------------------------------
//  File:        module_28.txt (Transformation Orchestrator & Strategy Registry)
//  Project:     PulseOps Warehouse (data_warehouse)
//  Language:    C# 10
//  Description: Implements a pluggable, runtime-discoverable transformation
//               framework that applies Strategy, Observer, and Parallel
//               Processing patterns to convert raw event streams into KPIs.
//
//  Note:        In production this file would live at 
//               src/Transformations/TransformationOrchestrator.cs
// -----------------------------------------------------------------------------

#nullable enable
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region Models

    /// <summary>
    /// Represents a raw, denormalized event emitted by upstream ingestion Lambdas.
    /// The Payload is schema-less JSON; domain strategies are responsible for
    /// parsing only the fields they need.
    /// </summary>
    public sealed record RawEvent
    {
        [JsonPropertyName("event_type")]
        public required string EventType { get; init; }

        [JsonPropertyName("occurred_at")]
        public required DateTimeOffset OccurredAt { get; init; }

        [JsonPropertyName("payload")]
        public required JsonElement Payload { get; init; }
    }

    /// <summary>
    /// Represents a normalized business metric ready for downstream consumers.
    /// </summary>
    public sealed record Metric
    {
        public required string MetricName { get; init; }
        public required string Granularity { get; init; } // e.g. "Daily"
        public required DateTime Date { get; init; }
        public required double Value { get; init; }
        public required IDictionary<string, string> Dimensions { get; init; }
    }

    #endregion

    #region Strategy Infrastructure

    /// <summary>
    /// Marker attribute used for auto-registration of transformation strategies.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited = false)]
    public sealed class TransformationStrategyAttribute : Attribute
    {
        public string Name { get; }

        public TransformationStrategyAttribute(string name) => Name = name;
    }

    /// <summary>
    /// The contract every transformation strategy must fulfill.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>The unique strategy name.</summary>
        string Name { get; }

        /// <summary>
        /// Execute the transformation asynchronously on a batch of events.
        /// </summary>
        /// <param name="events">Collection of raw events for the batch window.</param>
        /// <param name="logger">Structured logger.</param>
        /// <param name="token">Cancellation token.</param>
        /// <returns>Zero or more derived metrics.</returns>
        Task<IEnumerable<Metric>> TransformAsync(
            IReadOnlyCollection<RawEvent> events,
            ILogger logger,
            CancellationToken token = default);
    }

    /// <summary>
    /// Registry that lazily discovers and instantiates strategies by reflection.
    /// </summary>
    public sealed class TransformationStrategyRegistry
    {
        private readonly ConcurrentDictionary<string, Lazy<ITransformationStrategy>> _strategies = new();

        public TransformationStrategyRegistry(ILogger logger)
        {
            // Scan all loaded assemblies only once.
            var strategies = Assembly.GetExecutingAssembly()
                                     .GetTypes()
                                     .Where(t => t is { IsAbstract: false, IsInterface: false } &&
                                                 typeof(ITransformationStrategy).IsAssignableFrom(t) &&
                                                 t.GetCustomAttribute<TransformationStrategyAttribute>() is not null);

            foreach (var type in strategies)
            {
                var attr = type.GetCustomAttribute<TransformationStrategyAttribute>()!;
                logger.LogDebug("Registering transformation strategy: {StrategyName} ({Type})",
                                attr.Name, type.FullName);

                _strategies[attr.Name] = new Lazy<ITransformationStrategy>(() =>
                {
                    try
                    {
                        return (ITransformationStrategy)Activator.CreateInstance(type)!;
                    }
                    catch (Exception ex)
                    {
                        logger.LogError(ex, "Unable to instantiate strategy {Strategy}", type.FullName);
                        throw;
                    }
                }, LazyThreadSafetyMode.ExecutionAndPublication);
            }
        }

        /// <summary>Retrieve a strategy instance by its name.</summary>
        public ITransformationStrategy Resolve(string name, ILogger logger)
        {
            if (!_strategies.TryGetValue(name, out var factory))
            {
                throw new KeyNotFoundException($"Transformation strategy '{name}' is not registered.");
            }

            var strategy = factory.Value; // Lazy instantiation
            logger.LogDebug("Strategy {StrategyName} resolved to type {Type}", name, strategy.GetType().FullName);
            return strategy;
        }

        /// <summary>Used by orchestrator to fan-out across all strategies.</summary>
        public IReadOnlyCollection<ITransformationStrategy> AllStrategies =>
            _strategies.Values.Select(lazy => lazy.Value).ToArray();
    }

    #endregion

    #region Sample Strategies

    [TransformationStrategy("focus_time")]
    internal sealed class FocusTimeStrategy : ITransformationStrategy
    {
        public string Name => "focus_time";

        private const string MeetingEventType = "calendar.meeting";

        public Task<IEnumerable<Metric>> TransformAsync(
            IReadOnlyCollection<RawEvent> events,
            ILogger logger,
            CancellationToken token = default)
        {
            // Calculate daily focus time: workingHours - meetingDuration
            var groups = events.Where(e => e.EventType == MeetingEventType)
                               .GroupBy(e => e.OccurredAt.Date);

            var metrics = new List<Metric>();

            foreach (var g in groups)
            {
                if (token.IsCancellationRequested) break;

                var totalMeetingMinutes = g.Sum(ev =>
                {
                    var start = ev.Payload.GetProperty("start").GetDateTimeOffset();
                    var end = ev.Payload.GetProperty("end").GetDateTimeOffset();
                    return (end - start).TotalMinutes;
                });

                const double workingDayMinutes = 8d * 60d;
                var focusRatio = (workingDayMinutes - totalMeetingMinutes) / workingDayMinutes;

                logger.LogInformation("Computed focus ratio for {Date}: {Ratio:P2}", g.Key, focusRatio);

                metrics.Add(new Metric
                {
                    MetricName = "focus_time_ratio",
                    Granularity = "Daily",
                    Date = g.Key,
                    Value = Math.Round(focusRatio, 4),
                    Dimensions = new Dictionary<string, string>()
                });
            }

            return Task.FromResult<IEnumerable<Metric>>(metrics);
        }
    }

    [TransformationStrategy("deployment_lead_time")]
    internal sealed class DeploymentLeadTimeStrategy : ITransformationStrategy
    {
        public string Name => "deployment_lead_time";

        public Task<IEnumerable<Metric>> TransformAsync(
            IReadOnlyCollection<RawEvent> events,
            ILogger logger,
            CancellationToken token = default)
        {
            const string Commit = "gitlab.commit_pushed";
            const string Deploy = "codepipeline.deployment_succeeded";

            var commits = events.Where(e => e.EventType == Commit)
                                .ToDictionary(
                                    e => e.Payload.GetProperty("commit_id").GetString()!,
                                    e => e.OccurredAt);

            var metrics = new List<Metric>();

            foreach (var deployEvent in events.Where(e => e.EventType == Deploy))
            {
                if (token.IsCancellationRequested) break;

                var commitId = deployEvent.Payload.GetProperty("commit_id").GetString();
                if (commitId is null || !commits.TryGetValue(commitId, out var commitTime))
                {
                    logger.LogWarning("Deployment event {EventId} referenced unknown commit {CommitId}",
                                      deployEvent.Payload.GetProperty("event_id").GetString(), commitId);
                    continue;
                }

                var leadTimeHours = (deployEvent.OccurredAt - commitTime).TotalHours;

                metrics.Add(new Metric
                {
                    MetricName = "deployment_lead_time_hours",
                    Granularity = "Event",
                    Date = deployEvent.OccurredAt.Date,
                    Value = Math.Round(leadTimeHours, 2),
                    Dimensions = new Dictionary<string, string>
                    {
                        ["commit_id"] = commitId,
                        ["pipeline"] = deployEvent.Payload.GetProperty("pipeline").GetString() ?? "unknown"
                    }
                });

                logger.LogInformation("Computed lead time for commit {CommitId}: {Hours}h", commitId, leadTimeHours);
            }

            return Task.FromResult<IEnumerable<Metric>>(metrics);
        }
    }

    #endregion

    #region Orchestrator

    /// <summary>
    /// Entry-point orchestrator used by the Lambda runtime or batch job to process
    /// a chunk of events and emit derived metrics in parallel across strategies.
    /// </summary>
    public sealed class TransformationOrchestrator
    {
        private readonly TransformationStrategyRegistry _registry;
        private readonly ILogger _logger;

        public TransformationOrchestrator(TransformationStrategyRegistry registry, ILogger logger)
        {
            _registry = registry;
            _logger = logger;
        }

        /// <summary>
        /// Runs all registered transformation strategies against a batch of events
        /// using parallel fan-out to maximize throughput.
        /// </summary>
        /// <returns>Flattened collection of all metrics produced.</returns>
        public async Task<IReadOnlyCollection<Metric>> ExecuteAsync(
            IReadOnlyCollection<RawEvent> events,
            CancellationToken token = default)
        {
            _logger.LogInformation("Executing transformation orchestrator for batch size {Count}", events.Count);

            var metricsBag = new ConcurrentBag<Metric>();

            var tasks = _registry.AllStrategies.Select(async strategy =>
            {
                try
                {
                    _logger.LogDebug("Starting strategy {Strategy}", strategy.Name);
                    var produced = await strategy.TransformAsync(events, _logger, token);
                    foreach (var m in produced)
                        metricsBag.Add(m);
                    _logger.LogDebug("Strategy {Strategy} produced {Count} metrics", strategy.Name, produced.Count());
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Strategy {Strategy} failed", strategy.Name);
                    // Allow other strategies to continue processing; error is logged.
                }
            });

            await Task.WhenAll(tasks);

            _logger.LogInformation("Orchestrator produced total {Count} metrics", metricsBag.Count);
            return metricsBag.ToArray();
        }
    }

    #endregion
}
```