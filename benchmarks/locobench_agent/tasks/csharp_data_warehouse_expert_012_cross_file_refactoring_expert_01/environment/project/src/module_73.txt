```csharp
// File: src/module_73.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//
// Description:
//   This module implements a concrete data–transformation strategy that converts
//   raw “time-entry” domain events (e.g., calendar focus-time slices, meeting
//   blocks, pomodoro sessions, etc.) into per-user, per-day productivity metrics.
//   It follows the Strategy-Pattern so that it can be hot-swapped at runtime via
//   DI without redeploying the Lambda micro-component that hosts it.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.Strategies
{
    #region Public Contracts ────────────────────────────────────────────────────

    /// <summary>
    /// Marker interface for all PulseOps data-transformation strategies.
    /// </summary>
    /// <typeparam name="TIn">Inbound raw event type.</typeparam>
    /// <typeparam name="TOut">Outbound KPI or metric type.</typeparam>
    public interface IDataTransformationStrategy<in TIn, TOut>
    {
        /// <summary>
        /// A human-readable name that will show up in logs and observability
        /// tooling so that operators understand which strategy was executed.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Transforms a batch of <typeparamref name="TIn" /> events into a
        /// collection of <typeparamref name="TOut" /> metrics.
        /// </summary>
        /// <param name="events">Raw inbound events.</param>
        /// <param name="cancellationToken">Operation cancellation token.</param>
        /// <returns>A collection of metrics.</returns>
        Task<IReadOnlyCollection<TOut>> TransformAsync(
            IEnumerable<TIn>      events,
            CancellationToken     cancellationToken = default);
    }

    /// <summary>
    /// Raw time-entry event generated by various ingestion pipelines
    /// (Calendar, VS Code Focus Mode, Slack Status, etc.).
    /// </summary>
    /// <param name="UserId">Unique user identifier (tenant-scoped).</param>
    /// <param name="StartUtc">Start timestamp (UTC).</param>
    /// <param name="EndUtc">End timestamp (UTC).</param>
    /// <param name="EntryType">Categorization for the timeslice.</param>
    public sealed record TimeEntryEvent(
        string         UserId,
        DateTimeOffset StartUtc,
        DateTimeOffset EndUtc,
        TimeEntryType  EntryType);

    /// <summary>
    /// Semantic categories for a <see cref="TimeEntryEvent" />.
    /// </summary>
    public enum TimeEntryType
    {
        Focus   = 0,
        Meeting = 1,
        Break   = 2,
        Unknown = 3
    }

    /// <summary>
    /// Resulting productivity KPI emitted by
    /// <see cref="FocusTimeRatioTransformationStrategy" />.
    /// </summary>
    /// <param name="UserId">User identifier (tenant-scoped).</param>
    /// <param name="Date">Calendar date (local).</param>
    /// <param name="TotalFocusMinutes">Aggregated minutes users spent focusing.</param>
    /// <param name="TotalMeetingMinutes">Aggregated minutes users spent in meetings.</param>
    /// <param name="FocusRatio">
    ///     <c>TotalFocusMinutes / (TotalFocusMinutes + TotalMeetingMinutes)</c>;
    ///     0 ≤ x ≤ 1; NaN when denominator is 0.
    /// </param>
    public sealed record ProductivityMetric(
        string UserId,
        DateOnly Date,
        double TotalFocusMinutes,
        double TotalMeetingMinutes,
        double FocusRatio);

    #endregion

    #region Strategy Implementation ─────────────────────────────────────────────

    /// <summary>
    /// Calculates the daily <c>Focus : Meeting</c> ratio for each user.
    /// </summary>
    /// <remarks>
    /// The strategy is thread-safe and can be reused across Lambda invocations.
    /// </remarks>
    public sealed class FocusTimeRatioTransformationStrategy :
        IDataTransformationStrategy<TimeEntryEvent, ProductivityMetric>
    {
        private readonly ILogger<FocusTimeRatioTransformationStrategy> _logger;

        public FocusTimeRatioTransformationStrategy(
            ILogger<FocusTimeRatioTransformationStrategy> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public string Name => nameof(FocusTimeRatioTransformationStrategy);

        public async Task<IReadOnlyCollection<ProductivityMetric>> TransformAsync(
            IEnumerable<TimeEntryEvent> events,
            CancellationToken           cancellationToken = default)
        {
            if (events is null)
                throw new ArgumentNullException(nameof(events));

            // Materialize to avoid multiple enumerations and to keep snapshot isolated.
            var eventList = events.ToList();

            _logger.LogInformation("Starting transformation strategy {Strategy}. Count={Count}",
                Name, eventList.Count);

            // Concurrent dictionary for thread-safe aggregation when parallelizing.
            var aggregates = new ConcurrentDictionary<(string UserId, DateOnly Date),
                                                      (double FocusMinutes, double MeetingMinutes)>();

            // Parallelize to speed up large batches received via Kinesis fan-out.
            await Task.Run(() =>
            {
                Parallel.ForEach(eventList, new ParallelOptions
                {
                    CancellationToken   = cancellationToken,
                    // Heuristic to avoid thread oversubscription inside Lambda sandbox
                    MaxDegreeOfParallelism = Environment.ProcessorCount
                },
                timeEntry =>
                {
                    try
                    {
                        ValidateOrThrow(timeEntry);

                        var key  = (timeEntry.UserId,
                                    ToUserLocaleDate(timeEntry.StartUtc, timeEntry.UserId));

                        var durationMinutes = (timeEntry.EndUtc - timeEntry.StartUtc)
                                              .TotalMinutes;

                        // Guard against ultra-long or negative slices.
                        if (durationMinutes is <= 0 or > 12 * 60)
                        {
                            _logger.LogWarning(
                                "Ignoring suspicious time entry {@Event}. Duration={Duration} minutes",
                                timeEntry, durationMinutes);
                            return;
                        }

                        aggregates.AddOrUpdate(
                            key,
                            _ => timeEntry.EntryType switch
                            {
                                TimeEntryType.Focus   => (durationMinutes, 0d),
                                TimeEntryType.Meeting => (0d, durationMinutes),
                                _                     => default
                            },
                            (_, current) =>
                            {
                                return timeEntry.EntryType switch
                                {
                                    TimeEntryType.Focus   => (current.FocusMinutes + durationMinutes,
                                                               current.MeetingMinutes),
                                    TimeEntryType.Meeting => (current.FocusMinutes,
                                                               current.MeetingMinutes + durationMinutes),
                                    _                     => current
                                };
                            });
                    }
                    catch (Exception ex) when (!ex.IsFatal())
                    {
                        _logger.LogError(ex,
                            "Failed to process TimeEntryEvent {@Event} — continuing with next.",
                            timeEntry);
                    }
                });
            }, cancellationToken);

            var metrics = aggregates.Select(kvp =>
            {
                var (userId, date) = kvp.Key;
                var (focusMinutes, meetingMinutes) = kvp.Value;
                var denominator = focusMinutes + meetingMinutes;
                var ratio       = denominator == 0 ? double.NaN : focusMinutes / denominator;

                return new ProductivityMetric(
                    userId,
                    date,
                    Math.Round(focusMinutes,   2),
                    Math.Round(meetingMinutes, 2),
                    Math.Round(ratio,          4));
            }).ToArray();

            _logger.LogInformation(
                "Transformation strategy {Strategy} yielded {MetricCount} metrics.",
                Name, metrics.Length);

            return metrics;
        }

        #endregion

        #region Private Helpers ────────────────────────────────────────────────

        private static void ValidateOrThrow(TimeEntryEvent evt)
        {
            if (string.IsNullOrWhiteSpace(evt.UserId))
                throw new InvalidTimeEntryException("UserId cannot be null or empty.", evt);

            if (evt.StartUtc > evt.EndUtc)
                throw new InvalidTimeEntryException(
                    "StartUtc must be earlier than EndUtc.", evt);
        }

        /// <summary>
        /// Converts the UTC timestamp to user-local date. For demo purposes we
        /// infer locale from the <c>UserId</c> postfix; production would query
        /// an identity-profile service.
        /// </summary>
        private static DateOnly ToUserLocaleDate(DateTimeOffset utc, string userId)
        {
            // Example userid: alice_us-pdx@acme.com → "us-pdx" IANA TZ
            var tzToken = userId.Split('_')
                                .Skip(1)
                                .FirstOrDefault() ?? "Etc/UTC";

            try
            {
                var tz = TimeZoneInfo.FindSystemTimeZoneById(tzToken);
                var local = TimeZoneInfo.ConvertTimeFromUtc(utc.UtcDateTime, tz);
                return DateOnly.FromDateTime(local);
            }
            catch (TimeZoneNotFoundException)
            {
                // Fallback to UTC date.
                return DateOnly.FromDateTime(utc.UtcDateTime);
            }
            catch (InvalidTimeZoneException)
            {
                return DateOnly.FromDateTime(utc.UtcDateTime);
            }
        }

        #endregion
    }

    #region Custom Exceptions ──────────────────────────────────────────────────

    /// <summary>
    /// Thrown when <see cref="TimeEntryEvent" /> fails basic semantic validation.
    /// </summary>
    public sealed class InvalidTimeEntryException : Exception
    {
        public InvalidTimeEntryException(string message, TimeEntryEvent offendingEvent)
            : base(message)
        {
            OffendingEvent = offendingEvent;
        }

        public TimeEntryEvent OffendingEvent { get; }
    }

    #endregion

    #region Extensions ─────────────────────────────────────────────────────────

    internal static class ExceptionExtensions
    {
        /// <summary>
        /// Determines if the exception is fatal and should not be swallowed.
        /// </summary>
        public static bool IsFatal(this Exception ex) =>
            ex is OutOfMemoryException
               or StackOverflowException
               or ThreadAbortException;
    }

    #endregion
}
```