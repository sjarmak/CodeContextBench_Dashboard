```csharp
// -----------------------------------------------------------------------------
//  File:        module_29.txt (C# source)
//  Project:     PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//  Component:   Transformation Strategy Resolver (Strategy_Pattern)
//  ----------------------------------------------------------------------------
//  Description:
//      • Dynamically discovers, materializes, and caches transformation
//        strategies that implement ITransformationStrategy.
//      • Enables hot-swappable business logic without redeploying Lambda mesh.
//      • Provides a concrete example strategy (FocusTimeStrategy).
// -----------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    /// <summary>
    /// Attribute used to decorate <see cref="ITransformationStrategy"/> implementations
    /// with discoverable metadata (e.g., logical name & version).
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public sealed class StrategyMetadataAttribute : Attribute
    {
        public string Name   { get; }
        public string Version { get; }

        public StrategyMetadataAttribute(string name, string version = "1.0")
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Strategy name cannot be null or whitespace.", nameof(name));

            Name    = name.Trim();
            Version = version?.Trim() ?? "1.0";
        }
    }

    /// <summary>
    /// Base contract for any data-transformation strategy plugged into the
    /// Pipeline_Pattern. Implementations are expected to be stateless & thread-safe.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>
        /// Fallback key when <see cref="StrategyMetadataAttribute"/> is omitted.
        /// </summary>
        string Key { get; }

        /// <summary>
        /// Execute transformation against the incoming <paramref name="input"/>.
        /// </summary>
        /// <param name="input">Arbitrary payload: JSON, domain model, parquet row, etc.</param>
        /// <returns>Transformed object or <c>null</c> if no output is produced.</returns>
        object? Execute(object input);
    }

    /// <summary>
    /// Public contract for resolving <see cref="ITransformationStrategy"/> instances.
    /// </summary>
    public interface ITransformationStrategyResolver
    {
        /// <summary>
        /// Resolve a strategy by logical key.
        /// </summary>
        ITransformationStrategy GetStrategy(string key);

        /// <summary>
        /// Enumerate all registered strategy keys.
        /// </summary>
        IEnumerable<string> ListStrategies();
    }

    /// <summary>
    /// Exception thrown when a requested transformation strategy cannot be found.
    /// </summary>
    public sealed class StrategyNotFoundException : Exception
    {
        public StrategyNotFoundException(string? message) : base(message) { }
        public StrategyNotFoundException(string? message, Exception? innerException)
            : base(message, innerException) { }
    }

    /// <summary>
    /// Implementation of <see cref="ITransformationStrategyResolver"/> that discovers
    /// strategies via reflection and lazily instantiates them through <see cref="Activator"/>.
    /// </summary>
    public sealed class TransformationStrategyResolver : ITransformationStrategyResolver, IDisposable
    {
        private readonly ILogger<TransformationStrategyResolver> _logger;
        private readonly IServiceProvider                         _serviceProvider;

        // Thread-safe cache (key -> Lazy(strategy))
        private readonly ConcurrentDictionary<string, Lazy<ITransformationStrategy>> _cache =
            new(StringComparer.OrdinalIgnoreCase);

        private readonly HashSet<Assembly> _processedAssemblies = new();
        private readonly object            _syncRoot           = new();

        private bool _disposed;

        public TransformationStrategyResolver(
            ILogger<TransformationStrategyResolver> logger,
            IServiceProvider                         serviceProvider)
        {
            _logger          = logger          ?? throw new ArgumentNullException(nameof(logger));
            _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));

            // Warm-up with already-loaded assemblies.
            DiscoverStrategies(AppDomain.CurrentDomain.GetAssemblies());
        }

        /// <inheritdoc/>
        public ITransformationStrategy GetStrategy(string key)
        {
            if (string.IsNullOrWhiteSpace(key))
                throw new ArgumentException("Strategy key must be provided.", nameof(key));

            EnsureNotDisposed();

            if (_cache.TryGetValue(key, out var lazy))
                return lazy.Value;

            // Plug-ins might be loaded at runtime—perform a defensive rescan.
            lock (_syncRoot)
            {
                if (!_cache.ContainsKey(key))
                    DiscoverStrategies(AppDomain.CurrentDomain
                                       .GetAssemblies()
                                       .Where(a => !_processedAssemblies.Contains(a)));
            }

            if (_cache.TryGetValue(key, out lazy))
                return lazy.Value;

            throw new StrategyNotFoundException(
                $"Transformation strategy with key '{key}' was not found.");
        }

        /// <inheritdoc/>
        public IEnumerable<string> ListStrategies()
        {
            EnsureNotDisposed();
            return _cache.Keys.ToArray();
        }

        // ---------------------------------------------------------------------
        //  Discovery Logic
        // ---------------------------------------------------------------------
        private void DiscoverStrategies(IEnumerable<Assembly> assemblies)
        {
            foreach (var assembly in assemblies.Where(a => !_processedAssemblies.Contains(a)))
            {
                try
                {
                    foreach (var candidate in assembly.GetTypes()
                                                      .Where(t => !t.IsAbstract &&
                                                                  typeof(ITransformationStrategy)
                                                                      .IsAssignableFrom(t)))
                    {
                        var metadata = candidate.GetCustomAttribute<StrategyMetadataAttribute>();
                        var key      = metadata?.Name ?? candidate.Name;

                        _cache.GetOrAdd(
                            key,
                            _ => new Lazy<ITransformationStrategy>(() =>
                            {
                                try
                                {
                                    var instance = (ITransformationStrategy)
                                                   Activator.CreateInstance(candidate)!;
                                    _logger.LogInformation(
                                        "Loaded transformation strategy {Strategy} (v{Version})",
                                        key,
                                        metadata?.Version ?? "1.0");
                                    return instance;
                                }
                                catch (Exception ex)
                                {
                                    _logger.LogError(
                                        ex,
                                        "Failed to instantiate transformation strategy '{Strategy}'.",
                                        key);
                                    throw;
                                }
                            }));
                    }

                    _processedAssemblies.Add(assembly);
                }
                catch (ReflectionTypeLoadException ex)
                {
                    _logger.LogWarning(
                        ex,
                        "ReflectionTypeLoadException while scanning assembly {Assembly}.",
                        assembly.FullName);
                }
            }
        }

        // ---------------------------------------------------------------------
        //  IDisposable
        // ---------------------------------------------------------------------
        public void Dispose()
        {
            if (_disposed) return;

            foreach (var (_, lazy) in _cache)
            {
                if (lazy.IsValueCreated && lazy.Value is IDisposable disposable)
                    disposable.Dispose();
            }

            _cache.Clear();
            _disposed = true;
            GC.SuppressFinalize(this);
        }

        private void EnsureNotDisposed()
        {
            if (_disposed)
                throw new ObjectDisposedException(nameof(TransformationStrategyResolver));
        }
    }
}

// -----------------------------------------------------------------------------
//  Example Strategy Implementation
// -----------------------------------------------------------------------------
namespace PulseOps.Warehouse.Transformations.Strategies
{
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Calculates the ratio between focus-time and total calendar time over a time
    /// slice. Intended to ingest enriched calendar events produced by earlier
    /// ETL stages.
    ///
    /// Example output:
    ///     { "FocusRatio": 0.42 }
    /// </summary>
    [PulseOps.Warehouse.Transformations.StrategyMetadata("FocusTime", "2.1")]
    public sealed class FocusTimeStrategy : PulseOps.Warehouse.Transformations.ITransformationStrategy
    {
        public string Key => "FocusTime";

        public object Execute(object input)
        {
            if (input is not IReadOnlyCollection<CalendarEvent> events)
            {
                throw new ArgumentException(
                    $"Expected {typeof(IReadOnlyCollection<CalendarEvent>).FullName} but " +
                    $"received {input?.GetType().FullName}.",
                    nameof(input));
            }

            var focusMinutes  = events.Where(e => e.IsFocusTime).Sum(e => e.DurationMinutes);
            var totalMinutes  = events.Sum(e  => e.DurationMinutes);

            var ratio = totalMinutes == 0
                ? 0.0
                : focusMinutes / (double) totalMinutes;

            return new { FocusRatio = ratio };
        }
    }

    /// <summary>
    /// Simplified calendar event domain model used by <see cref="FocusTimeStrategy"/>.
    /// </summary>
    public record CalendarEvent(DateTimeOffset Start,
                                DateTimeOffset End,
                                bool           IsFocusTime)
    {
        public int DurationMinutes => (int) (End - Start).TotalMinutes;
    }
}
```