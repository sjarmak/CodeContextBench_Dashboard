```csharp
// -------------------------------------------------------------------------------------------------
// File:        module_34.cs
// Project:     PulseOps Warehouse ‚Äî Serverless Productivity Intelligence Fabric (data_warehouse)
// Description: Registry, engine and exemplar strategies for KPI computation.  Leverages the
//              Strategy Pattern to allow drop-in replacement of business rules without redeploying
//              Lambda functions.  Designed to run inside a .NET AWS Lambda, but decoupled from the
//              runtime so the same code can be executed in unit-tests or containers.
// -------------------------------------------------------------------------------------------------
#nullable enable

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.KpiComputation
{
    #region üîë Public Contracts

    /// <summary>
    /// Common contract for all KPI computation strategies.
    /// Implementations MUST be stateless and thread-safe.
    /// </summary>
    public interface IKpiComputationStrategy
    {
        /// <summary>
        /// Friendly identifier used for routing and diagnostics.
        /// </summary>
        string StrategyId { get; }

        /// <summary>
        /// Computes a KPI for the specified time-range and entity scope.
        /// Implementations are encouraged to stream results progressively.
        /// </summary>
        /// <param name="context">The input context containing raw events.</param>
        /// <param name="logger">Structured logger for diagnostics.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>A KPI computation result payload.</returns>
        Task<KpiComputationResult> ComputeAsync(
            KpiComputationContext context,
            ILogger logger,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Context object passed to KPI calculators, containing the raw material required
    /// for the computation of a single KPI incl. configuration and raw events.
    /// </summary>
    public sealed record KpiComputationContext(
        string TenantId,
        DateTimeOffset From,
        DateTimeOffset To,
        IReadOnlyDictionary<string, JsonElement> Parameters,
        RawEventBuffer RawEvents);

    /// <summary>
    /// Standard envelope returned by all KPI computation strategies.
    /// </summary>
    public sealed record KpiComputationResult(
        string TenantId,
        string KpiKey,
        DateTimeOffset From,
        DateTimeOffset To,
        JsonElement Payload);

    #endregion

    #region üì¶ Registry & Engine

    /// <summary>
    /// Thread-safe registry responsible for resolving KPI computation strategies at runtime.
    /// Typically wired into the DI container with a Singleton lifetime.
    /// </summary>
    public sealed class KpiComputationStrategyRegistry
    {
        private readonly ConcurrentDictionary<string, IKpiComputationStrategy> _strategies = new();

        public KpiComputationStrategyRegistry(IEnumerable<IKpiComputationStrategy> discoveredStrategies,
                                              ILogger<KpiComputationStrategyRegistry> logger)
        {
            foreach (var strategy in discoveredStrategies)
            {
                if (!_strategies.TryAdd(strategy.StrategyId, strategy))
                {
                    logger.LogWarning("Duplicate KPI strategy registration detected for {StrategyId}", strategy.StrategyId);
                }
                else
                {
                    logger.LogInformation("Registered KPI strategy: {StrategyId}", strategy.StrategyId);
                }
            }
        }

        /// <summary>
        /// Resolve a strategy by its logical identifier.
        /// </summary>
        /// <exception cref="KeyNotFoundException">Thrown when the strategy cannot be resolved.</exception>
        public IKpiComputationStrategy Resolve(string strategyId)
        {
            if (_strategies.TryGetValue(strategyId, out var strategy))
                return strategy;

            throw new KeyNotFoundException(
                $"No KPI computation strategy has been registered with id '{strategyId}'.");
        }

        /// <summary>
        /// Returns all known strategy identifiers.
        /// </summary>
        public IReadOnlyCollection<string> KnownStrategies => _strategies.Keys.ToArray();
    }

    /// <summary>
    /// Orchestrates KPI computation by delegating to a concrete strategy.
    /// Serves as an anti-corruption layer between the Lambda handler and strategy implementations.
    /// </summary>
    public sealed class KpiComputationEngine
    {
        private readonly KpiComputationStrategyRegistry _registry;
        private readonly ILogger<KpiComputationEngine> _logger;

        public KpiComputationEngine(KpiComputationStrategyRegistry registry,
                                    ILogger<KpiComputationEngine> logger)
        {
            _registry = registry;
            _logger = logger;
        }

        /// <summary>
        /// Compute a KPI using the strategy specified in the context parameters ("strategyId").
        /// Unknown strategies are automatically routed to a default pass-through result to avoid
        /// poisoning the entire batch.
        /// </summary>
        public async Task<KpiComputationResult?> ComputeAsync(
            KpiComputationContext context,
            CancellationToken cancellationToken = default)
        {
            if (!context.Parameters.TryGetValue("strategyId", out var strategyIdElement) ||
                strategyIdElement.ValueKind != JsonValueKind.String)
            {
                _logger.LogError("KPI context is missing 'strategyId' parameter");
                return null;
            }

            var strategyId = strategyIdElement.GetString()!;
            IKpiComputationStrategy strategy;

            try
            {
                strategy = _registry.Resolve(strategyId);
            }
            catch (KeyNotFoundException ex)
            {
                _logger.LogError(ex, "Failed to resolve KPI strategy '{StrategyId}'", strategyId);
                return null;
            }

            using var activity = Telemetry.StartActivity("ComputeKpi", ("strategyId", strategyId));

            _logger.LogInformation("Starting KPI computation: {StrategyId} for Tenant={TenantId}", strategyId, context.TenantId);

            try
            {
                var result = await strategy.ComputeAsync(context, _logger, cancellationToken).ConfigureAwait(false);

                _logger.LogInformation("Computed KPI '{KpiKey}' for Tenant={TenantId}", result.KpiKey, result.TenantId);
                return result;
            }
            catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
            {
                _logger.LogWarning("KPI computation was cancelled (Strategy={StrategyId}, Tenant={TenantId})",
                    strategyId, context.TenantId);
                return null;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Unhandled error while computing KPI (Strategy={StrategyId}, Tenant={TenantId})",
                    strategyId, context.TenantId);
                throw; // Bubble up to Lambda error handler ‚Üí DLQ
            }
        }
    }

    #endregion

    #region üìä Exemplary Strategies

    /// <summary>
    /// Calculates the Focus Time Ratio:
    /// (Total Focus Hours) / (Total Working Hours)
    /// Focus hours are defined as continuous blocks of time ‚â• 2h with
    /// no meetings, no commit activity, and no Slack messages.
    /// </summary>
    public sealed class FocusTimeRatioStrategy : IKpiComputationStrategy
    {
        public string StrategyId => "focus-time-ratio";

        public async Task<KpiComputationResult> ComputeAsync(
            KpiComputationContext context,
            ILogger logger,
            CancellationToken cancellationToken = default)
        {
            // Simulate async I/O, e.g. reading additional artefacts from S3
            await Task.Yield();

            var focusIntervals = new List<DateTimeOffset>();
            var workingIntervals = new List<DateTimeOffset>();

            foreach (var e in context.RawEvents.Iterate())
            {
                cancellationToken.ThrowIfCancellationRequested();

                switch (e)
                {
                    case TimeEntryEvent tee:
                        workingIntervals.Add(tee.Timestamp);
                        break;
                    case MeetingEvent me:
                        // Mark as non-focus
                        break;
                    case CommitEvent ce:
                        // Non-focus
                        break;
                    default:
                        break;
                }

                // For demo purposes we synthesise results
                if (e.Timestamp.Minute % 13 == 0)
                    focusIntervals.Add(e.Timestamp);
            }

            var totalWorkingHours = workingIntervals.Count / 4.0; // Fake math
            var totalFocusHours   = focusIntervals.Count   / 4.0;

            var ratio = totalWorkingHours == 0 ? 0 : totalFocusHours / totalWorkingHours;

            var payloadJson = JsonSerializer.SerializeToElement(new
            {
                ratio,
                totalFocusHours,
                totalWorkingHours
            });

            return new KpiComputationResult(
                context.TenantId,
                "focus_time_ratio",
                context.From,
                context.To,
                payloadJson);
        }
    }

    /// <summary>
    /// Calculates Deployment Lead Time:
    /// Time elapsed between code commit and successful production deployment.
    /// </summary>
    public sealed class DeploymentLeadTimeStrategy : IKpiComputationStrategy
    {
        public string StrategyId => "deployment-lead-time";

        public async Task<KpiComputationResult> ComputeAsync(
            KpiComputationContext context,
            ILogger logger,
            CancellationToken cancellationToken = default)
        {
            await Task.Yield();

            var leadTimes = new List<TimeSpan>();

            // Naive sample implementation
            var commits     = context.RawEvents.OfType<CommitEvent>().OrderBy(c => c.Timestamp).ToList();
            var deployments = context.RawEvents.OfType<DeploymentEvent>().OrderBy(d => d.Timestamp).ToList();

            foreach (var commit in commits)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var deploy = deployments.FirstOrDefault(d => d.CommitId == commit.CommitId);
                if (deploy != null)
                {
                    leadTimes.Add(deploy.Timestamp - commit.Timestamp);
                }
            }

            var p50 = Percentile(leadTimes, 0.50);
            var p90 = Percentile(leadTimes, 0.90);

            var payloadJson = JsonSerializer.SerializeToElement(new
            {
                p50_minutes = p50.TotalMinutes,
                p90_minutes = p90.TotalMinutes
            });

            return new KpiComputationResult(
                context.TenantId,
                "deployment_lead_time",
                context.From,
                context.To,
                payloadJson);
        }

        private static TimeSpan Percentile(IReadOnlyList<TimeSpan> data, double percentile)
        {
            if (data.Count == 0) return TimeSpan.Zero;

            var ordered = data.OrderBy(x => x).ToArray();
            var index   = (int)Math.Ceiling(percentile * ordered.Length) - 1;
            index       = Math.Clamp(index, 0, ordered.Length - 1);

            return ordered[index];
        }
    }

    /// <summary>
    /// Calculates Meeting Cost Index ‚Äì total salary cost of meetings held in the timeframe.
    /// </summary>
    public sealed class MeetingCostIndexStrategy : IKpiComputationStrategy
    {
        public string StrategyId => "meeting-cost-index";

        public async Task<KpiComputationResult> ComputeAsync(
            KpiComputationContext context,
            ILogger logger,
            CancellationToken cancellationToken = default)
        {
            await Task.Yield();

            var hourlyRate      = context.Parameters.TryGetValue("hourlyRateUSD", out var rateElm) &&
                                  rateElm.TryGetDecimal(out var rateUsd) ? rateUsd : 90m;

            decimal totalCost = 0m;
            int     meetings  = 0;

            foreach (var meeting in context.RawEvents.OfType<MeetingEvent>())
            {
                cancellationToken.ThrowIfCancellationRequested();

                var durationHours = meeting.Duration.TotalHours;
                var attendeeCount = meeting.Attendees.Count;

                totalCost += (decimal)durationHours * attendeeCount * hourlyRate;
                meetings++;
            }

            var payloadJson = JsonSerializer.SerializeToElement(new
            {
                totalCostUSD = Math.Round(totalCost, 2),
                meetingCount = meetings,
                avgCostPerMeetingUSD = meetings == 0 ? 0 : Math.Round(totalCost / meetings, 2)
            });

            return new KpiComputationResult(
                context.TenantId,
                "meeting_cost_index",
                context.From,
                context.To,
                payloadJson);
        }
    }

    #endregion

    #region üß± Supporting Domain Objects

    /// <summary>
    /// Simplistic in-memory buffer for raw events.  Backed by the Kinesis stream / S3
    /// objects at runtime, but abstracted for testability.
    /// </summary>
    public sealed class RawEventBuffer : IEnumerable<BaseEvent>
    {
        private readonly IReadOnlyList<BaseEvent> _events;

        public RawEventBuffer(IEnumerable<BaseEvent> events)
        {
            _events = events.ToArray();
        }

        public IEnumerator<BaseEvent> GetEnumerator() => _events.GetEnumerator();
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

        public IEnumerable<T> OfType<T>() where T : BaseEvent => _events.OfType<T>();

        public IEnumerable<BaseEvent> Iterate() => _events;
    }

    public abstract record BaseEvent(DateTimeOffset Timestamp);

    public sealed record TimeEntryEvent(DateTimeOffset Timestamp, string UserId) : BaseEvent(Timestamp);
    public sealed record CommitEvent(DateTimeOffset Timestamp, string CommitId, string Author) : BaseEvent(Timestamp);
    public sealed record DeploymentEvent(DateTimeOffset Timestamp, string CommitId, string Environment) : BaseEvent(Timestamp);
    public sealed record MeetingEvent(DateTimeOffset Timestamp,
                                      TimeSpan Duration,
                                      IReadOnlyList<string> Attendees) : BaseEvent(Timestamp);

    #endregion

    #region ‚öôÔ∏è  Telemetry Helper

    /// <summary>
    /// Minimalistic OpenTelemetry shim so callers don‚Äôt need to reference the full library.
    /// For production deployments this type is replaced by a proper wrapper.
    /// </summary>
    internal static class Telemetry
    {
        public static IDisposable StartActivity(string name, params (string Key, string? Value)[] tags)
        {
            // In production this would be: ActivitySource.StartActivity(...);
            return new NullActivity();
        }

        private sealed class NullActivity : IDisposable
        {
            public void Dispose() { /* no-op */ }
        }
    }

    #endregion

    #region üîß JsonElement Extensions

    internal static class JsonElementExtensions
    {
        public static bool TryGetDecimal(this JsonElement element, out decimal value)
        {
            switch (element.ValueKind)
            {
                case JsonValueKind.Number when element.TryGetDecimal(out value):
                    return true;
                case JsonValueKind.String when decimal.TryParse(element.GetString(), out value):
                    return true;
                default:
                    value = default;
                    return false;
            }
        }
    }

    #endregion
}
```