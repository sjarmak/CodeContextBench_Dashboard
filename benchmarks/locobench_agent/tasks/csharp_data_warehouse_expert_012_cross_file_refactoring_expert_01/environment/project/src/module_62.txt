```csharp
// --------------------------------------------------------------------------------------------------------------------
// <copyright file="FocusTimeRatioStrategy.cs" company="PulseOps">
//   Copyright (c) PulseOps.
//   Licensed under the MIT license. See LICENSE file in the solution root for full license information.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------
//
//   Project  : PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//   File     : src/module_62.txt  (mapped to: FocusTimeRatioStrategy.cs)
//   Author   : AI Generated
//   Purpose  : Implements a pluggable Strategy for calculating the focus-time KPI
//              from a stream of calendar events.
// --------------------------------------------------------------------------------------------------------------------

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.FocusTime
{
    /// <summary>
    /// Represents a calendar event ingested from the SaaS connector.
    /// </summary>
    public sealed record CalendarEvent(
        string   UserId,
        DateTimeOffset StartUtc,
        DateTimeOffset EndUtc,
        bool     IsMeeting,
        string?  Title,
        string?  Organizer);

    /// <summary>
    /// Output KPI produced by <see cref="FocusTimeRatioStrategy"/>.
    /// </summary>
    public sealed record FocusTimeKpi(
        string   UserId,
        DateTime Date,          // Calendar date in local workspace/tz (normalized elsewhere).
        double   FocusRatio,    // FocusTime / TotalWorkSpan.
        TimeSpan FocusTime,
        TimeSpan MeetingTime);

    /// <summary>
    /// Defines a generic transformation strategy contract.
    /// </summary>
    /// <typeparam name="TInput">Input record.</typeparam>
    /// <typeparam name="TOutput">Output record.</typeparam>
    public interface ITransformationStrategy<in TInput, TOutput>
    {
        /// <summary>
        /// Asynchronously transforms an <see cref="IAsyncEnumerable{T}"/> of <typeparamref name="TInput"/> into
        /// one or many <typeparamref name="TOutput"/> instances.
        /// </summary>
        /// <param name="stream">Input stream.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>A stream of transformed outputs.</returns>
        IAsyncEnumerable<TOutput> TransformAsync(IAsyncEnumerable<TInput> stream, CancellationToken ct = default);
    }

    /// <summary>
    /// Strategy that converts raw <see cref="CalendarEvent"/>s into <see cref="FocusTimeKpi"/>s.
    /// </summary>
    /// <remarks>
    /// The algorithm collapses overlapping meeting blocks, then computes the ratio of non-meeting
    /// time to the configured work-day span (default 8 hours).  A ratio of 1.0 means the user had
    /// zero meetings that day.  Ratios &lt; 0 account for over-booking or incorrect data.
    /// </remarks>
    public sealed class FocusTimeRatioStrategy : ITransformationStrategy<CalendarEvent, FocusTimeKpi>
    {
        private static readonly TimeSpan DefaultWorkDay = TimeSpan.FromHours(8);

        private readonly ILogger<FocusTimeRatioStrategy> _logger;
        private readonly TimeSpan _workdaySpan;

        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger,
                                      TimeSpan? workdaySpan = null)
        {
            _logger       = logger ?? throw new ArgumentNullException(nameof(logger));
            _workdaySpan  = workdaySpan ?? DefaultWorkDay;
        }

        /// <inheritdoc/>
        public async IAsyncEnumerable<FocusTimeKpi> TransformAsync(
            IAsyncEnumerable<CalendarEvent> stream,
            [EnumeratorCancellation] CancellationToken ct = default)
        {
            // Group by userId + Date (local-date previously normalized by ingestion Lambda).
            var grouped = stream
                .GroupByAwaitWithCancellation(async ev =>
                {
                    ct.ThrowIfCancellationRequested();
                    return (ev.UserId, ev.StartUtc.Date);
                }, cancellationToken: ct);

            await foreach (var group in grouped.WithCancellation(ct))
            {
                // Materialize group into list to process overlaps.
                List<CalendarEvent> dayEvents = await group.ToListAsync(ct);

                if (dayEvents.Count == 0)
                {
                    continue;
                }

                var (userId, date) = group.Key;
                try
                {
                    TimeSpan meetingTime = CollapseAndSumMeetingTime(dayEvents);
                    TimeSpan focusTime   = _workdaySpan - meetingTime;
                    double   ratio       = Math.Max(0, focusTime.TotalMinutes) / _workdaySpan.TotalMinutes;

                    yield return new FocusTimeKpi(
                        userId,
                        date,
                        Math.Round(ratio, 3),
                        focusTime < TimeSpan.Zero ? TimeSpan.Zero : focusTime,
                        meetingTime);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex,
                        "Failed to compute FocusTime KPI for user {UserId} on {Date}. Payload={CalendarEvents}",
                        userId,
                        date.ToShortDateString(),
                        JsonSerializer.Serialize(dayEvents));
                    // Surface the exception so DLQ/Retry can kick in via Lambda failure semantics.
                    throw;
                }

                // Proactively yield back control to avoid starving other async tasks.
                await Task.Yield();
            }
        }

        /// <summary>
        /// Collapses overlapping meeting blocks and sums their duration.
        /// </summary>
        /// <param name="events">Events for a single user/day.</param>
        private static TimeSpan CollapseAndSumMeetingTime(IEnumerable<CalendarEvent> events)
        {
            IEnumerable<CalendarEvent> meetings = events.Where(e => e.IsMeeting);

            // Sort by start time.
            var sorted = meetings
                .OrderBy(e => e.StartUtc)
                .Select(e => (Start: e.StartUtc, End: e.EndUtc));

            TimeSpan total = TimeSpan.Zero;
            DateTimeOffset? currentStart = null;
            DateTimeOffset? currentEnd   = null;

            foreach (var (start, end) in sorted)
            {
                // Initialize the first bucket.
                if (currentStart is null)
                {
                    currentStart = start;
                    currentEnd   = end;
                    continue;
                }

                // Overlap ‑ extend current block.
                if (start <= currentEnd)
                {
                    if (end > currentEnd)
                    {
                        currentEnd = end;
                    }
                }
                // Disjoint ‑ finalize current block and start new one.
                else
                {
                    total += currentEnd.Value - currentStart.Value;
                    currentStart = start;
                    currentEnd   = end;
                }
            }

            // Add last bucket if exists.
            if (currentStart is not null && currentEnd is not null)
            {
                total += currentEnd.Value - currentStart.Value;
            }

            // Guard for negative/invalid durations (corrupted data).
            return total < TimeSpan.Zero ? TimeSpan.Zero : total;
        }
    }

    /// <summary>
    /// Helper extensions used by <see cref="FocusTimeRatioStrategy"/>.
    /// </summary>
    internal static class AsyncLinqExtensions
    {
        /// <summary>
        /// Polyfill for LINQ <c>GroupBy</c> that supports async delegates without pulling in
        /// additional packages.  Adapted from <c>System.Linq.Async</c> for brevity.
        /// </summary>
        public static async IAsyncEnumerable<IAsyncGrouping<TKey, TSource>> GroupByAwaitWithCancellation<TSource, TKey>(
            this IAsyncEnumerable<TSource> source,
            Func<TSource, CancellationToken, ValueTask<TKey>> keySelector,
            [EnumeratorCancellation] CancellationToken ct = default)
        {
            // Build lookup in memory ‑ suitable for per-user/day segregation (bounded set).
            var lookup = new Dictionary<TKey, List<TSource>>();

            await foreach (var item in source.WithCancellation(ct))
            {
                TKey key = await keySelector(item, ct);

                if (!lookup.TryGetValue(key, out var bucket))
                {
                    bucket = new List<TSource>();
                    lookup[key] = bucket;
                }

                bucket.Add(item);
            }

            // Materialize groupings back into async stream so caller remains fully async.
            foreach (var pair in lookup)
            {
                yield return new AsyncGrouping<TKey, TSource>(pair.Key, pair.Value);
            }
        }

        /// <summary>
        /// Lightweight <see cref="IAsyncGrouping{TKey,TElement}"/> implementation.
        /// </summary>
        private sealed class AsyncGrouping<TKey, TElement> : IAsyncGrouping<TKey, TElement>
        {
            private readonly IEnumerable<TElement> _enumerable;
            public TKey Key { get; }

            public AsyncGrouping(TKey key, IEnumerable<TElement> enumerable)
            {
                Key         = key;
                _enumerable = enumerable;
            }

            public IAsyncEnumerator<TElement> GetAsyncEnumerator(CancellationToken cancellationToken = default)
            {
                return ToAsync(_enumerable, cancellationToken).GetAsyncEnumerator(cancellationToken);
            }

            private static async IAsyncEnumerable<TElement> ToAsync(
                IEnumerable<TElement> enumerable,
                [EnumeratorCancellation] CancellationToken ct)
            {
                foreach (var item in enumerable)
                {
                    ct.ThrowIfCancellationRequested();
                    yield return item;
                    await Task.Yield();
                }
            }
        }
    }

    /// <summary>
    /// Mirrors <see cref="IGrouping{TKey,TElement}"/> but for async enumerables.
    /// </summary>
    internal interface IAsyncGrouping<out TKey, out TElement> : IAsyncEnumerable<TElement>
    {
        TKey Key { get; }
    }
}
```