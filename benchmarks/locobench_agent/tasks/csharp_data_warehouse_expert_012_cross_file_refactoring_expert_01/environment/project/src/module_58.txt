```csharp
// ---------------------------------------------------------------------------------------------------------------------
// File: module_58.txt  (logical name: TransformationStrategies.cs)
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric (data_warehouse)
// Description:  Provides a pluggable, runtime-resolvable strategy engine for converting raw
//               productivity events into KPI results.  Adheres to Strategy Pattern, allows
//               hot-swapping of business logic without redeploying Lambda functions.
// ---------------------------------------------------------------------------------------------------------------------

#nullable enable
using System;
using System.Collections.Concurrent;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

// In a real project these would be in separate files/namespaces.  For the sake of
// the challenge they are colocated in a single compilation unit.
namespace PulseOps.DataWarehouse.Transformation
{
    // --------------------------------------------------------------------------------------------------------------
    // DOMAIN PRIMITIVES
    // --------------------------------------------------------------------------------------------------------------

    /// <summary>
    /// Enumerates the KPI types the warehouse can calculate.
    /// Extend with caution; adding a new value should coincide with a new concrete strategy.
    /// </summary>
    public enum KpiType
    {
        FocusTimeRatio,
        DeploymentLeadTime,
        MeetingCostIndex
    }

    /// <summary>
    /// Represents a raw event pulled from the lake that needs to be turned into a KPI.
    /// The payload is intentionally unstructured; individual strategies are responsible
    /// for validating/deserializing the content they care about.
    /// </summary>
    /// <param name="TenantId">Tenant (customer) identifier.</param>
    /// <param name="Kpi">Target KPI type this event belongs to.</param>
    /// <param name="Payload">Unparsed JSON payload.</param>
    /// <param name="Timestamp">Event occurrence time in UTC.</param>
    public readonly record struct ProductivityEvent(
        string TenantId,
        KpiType Kpi,
        JsonElement Payload,
        DateTimeOffset Timestamp);

    /// <summary>
    /// Standardized output emitted by each strategy.
    /// </summary>
    /// <param name="TenantId">Tenant (customer) identifier.</param>
    /// <param name="Kpi">KPI that was calculated.</param>
    /// <param name="Value">Numeric result.  Down-stream analytics can cast/scale as needed.</param>
    /// <param name="WindowStart">Start of the time window the KPI covers.</param>
    /// <param name="WindowEnd">End of the time window the KPI covers.</param>
    public readonly record struct KpiResult(
        string TenantId,
        KpiType Kpi,
        double Value,
        DateTimeOffset WindowStart,
        DateTimeOffset WindowEnd);

    // --------------------------------------------------------------------------------------------------------------
    // STRATEGY CONTRACT & DEFAULT IMPLEMENTATIONS
    // --------------------------------------------------------------------------------------------------------------

    /// <summary>
    /// Contract every KPI computation strategy must fulfill.
    /// </summary>
    public interface IKpiComputationStrategy
    {
        /// <summary>Friendly name used for logging/diagnostics.</summary>
        string Name { get; }

        /// <summary> Kpi type handled by this strategy. </summary>
        KpiType SupportedKpi { get; }

        /// <summary>
        /// Calculates a KPI result from the raw productivity event.
        /// Implementations should be thread-safe and side-effect-free.
        /// </summary>
        ValueTask<KpiResult> ComputeAsync(ProductivityEvent evt, CancellationToken ct = default);
    }

    /// <summary>
    /// Focus-Time Ratio implementation.
    /// Business rules (example):
    ///   - Payload contains { "totalMinutes": int, "meetingMinutes": int }
    ///   - Focus ratio = (totalMinutes - meetingMinutes) / totalMinutes
    /// </summary>
    public sealed class FocusTimeRatioStrategy : IKpiComputationStrategy
    {
        private readonly ILogger<FocusTimeRatioStrategy> _logger;

        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public string Name => nameof(FocusTimeRatioStrategy);
        public KpiType SupportedKpi => KpiType.FocusTimeRatio;

        public ValueTask<KpiResult> ComputeAsync(ProductivityEvent evt, CancellationToken ct = default)
        {
            try
            {
                if (!evt.Payload.TryGetProperty("totalMinutes", out var totalProp) ||
                    !evt.Payload.TryGetProperty("meetingMinutes", out var meetingProp))
                {
                    throw new InvalidOperationException("Payload missing required properties.");
                }

                int totalMinutes   = totalProp.GetInt32();
                int meetingMinutes = meetingProp.GetInt32();

                if (totalMinutes <= 0)
                {
                    throw new InvalidOperationException("Total minutes must be greater than zero.");
                }

                double ratio = (double)(totalMinutes - meetingMinutes) / totalMinutes;
                ratio = Math.Round(ratio, 4, MidpointRounding.AwayFromZero); // Standardize precision

                var result = new KpiResult
                (
                    evt.TenantId,
                    SupportedKpi,
                    ratio,
                    evt.Timestamp.Date,                 // Window is daily
                    evt.Timestamp.Date.AddDays(1).AddTicks(-1)
                );

                _logger.LogDebug("Computed FocusTimeRatio {@KpiResult}", result);
                return ValueTask.FromResult(result);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to compute FocusTimeRatio for tenant {TenantId}", evt.TenantId);
                throw;
            }
        }
    }

    /// <summary>
    /// Deployment Lead-Time implementation.
    /// Business rules (example):
    ///   - Payload contains { "prCreated": string iso8601, "deploymentCompleted": string iso8601 }
    ///   - Lead-time = deploymentCompleted - prCreated
    /// </summary>
    public sealed class DeploymentLeadTimeStrategy : IKpiComputationStrategy
    {
        private readonly ILogger<DeploymentLeadTimeStrategy> _logger;

        public DeploymentLeadTimeStrategy(ILogger<DeploymentLeadTimeStrategy> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public string Name => nameof(DeploymentLeadTimeStrategy);
        public KpiType SupportedKpi => KpiType.DeploymentLeadTime;

        public ValueTask<KpiResult> ComputeAsync(ProductivityEvent evt, CancellationToken ct = default)
        {
            try
            {
                var prCreated          = evt.Payload.GetProperty("prCreated").GetDateTimeOffset();
                var deploymentFinished = evt.Payload.GetProperty("deploymentCompleted").GetDateTimeOffset();

                if (deploymentFinished < prCreated)
                {
                    throw new InvalidOperationException("Deployment time cannot precede the PR creation time.");
                }

                var leadTime = (deploymentFinished - prCreated).TotalHours;

                var result = new KpiResult
                (
                    evt.TenantId,
                    SupportedKpi,
                    Math.Round(leadTime, 2),
                    prCreated,
                    deploymentFinished
                );

                _logger.LogDebug("Computed DeploymentLeadTime {@KpiResult}", result);
                return ValueTask.FromResult(result);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to compute DeploymentLeadTime for tenant {TenantId}", evt.TenantId);
                throw;
            }
        }
    }

    /// <summary>
    /// Meeting Cost Index implementation.
    /// Business rules (example):
    ///   - Payload contains { "participants": int, "hourlyCostUSD": double, "durationMinutes": int }
    ///   - Cost = participants * hourlyCostUSD * (durationMinutes / 60)
    /// </summary>
    public sealed class MeetingCostIndexStrategy : IKpiComputationStrategy
    {
        private readonly ILogger<MeetingCostIndexStrategy> _logger;

        public MeetingCostIndexStrategy(ILogger<MeetingCostIndexStrategy> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public string Name  => nameof(MeetingCostIndexStrategy);
        public KpiType SupportedKpi => KpiType.MeetingCostIndex;

        public ValueTask<KpiResult> ComputeAsync(ProductivityEvent evt, CancellationToken ct = default)
        {
            try
            {
                int participants       = evt.Payload.GetProperty("participants").GetInt32();
                double hourlyCost      = evt.Payload.GetProperty("hourlyCostUSD").GetDouble();
                int durationMinutes    = evt.Payload.GetProperty("durationMinutes").GetInt32();

                double cost = participants * hourlyCost * (durationMinutes / 60d);

                var result = new KpiResult
                (
                    evt.TenantId,
                    SupportedKpi,
                    Math.Round(cost, 2),
                    evt.Timestamp,
                    evt.Timestamp.AddMinutes(durationMinutes)
                );

                _logger.LogDebug("Computed MeetingCostIndex {@KpiResult}", result);
                return ValueTask.FromResult(result);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to compute MeetingCostIndex for tenant {TenantId}", evt.TenantId);
                throw;
            }
        }
    }

    // --------------------------------------------------------------------------------------------------------------
    // STRATEGY RESOLUTION ENGINE
    // --------------------------------------------------------------------------------------------------------------

    /// <summary>
    /// Resolves KPI strategies at runtime.  Keeps an internal cache so costly reflection/DI
    /// operations aren’t repeated for each message on high-throughput streams.
    /// Thread-safe, lock-free using <see cref="ConcurrentDictionary{TKey,TValue}"/>.
    /// </summary>
    public sealed class StrategyResolver
    {
        private readonly ConcurrentDictionary<KpiType, IKpiComputationStrategy> _cache = new();
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogger<StrategyResolver> _logger;

        public StrategyResolver(IServiceProvider serviceProvider, ILogger<StrategyResolver> logger)
        {
            _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
            _logger          = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Resolves a registered strategy, or throws <see cref="NotSupportedException"/>.
        /// </summary>
        public IKpiComputationStrategy Resolve(KpiType kpi)
        {
            return _cache.GetOrAdd(kpi, CreateStrategy);
        }

        private IKpiComputationStrategy CreateStrategy(KpiType kpi)
        {
            // In production we resolve via DI container to get proper logging/telemetry plumbing.
            var strategy = _serviceProvider.GetService(typeof(IKpiComputationStrategy), kpi) as IKpiComputationStrategy;
            if (strategy == null)
            {
                _logger.LogError("No strategy registered for KPI type {KpiType}", kpi);
                throw new NotSupportedException($"No strategy available for KPI {kpi}");
            }

            _logger.LogInformation("Materialized strategy {StrategyName} for KPI {KpiType}",
                                   strategy.Name, kpi);
            return strategy;
        }
    }

    // --------------------------------------------------------------------------------------------------------------
    // EXTENSION METHODS FOR DEPENDENCY INJECTION
    // --------------------------------------------------------------------------------------------------------------

    using Microsoft.Extensions.DependencyInjection;

    /// <summary>DI registration helpers.</summary>
    public static class KpiStrategyServiceCollectionExtensions
    {
        /// <summary>
        /// Wire-up all built-in KPI strategies and the resolver.
        /// </summary>
        public static IServiceCollection AddKpiStrategies(this IServiceCollection services)
        {
            // Transient — stateless, cheap to construct.  If strategies later gain expensive
            // resources (e.g., database connections) consider Scoped or Singleton lifetime.
            services.AddTransient<IKpiComputationStrategy, FocusTimeRatioStrategy>();
            services.AddTransient<IKpiComputationStrategy, DeploymentLeadTimeStrategy>();
            services.AddTransient<IKpiComputationStrategy, MeetingCostIndexStrategy>();

            // The resolver is singleton because it caches strategies and is thread-safe.
            services.AddSingleton<StrategyResolver>();

            return services;
        }

        /// <summary>
        /// Helper to resolve strategy by KpiType from the service provider.
        /// </summary>
        internal static object? GetService(this IServiceProvider provider, Type serviceType, KpiType kpiHint)
        {
            // We cannot rely on the default DI container to filter by KpiType, hence we
            // must iterate manually.  Custom containers (Autofac) can do keyed resolution instead.
            foreach (var candidate in provider.GetServices(serviceType))
            {
                if (candidate is IKpiComputationStrategy strategy && strategy.SupportedKpi == kpiHint)
                {
                    return candidate;
                }
            }
            return null;
        }
    }
}
```