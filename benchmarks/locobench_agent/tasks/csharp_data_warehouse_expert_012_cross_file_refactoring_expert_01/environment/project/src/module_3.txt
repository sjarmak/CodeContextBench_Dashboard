```csharp
// --------------------------------------------------------------------------------------------------------------------
// <copyright>
//   © 2024 PulseOps Inc. — All rights reserved.
//   Licensed under the PulseOps Enterprise License. Unauthorized copying of this file, via any medium, 
//   is strictly prohibited. Proprietary and confidential.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------
// File:        src/module_3.txt (compiled as .cs file in build pipeline)
// Project:     PulseOps Warehouse — Serverless Productivity Intelligence Fabric (data_warehouse)
// Description: Focus-Time Ratio KPI strategy implementation and supporting infrastructure.
// --------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.KpiStrategies
{
    #region Public-Facing Surface --------------------------------------------------------------------

    /// <summary>
    /// Contract every KPI strategy must fulfil.  Strategies are registered in <see cref="KpiStrategyRegistry"/>
    /// and resolved through dependency injection at runtime.
    /// </summary>
    public interface IKpiComputationStrategy
    {
        /// <summary>Unique machine-readable identifier for the KPI.</summary>
        string KpiName { get; }

        /// <summary>
        /// Asynchronous computation entry-point.  
        /// </summary>
        /// <param name="context">The context containing all relevant raw material for the KPI.</param>
        /// <param name="cancellationToken">Cancellation token for cooperative cancellation.</param>
        /// <returns>The calculation result wrapped in <see cref="KpiResult"/>.</returns>
        Task<KpiResult> ComputeAsync(
            KpiComputationContext context, 
            CancellationToken cancellationToken = default);
    }

    /// <summary>DI-friendly registry for run-time discovery of KPI strategies.</summary>
    public static class KpiStrategyRegistry
    {
        private static readonly Dictionary<string, Type> _strategies = new(StringComparer.OrdinalIgnoreCase);

        /// <summary>Registers a strategy type.</summary>
        public static void Register<T>() where T : IKpiComputationStrategy, new()
            => _strategies[Activator.CreateInstance<T>().KpiName] = typeof(T);

        /// <summary>Resolves a strategy given its <paramref name="kpiName"/>.</summary>
        /// <exception cref="KeyNotFoundException"/>
        public static IKpiComputationStrategy Resolve(string kpiName, IServiceProvider serviceProvider)
        {
            if (!_strategies.TryGetValue(kpiName, out var type))
                throw new KeyNotFoundException($"No KPI strategy registered for '{kpiName}'.");

            // Prefer serviceProvider when type is registered in DI, otherwise fallback to reflection.
            return (IKpiComputationStrategy)(serviceProvider.GetService(type) ?? Activator.CreateInstance(type)!);
        }
    }

    /// <summary>
    ///     A single, immutable KPI result.  Instances are emitted by <see cref="IKpiComputationStrategy"/>.
    /// </summary>
    /// <param name="Name">KPI identifier (snake_case).</param>
    /// <param name="Value">Calculated numeric value.</param>
    /// <param name="WindowStart">Inclusive lower bound of the time-window the KPI covers (UTC).</param>
    /// <param name="WindowEnd">Exclusive upper bound.</param>
    /// <param name="Metadata">Optional, arbitrarily nested metadata for downstream consumers.</param>
    public sealed record KpiResult(
        string Name,
        double Value,
        DateTimeOffset WindowStart,
        DateTimeOffset WindowEnd,
        IReadOnlyDictionary<string, object>? Metadata = null
    )
    {
        /// <summary>Serializes the KPI result using standard JSON options for wire transport.</summary>
        public string ToJson() => JsonSerializer.Serialize(this, JsonSerialization.Options);
    }

    #endregion

    #region Context + Domain Models ------------------------------------------------------------------

    /// <summary>
    /// Context passed to strategies containing raw events within a given window.
    /// Any additional pre-computed aggregations should be exposed here
    /// to avoid recomputation in downstream strategies.
    /// </summary>
    public sealed class KpiComputationContext
    {
        /// <summary>All calendar events (meetings, focus blocks, OOO) in the window.</summary>
        public IReadOnlyList<CalendarEvent> CalendarEvents { get; init; } = Array.Empty<CalendarEvent>();

        /// <summary>
        /// Start of the window (inclusive, UTC).  
        /// Assumes the same for all datasets inside this context.
        /// </summary>
        public DateTimeOffset WindowStart { get; init; }

        /// <summary>End of the window (exclusive, UTC).</summary>
        public DateTimeOffset WindowEnd { get; init; }

        /// <summary>A shared logger instance pre-configured with Lambda contextual metadata.</summary>
        public ILogger Logger { get; init; } = NullLogger.Instance;
    }

    /// <summary>Canonical representation of a calendar event after ETL normalization.</summary>
    public sealed record CalendarEvent(
        DateTimeOffset Start,
        DateTimeOffset End,
        CalendarEventType EventType,
        string Organizer,
        string Title,
        IReadOnlyList<string> Attendees
    )
    {
        public TimeSpan Duration => End - Start;

        public bool OverlapsWith(DateTimeOffset windowStart, DateTimeOffset windowEnd)
            => !(End <= windowStart || Start >= windowEnd);
    }

    public enum CalendarEventType
    {
        Meeting,
        Focus,
        OutOfOffice,
        Break
    }

    #endregion

    #region Strategy Implementation ------------------------------------------------------------------

    /// <summary>
    /// Focus-Time Ratio:  (Total Focus Time) / (Total Meeting Time + Total Focus Time)
    /// Produces a value in the range [0, 1].  If both denominators are zero, value is <c>double.NaN</c>.
    /// </summary>
    public sealed class FocusTimeRatioStrategy : IKpiComputationStrategy
    {
        public const string Identifier = "focus_time_ratio";

        public string KpiName => Identifier;

        /// <inheritdoc />
        public async Task<KpiResult> ComputeAsync(
            KpiComputationContext context,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(context);

            var logger = context.Logger ?? NullLogger.Instance;
            using var _ = logger.BeginScope("{Kpi}", Identifier);

            logger.LogDebug("Starting KPI computation.");

            // Filter events that overlap with computation window.
            var windowEvents = context.CalendarEvents
                                      .Where(e => e.OverlapsWith(context.WindowStart, context.WindowEnd))
                                      .ToArray();

            logger.LogDebug("Found {Count} overlapping calendar events.", windowEvents.Length);

            // Compute durations.
            var focusDuration   = AggregateDuration(windowEvents, CalendarEventType.Focus);
            var meetingDuration = AggregateDuration(windowEvents, CalendarEventType.Meeting);

            // Defensive checks for cancellation.
            cancellationToken.ThrowIfCancellationRequested();

            double ratio;
            try
            {
                ratio = ComputeRatio(focusDuration, meetingDuration);
            }
            catch (Exception ex) when (ex is not OperationCanceledException)
            {
                logger.LogError(ex, "Error during ratio computation.");
                throw new KpiComputationException("Failed to compute Focus-Time Ratio.", ex);
            }

            logger.LogInformation(
                "Computed Focus-Time Ratio KPI. Focus: {Focus}h, Meeting: {Meeting}h, Ratio: {Ratio:p2}",
                focusDuration.TotalHours,
                meetingDuration.TotalHours,
                ratio);

            var metadata = new Dictionary<string, object>
            {
                ["focusHours"]   = Math.Round(focusDuration.TotalHours,   2),
                ["meetingHours"] = Math.Round(meetingDuration.TotalHours, 2),
                ["version"]      = "v1.0.0"
            };

            // Simulate IO-bound post-processing.  (E.g., fetch feature flags, audit logs.)
            await SimulateLatencyAsync(cancellationToken).ConfigureAwait(false);

            return new KpiResult(
                Name: Identifier,
                Value: ratio,
                WindowStart: context.WindowStart,
                WindowEnd: context.WindowEnd,
                Metadata: new ReadOnlyDictionary<string, object>(metadata)
            );
        }

        private static TimeSpan AggregateDuration(IEnumerable<CalendarEvent> events, CalendarEventType type) =>
            events.Where(e => e.EventType == type)
                  .Aggregate(TimeSpan.Zero, (acc, x) => acc + x.Duration);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static double ComputeRatio(TimeSpan focus, TimeSpan meeting)
            => (focus + meeting).TotalSeconds == 0
                   ? double.NaN
                   : focus.TotalSeconds / (focus + meeting).TotalSeconds;

        private static async Task SimulateLatencyAsync(CancellationToken token)
        {
            // The real implementation would call feature-flag services or other micro-services.
            await Task.Delay(5, token).ConfigureAwait(false);
        }
    }

    #endregion

    #region Support Types ---------------------------------------------------------------------------

    /// <summary>Strongly-typed computation exception for KPI engine.</summary>
    public sealed class KpiComputationException : Exception
    {
        public KpiComputationException(string message, Exception? innerException = null)
            : base(message, innerException) { }
    }

    /// <summary>Null-object logger to avoid noisy null-checks.</summary>
    internal sealed class NullLogger : ILogger
    {
        public static readonly ILogger Instance = new NullLogger();

        private NullLogger() { }

        public IDisposable BeginScope<TState>(TState state) => NullScope.Instance;
        public bool IsEnabled(LogLevel logLevel) => false;
        public void Log<TState>(
            LogLevel    logLevel,
            EventId     eventId,
            TState      state,
            Exception?  exception,
            Func<TState, Exception?, string> formatter) { }

        private sealed class NullScope : IDisposable
        {
            public static readonly IDisposable Instance = new NullScope();
            public void Dispose() { }
        }
    }

    /// <summary>
    /// Shared JSON serialization settings for wire-level DTOs.
    /// </summary>
    internal static class JsonSerialization
    {
        public static readonly JsonSerializerOptions Options = CreateDefault();

        private static JsonSerializerOptions CreateDefault()
        {
            var opts = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) },
                WriteIndented = false,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
            };

            // Note: Add further converters for DateOnly/TimeOnly if needed.
            return opts;
        }
    }

    #endregion
}
```