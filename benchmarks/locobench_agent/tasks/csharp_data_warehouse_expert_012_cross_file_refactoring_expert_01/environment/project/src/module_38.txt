```csharp
// -------------------------------------------------------------------------------------------------
// File: src/module_38.txt   (treated as C# source by build pipeline)
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric
//
// This module implements the Strategy-Pattern plumbing used by transformation Lambdas to locate
// and execute concrete data-transformation strategies at run-time.  It includes:
//
//  1.  TransformationStrategyAttribute – declarative metadata for strategy discovery.
//  2.  ITransformationStrategy        – contract implemented by all strategies.
//  3.  TransformationStrategyRegistry – thread-safe, reflection-based strategy loader & cache.
//  4.  MeetingCostIndexStrategy       – sample, production-grade strategy that converts raw
//                                        calendar events into Meeting-Cost KPI records.
//
// Usage (typical Lambda handler pseudo-code):
//
//      var registry  = TransformationStrategyRegistry.Default;
//      var strategy  = registry.Resolve("meeting_cost_index");
//      var kpiFrame  = await strategy.TransformAsync(rawBatch, context.CancellationToken);
//
// -------------------------------------------------------------------------------------------------
#nullable enable

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

// ReSharper disable once CheckNamespace
namespace PulseOps.Warehouse.Transformation
{
    #region 1. Attribute --------------------------------------------------------------------------

    /// <summary>
    /// Decorates a class that implements <see cref="ITransformationStrategy"/>, exposing the logical
    /// strategy name used for run-time look-ups.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public sealed class TransformationStrategyAttribute : Attribute
    {
        /// <summary>
        /// Gets the case-insensitive external name of the strategy.
        /// </summary>
        public string Name { get; }

        public TransformationStrategyAttribute(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Strategy name must be a non-empty string.", nameof(name));

            Name = name;
        }
    }

    #endregion

    #region 2. Contract ----------------------------------------------------------------------------

    /// <summary>
    /// A pluggable data-transformation strategy.  Implementations must be thread-safe and stateless.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>
        /// The logical name of the strategy (identity). Should match
        /// <see cref="TransformationStrategyAttribute.Name"/>.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Performs the transformation asynchronously.
        /// </summary>
        /// <param name="batch">The input batch of raw events.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>Transformed payload (opaque to upstream consumers).</returns>
        Task<TransformationResult> TransformAsync(RawEventBatch batch, CancellationToken ct = default);
    }

    #endregion

    #region 3. Registry ----------------------------------------------------------------------------

    /// <summary>
    /// Reflection-based discovery + cache of <see cref="ITransformationStrategy"/> implementations.
    /// </summary>
    public sealed class TransformationStrategyRegistry
    {
        private static readonly Lazy<TransformationStrategyRegistry> _lazy =
            new(() => new TransformationStrategyRegistry(AppDomain.CurrentDomain.GetAssemblies()));

        public static TransformationStrategyRegistry Default => _lazy.Value;

        private readonly ConcurrentDictionary<string, ITransformationStrategy> _cache =
            new(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// Discovers all strategies contained in the given assemblies.
        /// </summary>
        private TransformationStrategyRegistry(IEnumerable<Assembly> assemblies)
        {
            foreach (var assembly in assemblies)
            {
                TryLoadStrategiesFromAssembly(assembly);
            }

            // Listen for new assemblies loaded after the registry was created (e.g., plugin warm-swap).
            AppDomain.CurrentDomain.AssemblyLoad += (_, args) => TryLoadStrategiesFromAssembly(args.LoadedAssembly);
        }

        /// <summary>
        /// Resolves a strategy by name.
        /// </summary>
        /// <exception cref="KeyNotFoundException">If the strategy cannot be found.</exception>
        public ITransformationStrategy Resolve(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Strategy name must be provided.", nameof(name));

            if (_cache.TryGetValue(name, out var strategy))
                return strategy;

            throw new KeyNotFoundException(
                $"Transformation strategy '{name}' is not registered. " +
                $"Available strategies: {string.Join(", ", _cache.Keys)}");
        }

        private void TryLoadStrategiesFromAssembly(Assembly assembly)
        {
            IEnumerable<Type> candidates;
            try
            {
                candidates = assembly
                    .GetTypes()
                    .Where(t =>
                        !t.IsAbstract &&
                        !t.IsInterface &&
                        typeof(ITransformationStrategy).IsAssignableFrom(t) &&
                        t.GetCustomAttribute<TransformationStrategyAttribute>() != null);
            }
            catch (ReflectionTypeLoadException ex)
            {
                candidates = ex.Types.Where(t =>
                    t != null &&
                    !t.IsAbstract &&
                    !t.IsInterface &&
                    typeof(ITransformationStrategy).IsAssignableFrom(t) &&
                    t!.GetCustomAttribute<TransformationStrategyAttribute>() != null)!;
            }

            foreach (var candidate in candidates)
            {
                var attr = candidate.GetCustomAttribute<TransformationStrategyAttribute>()!;
                var instance = (ITransformationStrategy)Activator.CreateInstance(candidate)!;

                // First one wins – prevents accidental duplicate registrations.
                _cache.TryAdd(attr.Name, instance);
            }
        }
    }

    #endregion

    #region 4. Sample Strategy: Meeting Cost Index --------------------------------------------------

    /// <summary>
    /// Concrete strategy that converts <see cref="CalendarEvent"/> records into KPI rows representing
    /// meeting cost.  Formula:
    ///
    ///      cost = Σ(attendee.hourlyRate) * duration.hours
    ///
    /// The calculation purposefully does not include overhead multipliers (e.g., fringe benefits) to
    /// keep the metric consistent across disparate organizations.
    /// </summary>
    [TransformationStrategy("meeting_cost_index")]
    public sealed class MeetingCostIndexStrategy : ITransformationStrategy
    {
        public string Name => "meeting_cost_index";

        private readonly JsonSerializerOptions _jsonOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
        };

        /// <inheritdoc />
        public async Task<TransformationResult> TransformAsync(RawEventBatch batch, CancellationToken ct = default)
        {
            ArgumentNullException.ThrowIfNull(batch);

            var kpiRows = new List<MeetingCostRecord>();

            foreach (var raw in batch.Events.OfType<CalendarEvent>())
            {
                ct.ThrowIfCancellationRequested();

                try
                {
                    var row = ToKpiRecord(raw);
                    if (row != null)
                        kpiRows.Add(row);
                }
                catch (Exception ex)
                {
                    batch.Logger?.LogError(ex,
                        "Failed to transform calendar event '{EventId}' into MeetingCostIndex row.", raw.EventId);
                    // Poisoned record is skipped; it will surface in quality reports downstream.
                }
            }

            // Simulate async I/O latency (e.g., remote config fetch, ML model load).
            await Task.Yield();

            // Serialize result as newline-delimited JSON for Kinesis ingestion.
            var payload = string.Join(
                Environment.NewLine,
                kpiRows.Select(row => JsonSerializer.Serialize(row, _jsonOptions)));

            return new TransformationResult(
                content: payload,
                contentType: "application/x-ndjson",
                recordCount: kpiRows.Count);
        }

        private static MeetingCostRecord? ToKpiRecord(CalendarEvent e)
        {
            if (e.Attendees.Count == 0)
                return null;

            var durationHours = (e.EndUtc - e.StartUtc).TotalHours;
            if (durationHours <= 0)
                return null;

            var attendeeCostPerHour = e.Attendees.Sum(a => a.HourlyRateUsd);
            var cost = attendeeCostPerHour * durationHours;

            return new MeetingCostRecord(
                eventId:        e.EventId,
                organizer:      e.Organizer,
                startUtc:       e.StartUtc,
                endUtc:         e.EndUtc,
                attendeeCount:  e.Attendees.Count,
                costUsd:        Math.Round(cost, 2, MidpointRounding.AwayFromZero),
                currency:       "USD");
        }
    }

    #endregion

    #region DTOs & Utility -------------------------------------------------------------------------

    /// <summary>
    /// Container passed down from ingestion Lambda.
    /// </summary>
    public sealed class RawEventBatch
    {
        public RawEventBatch(IReadOnlyCollection<object> events, ILogger? logger = null)
        {
            Events = events ?? Array.Empty<object>();
            Logger = logger;
        }

        /// <summary>Raw events from previous pipeline stage.</summary>
        public IReadOnlyCollection<object> Events { get; }

        /// <summary>Optional structured logger propagated from Lambda context.</summary>
        public ILogger? Logger { get; }
    }

    /// <summary>
    /// Standardized transformation result that downstream pipeline stages understand.
    /// </summary>
    public sealed record TransformationResult(
        string Content,
        string ContentType,
        int    RecordCount);

    // -------------------------------------------------------------------- Event Model ------------

    public sealed record CalendarEvent(
        string                 EventId,
        string                 Organizer,
        DateTime               StartUtc,
        DateTime               EndUtc,
        IReadOnlyList<Attendee> Attendees);

    public sealed record Attendee(
        string  Email,
        double  HourlyRateUsd);

    // ---------------------------------------------------------------- KPI Model ------------------

    public sealed record MeetingCostRecord(
        string    EventId,
        string    Organizer,
        DateTime  StartUtc,
        DateTime  EndUtc,
        int       AttendeeCount,
        double    CostUsd,
        string    Currency);

    #endregion
}
```