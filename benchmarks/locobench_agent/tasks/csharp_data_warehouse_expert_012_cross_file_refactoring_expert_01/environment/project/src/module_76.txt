```csharp
// File: src/module_76.cs
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric (data_warehouse)
//
// Purpose:
//   Provides the core runtime components that power the pluggable transformation layer.
//   Implements a Strategy-Pattern–based dispatcher which dynamically selects the correct
//   KPI transformation at runtime and streams the results down-stream.
//
// Notes:
//   ‑ Designed for AWS Lambda, but is framework-agnostic so it can be re-used in
//     batch jobs (Glue / Step-Functions) or containerised micro-services.
//
//   ‑ Uses Microsoft.Extensions.* abstractions for IoC + structured logging so that the
//     code is easily testable and observability-friendly.
//
//   ‑ Thread-safe & async all the way.
//
// Author: PulseOps Engineering
// --------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region Public Contracts ─────────────────────────────────────────────────────

    /// <summary>
    ///     Represent a unit of work flowing through the transformation pipeline.
    /// </summary>
    public sealed record TransformationContext(
        string SourceStream,
        string RawPayload,
        DateTime IngestedAtUtc,
        IReadOnlyDictionary<string, string> Metadata);

    /// <summary>
    ///     Marker interface for all KPI records emitted by strategies.
    /// </summary>
    public interface IKpiRecord
    {
        string KpiName { get; }
        DateTime TimestampUtc { get; }
        string PartitionKey { get; }
        string ToJson();
    }

    /// <summary>
    ///     Pluggable strategy that converts an input <see cref="TransformationContext" /> into zero or more <see cref="IKpiRecord" /> items.
    /// </summary>
    public interface ITransformationStrategy
    {
        /// <summary>
        ///     Strategy identifier. Must be unique inside the registry.
        /// </summary>
        string Name { get; }

        /// <summary>
        ///     Checks whether the strategy can handle a given <paramref name="context" />.
        /// </summary>
        bool CanHandle(in TransformationContext context);

        /// <summary>
        ///     Executes the domain-specific transformation.
        /// </summary>
        Task<IReadOnlyCollection<IKpiRecord>> TransformAsync(
            TransformationContext context,
            CancellationToken token = default);
    }

    /// <summary>
    ///     Runtime dispatcher that resolves a strategy and executes it.
    /// </summary>
    public interface ITransformationDispatcher
    {
        Task<IReadOnlyCollection<IKpiRecord>> DispatchAsync(
            TransformationContext context,
            CancellationToken token = default);
    }

    #endregion

    #region Dispatcher Implementation ────────────────────────────────────────────

    /// <summary>
    ///     Thread-safe registry holding all available transformation strategies.
    /// </summary>
    public sealed class StrategyRegistry
    {
        private readonly ConcurrentDictionary<string, ITransformationStrategy> _strategies = new();

        public StrategyRegistry(IEnumerable<ITransformationStrategy> strategies)
        {
            foreach (var strategy in strategies)
            {
                if (!_strategies.TryAdd(strategy.Name, strategy))
                {
                    throw new InvalidOperationException(
                        $"A strategy with the name '{strategy.Name}' is already registered.");
                }
            }
        }

        public IEnumerable<ITransformationStrategy> All => _strategies.Values;

        public ITransformationStrategy? GetStrategy(string name) =>
            _strategies.TryGetValue(name, out var strategy) ? strategy : null;
    }

    /// <summary>
    ///     Default runtime dispatcher.
    /// </summary>
    public sealed class TransformationDispatcher : ITransformationDispatcher
    {
        private readonly StrategyRegistry _registry;
        private readonly ILogger<TransformationDispatcher> _logger;

        public TransformationDispatcher(StrategyRegistry registry, ILogger<TransformationDispatcher> logger)
        {
            _registry = registry;
            _logger = logger;
        }

        public async Task<IReadOnlyCollection<IKpiRecord>> DispatchAsync(
            TransformationContext context,
            CancellationToken token = default)
        {
            // Try to resolve strategy via explicit metadata hint first.
            if (context.Metadata.TryGetValue("strategy", out var hintedStrategyName))
            {
                var hintedStrategy = _registry.GetStrategy(hintedStrategyName);
                if (hintedStrategy is null)
                {
                    _logger.LogWarning(
                        "Metadata requested unknown strategy '{Strategy}'. Falling back to auto-discovery.",
                        hintedStrategyName);
                }
                else
                {
                    return await ExecuteAsync(hintedStrategy, context, token).ConfigureAwait(false);
                }
            }

            // Auto-discover a capable strategy.
            var candidate = _registry.All.FirstOrDefault(s => s.CanHandle(context));
            if (candidate is null)
            {
                _logger.LogError(
                    "No compatible transformation strategy found for SourceStream='{SourceStream}'.",
                    context.SourceStream);
                return Array.Empty<IKpiRecord>();
            }

            return await ExecuteAsync(candidate, context, token).ConfigureAwait(false);
        }

        private async Task<IReadOnlyCollection<IKpiRecord>> ExecuteAsync(
            ITransformationStrategy strategy,
            TransformationContext context,
            CancellationToken token)
        {
            using var scope = _logger.BeginScope(
                new Dictionary<string, object?>
                {
                    ["strategy"] = strategy.Name,
                    ["sourceStream"] = context.SourceStream,
                    ["ingestedAtUtc"] = context.IngestedAtUtc
                });

            _logger.LogInformation("Executing transformation strategy '{Strategy}'.", strategy.Name);

            var records = await strategy.TransformAsync(context, token).ConfigureAwait(false);

            _logger.LogInformation(
                "Strategy '{Strategy}' produced {RecordCount} record(s).",
                strategy.Name,
                records.Count);

            return records;
        }
    }

    #endregion

    #region Built-in Strategy: Focus-Time Ratio ──────────────────────────────────

    /// <summary>
    ///     KPI record representing the developer focus-time ratio.
    /// </summary>
    public sealed record FocusTimeRatioRecord(
        string DeveloperId,
        DateTime DayUtc,
        double Ratio) : IKpiRecord
    {
        public string KpiName => "focus_time_ratio";
        public DateTime TimestampUtc => DayUtc;
        public string PartitionKey => DeveloperId;

        public string ToJson() => JsonSerializer.Serialize(this);
    }

    /// <summary>
    ///     Payload contract for raw calendar events.
    /// </summary>
    internal sealed record CalendarEventDto(
        string EventId,
        string Organizer,
        string[] Attendees,
        DateTime StartUtc,
        DateTime EndUtc,
        bool IsOutOfOffice);

    /// <summary>
    ///     Calculates the focus-time ratio (meeting-free vs total work hours) from raw calendar events.
    /// </summary>
    public sealed class FocusTimeRatioStrategy : ITransformationStrategy
    {
        private readonly ILogger<FocusTimeRatioStrategy> _logger;

        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger)
        {
            _logger = logger;
        }

        public string Name => "focus_time_ratio";

        public bool CanHandle(in TransformationContext context) =>
            context.SourceStream.Equals("outlook.calendar.events", StringComparison.OrdinalIgnoreCase);

        public async Task<IReadOnlyCollection<IKpiRecord>> TransformAsync(
            TransformationContext context,
            CancellationToken token = default)
        {
            // Simulate I/O-bound call (e.g., decrypt payload/key fetch).
            await Task.Yield();

            var events = ParseEvents(context);

            // Group by developer & day.
            var results = events
                .SelectMany(ev =>
                {
                    var day = ev.StartUtc.Date;
                    foreach (var attendee in ev.Attendees)
                    {
                        yield return (DeveloperId: attendee, Day: day, Duration: ev.EndUtc - ev.StartUtc);
                    }
                })
                .GroupBy(x => (x.DeveloperId, x.Day))
                .Select(g =>
                {
                    var totalMeeting = g.Sum(x => x.Duration.TotalMinutes);
                    const double workDayMinutes = 8 * 60d;
                    var ratio = Math.Max(0, workDayMinutes - totalMeeting) / workDayMinutes;
                    return new FocusTimeRatioRecord(g.Key.DeveloperId, g.Key.Day, Math.Round(ratio, 4));
                })
                .Cast<IKpiRecord>()
                .ToArray();

            _logger.LogDebug(
                "Calculated FocusTimeRatio for {DeveloperCount} developer(s).",
                results.Length);

            return results;
        }

        private IReadOnlyCollection<CalendarEventDto> ParseEvents(TransformationContext context)
        {
            try
            {
                var events = JsonSerializer.Deserialize<CalendarEventDto[]>(
                    context.RawPayload,
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

                if (events == null || events.Length == 0)
                {
                    _logger.LogWarning(
                        "No calendar events found in payload for SourceStream='{SourceStream}'.",
                        context.SourceStream);

                    return Array.Empty<CalendarEventDto>();
                }

                return events;
            }
            catch (JsonException jex)
            {
                _logger.LogError(
                    jex,
                    "Failed to deserialize calendar events payload. Payload='{PayloadSnippet}'",
                    context.RawPayload.Length > 200
                        ? context.RawPayload[..200] + "..."
                        : context.RawPayload);

                return Array.Empty<CalendarEventDto>();
            }
        }
    }

    #endregion

    #region Service Collection Extensions ────────────────────────────────────────

    public static class ServiceCollectionExtensions
    {
        /// <summary>
        ///     Registers dispatcher and all built-in strategies.
        ///     External assemblies can add more strategies by simply registering <see cref="ITransformationStrategy" /> transient
        ///     services and relying on DI auto-discovery.
        /// </summary>
        public static IServiceCollection AddPulseOpsTransformations(this IServiceCollection services)
        {
            // Core infrastructure.
            services.AddSingleton<StrategyRegistry>(sp =>
            {
                var discovered = sp.GetServices<ITransformationStrategy>();
                return new StrategyRegistry(discovered);
            });

            services.AddSingleton<ITransformationDispatcher, TransformationDispatcher>();

            // Built-in strategies.
            services.AddTransient<ITransformationStrategy, FocusTimeRatioStrategy>();

            return services;
        }
    }

    #endregion
}
```