```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    /// <summary>
    /// Contract for all transformation strategies.
    /// </summary>
    /// <typeparam name="TIn">Type of the incoming payload.</typeparam>
    /// <typeparam name="TOut">Type of the outgoing payload.</typeparam>
    public interface ITransformationStrategy<in TIn, TOut>
    {
        /// <summary>
        /// Human-friendly name of the strategy.  Used for logging and metrics.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Semantic-version of the strategy implementation.
        /// </summary>
        string Version { get; }

        /// <summary>
        /// Executes the transformation asynchronously.
        /// </summary>
        Task<TOut> TransformAsync(TIn input, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Attribute used to mark classes as transformation strategies so they can be discovered via reflection.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited = false)]
    public sealed class TransformationAttribute : Attribute
    {
        public TransformationAttribute(string name, string version)
        {
            Name = name;
            Version = version;
        }

        public string Name { get; }
        public string Version { get; }
    }

    #region Concrete Strategy — Focus-Time Ratio

    /// <summary>
    /// Enumeration describing the high-level “kind” of a calendar entry.
    /// </summary>
    public enum CalendarEventType
    {
        Focus,
        Meeting,
        Break,
        Unknown
    }

    /// <summary>
    /// Raw calendar event as emitted by the ingestion Lambda.
    /// </summary>
    /// <param name="UserId">Employee identifier (email, sAMAccountName, etc.).</param>
    /// <param name="StartUtc">Inclusive UTC start timestamp.</param>
    /// <param name="EndUtc">Exclusive UTC end timestamp.</param>
    /// <param name="EventType">Semantic classification of the event.</param>
    /// <param name="SourceSystem">Originating system (“Google Calendar”, “Outlook”, …).</param>
    public sealed record CalendarEvent(
        string UserId,
        DateTime StartUtc,
        DateTime EndUtc,
        CalendarEventType EventType,
        string SourceSystem);

    /// <summary>
    /// Result object containing the daily focus-time ratio for a single user.
    /// </summary>
    /// <param name="UserId">Employee identifier.</param>
    /// <param name="DateUtc">Calendar date (midnight-anchored, UTC).</param>
    /// <param name="FocusMinutes">Total minutes classified as “Focus”.</param>
    /// <param name="TotalMinutes">Total minutes across all events.</param>
    /// <param name="FocusRatio">FocusMinutes ÷ TotalMinutes (0..1).</param>
    public sealed record FocusTimeRatioResult(
        string UserId,
        DateTime DateUtc,
        double FocusMinutes,
        double TotalMinutes,
        double FocusRatio);

    /// <summary>
    /// Transformation that converts raw calendar events into day-level focus-time ratios.
    /// </summary>
    [Transformation("FocusTimeRatio", "1.0.0")]
    public sealed class FocusTimeRatioStrategy
        : ITransformationStrategy<IReadOnlyCollection<CalendarEvent>, IReadOnlyCollection<FocusTimeRatioResult>>
    {
        private readonly ILogger<FocusTimeRatioStrategy> _logger;

        public FocusTimeRatioStrategy(ILogger<FocusTimeRatioStrategy> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public string Name    => "FocusTimeRatio";
        public string Version => "1.0.0";

        public async Task<IReadOnlyCollection<FocusTimeRatioResult>> TransformAsync(
            IReadOnlyCollection<CalendarEvent> input,
            CancellationToken cancellationToken = default)
        {
            if (input is null)
                throw new ArgumentNullException(nameof(input));

            if (input.Count == 0)
            {
                _logger.LogDebug("{Strategy}/{Version} invoked with empty payload.",
                                 Name, Version);
                return Array.Empty<FocusTimeRatioResult>();
            }

            // Compute per-user, per-day aggregates.
            var results = input
                .GroupBy(e => new { e.UserId, Day = e.StartUtc.Date })
                .Select(group =>
                {
                    double focusMinutes = 0;
                    double totalMinutes = 0;

                    foreach (var ev in group)
                    {
                        cancellationToken.ThrowIfCancellationRequested();

                        var duration = (ev.EndUtc - ev.StartUtc).TotalMinutes;
                        if (duration < 0)
                        {
                            _logger.LogWarning(
                                "Discarding calendar event with negative duration: {@Event}", ev);
                            continue;
                        }

                        totalMinutes += duration;
                        if (ev.EventType == CalendarEventType.Focus)
                            focusMinutes += duration;
                    }

                    var ratio = totalMinutes == 0
                        ? 0
                        : focusMinutes / totalMinutes;

                    return new FocusTimeRatioResult(
                        group.Key.UserId,
                        group.Key.Day,
                        Math.Round(focusMinutes, 2),
                        Math.Round(totalMinutes, 2),
                        Math.Round(ratio, 4));
                })
                .Where(r => r.TotalMinutes > 0) // Filter out days with no activity.
                .ToArray();

            return await Task.FromResult(results);
        }
    }

    #endregion

    #region Dependency-Injection Convenience Extensions

    /// <summary>
    /// Extension helpers to auto-register all transformation strategies that live
    /// in the given assembly (or inside the calling assembly if omitted).
    /// </summary>
    public static class TransformationServiceCollectionExtensions
    {
        /// <summary>
        /// Scans the supplied assembly for <see cref="TransformationAttribute"/>d-types
        /// implementing <see cref="ITransformationStrategy{TIn,TOut}"/> and registers
        /// them as transient services.
        /// </summary>
        public static IServiceCollection AddTransformationStrategies(
            this IServiceCollection services,
            Assembly? assemblyToScan = null)
        {
            assemblyToScan ??= Assembly.GetCallingAssembly();

            var strategyTypes = assemblyToScan
                .GetTypes()
                .Where(t => !t.IsAbstract && !t.IsInterface)
                .Where(t => t.GetCustomAttribute<TransformationAttribute>() != null)
                .Where(ImplementsOpenGenericITransformation)
                .ToArray();

            foreach (var type in strategyTypes)
                services.AddTransient(type);

            return services;
        }

        private static bool ImplementsOpenGenericITransformation(Type type)
            => type.GetInterfaces()
                   .Any(i => i.IsGenericType &&
                             i.GetGenericTypeDefinition() == typeof(ITransformationStrategy<,>));
    }

    #endregion
}
```