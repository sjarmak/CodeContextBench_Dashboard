```csharp
// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Module6.TransformationStrategies.cs"
//            project="PulseOps Warehouse — Serverless Productivity Intelligence Fabric">
//     © 2024 PulseOps, Inc.  All rights reserved.
//     Unauthorized copying of this file, via any medium, is strictly prohibited.
// --------------------------------------------------------------------------------------------------------------------
//
//   PURPOSE
//   =======
//   Provides pluggable KPI–transformation strategies (Strategy-Pattern) plus
//   a coordinating engine that selects, executes, and monitors them.  Each
//   strategy ingests a generic TransformationContext, executes domain-specific
//   business logic, and produces a strongly-typed KpiResult.  New KPIs can be
//   introduced at runtime without redeploying the Lambdas—simply drop-in a
//   new implementation that adheres to ITransformationStrategy.
//
// --------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region Public Abstractions

    /// <summary>
    ///     Strongly–typed discriminant to identify a KPI type.
    /// </summary>
    public enum KpiType
    {
        FocusTimeRatio,
        DeploymentLeadTime,
        MeetingCostIndex
    }

    /// <summary>
    ///     Represents the raw domain data required by a KPI strategy.
    /// </summary>
    /// <remarks>
    ///     For simplicity this is a multiplexed payload.  In production, each KPI
    ///     is modeled by a dedicated immutable record.
    /// </remarks>
    public sealed record TransformationContext(
        Guid TenantId,
        DateTimeOffset WindowStart,
        DateTimeOffset WindowEnd,
        IReadOnlyCollection<CalendarEvent> CalendarEvents,
        IReadOnlyCollection<GitDeploymentEvent> GitDeployments);

    /// <summary>
    ///     Base contract for KPI calculation strategies.
    /// </summary>
    public interface ITransformationStrategy
    {
        KpiType Kpi { get; }

        /// <summary>
        ///     Executes domain transformation asynchronously.
        /// </summary>
        /// <returns>Calculated KPI.</returns>
        Task<KpiResult> TransformAsync(
            TransformationContext context,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    ///     Represents a calculated KPI result.
    /// </summary>
    public sealed record KpiResult(
        Guid TenantId,
        KpiType Kpi,
        double Value,
        string Unit,
        DateTimeOffset CalculatedAtUtc);

    /// <summary>
    ///     User–visible exception for a transformation failure.
    /// </summary>
    public sealed class TransformationException : Exception
    {
        public TransformationException(string message, Exception? inner = null)
            : base(message, inner)
        {
        }
    }

    #endregion

    #region Domain DTOs (simplified)

    public sealed record CalendarEvent(
        DateTimeOffset StartUtc,
        DateTimeOffset EndUtc,
        string Subject,
        bool IsFocusTime);

    public sealed record GitDeploymentEvent(
        string CommitSha,
        DateTimeOffset BuildStartUtc,
        DateTimeOffset ProdDeployUtc);

    #endregion

    #region Strategy Implementations

    /// <summary>
    ///     Calculates the ratio between focus time and total scheduled time
    ///     inside the specified window.
    /// </summary>
    public sealed class FocusTimeRatioStrategy : ITransformationStrategy
    {
        public KpiType Kpi => KpiType.FocusTimeRatio;

        public Task<KpiResult> TransformAsync(
            TransformationContext context,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(context);

            double focusMinutes = context.CalendarEvents
                .Where(e => e.IsFocusTime &&
                            e.StartUtc < context.WindowEnd &&
                            e.EndUtc > context.WindowStart)
                .Sum(e => (e.EndUtc - e.StartUtc).TotalMinutes);

            double totalMinutes = context.CalendarEvents
                .Where(e => e.StartUtc < context.WindowEnd &&
                            e.EndUtc > context.WindowStart)
                .Sum(e => (e.EndUtc - e.StartUtc).TotalMinutes);

            double ratio = totalMinutes <= 0 ? 0 : focusMinutes / totalMinutes;

            return Task.FromResult(new KpiResult(
                context.TenantId,
                Kpi,
                Math.Round(ratio, 4),
                "%",
                DateTimeOffset.UtcNow));
        }
    }

    /// <summary>
    ///     Calculates Deployment Lead-Time (build-start to prod deploy) in hours.
    /// </summary>
    public sealed class DeploymentLeadTimeStrategy : ITransformationStrategy
    {
        public KpiType Kpi => KpiType.DeploymentLeadTime;

        public Task<KpiResult> TransformAsync(
            TransformationContext context,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(context);

            var deploymentDurations = context.GitDeployments
                .Select(d => (d.ProdDeployUtc - d.BuildStartUtc).TotalHours)
                .ToList();

            double averageHours = deploymentDurations.Any()
                ? deploymentDurations.Average()
                : 0d;

            return Task.FromResult(new KpiResult(
                context.TenantId,
                Kpi,
                Math.Round(averageHours, 2),
                "hours",
                DateTimeOffset.UtcNow));
        }
    }

    /// <summary>
    ///     Calculates meeting cost index (fictional formula).
    /// </summary>
    public sealed class MeetingCostIndexStrategy : ITransformationStrategy
    {
        private const double AverageSalaryPerMinuteUsd = 1.2;

        public KpiType Kpi => KpiType.MeetingCostIndex;

        public Task<KpiResult> TransformAsync(
            TransformationContext context,
            CancellationToken cancellationToken = default)
        {
            double meetingMinutes = context.CalendarEvents
                .Where(e => !e.IsFocusTime)
                .Sum(e => (e.EndUtc - e.StartUtc).TotalMinutes);

            double costUsd = meetingMinutes * AverageSalaryPerMinuteUsd;

            return Task.FromResult(new KpiResult(
                context.TenantId,
                Kpi,
                Math.Round(costUsd, 2),
                "USD",
                DateTimeOffset.UtcNow));
        }
    }

    #endregion

    #region Strategy Selector & Engine

    /// <summary>
    ///     Discovers and provides access to available KPI strategies.
    ///     Thread-safe and lazy.
    /// </summary>
    public sealed class StrategyRegistry
    {
        private readonly ConcurrentDictionary<KpiType, ITransformationStrategy> _map;

        public StrategyRegistry(IEnumerable<ITransformationStrategy>? overrides = null)
        {
            _map = new ConcurrentDictionary<KpiType, ITransformationStrategy>();

            // Discover built‐ins
            Register(new FocusTimeRatioStrategy());
            Register(new DeploymentLeadTimeStrategy());
            Register(new MeetingCostIndexStrategy());

            // Apply runtime overrides
            if (overrides != null)
            {
                foreach (var strategy in overrides)
                    Register(strategy, overwrite: true);
            }
        }

        public bool Register(ITransformationStrategy strategy, bool overwrite = false)
        {
            if (overwrite)
            {
                _map.AddOrUpdate(strategy.Kpi, strategy, (_, _) => strategy);
                return true;
            }

            return _map.TryAdd(strategy.Kpi, strategy);
        }

        public bool TryGet(KpiType kpi, out ITransformationStrategy strategy)
            => _map.TryGetValue(kpi, out strategy!);
    }

    /// <summary>
    ///     Coordinates the execution of multiple KPI strategies in parallel and
    ///     aggregates their results.
    /// </summary>
    public sealed class ProductivityKpiEngine
    {
        private readonly StrategyRegistry _registry;
        private readonly ILogger<ProductivityKpiEngine> _logger;

        public ProductivityKpiEngine(
            StrategyRegistry registry,
            ILogger<ProductivityKpiEngine> logger)
        {
            _registry = registry ?? throw new ArgumentNullException(nameof(registry));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        ///     Executes the specified KPI set.  On failure, each result gets a null
        ///     entry rather than blowing up the entire batch (fail-soft).
        /// </summary>
        public async Task<IReadOnlyCollection<KpiResult?>> ExecuteAsync(
            TransformationContext context,
            IEnumerable<KpiType> kpis,
            CancellationToken cancellationToken = default)
        {
            var sw = Stopwatch.StartNew();

            var tasks = kpis.Select(kpi => ExecuteSingleAsync(context, kpi, cancellationToken));
            var results = await Task.WhenAll(tasks).ConfigureAwait(false);

            _logger.LogInformation(
                "Executed {KpiCount} KPI strategies for Tenant={TenantId} in {ElapsedMs} ms",
                results.Length,
                context.TenantId,
                sw.ElapsedMilliseconds);

            return results;
        }

        private async Task<KpiResult?> ExecuteSingleAsync(
            TransformationContext context,
            KpiType kpi,
            CancellationToken cancellationToken)
        {
            if (!_registry.TryGet(kpi, out var strategy))
            {
                _logger.LogWarning("No strategy registered for KPI={Kpi}", kpi);
                return null;
            }

            try
            {
                _logger.LogDebug("Executing KPI={Kpi} for Tenant={Tenant}", kpi, context.TenantId);
                return await strategy.TransformAsync(context, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Failed to calculate KPI={Kpi} for Tenant={TenantId}", kpi, context.TenantId);

                // Persist to DLQ, trigger PagerDuty, etc. (omitted)
                return null;
            }
        }
    }

    #endregion
}
```