```csharp
// --------------------------------------------------------------------------------------------------------------------
// <copyright
//     file="FocusTimeKpiTransformationStrategy.cs"
//     company="PulseOps, Inc.">
//   © PulseOps, Inc. 2024.  All rights reserved.
// </copyright>
// <summary>
//   Strategy implementation that converts heterogeneous raw–event streams
//   (calendar, IDE-activity, SCM hooks) into a daily Focus-Time KPI record.
//   The Focus-Time KPI is defined as the fraction of a work-day that is spent
//   in sustained, uninterrupted focus activities (coding, code-review, design)
//   versus the total minutes worked.
// </summary>
// --------------------------------------------------------------------------------------------------------------------

#nullable enable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using PulseOps.Warehouse.Abstractions.Events;
using PulseOps.Warehouse.Abstractions.Kpis;
using PulseOps.Warehouse.Abstractions.Strategies;

namespace PulseOps.Warehouse.Transformations;

/// <summary>
/// Concrete Strategy for calculating Focus-Time KPI.
/// </summary>
[StrategyMetadata(
    Key           = "focus_time",
    DisplayName   = "Focus-Time Ratio",
    Version       = "1.3.0",
    Description   = "Computes daily ratio of uninterrupted focus minutes to total working minutes.")]
public sealed class FocusTimeKpiTransformationStrategy : IKpiTransformationStrategy
{
    private const int MinimumFocusBlockMinutes = 25;          // Pomodoro-style assumption
    private const int MaximumFocusGapMinutes   =  5;          // Allows short context switches
    private static readonly TimeSpan WorkDayStart = new( 8, 0, 0);   // 08:00
    private static readonly TimeSpan WorkDayEnd   = new(18, 0, 0);   // 18:00

    private readonly ILogger<FocusTimeKpiTransformationStrategy> _logger;

    public FocusTimeKpiTransformationStrategy(
        ILogger<FocusTimeKpiTransformationStrategy> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public string KpiName => "focus_time_ratio";

    /// <inheritdoc />
    public async ValueTask<KpiRecord> TransformAsync(
        IReadOnlyCollection<RawEvent> events,
        CancellationToken cancellationToken = default)
    {
        if (events is null)
        {
            throw new ArgumentNullException(nameof(events));
        }

        cancellationToken.ThrowIfCancellationRequested();

        // Partition by local day of the user inferred from event.TimeZone.
        // This strategy only handles one user-day worth of events at a time,
        // enforced by the caller.  Still, we guard against leakage.
        var grouped = events
            .GroupBy(e => ConvertUtcToUserLocal(e.TimestampUtc, e.TimeZoneId).Date);

        if (grouped.Count() != 1)
        {
            throw new InvalidOperationException(
                "FocusTime strategy expects events for a single user-day.");
        }

        var dayEvents = grouped.Single()
            .OrderBy(e => e.TimestampUtc) // chronological
            .ToList();

        // Filter only working-hours events to remove off-hours noise.
        var workingHoursEvents = dayEvents
            .Where(IsWithinWorkDay)
            .ToList();

        if (workingHoursEvents.Count == 0)
        {
            _logger.LogWarning(
                "No in-hours events found for user {UserId} on {Date}.  Returning KPI = 0.",
                dayEvents.First().UserId,
                grouped.Key.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture));

            return BuildKpiRecord(
                grouped.Key,
                userId: dayEvents.First().UserId,
                focusMinutes: 0,
                totalMinutes: 0,
                sourceSampleSize: 0);
        }

        // Calculate total worked minutes (approximation) by summing event durations.
        var totalWorkedMinutes = (int)Math.Round(
            workingHoursEvents.Sum(e => e.DurationMinutes));

        // Merge adjacent focus windows for a more accurate uninterrupted focus-time view.
        var focusEvents = workingHoursEvents
            .Where(e => e.EventType is EventType.IdeActivity or EventType.CodeReview)
            .ToList();

        var consolidatedFocusBlocks = MergeCloseEvents(focusEvents);

        var focusMinutes = consolidatedFocusBlocks
            .Where(block => block.DurationMinutes >= MinimumFocusBlockMinutes)
            .Sum(block => block.DurationMinutes);

        return BuildKpiRecord(
            grouped.Key,
            userId: dayEvents.First().UserId,
            focusMinutes: focusMinutes,
            totalMinutes: totalWorkedMinutes,
            sourceSampleSize: workingHoursEvents.Count);
    }

    #region Helpers

    private static IEnumerable<RawEvent> MergeCloseEvents(List<RawEvent> events)
    {
        if (events.Count == 0)
        {
            yield break;
        }

        // Assumes events sorted ascending by timestamp (caller ensures this).
        var currentStart      = events[0].TimestampUtc;
        var currentEnd        = events[0].TimestampUtc.AddMinutes(events[0].DurationMinutes);
        var currentDuration   = events[0].DurationMinutes;
        var currentTimeZoneId = events[0].TimeZoneId;
        var userId            = events[0].UserId;
        var source            = events[0].Source;

        for (var i = 1; i < events.Count; i++)
        {
            var e = events[i];
            var gapMinutes = (e.TimestampUtc - currentEnd).TotalMinutes;

            if (gapMinutes <= MaximumFocusGapMinutes)
            {
                // Extend the current block
                currentEnd      = e.TimestampUtc.AddMinutes(e.DurationMinutes);
                currentDuration += (int)Math.Round(e.DurationMinutes);
            }
            else
            {
                // Yield current block
                yield return CreateSyntheticEvent();
                // Start new block
                currentStart      = e.TimestampUtc;
                currentEnd        = e.TimestampUtc.AddMinutes(e.DurationMinutes);
                currentDuration   = e.DurationMinutes;
                currentTimeZoneId = e.TimeZoneId;
                source            = e.Source;
            }
        }

        // yield final block
        yield return CreateSyntheticEvent();

        RawEvent CreateSyntheticEvent() => new()
        {
            EventId         = $"merged-{Guid.NewGuid():N}",
            EventType       = EventType.IdeActivity, // semantic placeholder
            TimestampUtc    = currentStart,
            DurationMinutes = currentDuration,
            UserId          = userId,
            TimeZoneId      = currentTimeZoneId,
            Source          = source,
            RawPayload      = JsonSerializer.Serialize(
                new
                {
                    synthetic = true,
                    merged    = true,
                    original  = "FocusTimeKpiTransformationStrategy"
                })
        };
    }

    private static DateTime ConvertUtcToUserLocal(DateTime utc, string? timeZoneId)
    {
        if (string.IsNullOrWhiteSpace(timeZoneId))
        {
            return utc;
        }

        try
        {
#if NET6_0_OR_GREATER
            var tz = TimeZoneInfo.FindSystemTimeZoneById(timeZoneId);
#else
            var tz = TimeZoneInfo.FindSystemTimeZoneById(timeZoneId);
#endif
            return TimeZoneInfo.ConvertTimeFromUtc(utc, tz);
        }
        catch (TimeZoneNotFoundException)
        {
            // Fallback to UTC when time-zone mis-configured; caller can track metrics.
            return utc;
        }
    }

    private static bool IsWithinWorkDay(RawEvent e)
    {
        var localTime = ConvertUtcToUserLocal(e.TimestampUtc, e.TimeZoneId).TimeOfDay;
        return localTime >= WorkDayStart && localTime <= WorkDayEnd;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private KpiRecord BuildKpiRecord(
        DateTime day,
        string userId,
        int focusMinutes,
        int totalMinutes,
        int sourceSampleSize)
    {
        var ratio = totalMinutes == 0 ? 0d : (double)focusMinutes / totalMinutes;

        var record = new KpiRecord
        {
            KpiName          = KpiName,
            UserId           = userId,
            PeriodStartDate  = day,
            PeriodEndDate    = day,
            NumericValue     = Math.Round(ratio, 4, MidpointRounding.AwayFromZero),
            Unit             = "%",
            Metadata         = new Dictionary<string, object?>
            {
                ["focus_minutes"]       = focusMinutes,
                ["total_minutes"]       = totalMinutes,
                ["source_sample_size"]  = sourceSampleSize,
                ["minimum_block_min"]   = MinimumFocusBlockMinutes,
                ["maximum_gap_min"]     = MaximumFocusGapMinutes,
                ["strategy_version"]    = "1.3.0"
            }
        };

        _logger.LogInformation(
            "Generated Focus-Time KPI for user {UserId} on {Date} => {Ratio:P2} ({Focus}/{Total} mins) [{Sample} evts]",
            userId,
            day.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture),
            ratio,
            focusMinutes,
            totalMinutes,
            sourceSampleSize);

        return record;
    }

    #endregion
}
```