```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations.KpiStrategies
{
    /// <summary>
    ///     Calculates the total cost of a calendar meeting based on duration,
    ///     attendee hourly rates, and organizational modifiers (e.g. contractor uplift).
    ///     The result is exposed as <see cref="MeetingCostRecord"/>.
    ///
    ///     This strategy is later aggregated by downstream Lambdas to construct the
    ///     Meeting-Cost-Index KPI across teams, departments, or cost centres.
    /// </summary>
    public sealed class MeetingCostIndexStrategy : ITransformationStrategy<CalendarEventRecord, MeetingCostRecord>
    {
        private readonly IRateCardProvider _rateCardProvider;
        private readonly ILogger<MeetingCostIndexStrategy> _logger;

        public MeetingCostIndexStrategy(
            IRateCardProvider rateCardProvider,
            ILogger<MeetingCostIndexStrategy> logger)
        {
            _rateCardProvider = rateCardProvider ?? throw new ArgumentNullException(nameof(rateCardProvider));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc/>
        public async Task<MeetingCostRecord?> TransformAsync(
            CalendarEventRecord input,
            CancellationToken cancellationToken = default)
        {
            if (input is null)
            {
                throw new ArgumentNullException(nameof(input));
            }

            if (!input.Attendees.Any())
            {
                _logger.LogWarning("Calendar event '{EventId}' has no attendees — cost evaluation skipped.",
                                   input.EventId);
                return null;
            }

            try
            {
                var durationHours = (decimal)(input.EndTimeUtc - input.StartTimeUtc).TotalMinutes / 60m;
                if (durationHours <= 0)
                {
                    _logger.LogWarning("Calendar event '{EventId}' duration is <= 0. Event ignored.", input.EventId);
                    return null;
                }

                var costByAttendee = new ConcurrentBag<decimal>();

                // Parallelise rate look-ups for events with hundreds of attendees.
                await Parallel.ForEachAsync(input.Attendees, cancellationToken, async (attendee, ct) =>
                {
                    var hourlyRate = await _rateCardProvider.GetHourlyRateAsync(attendee, ct)
                                                            .ConfigureAwait(false);

                    costByAttendee.Add(hourlyRate * durationHours);
                });

                var totalCost = costByAttendee.Sum();

                var output = new MeetingCostRecord
                {
                    EventId = input.EventId,
                    StartTimeUtc = input.StartTimeUtc,
                    EndTimeUtc = input.EndTimeUtc,
                    CalculatedCost = Math.Round(totalCost, 2, MidpointRounding.AwayFromZero),
                    Currency = _rateCardProvider.CurrencyCode
                };

                _logger.LogDebug("Calculated meeting cost for '{EventId}': {Cost} {Currency}.",
                                 input.EventId,
                                 output.CalculatedCost.ToString("F2", CultureInfo.InvariantCulture),
                                 output.Currency);

                return output;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Fatal error while calculating MeetingCostIndex for event '{EventId}'.",
                                 input.EventId);
                throw;
            }
        }
    }

    #region Service-Registration Extension

    /// <summary>
    ///     Wiring helper to register <see cref="MeetingCostIndexStrategy"/> and its dependencies
    ///     with the application's <see cref="IServiceCollection"/>.
    /// </summary>
    public static class MeetingCostIndexStrategyServiceCollectionExtensions
    {
        public static IServiceCollection AddMeetingCostIndexStrategy(this IServiceCollection services)
        {
            return services
                .AddSingleton<IRateCardProvider, CachedRateCardProvider>() // pluggable provider
                .AddSingleton<ITransformationStrategy<CalendarEventRecord, MeetingCostRecord>,
                              MeetingCostIndexStrategy>();
        }
    }

    #endregion

    #region Domain Contracts

    /// <summary>
    ///     Generic contract for pluggable data-transformation strategies.
    /// </summary>
    public interface ITransformationStrategy<in TInput, TResult>
    {
        /// <summary>
        ///     Transforms an input record into <typeparamref name="TResult"/>.
        ///     Returns <c>null</c> when a record should be skipped.
        /// </summary>
        Task<TResult?> TransformAsync(TInput input, CancellationToken cancellationToken = default);
    }

    /// <summary>
    ///     Lightweight representation of a calendar event emitted from the ingestion pipeline.
    /// </summary>
    public sealed class CalendarEventRecord
    {
        public required string EventId { get; init; }
        public required DateTime StartTimeUtc { get; init; }
        public required DateTime EndTimeUtc { get; init; }

        public IReadOnlyCollection<Attendee> Attendees { get; init; } = Array.Empty<Attendee>();
    }

    /// <summary>
    ///     Minimal attendee descriptor. Extended fields omitted for brevity.
    /// </summary>
    public sealed class Attendee
    {
        public required string Email { get; init; }
        public string? Role { get; init; }
        public string? Department { get; init; }
        public bool IsContractor { get; init; }
    }

    /// <summary>
    ///     Resulting record containing monetary valuation of a calendar event.
    /// </summary>
    public sealed class MeetingCostRecord
    {
        public required string EventId { get; init; }
        public required DateTime StartTimeUtc { get; init; }
        public required DateTime EndTimeUtc { get; init; }

        /// <summary>The total cost (currency defined by <see cref="Currency"/>).</summary>
        public required decimal CalculatedCost { get; init; }

        /// <summary>
        ///     ISO-4217 currency code.
        /// </summary>
        public required string Currency { get; init; }
    }

    #endregion

    #region Rate-Card Provider

    /// <summary>
    ///     Abstraction responsible for supplying hourly rates for users.
    ///     The implementation may source data from AWS DynamoDB, S3, or an external HR API.
    /// </summary>
    public interface IRateCardProvider
    {
        string CurrencyCode { get; }

        /// <summary>
        ///     Resolves the hourly rate for a given <see cref="Attendee"/>.
        /// </summary>
        Task<decimal> GetHourlyRateAsync(Attendee attendee, CancellationToken cancellationToken = default);
    }

    /// <summary>
    ///     Production-ready implementation that caches rate-card look-ups in memory for 15 minutes
    ///     to minimise chattiness against the underlying data source.
    /// </summary>
    public sealed class CachedRateCardProvider : IRateCardProvider, IDisposable
    {
        private readonly IMemoryCache _cache;
        private readonly ILogger<CachedRateCardProvider> _logger;

        // Simulated backing store (would be an async repository in real life)
        private static readonly IDictionary<string, decimal> _hrDatabaseMock = new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase)
        {
            ["engineering"] = 95.00m,
            ["product"]     = 85.00m,
            ["sales"]       = 70.00m,
            ["default"]     = 60.00m
        };

        public CachedRateCardProvider(ILogger<CachedRateCardProvider> logger)
        {
            _cache  = new MemoryCache(new MemoryCacheOptions());
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public string CurrencyCode => "USD";

        /// <inheritdoc/>
        public Task<decimal> GetHourlyRateAsync(Attendee attendee, CancellationToken cancellationToken = default)
        {
            if (attendee is null)
                throw new ArgumentNullException(nameof(attendee));

            // Normalise cache key (email preferred for uniqueness; fallback to dept)
            var cacheKey = $"rate:{attendee.Email.ToLowerInvariant()}";

            if (_cache.TryGetValue<decimal>(cacheKey, out var cachedRate))
            {
                return Task.FromResult(cachedRate);
            }

            // Simulate expensive I/O latency
            return Task.Run(async () =>
            {
                _logger.LogTrace("Fetching hourly rate for {Email} from backing store…", attendee.Email);

                await Task.Delay(TimeSpan.FromMilliseconds(20), cancellationToken)
                          .ConfigureAwait(false);

                var baseRate = ResolveRateFromMock(attendee);
                var adjustedRate = attendee.IsContractor ? baseRate * 1.2m : baseRate; // contractor uplift

                // Cache for 15 minutes with sliding expiration
                _cache.Set(cacheKey, adjustedRate, new MemoryCacheEntryOptions
                {
                    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(15)
                });

                return adjustedRate;

            }, cancellationToken);
        }

        private static decimal ResolveRateFromMock(Attendee attendee)
        {
            if (!string.IsNullOrWhiteSpace(attendee.Department) &&
                _hrDatabaseMock.TryGetValue(attendee.Department, out var deptRate))
            {
                return deptRate;
            }

            // Fallback by role
            if (!string.IsNullOrWhiteSpace(attendee.Role) &&
                _hrDatabaseMock.TryGetValue(attendee.Role, out var roleRate))
            {
                return roleRate;
            }

            return _hrDatabaseMock["default"];
        }

        public void Dispose() => _cache.Dispose();
    }

    #endregion
}
```