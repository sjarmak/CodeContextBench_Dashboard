```csharp
// File: src/module_55.txt
// Project: PulseOps Warehouse — Serverless Productivity Intelligence Fabric (data_warehouse)
// Description: Transformation-layer components that implement the Strategy Pattern for KPI
//              computation.  Strategies are discovered automatically via reflection and can
//              be swapped/added without redeploying the core orchestrator.
//
// NOTE: file is saved with .txt extension to satisfy code-generation constraints in this
//       challenge, but would normally be placed under src/Transformations/ in a .cs file.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace PulseOps.Warehouse.Transformations
{
    #region ======= Domain Models =============================================================

    /// <summary>
    /// Generic event wrapper produced by upstream ingestion Lambdas before landing in the lake.
    /// </summary>
    public sealed record EventEnvelope
    {
        public Guid              EventId     { get; init; } = Guid.NewGuid();
        public DateTimeOffset    Timestamp   { get; init; } = DateTimeOffset.UtcNow;
        public string            EventType   { get; init; } = string.Empty;
        public JsonElement       Payload     { get; init; }
    }

    /// <summary>
    /// Canonical KPI record emitted by transformation strategies and stored in the warehouse.
    /// </summary>
    public sealed record KpiRecord
    {
        public Guid            KpiId        { get; init; } = Guid.NewGuid();
        public string          KpiName      { get; init; } = string.Empty;
        public double          Value        { get; init; }
        public DateTimeOffset  CalculatedAt { get; init; } = DateTimeOffset.UtcNow;
        public IDictionary<string, string> Dimensions { get; init; } =
            new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
    }

    #endregion

    #region ======= Attributes & Interfaces ===================================================

    /// <summary>
    /// Decorates a concrete strategy making it discoverable at runtime.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public sealed class TransformationStrategyAttribute : Attribute
    {
        public TransformationStrategyAttribute(string name) => Name = name;

        /// <summary>
        /// Unique name used for look-ups (case-insensitive).
        /// </summary>
        public string Name { get; }
    }

    /// <summary>
    /// Contract that every KPI transformation strategy must follow.
    /// </summary>
    public interface IKpiTransformationStrategy
    {
        /// <summary>Human-readable name — must match <see cref="TransformationStrategyAttribute"/> </summary>
        string StrategyName { get; }

        /// <summary>
        /// True if this strategy is interested in the provided event.
        /// Enables fast pre-filtering.
        /// </summary>
        bool CanHandle(EventEnvelope envelope);

        /// <summary>
        /// Computes KPI records for the supplied set of events.
        /// Implementations are responsible for ensuring thread-safety.
        /// </summary>
        /// <param name="events">Events that passed <see cref="CanHandle"/> filter.</param>
        /// <param name="cancellationToken">Cancellation token from upstream orchestrator.</param>
        /// <returns>Zero or more KPI records.</returns>
        IAsyncEnumerable<KpiRecord> TransformAsync(
            IAsyncEnumerable<EventEnvelope> events,
            CancellationToken cancellationToken = default);
    }

    #endregion

    #region ======= Strategy Implementations ==================================================

    /// <summary>
    /// Calculates the focus-time ratio (maker vs meeting time) on a per-user/day basis.
    /// </summary>
    [TransformationStrategy("focus_time_ratio")]
    public sealed class FocusTimeRatioStrategy : IKpiTransformationStrategy
    {
        private const string EventTypeMeeting      = "calendar_meeting";
        private const string EventTypeCodeFocus    = "code_focus_window";
        private static readonly TimeSpan OneMinute = TimeSpan.FromMinutes(1);

        public string StrategyName => "focus_time_ratio";

        public bool CanHandle(EventEnvelope envelope) =>
            envelope.EventType is EventTypeMeeting or EventTypeCodeFocus;

        public async IAsyncEnumerable<KpiRecord> TransformAsync(
            IAsyncEnumerable<EventEnvelope> events,
            [System.Runtime.CompilerServices.EnumeratorCancellation]
            CancellationToken cancellationToken = default)
        {
            // group by user + date; accumulate durations
            var buckets = new ConcurrentDictionary<(string user, DateOnly date),
                                                   (double focusMinutes, double meetingMinutes)>();

            await foreach (var envelope in events.WithCancellation(cancellationToken))
            {
                var user = ExtractUser(envelope) ?? "unknown";
                var date = DateOnly.FromDateTime(envelope.Timestamp.UtcDateTime);

                var durationMin = ExtractDurationMinutes(envelope);
                if (durationMin < 0.01) continue; // guard against bogus durations

                buckets.AddOrUpdate(
                    (user, date),
                    key => envelope.EventType == EventTypeCodeFocus
                        ? (focusMinutes: durationMin, meetingMinutes: 0)
                        : (focusMinutes: 0, meetingMinutes: durationMin),
                    (key, existing) =>
                    {
                        if (envelope.EventType == EventTypeCodeFocus)
                            return (existing.focusMinutes + durationMin, existing.meetingMinutes);
                        return (existing.focusMinutes, existing.meetingMinutes + durationMin);
                    });
            }

            foreach (var ((user, date), (focus, meeting)) in buckets)
            {
                var total = focus + meeting;
                if (total < OneMinute.TotalMinutes) continue; // negligible — skip
                yield return new KpiRecord
                {
                    KpiName   = "focus_time_ratio",
                    Value     = focus / total,
                    Dimensions = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
                    {
                        ["user"] = user,
                        ["date"] = date.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture)
                    }
                };
            }
        }

        private static string? ExtractUser(EventEnvelope e) =>
            e.Payload.TryGetProperty("user", out var userProp) && userProp.ValueKind == JsonValueKind.String
                ? userProp.GetString()
                : null;

        private static double ExtractDurationMinutes(EventEnvelope e) =>
            e.Payload.TryGetProperty("durationSeconds", out var durProp) &&
            durProp.TryGetDouble(out var seconds)
                ? seconds / 60d
                : 0d;
    }

    /// <summary>
    /// Calculates deployment lead-time (code commit -> prod deploy) for each release.
    /// </summary>
    [TransformationStrategy("deployment_lead_time")]
    public sealed class DeploymentLeadTimeStrategy : IKpiTransformationStrategy
    {
        private const string EventTypeCommit  = "code_commit";
        private const string EventTypeDeploy  = "deployment_completed";

        public string StrategyName => "deployment_lead_time";

        public bool CanHandle(EventEnvelope envelope) =>
            envelope.EventType is EventTypeCommit or EventTypeDeploy;

        public async IAsyncEnumerable<KpiRecord> TransformAsync(
            IAsyncEnumerable<EventEnvelope> events,
            [System.Runtime.CompilerServices.EnumeratorCancellation]
            CancellationToken cancellationToken = default)
        {
            // map commitId -> commitTime
            var commits = new ConcurrentDictionary<string, DateTimeOffset>();

            // Because events might come out-of-order we buffer until deploy seen
            await foreach (var e in events.WithCancellation(cancellationToken))
            {
                switch (e.EventType)
                {
                    case EventTypeCommit:
                        if (e.Payload.TryGetProperty("commit", out var c) &&
                            c.TryGetProperty("id", out var idProp) &&
                            idProp.GetString() is { } commitId)
                        {
                            commits.TryAdd(commitId, e.Timestamp);
                        }
                        break;

                    case EventTypeDeploy:
                        if (e.Payload.TryGetProperty("commitId", out var cidProp) &&
                            cidProp.GetString() is { } id &&
                            commits.TryRemove(id, out var commitTime))
                        {
                            var leadTimeHours = (e.Timestamp - commitTime).TotalHours;
                            if (leadTimeHours < 0) continue; // clock skew -> ignore

                            var serviceName = e.Payload.TryGetProperty("service", out var svcProp)
                                ? svcProp.GetString() ?? "unknown"
                                : "unknown";

                            yield return new KpiRecord
                            {
                                KpiName = "deployment_lead_time",
                                Value   = leadTimeHours,
                                Dimensions = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
                                {
                                    ["service"] = serviceName,
                                    ["commitId"] = id
                                }
                            };
                        }
                        break;
                }
            }
        }
    }

    #endregion

    #region ======= Strategy Registry & Orchestrator ==========================================

    /// <summary>
    /// Discovers and caches all KPI transformation strategies available in the current AppDomain.
    /// Consumers should treat this class as a singleton (thread-safe).
    /// </summary>
    public sealed class StrategyRegistry
    {
        private readonly ImmutableDictionary<string, IKpiTransformationStrategy> _strategies;
        private readonly ILogger<StrategyRegistry>? _logger;

        public StrategyRegistry(ILogger<StrategyRegistry>? logger = null)
        {
            _logger = logger;
            _strategies = DiscoverStrategies();
        }

        /// <summary>Returns all registered strategies keyed by name (case-insensitive).</summary>
        public IReadOnlyDictionary<string, IKpiTransformationStrategy> Strategies => _strategies;

        /// <summary>Finds a strategy by name; returns null if not found.</summary>
        public bool TryGet(string name, out IKpiTransformationStrategy? strategy) =>
            _strategies.TryGetValue(name, out strategy);

        /// <summary>Internal discovery using reflection.</summary>
        private ImmutableDictionary<string, IKpiTransformationStrategy> DiscoverStrategies()
        {
            var discovered = new Dictionary<string, IKpiTransformationStrategy>(StringComparer.OrdinalIgnoreCase);

            foreach (var type in AppDomain.CurrentDomain.GetAssemblies()
                     .SelectMany(a => SafeGetTypes(a))
                     .Where(t => !t.IsAbstract &&
                                 typeof(IKpiTransformationStrategy).IsAssignableFrom(t) &&
                                 t.GetCustomAttribute<TransformationStrategyAttribute>() != null))
            {
                var attr = type.GetCustomAttribute<TransformationStrategyAttribute>()!;
                try
                {
                    if (Activator.CreateInstance(type) is IKpiTransformationStrategy instance)
                    {
                        discovered[attr.Name] = instance;
                        _logger?.LogInformation("Registered KPI strategy {Strategy}", attr.Name);
                    }
                }
                catch (Exception ex)
                {
                    _logger?.LogError(ex, "Failed to instantiate strategy {Strategy}", attr.Name);
                }
            }

            return discovered.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase);
        }

        private static IEnumerable<Type> SafeGetTypes(Assembly assembly)
        {
            try { return assembly.GetTypes(); }
            catch (ReflectionTypeLoadException ex) { return ex.Types.Where(t => t != null)!; }
        }
    }

    /// <summary>
    /// Coordinates transformation of raw events into KPI records using the registered strategies.
    /// Supports concurrent processing and cancellation tokens.
    /// </summary>
    public sealed class TransformationOrchestrator
    {
        private readonly StrategyRegistry _registry;
        private readonly ILogger<TransformationOrchestrator> _logger;
        private readonly int _maxDegreeOfParallelism;

        public TransformationOrchestrator(
            StrategyRegistry registry,
            ILogger<TransformationOrchestrator> logger,
            int maxDegreeOfParallelism = 4)
        {
            _registry = registry;
            _logger   = logger;
            _maxDegreeOfParallelism = Math.Max(1, maxDegreeOfParallelism);
        }

        public async Task<IReadOnlyList<KpiRecord>> ExecuteAsync(
            IAsyncEnumerable<EventEnvelope> inputEvents,
            IEnumerable<string>? strategyFilter = null,
            CancellationToken cancellationToken = default)
        {
            var filterSet = strategyFilter is null
                ? null
                : strategyFilter.Select(s => s.ToLowerInvariant()).ToHashSet();

            // Pre-select strategies
            var strategies = _registry.Strategies
                .Where(s => filterSet == null || filterSet.Contains(s.Key.ToLowerInvariant()))
                .Select(s => s.Value)
                .ToArray();

            if (strategies.Length == 0)
            {
                _logger.LogWarning("No strategies selected. Returning empty KPI set.");
                return Array.Empty<KpiRecord>();
            }

            // Partition the event stream once into memory-friendly buffer
            var buffer = new List<EventEnvelope>();
            await foreach (var e in inputEvents.WithCancellation(cancellationToken))
            {
                buffer.Add(e);
            }

            var outputBag = new ConcurrentBag<KpiRecord>();
            var parallelOptions = new ParallelOptions
            {
                CancellationToken = cancellationToken,
                MaxDegreeOfParallelism = _maxDegreeOfParallelism
            };

            try
            {
                Parallel.ForEach(strategies, parallelOptions, strategy =>
                {
                    var interestedEvents = buffer
                        .Where(strategy.CanHandle)
                        .ToAsyncEnumerable();

                    await strategy.TransformAsync(interestedEvents, cancellationToken)
                        .ForEachAwaitAsync(async kpi =>
                        {
                            outputBag.Add(kpi);
                            await Task.Yield(); // shift continuation to avoid sync-context issues
                        }, cancellationToken);
                });
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("Transformation orchestrator canceled.");
                throw;
            }

            return outputBag.ToArray();
        }
    }

    #endregion
}
```