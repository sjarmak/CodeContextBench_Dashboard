"""
UtilityChain Core Suite — GraphQL Schema (SDL)
==============================================

This schema exposes read (Query), write (Mutation), and real-time streaming
(Subscription) capabilities for the UtilityChain monolith.  It unifies
staking, governance, consensus, token, NFT, and smart-contract engine APIs
into a single contract that the gateway layer can surface over HTTP, WebSocket,
or gRPC transports.

NOTE:
• Scalars prefixed with `UC_` are custom and mapped in the .NET resolver layer.
• Authentication / authorisation is enforced via the @auth directive.
• Pagination follows the Relay Connection spec for forward & backward paging.
"""

# ---------------------------------------------------------------------------
# Custom Scalars
# ---------------------------------------------------------------------------

"""
RFC-3339 compliant date-time string with nanosecond precision.
"""
scalar UC_DateTime

"""
Unsigned 256-bit integer represented as a decimal string.
"""
scalar UC_BigInt

"""
Keccak-256 hash (32-byte hexadecimal string prefixed with 0x).
"""
scalar UC_Hash

"""
EIP-55 checksum-encoded 20-byte address prefixed with 0x.
"""
scalar UC_Address


# ---------------------------------------------------------------------------
# Directives
# ---------------------------------------------------------------------------

"""
Ensures that a field or operation can only be executed by callers possessing
the specified permission scope (e.g. "wallet:read", "governance:vote").
"""
directive @auth(
  requires: [String!]!
) on OBJECT | FIELD_DEFINITION


# ---------------------------------------------------------------------------
# Enumerations
# ---------------------------------------------------------------------------

enum ConsensusEngineType {
  POW
  POS
  DPOS
  POA
  CUSTOM
}

enum TransactionStatus {
  PENDING
  CONFIRMED
  FAILED
  REJECTED
}

enum ProposalStatus {
  DRAFT
  ACTIVE
  ACCEPTED
  REJECTED
  EXECUTED
}

enum VoteType {
  YES
  NO
  ABSTAIN
}

enum NFTStandard {
  ERC721
  ERC1155
  CUSTOM
}


# ---------------------------------------------------------------------------
# Core Object Types
# ---------------------------------------------------------------------------

type ChainInfo {
  chainId: String!
  networkName: String!
  consensus: ConsensusStatus!
  latestBlock: Block!
  totalSupply: UC_BigInt!
  nativeTokenSymbol: String!
  nodeVersion: String!
}

type ConsensusStatus {
  engine: ConsensusEngineType!
  epoch: Int!
  validatorCount: Int!
  stakedAmount: UC_BigInt!
  blockTimeMs: Int!
}

type Block {
  number: Int!
  hash: UC_Hash!
  parentHash: UC_Hash!
  timestamp: UC_DateTime!
  miner: UC_Address!
  txCount: Int!
  gasUsed: UC_BigInt!
  gasLimit: UC_BigInt!
  rewards: UC_BigInt!
  transactions(
    first: Int
    after: String
    last: Int
    before: String
  ): TransactionConnection!
}

type Transaction {
  hash: UC_Hash!
  from: UC_Address!
  to: UC_Address
  nonce: Int!
  gasPrice: UC_BigInt!
  gasUsed: UC_BigInt!
  value: UC_BigInt!
  status: TransactionStatus!
  blockNumber: Int
  timestamp: UC_DateTime!
  logs: [EventLog!]!
}

"""
Relay-style connection wrapper for Transaction pagination.
"""
type TransactionConnection {
  edges: [TransactionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TransactionEdge {
  cursor: String!
  node: Transaction!
}

"""
Pagination metadata.
"""
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Account {
  address: UC_Address!
  balance: UC_BigInt!
  nonce: Int!
  code: String
  stakes: [StakePosition!]!
  tokens(
    first: Int
    after: String
    last: Int
    before: String
  ): TokenHoldingConnection!
}

type StakePosition {
  validator: UC_Address!
  amount: UC_BigInt!
  startBlock: Int!
  rewardsClaimed: UC_BigInt!
  unlockHeight: Int
}

type TokenHolding {
  contract: UC_Address!
  symbol: String!
  balance: UC_BigInt!
  decimals: Int!
}

type TokenHoldingConnection {
  edges: [TokenHoldingEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TokenHoldingEdge {
  cursor: String!
  node: TokenHolding!
}

type NFT {
  id: String!
  owner: UC_Address!
  contract: UC_Address!
  standard: NFTStandard!
  metadataURI: String!
  mintedAt: UC_DateTime!
}

type GovernanceProposal {
  id: ID!
  title: String!
  description: String!
  proposer: UC_Address!
  status: ProposalStatus!
  createdAt: UC_DateTime!
  expiresAt: UC_DateTime!
  votes: [GovernanceVote!]!
  quorum: UC_BigInt!
}

type GovernanceVote {
  voter: UC_Address!
  type: VoteType!
  weight: UC_BigInt!
  castAt: UC_DateTime!
}

type SmartContract {
  name: String!
  address: UC_Address!
  abi: String!
  bytecode: String!
  deployedBy: UC_Address!
  deployedAt: UC_DateTime!
}


# ---------------------------------------------------------------------------
# Event Types (for Subscriptions)
# ---------------------------------------------------------------------------

type EventLog {
  address: UC_Address!
  topics: [UC_Hash!]!
  data: String!
  blockNumber: Int!
  transactionHash: UC_Hash!
  logIndex: Int!
}

type NewBlockEvent {
  block: Block!
}

type TransactionEvent {
  transaction: Transaction!
}

type ChainEventLog {
  log: EventLog!
}


# ---------------------------------------------------------------------------
# Root Operations
# ---------------------------------------------------------------------------

type Query {
  chainInfo: ChainInfo!

  block(number: Int!, includeTx: Boolean = false): Block
  blocks(
    from: Int!
    to: Int!
    includeTx: Boolean = false
  ): [Block!]!

  transaction(hash: UC_Hash!): Transaction

  account(address: UC_Address!): Account

  stakingInfo(address: UC_Address!): [StakePosition!]!

  governanceProposal(id: ID!): GovernanceProposal
  governanceProposals(
    status: ProposalStatus
    first: Int
    after: String
  ): GovernanceProposalConnection!

  nft(tokenId: String!, contract: UC_Address!): NFT

  smartContract(address: UC_Address!): SmartContract
}

"""
Relay connection for proposals.
"""
type GovernanceProposalConnection {
  edges: [GovernanceProposalEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type GovernanceProposalEdge {
  cursor: String!
  node: GovernanceProposal!
}

type Mutation {
  # ------------------------------------------------------------------------
  # Ledger & Token Transfers
  # ------------------------------------------------------------------------

  transferTokens(
    from: UC_Address!
    to: UC_Address!
    amount: UC_BigInt!
  ): Transaction! @auth(requires: ["wallet:write"])

  # ------------------------------------------------------------------------
  # Staking Operations
  # ------------------------------------------------------------------------

  stakeTokens(
    delegator: UC_Address!
    validator: UC_Address!
    amount: UC_BigInt!
    lockUntil: Int
  ): StakePosition! @auth(requires: ["staking:write"])

  unstakeTokens(
    delegator: UC_Address!
    validator: UC_Address!
    amount: UC_BigInt!
  ): StakePosition! @auth(requires: ["staking:write"])

  # ------------------------------------------------------------------------
  # Governance Operations
  # ------------------------------------------------------------------------

  submitProposal(
    title: String!
    description: String!
    proposer: UC_Address!
    quorum: UC_BigInt!
    expiresAt: UC_DateTime!
  ): GovernanceProposal! @auth(requires: ["governance:write"])

  voteProposal(
    proposalId: ID!
    voter: UC_Address!
    type: VoteType!
    weight: UC_BigInt!
  ): GovernanceVote! @auth(requires: ["governance:write"])

  # ------------------------------------------------------------------------
  # NFT Operations
  # ------------------------------------------------------------------------

  mintNFT(
    contract: UC_Address!
    to: UC_Address!
    metadataURI: String!
  ): NFT! @auth(requires: ["nft:write"])

  burnNFT(
    contract: UC_Address!
    tokenId: String!
  ): Boolean! @auth(requires: ["nft:write"])

  # ------------------------------------------------------------------------
  # Smart-Contract Operations
  # ------------------------------------------------------------------------

  deployContract(
    from: UC_Address!
    name: String!
    bytecode: String!
    abi: String!
  ): SmartContract! @auth(requires: ["contract:deploy"])

  invokeContract(
    from: UC_Address!
    contract: UC_Address!
    method: String!
    args: [String!]
    value: UC_BigInt = "0"
  ): Transaction! @auth(requires: ["contract:invoke"])
}

type Subscription {
  newBlock: NewBlockEvent!
  transactionCommitted(address: UC_Address): TransactionEvent!
  eventLog(
    address: UC_Address
    topic0: UC_Hash
  ): ChainEventLog!
}

# ---------------------------------------------------------------------------
# END OF SCHEMA
# ---------------------------------------------------------------------------