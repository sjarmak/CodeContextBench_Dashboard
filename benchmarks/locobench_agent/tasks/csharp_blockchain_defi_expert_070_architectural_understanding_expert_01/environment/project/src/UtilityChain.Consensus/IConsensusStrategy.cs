```csharp
// -----------------------------------------------------------------------------
//  UtilityChain Core Suite
//  File: IConsensusStrategy.cs
//  Author: Auto–generated by OpenAI GPT-4
//  Description:
//      Strategy abstraction for pluggable consensus engines. Implementations
//      encapsulate the full life-cycle of block production, validation, and
//      finalization while exposing a thin, event-driven surface to the runtime.
// -----------------------------------------------------------------------------

#nullable enable
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace UtilityChain.Consensus
{
    /// <summary>
    ///     Identifies the built-in consensus algorithms supported by the core
    ///     runtime. Custom engines may declare <see cref="Custom" /> and use a
    ///     vendor-specific <see cref="Name" />.
    /// </summary>
    public enum ConsensusType
    {
        ProofOfStake,
        DelegatedProofOfStake,
        ProofOfAuthority,
        ProofOfWork,
        Custom
    }

    /// <summary>
    ///     Describes the current operational state of the consensus engine.
    /// </summary>
    public enum ConsensusState
    {
        Idle,
        Proposing,
        Validating,
        Finalizing,
        Shutdown
    }

    /// <summary>
    ///     Event payload raised whenever the consensus engine transitions to a
    ///     new <see cref="ConsensusState" />.
    /// </summary>
    public sealed class ConsensusStateChangedEventArgs : EventArgs
    {
        public ConsensusStateChangedEventArgs(ulong blockHeight, ConsensusState state)
        {
            BlockHeight = blockHeight;
            State       = state;
        }

        public ulong           BlockHeight { get; }
        public ConsensusState  State       { get; }
    }

    /// <summary>
    ///     Primary strategy interface leveraged by the runtime when coordinating
    ///     block production and chain validation. Implementations MUST be
    ///     thread-safe and side-effect free except where explicitly documented.
    /// </summary>
    public interface IConsensusStrategy : IDisposable, IAsyncDisposable
    {
        /// <summary>
        ///     Human-readable identifier—e.g. "BFT-PoS (HotStuff)".
        /// </summary>
        string Name { get; }

        /// <summary>
        ///     Categorisation of the algorithm. Used for metric and UI purposes
        ///     only; execution logic relies on <see cref="Name" />.
        /// </summary>
        ConsensusType ConsensusType { get; }

        /// <summary>
        ///     Initializes the engine and spins up any required background
        ///     workers or timers.  This method is invoked exactly once during
        ///     node start-up.
        /// </summary>
        /// <param name="nodeContext">
        ///     Shared context object exposing persistence, networking and crypto
        ///     primitives. Guaranteed to be non-null and fully constructed.
        /// </param>
        /// <param name="cancellationToken">
        ///     Token propagated from the host. Must be observed to support
        ///     cooperative shutdown.
        /// </param>
        ValueTask InitializeAsync(INodeContext nodeContext,
                                  CancellationToken cancellationToken = default);

        /// <summary>
        ///     Creates a new candidate block for the supplied <paramref name="blockContext"/>.
        ///     Returns <c>null</c> if the current node is not the designated
        ///     proposer for the given slot.
        /// </summary>
        ValueTask<BlockCandidate?> ProposeBlockAsync(BlockContext      blockContext,
                                                     CancellationToken cancellationToken = default);

        /// <summary>
        ///     Performs full consensus validation of the supplied <paramref name="block"/>.
        ///     Implementations should stream validation steps to the
        ///     <paramref name="progress"/> reporter to allow UI feedback.
        /// </summary>
        ValueTask<BlockValidationResult> ValidateBlockAsync(Block                              block,
                                                            IProgress<ValidationStep>?         progress           = null,
                                                            CancellationToken                  cancellationToken  = default);

        /// <summary>
        ///     Finalizes a block after a quorum has been reached. Typical tasks
        ///     include state-root commitment, reward distribution or slashing.
        /// </summary>
        ValueTask FinalizeBlockAsync(Block block, CancellationToken cancellationToken = default);

        /// <summary>
        ///     Returns the validator set that will be active at
        ///     <paramref name="atHeight" />. Implementations MAY cache the
        ///     result for performance reasons.
        /// </summary>
        ValueTask<IReadOnlyList<Validator>> GetActiveValidatorsAsync(ulong            atHeight,
                                                                     CancellationToken cancellationToken = default);

        /// <summary>
        ///     Attempts to sign an arbitrary <paramref name="payload"/> using the
        ///     consensus engine’s private validator key. Returns <c>null</c> if
        ///     the node is not a validator.
        /// </summary>
        ValueTask<Signature?> SignAsync(ReadOnlyMemory<byte> payload,
                                        CancellationToken    cancellationToken = default);

        /// <summary>
        ///     Raised whenever the internal state machine transitions to a new
        ///     <see cref="ConsensusState" />.
        /// </summary>
        event EventHandler<ConsensusStateChangedEventArgs>? ConsensusStateChanged;
    }

    #region —————————————————————— Lightweight Domain Stubs ——————————————————————
    // NOTE: The below constructs are intentionally minimal and exist only to
    //       keep this file self-contained. Full implementations live in the
    //       corresponding UtilityChain.* packages and assemblies.

    public interface INodeContext
    {
        IChainStore         ChainStore     { get; }
        INetworkBroadcaster Broadcaster    { get; }
        IKeyStore           KeyStore       { get; }
        IEventPublisher     Events         { get; }
    }

    public sealed record BlockCandidate(Block Block, IReadOnlyList<Transaction> Transactions);

    public sealed record BlockValidationResult(bool IsValid, string? FailureReason = null);

    public interface IChainStore
    {
        ulong CurrentHeight { get; }
        ValueTask<Block?> GetBlockAsync(ulong height, CancellationToken token = default);
    }

    public interface INetworkBroadcaster
    {
        ValueTask BroadcastBlockAsync(Block block, CancellationToken token = default);
    }

    public interface IKeyStore
    {
        bool         IsValidator   { get; }
        PublicKey    PublicKey     { get; }
        ValueTask<Signature> SignAsync(ReadOnlyMemory<byte> data, CancellationToken token = default);
    }

    public interface IEventPublisher
    {
        void Publish<TEvent>(TEvent @event) where TEvent : notnull;
    }

    public sealed record Block(
        ulong                Height,
        Hash                 PreviousHash,
        DateTimeOffset       Timestamp,
        IReadOnlyList<Transaction> Transactions,
        PublicKey            Proposer,
        Signature            BlockSignature);

    public sealed record Transaction(Hash TxId, ReadOnlyMemory<byte> Payload, Signature Signature);

    public sealed record BlockContext(ulong Height, Hash PreviousHash, DateTimeOffset SlotTime);

    public sealed record Validator(PublicKey Address, ulong Stake);

    public readonly struct Hash      { public Hash(ReadOnlySpan<byte> _) => Value = Guid.NewGuid(); public Guid Value { get; } }
    public readonly struct Signature { public Signature(ReadOnlySpan<byte> _) => Value = Guid.NewGuid(); public Guid Value { get; } }
    public readonly struct PublicKey { public PublicKey(ReadOnlySpan<byte> _) => Value = Guid.NewGuid(); public Guid Value { get; } }

    public sealed class ValidationStep
    {
        public ValidationStep(string description) => Description = description;
        public string Description { get; }
    }
    #endregion
}
```