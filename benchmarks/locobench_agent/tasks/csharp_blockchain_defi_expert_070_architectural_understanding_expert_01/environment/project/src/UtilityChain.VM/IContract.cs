```csharp
// ***********************************************************************************************
//  UtilityChain Core Suite – Virtual-Machine Abstractions
//  ---------------------------------------------------------------------------------------------
//  File:       IContract.cs
//  Project:    UtilityChain.VM   (part of UtilityChain Core Suite)
//  Repository: https://github.com/utilitychain/core-suite
//  License:    MIT
//
//  Description:
//      Contract-level abstractions consumed by the embedded smart-contract virtual machine (VM).
//      All run-time contracts—regardless of their high-level language or compilation target—must
//      conform to this interface so they can be orchestrated uniformly by the VM scheduler,
//      state-manager, and event bus.
//
//  Important design notes:
//      • The VM is *in-process*—contracts are loaded as .NET assemblies and executed with zero
//        inter-process marshaling.  Cold/warm execution, metering, and sandboxing is handled by
//        higher-level components (see IVmScheduler, IGasMeter, ISandbox).
//      • This interface purposefully remains *behavior-oriented*—data contracts live in the
//        UtilityChain.Abstractions project to avoid circular dependencies.
// ***********************************************************************************************

#nullable enable

using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.Versioning;

namespace UtilityChain.VM;

/// <summary>
///     Public contract every executable smart-contract must fulfil in order to be hosted by the
///     <c>UtilityChain.VM</c>.  Implementations are usually generated by the compiler back-end
///     (e.g., the C# → IL transpiler) and loaded via reflection at runtime.
/// </summary>
[RequiresPreviewFeatures("Dynamic code generation for on-chain contracts relies on 'System.Reflection.Emit' which is still in preview for .NET 8 AOT.")]
public interface IContract : IDisposable
{
    // -----------------------------------------------------------------------------------------
    // Meta-information
    // -----------------------------------------------------------------------------------------

    /// <summary>Unique, deterministic address assigned by the chain during deployment.</summary>
    ContractAddress Address { get; }

    /// <summary>Human-readable name, typically declared in the contract source.</summary>
    string Name { get; }

    /// <summary>Semantic version of the contract’s code (major.minor.patch-prerelease+build).</summary>
    SemanticVersion Version { get; }

    /// <summary>Author, organization, or DAO that published the bytecode.</summary>
    string Author { get; }

    /// <summary>Timestamp when the contract was deployed to the current chain.</summary>
    DateTimeOffset DeployedAt { get; }

    /// <summary>
    ///     Fully qualified type name of the primary class implementing user logic.
    ///     Useful for reflection-based tooling (debuggers, analyzers, etc.).
    /// </summary>
    string EntryType { get; }

    // -----------------------------------------------------------------------------------------
    // Introspection
    // -----------------------------------------------------------------------------------------

    /// <summary>
    ///     Immutable map of publicly invokable methods exposed by the contract.<br/>
    ///     Key: method identifier (case-sensitive).<br/>
    ///     Value: reflected metadata (parameters, return type, gas cost hints, etc.).
    /// </summary>
    ImmutableDictionary<string, MethodMetadata> Methods { get; }

    /// <summary>
    ///     Current in-memory state.  Persisted snapshots are handled by the StateManager.
    /// </summary>
    IContractState State { get; }

    // -----------------------------------------------------------------------------------------
    // Lifecycle
    // -----------------------------------------------------------------------------------------

    /// <summary>
    ///     Called once immediately after the contract is activated by the VM.  Implementations
    ///     may allocate resources, create default state entries, or subscribe to global events.
    /// </summary>
    ValueTask InitializeAsync(IExecutionContext context, CancellationToken ct = default);

    /// <summary>
    ///     Executes a public method by name, forwarding strongly-typed parameters and returning a
    ///     boxed result.  The VM performs argument validation and gas accounting.
    /// </summary>
    /// <param name="method">Public method identifier (see <see cref="Methods"/>).</param>
    /// <param name="parameters">Typed parameters supplied by the caller.</param>
    /// <param name="context">Execution context (caller, block-height, gas, etc.).</param>
    /// <param name="ct">Propagates cancellation if the caller runs out of gas or aborts.</param>
    /// <returns>Structured result object containing status, return value, and side-effects.</returns>
    /// <exception cref="MethodNotFoundException">
    ///     Thrown when <paramref name="method"/> does not exist or is not invokable.
    /// </exception>
    /// <exception cref="ContractExecutionException">
    ///     Wraps any unhandled exception that occurs during user code execution.
    /// </exception>
    ValueTask<ExecutionResult> InvokeAsync(
        string method,
        ImmutableArray<ContractParameter> parameters,
        IExecutionContext context,
        CancellationToken ct = default);

    /// <summary>
    ///     Persists the current mutable state to the underlying key-value store.  Called by the
    ///     StateManager after a transaction has completed successfully.
    /// </summary>
    ValueTask PersistStateAsync(IStateWriter writer, CancellationToken ct = default);

    // -----------------------------------------------------------------------------------------
    // Events
    // -----------------------------------------------------------------------------------------

    /// <summary>
    ///     Raised every time the contract emits an application-level event (e.g., Transfer,
    ///     VoteCast).  The event bus will forward the payload to interested off-chain listeners.
    /// </summary>
    event EventHandler<ContractEventArgs>? EventEmitted;

    /// <summary>
    ///     Raised after <see cref="PersistStateAsync"/> has successfully written a snapshot to
    ///     disk.  Observers (e.g., data-indexers) can react without touching the VM core.
    /// </summary>
    event EventHandler<StatePersistedEventArgs>? StatePersisted;
}

// ***********************************************************************************************
//  Internal helper abstractions
//  ---------------------------------------------------------------------------------------------
//  These types live alongside IContract to maintain single-file portability for this prompt. In
//  the real repository they each reside in dedicated source files within UtilityChain.Abstractions
//  or UtilityChain.VM.
// ***********************************************************************************************

#region Internal helper abstractions

/// <summary>Represents a 20-byte EVM-style address.</summary>
public readonly record struct ContractAddress(ReadOnlySpan<byte> Value)
{
    public const int Length = 20;

    public static ContractAddress Zero => new(Enumerable.Repeat((byte)0, Length).ToArray());

    public readonly byte[] Bytes => Value.ToArray();

    public override string ToString() => $"0x{Convert.ToHexString(Value)}";

    public static ContractAddress Parse(string hex)
    {
        if (string.IsNullOrWhiteSpace(hex))
            throw new ArgumentNullException(nameof(hex));

        var clean = hex.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? hex[2..] : hex;
        if (clean.Length != Length * 2)
            throw new FormatException($"Address must be {Length * 2} hex characters.");

        return new ContractAddress(Convert.FromHexString(clean));
    }
}

/// <summary>SemVer implementation suitable for on-chain storage.</summary>
public sealed record SemanticVersion(int Major, int Minor, int Patch, string? Prerelease = null, string? Build = null)
    : IComparable<SemanticVersion>, ISpanFormattable
{
    public int CompareTo(SemanticVersion? other)
    {
        if (other is null) return 1;
        var result = Major.CompareTo(other.Major);
        if (result != 0) return result;
        result = Minor.CompareTo(other.Minor);
        if (result != 0) return result;
        result = Patch.CompareTo(other.Patch);
        if (result != 0) return result;
        return string.Compare(Prerelease ?? string.Empty, other.Prerelease ?? string.Empty, StringComparison.Ordinal);
    }

    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        var s = ToString();
        if (s.AsSpan().TryCopyTo(destination))
        {
            charsWritten = s.Length;
            return true;
        }

        charsWritten = 0;
        return false;
    }

    public override string ToString()
    {
        var core = $"{Major}.{Minor}.{Patch}";
        var pre  = string.IsNullOrEmpty(Prerelease) ? string.Empty : $"-{Prerelease}";
        var build = string.IsNullOrEmpty(Build) ? string.Empty : $"+{Build}";
        return $"{core}{pre}{build}";
    }
}

/// <summary>Metadata fingerprint for an invokable contract method.</summary>
public sealed record MethodMetadata(
    string Name,
    ImmutableArray<ParameterMetadata> Parameters,
    Type ReturnType,
    ulong GasCostHint);

/// <summary>Metadata for a single method parameter.</summary>
public sealed record ParameterMetadata(string Name, Type ParameterType, bool IsOptional);

/// <summary>Represents the dynamic parameter values passed to a contract call.</summary>
public readonly record struct ContractParameter(string Name, object? Value, Type Type);

/// <summary>Abstraction for a mutable key-value state bag.</summary>
public interface IContractState
{
    bool  TryGetRaw(ReadOnlySpan<byte> key, [NotNullWhen(true)] out ReadOnlyMemory<byte> value);
    void  SetRaw(ReadOnlySpan<byte> key, ReadOnlySpan<byte> value);
    void  RemoveRaw(ReadOnlySpan<byte> key);
}

/// <summary>Contextual information about the current execution frame.</summary>
public interface IExecutionContext
{
    ContractAddress Caller { get; }
    ulong           GasLeft { get; }
    ulong           BlockHeight { get; }
    DateTimeOffset  BlockTimestamp { get; }

    // Utility helpers
    void            BurnGas(ulong amount);
}

/// <summary>Abstraction used by the VM to persist contract state.</summary>
public interface IStateWriter
{
    ValueTask WriteAsync(ContractAddress address, ReadOnlyMemory<byte> snapshot, CancellationToken ct);
}

/// <summary>Structured result returned by <see cref="IContract.InvokeAsync"/>.</summary>
public sealed record ExecutionResult(
    bool Success,
    object? ReturnValue,
    ImmutableArray<ContractLogEntry> Logs,
    ulong GasConsumed,
    string? ErrorMessage = null);

/// <summary>Log entry emitted by a contract execution.</summary>
public sealed record ContractLogEntry(string EventName, ImmutableArray<object?> Arguments);

/// <summary>Raised when a contract calls <see cref="IExecutionContext.BurnGas"/> or emits an event.</summary>
public sealed class ContractEventArgs : EventArgs
{
    public ContractEventArgs(string name, ImmutableArray<object?> args) => (Name, Arguments) = (name, args);
    public string                      Name      { get; }
    public ImmutableArray<object?>     Arguments { get; }
}

/// <summary>Raised after a successful state snapshot.</summary>
public sealed class StatePersistedEventArgs : EventArgs
{
    public StatePersistedEventArgs(ulong blockHeight, ulong txIndex) => (BlockHeight, TransactionIndex) = (blockHeight, txIndex);
    public ulong BlockHeight      { get; }
    public ulong TransactionIndex { get; }
}

/// <summary>Thrown when an attempt is made to invoke an undefined method.</summary>
public sealed class MethodNotFoundException : Exception
{
    public MethodNotFoundException(string method) : base($"Contract method '{method}' not found.") { }
}

/// <summary>Wraps unhandled user-code exceptions so the VM can surface them uniformly.</summary>
public sealed class ContractExecutionException : Exception
{
    public ContractExecutionException(string method, Exception inner)
        : base($"Execution of contract method '{method}' failed: {inner.Message}", inner) { }
}

#endregion
```