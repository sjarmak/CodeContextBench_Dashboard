```csharp
// ------------------------------------------------------------------------------------------
//  UtilityChain Core Suite
//  File:    UtilityChainCoreSuite/src/UtilityChain.VM/ContractExecutor.cs
//  Project: UtilityChain Core Suite (blockchain_defi)
//  Language: C# 12 / .NET 8
//  Author:  *** GENERATED BY AI ***
//
//  Description:
//  Orchestrates the end-to-end lifecycle of a smart-contract invocation, providing
//  gas-metering, dynamic engine resolution (Strategy/Factory patterns), state handling, 
//  and event publication.  This class is the façade used by the consensus layer and the
//  RPC gateway to execute on-chain code in a deterministic and auditable manner.
// ------------------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace UtilityChain.VM
{
    #region Public Contracts ────────────────────────────────────────────────────────────────

    /// <summary>
    /// Supported smart-contract source/byte-code formats.
    /// </summary>
    public enum ContractLanguage
    {
        Wasm,
        CSharp,
        Python,
        SolidityEvm,   // Provided via an embedded EVM interpreter
    }

    /// <summary>
    /// Immutable description of a contract invocation request.
    /// </summary>
    public sealed record ContractInvocation(
        Address             Caller,
        Address             ContractAddress,
        string              MethodName,
        byte[]              CallData,
        ulong               GasLimit,
        ContractLanguage    Language,
        ulong               BlockHeight,
        DateTimeOffset      Timestamp);

    /// <summary>
    /// Execution result returned to the consensus layer / RPC gateway.
    /// </summary>
    public sealed record ExecutionReceipt(
        bool            Success,
        byte[]?         ReturnValue,
        ulong           GasUsed,
        string?         Error,
        ContractEvent[] Events);

    /// <summary>
    /// Lightweight strongly-typed contract event.
    /// </summary>
    public sealed record ContractEvent(
        Address Origin,
        string  Name,
        byte[]  Payload);

    /// <summary>
    /// Represents a canonical chain address.
    /// </summary>
    public readonly struct Address : IEquatable<Address>
    {
        public static Address Zero => new("0x0000000000000000000000000000000000000000");

        private readonly string _value;

        public Address(string value)
        {
            ArgumentException.ThrowIfNullOrWhiteSpace(value);
            _value = value.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? value : $"0x{value}";
        }

        public bool Equals(Address other) => string.Equals(_value, other._value, StringComparison.OrdinalIgnoreCase);
        public override bool Equals(object? obj) => obj is Address other && Equals(other);
        public override int GetHashCode() => StringComparer.OrdinalIgnoreCase.GetHashCode(_value);
        public override string ToString() => _value;
    }

    #endregion

    #region Dependencies / Service Contracts ────────────────────────────────────────────────

    /// <summary>
    /// Publishes domain events inside the monolith (Observer pattern).
    /// </summary>
    public interface IEventBus
    {
        ValueTask PublishAsync<T>(T @event, CancellationToken ct = default) where T : notnull;
    }

    /// <summary>
    /// Factory that resolves the correct execution engine for a given contract language
    /// (Strategy + Factory patterns combined).
    /// </summary>
    public interface IContractEngineFactory
    {
        IContractEngine Create(ContractLanguage language);
    }

    /// <summary>
    /// Smart-contract engine capable of executing byte-code for a single language/runtime.
    /// </summary>
    public interface IContractEngine
    {
        Task<EngineExecutionResult> ExecuteAsync(
            ContractInvocation invocation, 
            IGasMeter          gasMeter,
            IStateRepository   state,
            IEventBus          events,
            CancellationToken  ct);
    }

    /// <summary>
    /// Contains raw engine results before being transformed into a public receipt.
    /// </summary>
    public sealed record EngineExecutionResult(
        bool            Success,
        byte[]?         Result,
        ContractEvent[] Events,
        string?         Error);

    /// <summary>
    /// Thin abstraction over the chain state database.
    /// </summary>
    public interface IStateRepository
    {
        // Typical CRUD operations for accounts, storage slots, etc.
        ValueTask<byte[]> GetStorageAsync(Address contract, byte[] key, CancellationToken ct = default);
        ValueTask SetStorageAsync(Address contract, byte[] key, byte[] value, CancellationToken ct = default);
    }

    /// <summary>
    /// Simple gas-meter used by the engine to track consumption.
    /// </summary>
    public interface IGasMeter
    {
        ulong Remaining { get; }
        bool   Consume(ulong amount);
        void   Refund(ulong amount);
        ulong  Used { get; }
    }

    /// <summary>
    /// Creates new <see cref="IGasMeter"/> instances.
    /// </summary>
    public interface IGasMeterFactory
    {
        IGasMeter Create(ulong gasLimit);
    }

    #endregion

    /// <summary>
    /// Top-level façade responsible for executing smart contracts.  Thread-safe and re-entrant.
    /// </summary>
    public sealed class ContractExecutor
    {
        private readonly IContractEngineFactory _engineFactory;
        private readonly IGasMeterFactory       _gasFactory;
        private readonly IStateRepository       _state;
        private readonly IEventBus              _eventBus;
        private readonly ILogger<ContractExecutor> _log;

        public ContractExecutor(
            IContractEngineFactory engineFactory,
            IGasMeterFactory       gasFactory,
            IStateRepository       state,
            IEventBus              eventBus,
            ILogger<ContractExecutor> log)
        {
            _engineFactory = engineFactory  ?? throw new ArgumentNullException(nameof(engineFactory));
            _gasFactory    = gasFactory     ?? throw new ArgumentNullException(nameof(gasFactory));
            _state         = state          ?? throw new ArgumentNullException(nameof(state));
            _eventBus      = eventBus       ?? throw new ArgumentNullException(nameof(eventBus));
            _log           = log            ?? throw new ArgumentNullException(nameof(log));
        }

        /// <summary>
        /// Executes a contract method deterministically, returning a receipt that is safe to
        /// persist on-chain and expose via RPC.  Throws no exceptions; failures are encoded 
        /// within the returned receipt.
        /// </summary>
        public async Task<ExecutionReceipt> ExecuteAsync(
            ContractInvocation invocation,
            CancellationToken  ct = default)
        {
            ArgumentNullException.ThrowIfNull(invocation);
            if (invocation.GasLimit == 0)
                return Failure("Gas limit must be greater than 0");

            // Stopwatch is used purely for diagnostics; it is NOT consensus-critical.
            var sw = Stopwatch.StartNew();

            var gasMeter = _gasFactory.Create(invocation.GasLimit);
            var engine   = ResolveEngine(invocation.Language);

            // Publish an event so observers (e.g., diagnostics, governance modules) can react.
            await _eventBus.PublishAsync(
                new VmExecutionStarted(invocation.ContractAddress, invocation.MethodName, invocation.GasLimit),
                ct);

            EngineExecutionResult rawResult;

            try
            {
                rawResult = await engine.ExecuteAsync(invocation, gasMeter, _state, _eventBus, ct);
            }
            catch (OperationCanceledException)
            {
                _log.LogWarning("Contract execution was cancelled for {Contract}::{Method}", 
                                invocation.ContractAddress, invocation.MethodName);
                return Failure("Execution cancelled by caller or system.");
            }
            catch (Exception ex)
            {
                _log.LogError(ex, "Fatal error while executing smart contract {Contract}::{Method}", 
                              invocation.ContractAddress, invocation.MethodName);
                return Failure($"Unhandled VM exception: {ex.GetType().Name}");
            }
            finally
            {
                sw.Stop();
                _log.LogDebug("Executed {Contract}::{Method} in {ElapsedMs} ms, gas used {GasUsed}/{GasLimit}",
                              invocation.ContractAddress, invocation.MethodName, sw.ElapsedMilliseconds,
                              gasMeter.Used, invocation.GasLimit);
            }

            // Forge the publicly-visible execution receipt
            var receipt = new ExecutionReceipt(
                Success:     rawResult.Success,
                ReturnValue: rawResult.Result,
                GasUsed:     gasMeter.Used,
                Error:       rawResult.Error,
                Events:      rawResult.Events);

            // Emit a completion event for observers
            await _eventBus.PublishAsync(
                new VmExecutionCompleted(invocation.ContractAddress, invocation.MethodName, receipt.Success, receipt.GasUsed),
                ct);

            return receipt;

            // ------------- Local helper ----------------------------------------------------
            ExecutionReceipt Failure(string reason)
                => new(false, null, 0, reason, Array.Empty<ContractEvent>());
        }

        #region Private Helpers ──────────────────────────────────────────────────────────────

        private IContractEngine ResolveEngine(ContractLanguage language)
        {
            try
            {
                return _engineFactory.Create(language);
            }
            catch (Exception ex)
            {
                _log.LogError(ex, "Failed to resolve contract engine for language {Language}", language);
                throw; // Bubble-up; the caller will convert into a failure receipt.
            }
        }

        #endregion
    }

    #region Internal Diagnostic Events ─────────────────────────────────────────────────────-

    /// <summary>
    /// Event emitted when VM execution starts.
    /// </summary>
    internal sealed record VmExecutionStarted(Address Contract, string Method, ulong GasLimit);

    /// <summary>
    /// Event emitted when VM execution ends.
    /// </summary>
    internal sealed record VmExecutionCompleted(Address Contract, string Method, bool Success, ulong GasUsed);

    #endregion
}
```