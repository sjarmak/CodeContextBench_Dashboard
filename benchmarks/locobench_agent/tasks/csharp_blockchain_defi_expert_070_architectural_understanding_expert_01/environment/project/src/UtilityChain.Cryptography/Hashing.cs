```csharp
// -----------------------------------------------------------------------------
// File:    Hashing.cs
// Project: UtilityChain Core Suite  (blockchain_defi)
// Author:  Auto-generated by UtilityChain Code Generator
// -----------------------------------------------------------------------------

using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace UtilityChain.Cryptography
{
    /// <summary>
    /// Supported hashing algorithms throughout UtilityChain.  Only well-established,
    /// collision-resistant functions are included so that security reviews can be
    /// performed against a finite, audited surface area.
    /// </summary>
    public enum HashAlgorithmType
    {
        Sha256,
        Sha512,
        Ripemd160,
        DoubleSha256,
        Sha256Ripemd160
    }

    /// <summary>
    /// Centralised hashing helper that provides pooling, binary &amp; hex output,
    /// double-hashing helpers (e.g., Bitcoin-style <c>SHA256(SHA256(data))</c>),
    /// and merkle-tree construction for block headers and transaction sets.
    /// </summary>
    public static class Hashing
    {
        private const int _DefaultStreamBufferSize = 64 * 1024; // 64 KiB

        // An ArrayPool to reuse buffers when hashing streams.
        private static readonly ArrayPool<byte> _bufferPool = ArrayPool<byte>.Shared;

        // Dedicated pools per algorithm to avoid expensive initialise/dispose cycles.
        private static readonly ConcurrentDictionary<HashAlgorithmType, ConcurrentBag<HashAlgorithm>> _pools
            = new();

        #region Public API – Byte & Hex Helpers

        /// <summary>
        /// Computes the hash for the supplied data using the specified algorithm.
        /// </summary>
        /// <param name="data">Input data to hash.</param>
        /// <param name="type">Hashing algorithm.</param>
        /// <returns>Hash byte array (length depends on algorithm).</returns>
        public static byte[] ComputeHash(ReadOnlySpan<byte> data, HashAlgorithmType type = HashAlgorithmType.Sha256)
        {
            if (data.IsEmpty)
                throw new ArgumentException("Data to hash cannot be empty.", nameof(data));

            return type switch
            {
                HashAlgorithmType.DoubleSha256      => DoubleSha256(data),
                HashAlgorithmType.Sha256Ripemd160   => Sha256Ripemd160(data),
                _                                    => OneShotHash(data, type)
            };
        }

        /// <summary>
        /// Computes the hash for the supplied UTF-8 string and returns the result as
        /// a lowercase hexadecimal string.
        /// </summary>
        public static string ComputeHashHex(string input,
                                            HashAlgorithmType type = HashAlgorithmType.Sha256,
                                            Encoding? encoding = null)
        {
            if (input is null)
                throw new ArgumentNullException(nameof(input));

            encoding ??= Encoding.UTF8;
            var bytes = encoding.GetBytes(input);
            var hash  = ComputeHash(bytes, type);
            return ConvertToHex(hash);
        }

        /// <summary>
        /// Asynchronous convenience wrapper for hashing a stream.  The underlying
        /// algorithm is pooled and re-used.  The caller is responsible for
        /// rewinding or disposing the stream.
        /// </summary>
        public static async ValueTask<byte[]> ComputeHashAsync(
            System.IO.Stream stream,
            HashAlgorithmType type                = HashAlgorithmType.Sha256,
            int bufferSize                         = _DefaultStreamBufferSize,
            CancellationToken cancellationToken    = default)
        {
            if (stream is null)
                throw new ArgumentNullException(nameof(stream));
            if (!stream.CanRead)
                throw new ArgumentException("Stream must be readable.", nameof(stream));
            if (bufferSize <= 0)
                throw new ArgumentOutOfRangeException(nameof(bufferSize));

            var algorithm = RentAlgorithm(type);
            try
            {
                var buffer = _bufferPool.Rent(bufferSize);
                try
                {
                    int read;
                    while ((read = await stream.ReadAsync(buffer.AsMemory(0, bufferSize), cancellationToken)
                                               .ConfigureAwait(false)) > 0)
                    {
                        algorithm.TransformBlock(buffer, 0, read, null, 0);
                    }

                    algorithm.TransformFinalBlock(Array.Empty<byte>(), 0, 0);
                    return algorithm.Hash!;
                }
                finally
                {
                    _bufferPool.Return(buffer);
                }
            }
            finally
            {
                ReturnAlgorithm(type, algorithm);
            }
        }

        /// <summary>
        /// Builds a Merkle root for the provided list of leaf hashes using the
        /// <c>DoubleSHA256</c> combination commonly used in Bitcoin-derived systems.
        /// </summary>
        /// <remarks>
        /// If <paramref name="leafHashes"/> contains an odd number of elements the
        /// last element is duplicated (as per Satoshi’s specification).
        /// </remarks>
        public static byte[] BuildMerkleRoot(IReadOnlyList<byte[]> leafHashes)
        {
            if (leafHashes is null)
                throw new ArgumentNullException(nameof(leafHashes));
            if (leafHashes.Count == 0)
                throw new ArgumentException("At least one leaf is required.", nameof(leafHashes));

            List<byte[]> currentLevel = new(leafHashes);

            while (currentLevel.Count > 1)
            {
                var nextLevel = new List<byte[]>(capacity: (currentLevel.Count + 1) / 2);

                for (int i = 0; i < currentLevel.Count; i += 2)
                {
                    var left  = currentLevel[i];
                    var right = (i + 1 < currentLevel.Count)
                                ? currentLevel[i + 1]
                                : currentLevel[i];           // Duplicate last hash if uneven.

                    var concat = Concatenate(left, right);
                    nextLevel.Add(DoubleSha256(concat));
                }

                currentLevel = nextLevel;
            }

            return currentLevel[0];
        }

        #endregion

        #region Internal Helpers

        private static byte[] OneShotHash(ReadOnlySpan<byte> data, HashAlgorithmType type)
        {
            var algorithm = RentAlgorithm(type);
            try
            {
                return algorithm.ComputeHash(data);
            }
            finally
            {
                ReturnAlgorithm(type, algorithm);
            }
        }

        private static byte[] DoubleSha256(ReadOnlySpan<byte> data)
            => OneShotHash(OneShotHash(data, HashAlgorithmType.Sha256), HashAlgorithmType.Sha256);

        private static byte[] Sha256Ripemd160(ReadOnlySpan<byte> data)
            => OneShotHash(OneShotHash(data, HashAlgorithmType.Sha256), HashAlgorithmType.Ripemd160);

        private static string ConvertToHex(ReadOnlySpan<byte> bytes)
        {
            var sb = new StringBuilder(bytes.Length * 2);
            foreach (var b in bytes)
                sb.Append(b.ToString("x2"));
            return sb.ToString();
        }

        private static byte[] Concatenate(byte[] left, byte[] right)
        {
            var combined = new byte[left.Length + right.Length];
            Buffer.BlockCopy(left,  0, combined, 0,            left.Length);
            Buffer.BlockCopy(right, 0, combined, left.Length,  right.Length);
            return combined;
        }

        #endregion

        #region HashAlgorithm Pooling

        private static HashAlgorithm RentAlgorithm(HashAlgorithmType type)
        {
            var bag = _pools.GetOrAdd(type, _ => new ConcurrentBag<HashAlgorithm>());

            if (bag.TryTake(out var algorithm))
                return algorithm;

            // Recreate if pool is empty.
            return type switch
            {
                HashAlgorithmType.Sha256           => SHA256.Create(),
                HashAlgorithmType.Sha512           => SHA512.Create(),
                HashAlgorithmType.Ripemd160        => RIPEMD160.Create(),
                HashAlgorithmType.DoubleSha256     => SHA256.Create(),   // Placeholder; handled separately.
                HashAlgorithmType.Sha256Ripemd160  => SHA256.Create(),   // Placeholder; handled separately.
                _ => throw new NotSupportedException($"Unsupported hash algorithm: {type}")
            };
        }

        private static void ReturnAlgorithm(HashAlgorithmType type, HashAlgorithm algorithm)
        {
            // Clear internal state so the next caller starts fresh.
            algorithm.Initialize();

            var bag = _pools.GetOrAdd(type, _ => new ConcurrentBag<HashAlgorithm>());
            bag.Add(algorithm);
        }

        #endregion
    }
}
```