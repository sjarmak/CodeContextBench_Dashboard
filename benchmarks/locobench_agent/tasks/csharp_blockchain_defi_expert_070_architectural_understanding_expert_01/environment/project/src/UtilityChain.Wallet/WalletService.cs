```csharp
// -----------------------------------------------------------------------------
//  File:    WalletService.cs
//  Project: UtilityChain Core Suite  (blockchain_defi)
//  Author:  Auto-generated by UtilityChain AI assistant
//
//  Overview
//  ========
//  Provides a high-level façade around low-level cryptographic key-management
//  and RPC communication with the underlying UtilityChain node.  The service
//  is intentionally opinionated and hides encryption, address derivation, and
//  transaction-signing details behind a simple, task-based API so that
//  upstream UI, CLI, and automated agents can remain ignorant of the
//  blockchain plumbing.
//
//  Patterns Utilised
//  -----------------
//  • Factory Pattern…………… Generates wallet entities through 3 separate factories
//  • Observer Pattern………… Raises events when wallet state changes
//  • Strategy Pattern………  Pluggable signers (ECDSA, EdDSA,…)
//  • Proxy Pattern……………… Delegates RPC calls to an injected IBlockchainNodeClient
// -----------------------------------------------------------------------------

using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace UtilityChain.Wallet
{
    #region Public Contracts
    // ------------------------------------------------------------------------
    //  NOTE:
    //  In the actual monolith these contracts live in their own projects that
    //  are referenced by both the Wallet and Node layers.  They are duplicated
    //  here to keep the file self-contained.
    // ------------------------------------------------------------------------

    /// <summary>
    /// Abstraction over the RPC client (REST / gRPC / raw sockets) that
    /// communicates with the running UtilityChain node.
    /// </summary>
    public interface IBlockchainNodeClient
    {
        Task<decimal> GetBalanceAsync(string address, CancellationToken ct = default);

        /// <summary>Sends a signed transaction to the network.</summary>
        Task<string> BroadcastTransactionAsync(TransactionPayload payload, CancellationToken ct = default);
    }

    /// <summary>
    /// Abstract persistence boundary.  Implementations decide whether data is
    /// stored on disk, in a database, or in-memory for testing.
    /// </summary>
    public interface IWalletRepository
    {
        Task PersistAsync(WalletEntity entity, CancellationToken ct = default);
        Task<IReadOnlyCollection<WalletEntity>> GetAllAsync(CancellationToken ct = default);
    }

    /// <summary>
    /// Strategy for signing binary payloads.  The chosen algorithm is selected
    /// by name (e.g. "ECDSA-secp256k1", "Ed25519").
    /// </summary>
    public interface ICryptoSigner
    {
        string Name { get; }
        byte[] Sign(ReadOnlySpan<byte> data, ReadOnlySpan<byte> privateKey);
        string PublicKeyFromPrivateKey(ReadOnlySpan<byte> privateKey);
    }

    /// <summary>
    /// Immutable, network-ready wire payload.
    /// </summary>
    /// <param name="From">Sender address</param>
    /// <param name="To">Receiver address</param>
    /// <param name="Amount">Token amount</param>
    /// <param name="Fee">Network fee</param>
    /// <param name="Signature">Hex-encoded signature</param>
    public record TransactionPayload(string From,
                                     string To,
                                     decimal Amount,
                                     decimal Fee,
                                     string Signature);

    /// <summary>
    /// Publicly visible wallet information (never exposes the private key).
    /// </summary>
    public record WalletInfo(string Address,
                             string PublicKey,
                             string? Label,
                             DateTime CreatedAt);

    /// <summary>
    /// Event args for wallet updates (balance, label change, etc.).
    /// </summary>
    public sealed class WalletChangedEventArgs : EventArgs
    {
        public WalletInfo Wallet { get; }
        public WalletChangedEventArgs(WalletInfo wallet) => Wallet = wallet;
    }

    /// <summary>
    /// Wallet service boundary used by UI & API layers.
    /// </summary>
    public interface IWalletService
    {
        Task<WalletInfo> CreateAsync(string? label,
            string? passphrase,
            CancellationToken ct = default);

        Task<WalletInfo> ImportFromPrivateKeyAsync(string privateKeyHex,
            string? label,
            string? passphrase,
            CancellationToken ct = default);

        Task<WalletInfo> ImportFromMnemonicAsync(string mnemonic,
            string? label,
            string? passphrase,
            CancellationToken ct = default);

        Task<decimal> GetBalanceAsync(string address, CancellationToken ct = default);

        Task<string> SendAsync(string fromAddress,
            string toAddress,
            decimal amount,
            decimal fee,
            string passphrase,
            CancellationToken ct = default);

        IReadOnlyCollection<WalletInfo> ListLocalWallets();

        event EventHandler<WalletChangedEventArgs>? WalletChanged;
    }

    #endregion

    #region Entity Model

    internal enum WalletSource
    {
        Generated,
        ImportedPrivateKey,
        ImportedMnemonic
    }

    /// <summary>
    /// Internal persistence-ready entity (encrypted private key is stored).
    /// </summary>
    internal sealed record WalletEntity(string Address,
                                        string PublicKey,
                                        string EncryptedPrivateKey,
                                        WalletSource Source,
                                        string? Label,
                                        DateTime CreatedAt);

    #endregion

    // =========================================================================
    //                               SERVICE
    // =========================================================================
    public sealed class WalletService : IWalletService, IDisposable
    {
        private const int PBKDF2_Iterations = 100_000;
        private const int AesKeySizeBits    = 256;
        private static readonly Encoding Utf8 = Encoding.UTF8;

        private readonly IWalletRepository _repo;
        private readonly IBlockchainNodeClient _node;
        private readonly IReadOnlyDictionary<string, ICryptoSigner> _signers;
        private readonly ILogger<WalletService> _logger;
        private readonly ConcurrentDictionary<string, WalletEntity> _walletCache = new();

        private readonly Timer _pollTimer;
        private readonly TimeSpan _pollInterval = TimeSpan.FromSeconds(15);
        private bool _disposed;

        public event EventHandler<WalletChangedEventArgs>? WalletChanged;

        public WalletService(IWalletRepository repository,
                             IBlockchainNodeClient nodeClient,
                             IEnumerable<ICryptoSigner> signers,
                             ILogger<WalletService> logger)
        {
            _repo    = repository  ?? throw new ArgumentNullException(nameof(repository));
            _node    = nodeClient  ?? throw new ArgumentNullException(nameof(nodeClient));
            _logger  = logger      ?? throw new ArgumentNullException(nameof(logger));

            // Map signers by unique name for quick access.
            var dict = new Dictionary<string, ICryptoSigner>(StringComparer.OrdinalIgnoreCase);
            foreach (var s in signers ?? throw new ArgumentNullException(nameof(signers)))
                dict[s.Name] = s;
            _signers = dict;

            // Load persisted wallets into memory.
            BootstrapAsync(CancellationToken.None).GetAwaiter().GetResult();

            // Start background polling to raise balance-change events.
            _pollTimer = new Timer(_ => _ = PollBalancesAsync(),
                                    null,
                                    _pollInterval,
                                    _pollInterval);
        }

        // ---------------------------------------------------------------------
        //  IWalletService implementation
        // ---------------------------------------------------------------------

        public async Task<WalletInfo> CreateAsync(
            string? label,
            string? passphrase,
            CancellationToken ct = default)
        {
            var privateKey = GeneratePrivateKey(out var publicKey);

            var encryptedPk = EncryptPrivateKey(privateKey, passphrase);
            var address     = DeriveAddress(publicKey);

            var entity = new WalletEntity(address,
                                          publicKey,
                                          encryptedPk,
                                          WalletSource.Generated,
                                          label,
                                          DateTime.UtcNow);

            await _repo.PersistAsync(entity, ct).ConfigureAwait(false);
            _walletCache[address] = entity;

            var info = ToInfo(entity);
            WalletChanged?.Invoke(this, new WalletChangedEventArgs(info));

            _logger.LogInformation("New wallet generated {Address}", address);
            return info;
        }

        public async Task<WalletInfo> ImportFromPrivateKeyAsync(
            string privateKeyHex,
            string? label,
            string? passphrase,
            CancellationToken ct = default)
        {
            if (string.IsNullOrWhiteSpace(privateKeyHex))
                throw new ArgumentException("Private key cannot be empty.", nameof(privateKeyHex));

            byte[] privateKey = Convert.FromHexString(privateKeyHex);
            string publicKey  = GetSigner().PublicKeyFromPrivateKey(privateKey);
            string address    = DeriveAddress(publicKey);

            var entity = new WalletEntity(address,
                                          publicKey,
                                          EncryptPrivateKey(privateKey, passphrase),
                                          WalletSource.ImportedPrivateKey,
                                          label,
                                          DateTime.UtcNow);

            await _repo.PersistAsync(entity, ct).ConfigureAwait(false);
            _walletCache[address] = entity;

            var info = ToInfo(entity);
            WalletChanged?.Invoke(this, new WalletChangedEventArgs(info));
            _logger.LogInformation("Wallet imported from private-key {Address}", address);

            return info;
        }

        public async Task<WalletInfo> ImportFromMnemonicAsync(
            string mnemonic,
            string? label,
            string? passphrase,
            CancellationToken ct = default)
        {
            if (string.IsNullOrWhiteSpace(mnemonic))
                throw new ArgumentException("Mnemonic cannot be blank.", nameof(mnemonic));

            // In full build we would call BIP-39/44 lib here.  For now hash it.
            using var sha = SHA256.Create();
            var seed = sha.ComputeHash(Utf8.GetBytes(mnemonic.Trim().ToLowerInvariant()));
            byte[] privateKey = seed[..32];                                    // first 256-bits
            string publicKey  = GetSigner().PublicKeyFromPrivateKey(privateKey);
            string address    = DeriveAddress(publicKey);

            var entity = new WalletEntity(address,
                                          publicKey,
                                          EncryptPrivateKey(privateKey, passphrase),
                                          WalletSource.ImportedMnemonic,
                                          label,
                                          DateTime.UtcNow);

            await _repo.PersistAsync(entity, ct).ConfigureAwait(false);
            _walletCache[address] = entity;

            var info = ToInfo(entity);
            WalletChanged?.Invoke(this, new WalletChangedEventArgs(info));
            _logger.LogInformation("Wallet imported from mnemonic {Address}", address);

            return info;
        }

        public Task<decimal> GetBalanceAsync(string address, CancellationToken ct = default)
            => _node.GetBalanceAsync(address, ct);

        public async Task<string> SendAsync(
            string fromAddress,
            string toAddress,
            decimal amount,
            decimal fee,
            string passphrase,
            CancellationToken ct = default)
        {
            if (!_walletCache.TryGetValue(fromAddress, out var entity))
                throw new InvalidOperationException($"Wallet '{fromAddress}' not found.");

            byte[] privateKey = DecryptPrivateKey(entity.EncryptedPrivateKey, passphrase);
            var signer = GetSigner();

            // Compose canonical serialisation:
            string message = string.Create(CultureInfo.InvariantCulture,
                $"{fromAddress}:{toAddress}:{amount}:{fee}:{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}");
            byte[] msgBytes = Utf8.GetBytes(message);
            byte[] sigBytes = signer.Sign(msgBytes, privateKey);

            var payload = new TransactionPayload(fromAddress,
                                                 toAddress,
                                                 amount,
                                                 fee,
                                                 Convert.ToHexString(sigBytes));

            string txHash = await _node.BroadcastTransactionAsync(payload, ct)
                                        .ConfigureAwait(false);

            _logger.LogInformation("Tx broadcasted {Hash} from {Sender} to {Recipient} ({Amount})",
                txHash, fromAddress, toAddress, amount);

            return txHash;
        }

        public IReadOnlyCollection<WalletInfo> ListLocalWallets()
        {
            var list = new List<WalletInfo>(_walletCache.Count);
            foreach (var w in _walletCache.Values)
                list.Add(ToInfo(w));
            return list.AsReadOnly();
        }

        #endregion

        #region Private Helpers

        private async ValueTask BootstrapAsync(CancellationToken ct)
        {
            var all = await _repo.GetAllAsync(ct).ConfigureAwait(false);
            foreach (var entity in all)
                _walletCache[entity.Address] = entity;
            _logger.LogInformation("WalletService bootstrapped with {Count} wallet(s)", _walletCache.Count);
        }

        private async Task PollBalancesAsync()
        {
            try
            {
                foreach (var kvp in _walletCache)
                {
                    string address = kvp.Key;
                    decimal newBal = await _node.GetBalanceAsync(address).ConfigureAwait(false);

                    // Balance comparison & caching omitted for brevity—would normally
                    // preserve old balance to avoid redundant events.
                    WalletChanged?.Invoke(this, new WalletChangedEventArgs(ToInfo(kvp.Value)));
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Wallet balance polling failed");
            }
        }

        private ICryptoSigner GetSigner()
        {
            const string DefaultSignerName = "ECDSA-secp256k1";
            if (!_signers.TryGetValue(DefaultSignerName, out var signer))
                throw new InvalidOperationException($"Signer '{DefaultSignerName}' was not registered with DI.");
            return signer;
        }

        private static WalletInfo ToInfo(WalletEntity entity)
            => new(entity.Address, entity.PublicKey, entity.Label, entity.CreatedAt);

        private static byte[] GeneratePrivateKey(out string publicKey)
        {
            // Use secp256k1 curve – available via explicit OID
            using var ecdsa = ECDsa.Create(new ECParameters
            {
                Curve = ECCurve.CreateFromOid(new Oid("1.3.132.0.10")) // secp256k1
            });

            var parameters = ecdsa.ExportParameters(true);
            byte[] priv = parameters.D!.Clone() as byte[] ?? throw new InvalidOperationException("Failed to export D");

            byte[] pubX = parameters.Q.X!;
            byte[] pubY = parameters.Q.Y!;
            Span<byte> pub = stackalloc byte[1 + pubX.Length + pubY.Length];
            pub[0] = 0x04;                                             // uncompressed prefix
            pubX.CopyTo(pub[1..]);
            pubY.CopyTo(pub[(1 + pubX.Length)..]);

            publicKey = Convert.ToHexString(pub);
            return priv;
        }

        private static string DeriveAddress(string publicKeyHex)
        {
            // Toy derivation: address = RIPEMD160(SHA256(pubKey))  (similar to BTC)
            byte[] pubBytes = Convert.FromHexString(publicKeyHex);
            Span<byte> sha = stackalloc byte[32];
            SHA256.HashData(pubBytes, sha);

            Span<byte> ripe = stackalloc byte[20];
            using var ripemd = RIPEMD160.Create();
            ripemd.TryComputeHash(sha, ripe, out _);

            return Convert.ToHexString(ripe);
        }

        private static string EncryptPrivateKey(byte[] privateKey, string? passphrase)
        {
            if (privateKey.Length != 32)
                throw new ArgumentException("Private key must be 256-bit.", nameof(privateKey));

            if (string.IsNullOrEmpty(passphrase))
                return Convert.ToHexString(privateKey);                // store raw (NOT recommended)

            // Derive symmetric key
            byte[] salt = RandomNumberGenerator.GetBytes(16);
            using var kdf = new Rfc2898DeriveBytes(passphrase, salt, PBKDF2_Iterations,
                                                   HashAlgorithmName.SHA256);
            byte[] key = kdf.GetBytes(AesKeySizeBits / 8);

            using var aes = Aes.Create();
            aes.Key = key;
            aes.GenerateIV();
            using var enc = aes.CreateEncryptor();

            byte[] cipher = new byte[privateKey.Length];
            enc.TransformBlock(privateKey, 0, privateKey.Length, cipher, 0);

            // finalised encryption (CBC padding not required—exact block)
            enc.TransformFinalBlock(Array.Empty<byte>(), 0, 0);

            // Persist SALT|IV|CIPHERTEXT → Base64
            using var ms = new MemoryStream();
            ms.Write(salt);
            ms.Write(aes.IV);
            ms.Write(cipher);
            return Convert.ToBase64String(ms.ToArray());
        }

        private static byte[] DecryptPrivateKey(string encrypted, string passphrase)
        {
            if (string.IsNullOrEmpty(passphrase))
                return Convert.FromHexString(encrypted);

            byte[] all = Convert.FromBase64String(encrypted);
            byte[] salt      = all[..16];
            byte[] iv        = all[16..32];
            byte[] cipherKey = all[32..];

            using var kdf = new Rfc2898DeriveBytes(passphrase, salt, PBKDF2_Iterations,
                                                   HashAlgorithmName.SHA256);
            byte[] key = kdf.GetBytes(AesKeySizeBits / 8);

            using var aes = Aes.Create();
            aes.Key = key;
            aes.IV  = iv;
            using var dec = aes.CreateDecryptor();

            byte[] plain = new byte[cipherKey.Length];
            dec.TransformBlock(cipherKey, 0, cipherKey.Length, plain, 0);
            dec.TransformFinalBlock(Array.Empty<byte>(), 0, 0);

            return plain;
        }

        #endregion

        #region IDisposable

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;
            _pollTimer.Dispose();
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}
```