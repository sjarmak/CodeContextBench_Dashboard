```csharp
// File: UtilityChainCoreSuite/src/UtilityChain.Wallet/Desktop/MainWindow.axaml.cs
//
// NOTE: Although this file lives next to the Avalonia XAML file (*.axaml),
// it is pure C# and contains the backing logic for the MainWindow.  The
// corresponding XAML markup must declare `x:Class="UtilityChain.Wallet.Desktop.MainWindow"`.
//
// UtilityChain Core Suite – Desktop Wallet
// ----------------------------------------
// • Displays balances, staking information, and network status
// • Reacts to domain-events dispatched by the in-process event-bus
// • Executes wallet commands (send, stake, refresh) through a façade
// • Demonstrates Observer, State-Machine, and Factory patterns in practice
//
// The code is intentionally kept framework-agnostic except for Avalonia UI
// and CommunityToolkit.Mvvm.  It may be wired through DI (e.g., Microsoft.Extensions.DependencyInjection)
// from the root Program.cs.
//
using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using UtilityChain.Common.Eventing;
using UtilityChain.Wallet.Abstractions;

namespace UtilityChain.Wallet.Desktop;

/// <summary>
/// Main application window for the UtilityChain desktop wallet.
/// Handles UI-related interaction and reacts to domain events coming
/// from the in-process event bus.
/// </summary>
public sealed partial class MainWindow : Window, IAsyncDisposable
{
    private readonly MainWindowViewModel               _viewModel;
    private readonly IEventBus                         _eventBus;
    private readonly IWalletFacade                     _wallet;
    private readonly ILogger<MainWindow>               _logger;
    private          IDisposable?                      _balanceChangedSubscription;
    private          CancellationTokenSource?          _cts;

    public MainWindow(
        IWalletFacade wallet,
        IEventBus     eventBus,
        ILogger<MainWindow> logger)
    {
        _wallet   = wallet  ?? throw new ArgumentNullException(nameof(wallet));
        _eventBus = eventBus?? throw new ArgumentNullException(nameof(eventBus));
        _logger   = logger  ?? throw new ArgumentNullException(nameof(logger));

        // View-model is constructed through a small factory helper to keep
        // DI registrations simple and testable.
        _viewModel        = new MainWindowViewModelFactory(wallet, logger).Create();
        DataContext       = _viewModel;

        InitializeComponent();
        SubscribeToDomainEvents();

        // Fire-and-forget initial refresh
        _ = RefreshAsync();
    }

    #region Event-Bus Wiring
    private void SubscribeToDomainEvents()
    {
        // Observer pattern; subscription disposed in DisposeAsync.
        _balanceChangedSubscription = _eventBus.Subscribe<WalletBalanceChangedEvent>(HandleBalanceChanged);
    }

    private void HandleBalanceChanged(WalletBalanceChangedEvent evt)
    {
        if (evt is null || evt.WalletAddress != _wallet.Address)
            return; // Not for this wallet instance

        _logger.LogInformation("Balance updated via event-bus: {Balance}", evt.NewBalance);

        // Update UI on dispatcher thread
        Dispatcher.UIThread.Post(() =>
        {
            _viewModel.Balance = evt.NewBalance;
        });
    }
    #endregion

    #region Async Refresh / Lifecycle

    /// <summary>
    /// Refreshes wallet data by querying the wallet façade asynchronously.
    /// </summary>
    private async Task RefreshAsync()
    {
        await (_cts?.CancelAsync() ?? ValueTask.CompletedTask);          // Cancel any inflight refresh
        _cts = new CancellationTokenSource();

        try
        {
            _viewModel.IsBusy = true;

            var (bal, staked) = await _wallet.GetBalanceAsync(_cts.Token);
            _viewModel.Balance        = bal;
            _viewModel.StakedBalance  = staked;
            _viewModel.IsNodeSynced   = await _wallet.IsNodeSyncedAsync(_cts.Token);
        }
        catch (OperationCanceledException)
        {
            _logger.LogDebug("Refresh operation was cancelled.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to refresh wallet state.");
            _viewModel.LastError = ex.Message;
        }
        finally
        {
            _viewModel.IsBusy = false;
        }
    }

    protected override async void OnClosed(EventArgs e)
    {
        base.OnClosed(e);
        await DisposeAsync();
    }

    public async ValueTask DisposeAsync()
    {
        _balanceChangedSubscription?.Dispose();
        _balanceChangedSubscription = null;

        if (_cts is { } cts)
        {
            cts.Cancel();
            await Task.Yield(); // Let cancellation propagate
            cts.Dispose();
        }
    }
    #endregion

    #region XAML Code-Behind Boilerplate
    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
    #endregion

    #region View-Model
    /// <summary>
    /// Strongly typed VM for the MainWindow.  All properties raise change-notifications
    /// via CommunityToolkit.Mvvm's <see cref="ObservableObject"/>.
    /// </summary>
    internal sealed partial class MainWindowViewModel : ObservableObject
    {
        [ObservableProperty] private string  _walletAddress = string.Empty;
        [ObservableProperty] private decimal _balance;
        [ObservableProperty] private decimal _stakedBalance;
        [ObservableProperty] private bool    _isNodeSynced;
        [ObservableProperty] private bool    _isBusy;
        [ObservableProperty] private string? _lastError;

        public IAsyncRelayCommand RefreshCommand { get; }
        public IAsyncRelayCommand SendCommand    { get; }
        public IAsyncRelayCommand StakeCommand   { get; }

        public MainWindowViewModel(
            IWalletFacade walletFacade,
            ILogger logger,
            Func<CancellationToken, Task> refreshFunc)
        {
            _walletAddress = walletFacade.Address;

            RefreshCommand = new AsyncRelayCommand(refreshFunc, CanExecute);
            SendCommand    = new AsyncRelayCommand(ct => SendAsync(walletFacade, ct),   CanExecute);
            StakeCommand   = new AsyncRelayCommand(ct => StakeAsync(walletFacade, ct),  CanExecute);

            bool CanExecute() => !IsBusy && walletFacade.IsUnlocked;
        }

        #region Command Handlers
        private static async Task SendAsync(IWalletFacade wallet, CancellationToken ct)
        {
            // This would normally open a dialog; simplified to CLI-style prompt for brevity.
            var recipient = Prompt("Recipient Address:");
            var amountStr = Prompt("Amount (UCN):");

            if (!decimal.TryParse(amountStr, NumberStyles.Number, CultureInfo.InvariantCulture, out var amount))
                throw new InvalidOperationException("Invalid numeric value.");

            await wallet.SendAsync(recipient, amount, ct);
        }

        private static async Task StakeAsync(IWalletFacade wallet, CancellationToken ct)
        {
            var amountStr = Prompt("Stake Amount (UCN):");

            if (!decimal.TryParse(amountStr, NumberStyles.Number, CultureInfo.InvariantCulture, out var amount))
                throw new InvalidOperationException("Invalid numeric value.");

            await wallet.StakeAsync(amount, ct);
        }

        private static string Prompt(string caption)
        {
            // Real UI would be better; Console fallback is acceptable in hybrid desktop-cli mode.
            Console.Write($"{caption} ");
            return Console.ReadLine() ?? string.Empty;
        }
        #endregion
    }

    /// <summary>
    /// Small factory that hides constructor complexity and allows MainWindow
    /// to stay ignorant of view-model specifics.
    /// </summary>
    private sealed class MainWindowViewModelFactory
    {
        private readonly IWalletFacade           _wallet;
        private readonly ILogger<MainWindow>     _logger;

        public MainWindowViewModelFactory(IWalletFacade wallet, ILogger<MainWindow> logger)
        {
            _wallet = wallet;
            _logger = logger;
        }

        public MainWindowViewModel Create()
        {
            return new MainWindowViewModel(
                _wallet,
                _logger,
                RefreshAsyncWrapper);

            async Task RefreshAsyncWrapper(CancellationToken token)
            {
                try
                {
                    await _wallet.RefreshAsync(token);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to execute manual refresh.");
                    throw; // Let AsyncRelayCommand deal with visualization
                }
            }
        }
    }
    #endregion
}
```