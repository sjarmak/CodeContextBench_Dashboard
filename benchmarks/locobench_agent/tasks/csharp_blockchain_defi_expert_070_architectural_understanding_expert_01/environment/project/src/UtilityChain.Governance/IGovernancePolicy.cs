```csharp
//------------------------------------------------------------------------------
// <auto-generated>
//     This file is part of UtilityChain Core Suite – Governance Module.
//     Copyright © UtilityChain Contributors
//
//     Licensed under the Business Source License, Version 1.1.
//     You may obtain a copy of the License at
//     https://github.com/utilitychain/utilitychain/blob/main/LICENSE
//
//     Unless required by applicable law or agreed to in writing, software
//     distributed under the License is distributed on an "AS IS" BASIS,
//     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace UtilityChain.Governance
{
    /// <summary>
    /// Abstraction for a governance policy engine.
    /// 
    /// A governance policy is responsible for:
    ///   • Validating and creating proposals.<br/>
    ///   • Authorising electors to cast votes.<br/>
    ///   • Maintaining proposal state and triggering finalisation.<br/>
    ///   • Emitting domain events consumed by the rest of the suite.
    ///
    /// Implementations must be thread-safe and re-entrant as the Core Suite
    /// executes modules concurrently in an in-process event loop.
    /// </summary>
    public interface IGovernancePolicy : IAsyncDisposable
    {
        /// <summary>
        /// A stable, unique identifier for the policy (e.g. "QuadraticVote").
        /// </summary>
        string PolicyName { get; }

        /// <summary>
        /// Short, human-readable description.
        /// </summary>
        string Description { get; }

        /// <summary>
        /// A set of proposal kinds accepted by this policy.
        /// </summary>
        IReadOnlyCollection<GovernanceProposalKind> SupportedProposalKinds { get; }

        /// <summary>
        /// Creates and persists an immutable proposal that is ready for voting.
        /// </summary>
        /// <exception cref="ArgumentNullException">Draft is <c>null</c>.</exception>
        /// <exception cref="GovernanceValidationException">
        ///     The draft violates one or more policy rules.
        /// </exception>
        Task<GovernanceProposal> CreateProposalAsync(
            GovernanceProposalDraft draft,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves a proposal by its identifier or throws <see cref="KeyNotFoundException"/>.
        /// </summary>
        Task<GovernanceProposal> GetProposalAsync(
            GovernanceProposalId proposalId,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Casts a vote and returns the resulting status.
        /// </summary>
        Task<GovernanceVoteResult> VoteAsync(
            GovernanceVote vote,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Finalises a proposal (if applicable) and returns the resulting status.
        /// </summary>
        Task<GovernanceProposalStatus> FinaliseAsync(
            GovernanceProposalId proposalId,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Permanently deletes a proposal. Intended for administrative clean-up
        /// in private deployments; not part of the canonical on-chain flow.
        /// </summary>
        Task DeleteAsync(
            GovernanceProposalId proposalId,
            ParticipantId requester,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Raised when a proposal is accepted and queued for execution.
        /// </summary>
        event EventHandler<GovernanceProposalEventArgs>? ProposalAccepted;

        /// <summary>
        /// Raised when a proposal fails (rejected, expired, etc.).
        /// </summary>
        event EventHandler<GovernanceProposalEventArgs>? ProposalFailed;

        /// <summary>
        /// Raised whenever a vote is successfully cast.
        /// </summary>
        event EventHandler<GovernanceVoteEventArgs>? VoteCast;
    }

    #region ‑-- Supporting domain types (included for compile-time completeness) ‑--

    /// <summary>
    /// Deterministic identifier of a proposal.
    /// </summary>
    public readonly record struct GovernanceProposalId(Guid Value)
    {
        public static GovernanceProposalId New() => new(Guid.NewGuid());
        public override string ToString() => Value.ToString();
        public static implicit operator Guid(GovernanceProposalId id) => id.Value;
    }

    /// <summary>
    /// Identifier of a participant (wallet address, node id, etc.).
    /// </summary>
    public readonly record struct ParticipantId(string Value)
    {
        public override string ToString() => Value;
        public static implicit operator string(ParticipantId id) => id.Value;
    }

    /// <summary>
    /// Supported proposal kinds.
    /// </summary>
    public enum GovernanceProposalKind : byte
    {
        Unknown = 0,
        ParameterChange = 1,
        TreasuryTransfer = 2,
        SmartContractUpgrade = 3,
        Custom = 255
    }

    /// <summary>
    /// Immutable proposal model.
    /// </summary>
    public sealed record GovernanceProposal(
        GovernanceProposalId Id,
        GovernanceProposalKind Kind,
        string Title,
        string Description,
        ParticipantId Proposer,
        DateTimeOffset CreatedAt,
        DateTimeOffset? ExpiresAt,
        GovernanceProposalStatus Status,
        IReadOnlyDictionary<ParticipantId, GovernanceVote> Votes);

    /// <summary>
    /// Draft provided by client before validation.
    /// </summary>
    public sealed record GovernanceProposalDraft(
        GovernanceProposalKind Kind,
        string Title,
        string Description,
        ParticipantId Proposer,
        TimeSpan? LifeTime);

    /// <summary>
    /// Vote envelope.
    /// </summary>
    public sealed record GovernanceVote(
        GovernanceProposalId ProposalId,
        ParticipantId Elector,
        GovernanceVoteValue Value,
        byte[] Signature,
        DateTimeOffset Timestamp);

    /// <summary>Vote choice enumeration.</summary>
    public enum GovernanceVoteValue : byte
    {
        Abstain = 0,
        Yes = 1,
        No = 2
    }

    /// <summary>
    /// Result returned by <see cref="IGovernancePolicy.VoteAsync"/>.
    /// </summary>
    public sealed record GovernanceVoteResult(
        GovernanceVoteStatus Status,
        GovernanceProposal Proposal,
        string? Message = null);

    public enum GovernanceVoteStatus : byte
    {
        Accepted = 0,
        Duplicate = 1,
        Rejected = 2,
        NotPermitted = 3,
        OutOfScope = 4,
        Error = 255
    }

    /// <summary>Lifecycle states of a proposal.</summary>
    public enum GovernanceProposalStatus : byte
    {
        Pending = 0,
        Voting = 1,
        Accepted = 2,
        Rejected = 3,
        Executed = 4,
        Expired = 5,
        Cancelled = 6
    }

    /// <summary>EventArgs for proposal-related events.</summary>
    public sealed class GovernanceProposalEventArgs : EventArgs
    {
        public GovernanceProposal Proposal { get; }

        public GovernanceProposalEventArgs(GovernanceProposal proposal)
        {
            Proposal = proposal ?? throw new ArgumentNullException(nameof(proposal));
        }
    }

    /// <summary>EventArgs for vote-related events.</summary>
    public sealed class GovernanceVoteEventArgs : EventArgs
    {
        public GovernanceProposalId ProposalId { get; }
        public GovernanceVote Vote { get; }

        public GovernanceVoteEventArgs(GovernanceVote vote)
        {
            Vote = vote ?? throw new ArgumentNullException(nameof(vote));
            ProposalId = vote.ProposalId;
        }
    }

    /// <summary>Thrown when policy validation fails.</summary>
    public sealed class GovernanceValidationException : Exception
    {
        public GovernanceValidationException(string message) : base(message) { }
        public GovernanceValidationException(string message, Exception inner) : base(message, inner) { }
    }

    #endregion
}
```