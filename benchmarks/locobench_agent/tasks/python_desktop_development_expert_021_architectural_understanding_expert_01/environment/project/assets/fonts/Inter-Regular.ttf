```python
"""
FlockDesk – Font Asset Loader
File: assets/fonts/Inter-Regular.ttf  (logical representation)

This module takes care of validating and registering the Inter-Regular font
with Qt at run–time.  It is intentionally located *next to* the asset so that
packagers (PyInstaller / Briefcase / cx_Freeze / snapcraft) can keep the font
and its run–time helper in the same folder tree.

Usage
-----
>>> from assets.fonts.inter_regular import InterFont
>>> InterFont.install()                       # one-liner for app start-up
>>> label.setFont(InterFont.qfont(12))        # convenient helpers

The loader
----------
1. Verifies that the font file is present and uncorrupted (SHA-256 checksum).
2. Registers it with Qt’s `QFontDatabase`.
3. Emits diagnostic events so the rest of the event-bus-driven application
   can react to success or failure without tight coupling.

Dependencies
------------
PySide6 >= 6.4, watchdog (optional, only if hot-reload is desired).

Why is this a .py next to a .ttf?
---------------------------------
The project’s “assets/fonts” folder is declared as a Python namespace package
to piggy-back on the import-loader for asset discovery while still allowing
familiar `pkg_resources` / `importlib.resources` techniques.
"""

from __future__ import annotations

import hashlib
import logging
import os
import sys
from pathlib import Path
from typing import Final, Optional

from PySide6.QtGui import QFont, QFontDatabase

# Optional live-reload of the font file for designers who like instantaneous
# feedback.  If the package is frozen and watchdog is unavailable this is a
# harmless no-op.
try:
    from watchdog.events import FileSystemEventHandler
    from watchdog.observers import Observer

    _WATCHDOG_AVAILABLE = True
except ImportError:  # pragma: no cover
    _WATCHDOG_AVAILABLE = False


LOGGER: Final[logging.Logger] = logging.getLogger("flockdesk.fonts.inter")
HERE: Final[Path] = Path(__file__).resolve().parent
FONT_FILE: Final[Path] = HERE / "Inter-Regular.ttf"
# Calculated once by: shasum -a256 assets/fonts/Inter-Regular.ttf
FONT_SHA256: Final[str] = (
    "ca21d0dbc639e8af7d20508df3b39401008a0dc0e91a8c3dc27646b3f597e4fb"
)


class FontLoadError(RuntimeError):
    """Raised when the Inter font cannot be loaded or is invalid."""


class InterFont:
    """
    Namespace helper that abstracts away Qt font-handling specifics while
    exposing tiny, ergonomic helpers for the rest of the code–base.
    """

    _family: Optional[str] = None
    _id: Optional[int] = None

    # --------------------------------------------------------------------- #
    # Public section                                                        #
    # --------------------------------------------------------------------- #

    @classmethod
    def install(cls, hot_reload: bool = False) -> None:
        """
        Verify & install the Inter-Regular font into the current Qt instance.

        Parameters
        ----------
        hot_reload:
            Start a watchdog observer that reloads the font if the .ttf file
            changes on disk.  Effective during live-development only – ignored
            when running from a frozen build that bundles resources.
        """
        if cls._family:
            LOGGER.debug("Inter font already registered as '%s'", cls._family)
            return

        cls._verify_asset_integrity()
        font_id = QFontDatabase.addApplicationFont(str(FONT_FILE))

        if font_id == -1:
            raise FontLoadError(
                f"Qt rejected '{FONT_FILE.name}'. Inspect the font file."
            )

        families = QFontDatabase.applicationFontFamilies(font_id)
        if not families:
            raise FontLoadError(
                f"Qt registered '{FONT_FILE.name}' but returned zero families."
            )

        cls._family = families[0]
        cls._id = font_id
        LOGGER.info("Inter font registered: id=%s, family='%s'", font_id, cls._family)

        # ------------------------------------------------------------- #
        # Optional hot-reload                                           #
        # ------------------------------------------------------------- #
        if hot_reload and _WATCHDOG_AVAILABLE and _is_dev_mode():
            LOGGER.info("Enabling hot-reload for Inter font asset.")
            _FontHotReloader(cls).start()

    @classmethod
    def qfont(cls, point_size: int = 10, weight: int = QFont.Normal) -> QFont:
        """
        Return a fully initialised QFont instance for Inter-Regular.

        The font **must** have been installed beforehand (usually by the
        application bootstrap).  Otherwise a plain QFont fallback is returned
        and a soft-warning is logged.
        """
        if not cls._family:
            LOGGER.warning("Inter font requested before installation.")
            return QFont("", point_size, weight)

        font = QFont(cls._family, point_size, weight)
        font.setStyleHint(QFont.SansSerif)
        return font

    # --------------------------------------------------------------------- #
    # Internal helpers                                                      #
    # --------------------------------------------------------------------- #

    @classmethod
    def _verify_asset_integrity(cls) -> None:
        """Ensure the local Inter-Regular.ttf matches the shipped checksum."""
        if not FONT_FILE.exists():
            raise FontLoadError(
                f"Font asset '{FONT_FILE}' missing. "
                "Has the packaging step removed it?"
            )

        sha256 = _file_sha256(FONT_FILE)
        if sha256 != FONT_SHA256:
            raise FontLoadError(
                f"Font asset checksum mismatch for '{FONT_FILE.name}'. "
                f"Expected {FONT_SHA256[:12]}…, got {sha256[:12]}…"
            )
        LOGGER.debug("Inter font checksum OK (%s)", sha256[:12])


# ------------------------------------------------------------------------- #
# Utility / support sections                                                #
# ------------------------------------------------------------------------- #
def _file_sha256(path: Path) -> str:
    """Return SHA-256 hex‐digest for a given path (streamed, memory-safe)."""
    digest = hashlib.sha256()
    with path.open("rb") as fp:
        for chunk in iter(lambda: fp.read(8192), b""):
            digest.update(chunk)
    return digest.hexdigest()


def _is_dev_mode() -> bool:
    """
    Decide if the app is running from source or from a frozen/installed build.

    The heuristic is very simple (inspect ._MEIPASS or site-packages).  Projects
    with specialised needs may override this at bootstrap time.
    """
    return not getattr(sys, "frozen", False)


# ------------------------------------------------------------------------- #
# Hot-reload helper                                                         #
# ------------------------------------------------------------------------- #
class _FontHotReloader(FileSystemEventHandler):
    """
    Watch the Inter-Regular.ttf file on disk and re-install the font if it
    changes.  Designers do not have to restart the whole application while
    tweaking font hinting.
    """

    def __init__(self, font_cls: type[InterFont]) -> None:
        self._font_cls = font_cls
        self._observer: Optional[Observer] = None

    # --------------------------- watchdog hooks -------------------------- #

    def on_modified(self, event):  # pylint: disable=invalid-name
        if event.src_path != str(FONT_FILE):
            return
        LOGGER.info("Detected modification of '%s' – re-loading font.", FONT_FILE)
        try:
            self._font_cls._family = None  # type: ignore[protected-access]
            self._font_cls.install()
        except Exception:  # pylint: disable=broad-except
            LOGGER.exception("Failed to hot-reload '%s'.", FONT_FILE)

    # --------------------------- public API ------------------------------ #

    def start(self) -> None:
        if self._observer:
            return  # already started

        self._observer = Observer()
        self._observer.schedule(self, str(FONT_FILE.parent), recursive=False)
        self._observer.daemon = True
        self._observer.start()
        LOGGER.debug("Watchdog observer started for '%s'.", FONT_FILE)

    def stop(self) -> None:
        if not self._observer:
            return

        self._observer.stop()
        self._observer.join(timeout=1)
        LOGGER.debug("Watchdog observer stopped for '%s'.", FONT_FILE)


# ------------------------------------------------------------------------- #
# CLI test/debug interface                                                  #
# ------------------------------------------------------------------------- #
if __name__ == "__main__":  # pragma: no cover
    logging.basicConfig(
        level=logging.DEBUG, format="%(levelname)7s  %(name)s – %(message)s"
    )

    try:
        InterFont.install(hot_reload=True)
        print("Inter font installed.  Family =", InterFont._family)  # noqa: SLF001
    except FontLoadError as exc:
        print("ERROR:", exc)
```