```python
"""
FlockDesk – Social Workspace Orchestrator
Module.....: flockdesk.modules.chat.view.chat_widget
File type..: Source (UI/View)
Purpose....: Qt-based “ChatWidget” that represents the *View* layer in the
             MVVM triad.  The widget is consciously *dumb*; it forwards user
             intent to the supplied `ChatViewModel`, reacts to its signals, and
             notifies the global event-bus for cross-process communication.

NOTE:
    Even though the file path ends with “.ui”, the project evolved to generate
    widgets programmatically in order to support hot theme-switching and live
    plugin injection.  The original Qt-Designer XML was kept for reference but
    is no longer loaded at runtime.
"""

from __future__ import annotations

import logging
import pathlib
from typing import Optional, Callable

from PySide6.QtCore import Qt, Signal, Slot, QEvent
from PySide6.QtGui import QColor, QDragEnterEvent, QDropEvent, QKeySequence
from PySide6.QtWidgets import (
    QApplication,
    QHBoxLayout,
    QListWidget,
    QListWidgetItem,
    QPlainTextEdit,
    QPushButton,
    QSizePolicy,
    QToolButton,
    QVBoxLayout,
    QWidget,
    QStyle,
    QMessageBox,
)

# --------------------------------------------------------------------------- #
# Local project imports.  They are intentionally *hard* imports to fail fast  #
# during plugin start-up if the environment is not sane.                      #
# --------------------------------------------------------------------------- #
try:
    from flockdesk.core.events import EventBus, BusEvent             # type: ignore
    from flockdesk.modules.chat.model.message import ChatMessage     # type: ignore
    from flockdesk.modules.chat.view_model import ChatViewModel      # type: ignore
except ImportError as exc:  # pragma: no cover
    raise SystemExit(
        "Fatal – ChatWidget could not import required FlockDesk packages."
    ) from exc


_LOGGER = logging.getLogger(__name__)


# =============================================================================
# Widget
# =============================================================================
class ChatWidget(QWidget):
    """
    A re-usable chat widget that can be embedded into *any* parent-view.
    The widget does *not* perform domain logic.  Everything smart happens inside
    `ChatViewModel`.  The control flow is:

        UI event ──► ChatWidget *(signals)* ──► ViewModel
        ViewModel  ──► ChatWidget *(slots)* ──► UI update
        ViewModel  ──► EventBus   *(publish)*

    Public signals:
        messageSent(ChatMessage)
    """

    messageSent = Signal(ChatMessage)

    # ---------- ctor ----------------------------------------------------- #
    def __init__(
        self,
        view_model: ChatViewModel,
        event_bus: EventBus,
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self._vm: ChatViewModel = view_model
        self._bus: EventBus = event_bus

        self._setup_ui()
        self._wire_signals()
        self._apply_initial_state()

    # --------------------------------------------------------------------- #
    # UI                                                                   #
    # --------------------------------------------------------------------- #
    def _setup_ui(self) -> None:
        """Assemble the widget tree."""
        self.setObjectName("ChatWidget")
        self.setAcceptDrops(True)

        # Outer layout.  Using V-layout so content grows vertically.
        root_layout = QVBoxLayout(self)
        root_layout.setContentsMargins(8, 8, 8, 8)
        root_layout.setSpacing(6)

        # Message list at the top ‑- read-only
        self._list = QListWidget(self)
        self._list.setObjectName("MessageList")
        self._list.setAlternatingRowColors(True)
        self._list.setSelectionMode(QListWidget.NoSelection)
        self._list.setWordWrap(True)
        self._list.verticalScrollBar().setSingleStep(20)
        root_layout.addWidget(self._list, 10)

        # Compose area at the bottom
        editor_layout = QHBoxLayout()
        editor_layout.setSpacing(4)

        self._editor = QPlainTextEdit(self)
        self._editor.setObjectName("ChatEditor")
        self._editor.setPlaceholderText("Write a message…")
        self._editor.setTabChangesFocus(True)
        self._editor.setMaximumBlockCount(2048)  # Soft-limit message length
        self._editor.setSizePolicy(
            QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum
        )
        editor_layout.addWidget(self._editor, 1)

        # Side button column
        button_column = QVBoxLayout()
        button_column.setSpacing(2)

        self._attach_button = QToolButton(self)
        self._attach_button.setIcon(
            self.style().standardIcon(QStyle.SP_FileDialogNewFolder)
        )
        self._attach_button.setToolTip("Attach file (Ctrl+Shift+U)")
        button_column.addWidget(self._attach_button)

        self._send_button = QPushButton("Send", self)
        self._send_button.setObjectName("SendButton")
        self._send_button.setDefault(True)
        self._send_button.setEnabled(False)
        button_column.addWidget(self._send_button)

        # Push column to bottom of editor row
        button_column.addStretch()
        editor_layout.addLayout(button_column)

        root_layout.addLayout(editor_layout)

        # Accessibility / Shortcuts
        self._editor.installEventFilter(self)
        self._send_shortcut = QKeySequence(Qt.CTRL | Qt.Key_Return)

    # ------------------------------------------------------------------ #
    # Qt Event Overrides                                                 #
    # ------------------------------------------------------------------ #
    def eventFilter(self, obj: QObject, event: QEvent) -> bool:  # type: ignore[name-defined]  # noqa: D401,E501
        """
        Intercept key strokes inside the editor to enable `Ctrl+Enter` sending
        while preserving normal newline for `Enter`.
        """
        if obj is self._editor and event.type() == QEvent.KeyPress:  # pylint: disable=no-member
            key_event = event  # type: ignore[assignment]
            if QKeySequence(key_event.modifiers() | key_event.key()) == self._send_shortcut:
                self._on_send_clicked()
                return True
        return super().eventFilter(obj, event)

    # -------------------------------
    # Drag-and-drop (file sharing)
    # -------------------------------
    def dragEnterEvent(self, event: QDragEnterEvent) -> None:  # noqa: N802
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            event.ignore()

    def dropEvent(self, event: QDropEvent) -> None:  # noqa: N802
        urls = event.mimeData().urls()
        if not urls:
            return
        for url in urls:
            local_path = pathlib.Path(url.toLocalFile())
            if local_path.exists():
                self._vm.enqueue_file_upload(local_path)
        event.acceptProposedAction()

    # ------------------------------------------------------------------ #
    # Signal wires                                                       #
    # ------------------------------------------------------------------ #
    def _wire_signals(self) -> None:
        """Connect GUI controls to methods and ViewModel signals to slots."""
        self._send_button.clicked.connect(self._on_send_clicked)
        self._attach_button.clicked.connect(self._on_attach_clicked)
        self._editor.textChanged.connect(self._adjust_send_button_state)

        # ViewModel → View
        self._vm.message_arrived.connect(self._append_message)
        self._vm.system_notification.connect(self._append_system_message)

        # View → EventBus
        self.messageSent.connect(self._bus.publish)

    # ------------------------------------------------------------------ #
    # Startup state                                                      #
    # ------------------------------------------------------------------ #
    def _apply_initial_state(self) -> None:
        """Populate the widget from the ViewModel’s current snapshot."""
        for msg in self._vm.initial_history():
            self._append_message(msg)

    # ------------------------------------------------------------------ #
    # UI update helpers                                                  #
    # ------------------------------------------------------------------ #
    @Slot(ChatMessage)
    def _append_message(self, message: ChatMessage) -> None:
        """Add an incoming chat message to the QListWidget."""
        item = QListWidgetItem(message.formatted())
        # Color-code own messages
        if message.username == self._vm.current_user():
            item.setForeground(QColor("#1e81b0"))
        self._list.addItem(item)
        self._list.scrollToBottom()

    @Slot(str)
    def _append_system_message(self, text: str) -> None:
        """Special styling for server notifications."""
        item = QListWidgetItem(f"⚙️ {text}")
        item.setForeground(QColor("gray"))
        self._list.addItem(item)
        self._list.scrollToBottom()

    # ------------------------------------------------------------------ #
    # UI action callbacks                                                #
    # ------------------------------------------------------------------ #
    def _on_send_clicked(self) -> None:
        """User hit the Send button (or shortcut)."""
        raw = self._editor.toPlainText().strip()
        self._editor.clear()
        if not raw:
            return

        try:
            message = self._vm.build_outgoing_message(raw)
        except ValueError as exc:
            _LOGGER.warning("Rejecting message: %s", exc, exc_info=True)
            QMessageBox.warning(self, "Unable to send", str(exc))
            return

        self.messageSent.emit(message)
        self._append_message(message)

    def _on_attach_clicked(self) -> None:
        """Let ViewModel handle attachment dialog."""
        self._vm.trigger_file_chooser(self)

    # ------------------------------------------------------------------ #
    # State helpers                                                      #
    # ------------------------------------------------------------------ #
    @Slot()
    def _adjust_send_button_state(self) -> None:
        """Disable *Send* until the editor has some input."""
        text = self._editor.toPlainText()
        self._send_button.setEnabled(bool(text.strip()))


# =============================================================================
# Kick-off (debug/run-stand-alone)
# =============================================================================
def _debug_main() -> None:  # pragma: no cover
    """Run the widget stand-alone for quick developer iteration."""
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(levelname)1.1s %(message)s",
    )
    app = QApplication([])

    from flockdesk.core.events import LocalEventBus  # Local stub / test-bus
    from flockdesk.modules.chat.model.simple_message import SimpleChatMessage
    from flockdesk.modules.chat.view_model.simple import SimpleChatViewModel

    bus: EventBus = LocalEventBus()
    vm = SimpleChatViewModel(bus=bus)
    vm.inject_debug_history()  # Pre-populate with sample messages

    widget = ChatWidget(view_model=vm, event_bus=bus)
    widget.resize(640, 480)
    widget.show()

    _LOGGER.info("Starting ChatWidget debug-session.")
    app.exec()


if __name__ == "__main__":  # pragma: no cover
    _debug_main()
```