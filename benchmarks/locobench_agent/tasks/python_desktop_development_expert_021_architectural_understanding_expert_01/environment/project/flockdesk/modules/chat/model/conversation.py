```python
"""
flockdesk.modules.chat.model.conversation
-----------------------------------------

Data-model and domain logic for FlockDesk “Chat” micro-front-end.

The Conversation class is intentionally *business-logic only* (no GUI
or transport concerns) so that it can be reused by:

* the Qt MVVM view-model layer
* the persistence layer (SQLite / Realm / Cloud sync service)
* the internal event-bus bridges (IPC & WebSocket gateways)

Thread-safety: All mutating operations are protected by an
`RLock` to guarantee consistency when the same Conversation instance is
shared between the GUI thread and background sync workers.
"""

from __future__ import annotations

import json
import logging
import threading
import uuid
from dataclasses import asdict, dataclass, field
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence

# --------------------------------------------------------------------------- #
# Event-bus integration – only import the protocol, do NOT import heavy code
# here (lazy-loading prevents circular deps inside micro-front-ends).
# --------------------------------------------------------------------------- #

try:
    # Local import; the actual implementation lives in
    # flockdesk.infrastructure.event_bus
    from flockdesk.infrastructure.event_bus import EventBus, PublishKwargs
except ModuleNotFoundError:  # Fallback for unit-tests
    class EventBus:  # noqa: D401 – stub class
        """Simple in-process dummy bus for tests/build-time type-checks."""

        def publish(self, topic: str, payload: Any, **_: Any) -> None:  # noqa: ANN401
            logging.getLogger(__name__).debug("EventBus stub publish: %s %s", topic, payload)

    PublishKwargs = Dict[str, Any]  # type: ignore


__all__ = [
    "MessageType",
    "Message",
    "Conversation",
    "ConversationError",
]

LOGGER = logging.getLogger(__name__)
ISO8601_FMT = "%Y-%m-%dT%H:%M:%S.%fZ"


# --------------------------------------------------------------------------- #
# Domain types
# --------------------------------------------------------------------------- #

class MessageType(str, Enum):
    """All recognised message flavours handled by FlockDesk chat."""

    REGULAR = "regular"          # Plain text
    SYSTEM = "system"            # “X joined the room”, etc.
    PLUGIN = "plugin"            # Generated by a plug-in (polls, code review)
    MEDIA = "media"              # Attachments or inline media


@dataclass(slots=True, frozen=True, kw_only=True)
class Message:
    """
    Immutable message entity.

    `id` is globally unique (not per-conversation) to simplify syncing
    between offline devices.
    """

    sender_id: str
    content: str
    msg_type: MessageType = MessageType.REGULAR
    created_at: datetime = field(
        default_factory=lambda: datetime.now(tz=timezone.utc)
    )
    id: str = field(default_factory=lambda: uuid.uuid4().hex)
    plugin_payload: Optional[Dict[str, Any]] = None

    # Serialization helpers --------------------------------------------------- #
    def to_dict(self) -> Dict[str, Any]:
        """Convert to JSON-serializable dict (timezone-aware)."""
        dct = asdict(self)
        dct["msg_type"] = self.msg_type.value
        dct["created_at"] = self.created_at.strftime(ISO8601_FMT)
        return dct

    @classmethod
    def from_dict(cls, raw: Dict[str, Any]) -> "Message":
        """Reverse of `to_dict`—strict validation is enforced."""
        try:
            return cls(
                sender_id=str(raw["sender_id"]),
                content=str(raw["content"]),
                msg_type=MessageType(raw["msg_type"]),
                created_at=datetime.strptime(raw["created_at"], ISO8601_FMT).replace(
                    tzinfo=timezone.utc
                ),
                id=str(raw["id"]),
                plugin_payload=raw.get("plugin_payload"),
            )
        except (KeyError, ValueError) as exc:
            raise ConversationError("Malformed message data") from exc


# --------------------------------------------------------------------------- #
# Errors
# --------------------------------------------------------------------------- #

class ConversationError(RuntimeError):
    """Top-level error for conversation-related issues."""


# --------------------------------------------------------------------------- #
# Conversation model
# --------------------------------------------------------------------------- #

class Conversation:
    """
    Aggregate root for a single chat stream.

    Persistence is responsibility of *callers* – yet JSON roundtrip
    helpers are provided for convenience.
    """

    VERSION = 1  # Used in serialization to support migrations

    def __init__(
        self,
        participants: Sequence[str],
        *,
        topic: str | None = None,
        id: Optional[str] = None,
        read_only: bool = False,
        event_bus: Optional[EventBus] = None,
    ) -> None:
        if not participants:
            raise ConversationError("Participants list may not be empty")

        self._id: str = id or uuid.uuid4().hex
        self._topic: Optional[str] = topic
        self._participants: List[str] = sorted(set(participants))
        self._messages: List[Message] = []
        self._created_at: datetime = datetime.now(tz=timezone.utc)
        self._read_only: bool = read_only

        self._event_bus: EventBus | None = event_bus
        self._lock = threading.RLock()

        LOGGER.debug("Conversation<%s> created: %s", self._id, self.snapshot())

        # Emit creation event
        self._publish(
            topic="chat.conversation.created",
            payload={"conversation_id": self._id, "participants": self._participants},
        )

    # Public properties ------------------------------------------------------- #
    @property
    def id(self) -> str:
        return self._id

    @property
    def topic(self) -> Optional[str]:
        return self._topic

    @topic.setter
    def topic(self, value: Optional[str]) -> None:
        with self._lock:
            self._topic = value
            self._publish(
                topic="chat.conversation.topic_changed",
                payload={"conversation_id": self._id, "topic": value},
            )

    @property
    def participants(self) -> List[str]:
        # Return a copy to avoid external mutation
        with self._lock:
            return list(self._participants)

    @property
    def read_only(self) -> bool:
        return self._read_only

    @property
    def messages(self) -> List[Message]:
        with self._lock:
            return list(self._messages)

    # Business logic ---------------------------------------------------------- #
    def add_participant(self, user_id: str) -> None:
        with self._lock:
            if user_id not in self._participants:
                self._participants.append(user_id)
                self._publish(
                    topic="chat.conversation.participant_added",
                    payload={"conversation_id": self._id, "user_id": user_id},
                )

    def remove_participant(self, user_id: str) -> None:
        with self._lock:
            if user_id in self._participants:
                self._participants.remove(user_id)
                self._publish(
                    topic="chat.conversation.participant_removed",
                    payload={"conversation_id": self._id, "user_id": user_id},
                )
                # Auto-archive conversation when last participant leaves
                if not self._participants:
                    self._read_only = True
                    LOGGER.info(
                        "Conversation<%s> became read-only; no participants left", self._id
                    )

    def append_message(self, message: Message) -> None:
        if self._read_only:
            raise ConversationError("Conversation is read-only")

        with self._lock:
            # Prevent duplicates when syncing from multiple devices
            if any(msg.id == message.id for msg in self._messages):
                LOGGER.debug("Duplicate message <%s> skipped", message.id)
                return

            self._messages.append(message)
            self._publish(
                topic="chat.message.appended",
                payload={"conversation_id": self._id, "message": message.to_dict()},
            )
            LOGGER.debug(
                "Message<%s> appended to Conversation<%s>", message.id, self._id
            )

    def latest_message(self) -> Optional[Message]:
        with self._lock:
            return self._messages[-1] if self._messages else None

    def snapshot(self) -> Dict[str, Any]:
        """
        Return lightweight representation—for UI binding or diagnostics.
        Does **not** include full message bodies for performance.
        """
        with self._lock:
            return {
                "id": self._id,
                "topic": self._topic,
                "participants": list(self._participants),
                "message_count": len(self._messages),
                "created_at": self._created_at.strftime(ISO8601_FMT),
                "read_only": self._read_only,
            }

    # ----------------------------------------------------------------------- #
    # (De)serialization helpers
    # ----------------------------------------------------------------------- #
    def to_dict(self, include_messages: bool = True) -> Dict[str, Any]:
        with self._lock:
            data: Dict[str, Any] = {
                "version": self.VERSION,
                "id": self._id,
                "topic": self._topic,
                "participants": list(self._participants),
                "created_at": self._created_at.strftime(ISO8601_FMT),
                "read_only": self._read_only,
            }
            if include_messages:
                data["messages"] = [msg.to_dict() for msg in self._messages]
            return data

    @classmethod
    def from_dict(
        cls,
        raw: Dict[str, Any],
        *,
        event_bus: Optional[EventBus] = None,
    ) -> "Conversation":
        """Hydrate instance from previously persisted dict."""
        try:
            if raw.get("version") != cls.VERSION:
                LOGGER.warning(
                    "Conversation version mismatch. Expected %s, got %s",
                    cls.VERSION,
                    raw.get("version"),
                )
            participants = raw["participants"]
            conv = cls(
                participants=participants,
                topic=raw.get("topic"),
                id=raw["id"],
                read_only=raw.get("read_only", False),
                event_bus=event_bus,
            )
            conv._created_at = datetime.strptime(raw["created_at"], ISO8601_FMT).replace(
                tzinfo=timezone.utc
            )

            # Messages
            for message_raw in raw.get("messages", []):
                conv._messages.append(Message.from_dict(message_raw))
            return conv
        except (KeyError, ValueError) as exc:
            raise ConversationError("Malformed conversation data") from exc

    # JSON helpers ------------------------------------------------------------ #
    def to_json(self, **json_kwargs: Any) -> str:
        """Dump to JSON string (no pretty-print by default for disk size)."""
        return json.dumps(self.to_dict(), separators=(",", ":"), **json_kwargs)

    @classmethod
    def from_json(cls, payload: str, *, event_bus: Optional[EventBus] = None) -> "Conversation":
        return cls.from_dict(json.loads(payload), event_bus=event_bus)

    # Filesystem helpers ------------------------------------------------------ #
    def save_to_file(self, path: Path) -> None:
        """
        Atomically write JSON payload to `path`.

        The write is performed to a temporary file first and then renamed,
        preventing half-written files after crashes.
        """
        tmp_path = path.with_suffix(".tmp")
        try:
            with tmp_path.open("w", encoding="utf-8") as handle:
                handle.write(self.to_json())
            tmp_path.replace(path)
            LOGGER.debug("Conversation<%s> persisted to %s", self._id, path)
        finally:
            # Clean up in case of exceptions
            if tmp_path.exists():
                try:
                    tmp_path.unlink(missing_ok=True)
                except OSError:
                    LOGGER.warning("Failed to clean temporary file %s", tmp_path)

    @classmethod
    def load_from_file(cls, path: Path, *, event_bus: Optional[EventBus] = None) -> "Conversation":
        """Read JSON from disk and hydrate Conversation instance."""
        try:
            payload = path.read_text(encoding="utf-8")
            return cls.from_json(payload, event_bus=event_bus)
        except FileNotFoundError as exc:
            raise ConversationError(f"Conversation file {path} not found") from exc

    # Private helpers --------------------------------------------------------- #
    def _publish(self, topic: str, payload: Any, **kwargs: PublishKwargs) -> None:
        """Wrapper for the event-bus – no-op when not configured."""
        if self._event_bus:
            try:
                self._event_bus.publish(topic=topic, payload=payload, **kwargs)
            except Exception:  # noqa: BLE001 broad-except: bus should not crash us
                LOGGER.exception("Failed to publish event %s", topic)
```