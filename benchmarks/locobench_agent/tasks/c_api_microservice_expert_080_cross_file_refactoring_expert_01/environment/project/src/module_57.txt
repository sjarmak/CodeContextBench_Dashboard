/*
 * MercuryMonolith Commerce Hub – Response Cache (module 57)
 *
 * This module implements an in-memory, thread-safe, TTL-aware LRU cache used by
 * the HTTP/GraphQL gateway to short-circuit expensive service calls when the
 * same request/response pair is observed repeatedly within a bounded time
 * window.  The implementation favours predictable latency over perfect memory
 * utilisation – once the configured capacity is reached, the least recently
 * used entry is discarded regardless of its remaining TTL.
 *
 * Build notes:
 *   – Requires POSIX threads (‐pthread)
 *   – Relies on the internal logging, metrics, and event-bus facilities
 *
 *   gcc -std=c11 -Wall -Wextra -O2 -pthread -c mm_response_cache.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <stdint.h>
#include <stdbool.h>
#include <errno.h>

#include "mm_logger.h"      /* TRACE(), DEBUG(), INFO(), WARN(), ERROR()      */
#include "mm_metrics.h"     /* mm_metrics_counter_inc(), mm_metrics_gauge_set */
#include "mm_event_bus.h"   /* mm_event_publish()                             */

#define MODULE_57_VERSION "1.3.0"

/* ---------------------------  Configuration  -------------------------------- */
#ifndef MM_CACHE_DEFAULT_CAPACITY
#   define MM_CACHE_DEFAULT_CAPACITY  8192  /* maximum number of entries   */
#endif

#ifndef MM_CACHE_DEFAULT_HT_SIZE
#   define MM_CACHE_DEFAULT_HT_SIZE   16384 /* buckets – power of two >= 2×capacity */
#endif

/* -----------------------------  Structures  --------------------------------- */

typedef struct cache_entry
{
    char                *key;          /* unique identifier (URI+Vary headers hash) */
    unsigned char       *payload;      /* HTTP/GraphQL serialized body              */
    size_t               payload_len;
    char                *content_type; /* MIME type                                 */
    uint16_t             status_code;

    time_t               expires_at;

    /* Intrusive doubly-linked list for LRU eviction */
    struct cache_entry  *prev;
    struct cache_entry  *next;

    struct cache_entry  *hnext;        /* next in hash bucket chain                 */

} cache_entry_t;

typedef struct
{
    size_t          capacity;      /* logical max size (entries)                 */
    size_t          size;          /* current number of live entries             */
    size_t          hsize;         /* hash table buckets                         */
    cache_entry_t **htable;        /* closed-addressing hash table               */

    cache_entry_t  *lru_head;      /* MRU at head                                */
    cache_entry_t  *lru_tail;      /* LRU at tail                                */

    pthread_rwlock_t lock;         /* global rw-lock (coarse grained)            */
} response_cache_t;

/* ---------------------------  Static helpers  -------------------------------- */

/* djb2 ‑ simple non-cryptographic hash. */
static uint64_t
mm_hash(const char *s)
{
    uint64_t h = 5381;
    int      c;
    while ((c = *s++))
        h = ((h << 5) + h) + (uint64_t)c;
    return h;
}

static inline void
lru_move_to_front(response_cache_t *c, cache_entry_t *e)
{
    if (c->lru_head == e) return;

    /* unlink */
    if (e->prev) e->prev->next = e->next;
    if (e->next) e->next->prev = e->prev;

    if (c->lru_tail == e)
        c->lru_tail = e->prev;

    /* push front */
    e->prev = NULL;
    e->next = c->lru_head;
    if (c->lru_head) c->lru_head->prev = e;
    c->lru_head = e;
    if (!c->lru_tail) c->lru_tail = e;
}

static void
lru_evict_tail(response_cache_t *c)
{
    cache_entry_t *victim = c->lru_tail;
    if (!victim) return; /* should not happen */

    /* unlink from LRU list */
    if (victim->prev)
        victim->prev->next = NULL;
    else
        c->lru_head = NULL; /* victim was also head */

    c->lru_tail = victim->prev;

    /* unlink from hash */
    uint64_t h      = mm_hash(victim->key) & (c->hsize - 1);
    cache_entry_t *p = c->htable[h];
    cache_entry_t *q = NULL;
    while (p)
    {
        if (p == victim)
        {
            if (q)
                q->hnext = p->hnext;
            else
                c->htable[h] = p->hnext;
            break;
        }
        q = p;
        p = p->hnext;
    }

    /* free victim */
    free(victim->key);
    free(victim->payload);
    free(victim->content_type);
    free(victim);

    c->size--;

    mm_metrics_counter_inc("cache_evictions_total", 1);
}

/* -----------------------  Public API implementation ------------------------- */

response_cache_t *
mm_response_cache_create(size_t capacity, size_t hash_size)
{
    response_cache_t *c = calloc(1, sizeof *c);
    if (!c) return NULL;

    c->capacity = capacity ? capacity : MM_CACHE_DEFAULT_CAPACITY;

    /* ensure hsize is power of two */
    size_t p   = 1;
    while (p < hash_size) p <<= 1;
    c->hsize   = p ? p : MM_CACHE_DEFAULT_HT_SIZE;

    c->htable  = calloc(c->hsize, sizeof(cache_entry_t *));
    if (!c->htable)
    {
        free(c);
        return NULL;
    }

    if (pthread_rwlock_init(&c->lock, NULL) != 0)
    {
        free(c->htable);
        free(c);
        return NULL;
    }

    INFO("Response cache initialised – capacity=%zu entries, buckets=%zu",
         c->capacity, c->hsize);

    mm_metrics_gauge_set("cache_entries", 0);

    return c;
}

void
mm_response_cache_destroy(response_cache_t *c)
{
    if (!c) return;

    pthread_rwlock_wrlock(&c->lock);

    for (size_t i = 0; i < c->hsize; ++i)
    {
        cache_entry_t *e = c->htable[i];
        while (e)
        {
            cache_entry_t *n = e->hnext;
            free(e->key);
            free(e->payload);
            free(e->content_type);
            free(e);
            e = n;
        }
    }

    pthread_rwlock_unlock(&c->lock);
    pthread_rwlock_destroy(&c->lock);
    free(c->htable);
    free(c);
}

static bool
entry_is_expired(const cache_entry_t *e, time_t now)
{
    return e->expires_at && now >= e->expires_at;
}

bool
mm_response_cache_get(response_cache_t *c,
                      const char       *key,
                      unsigned char   **payload_out,
                      size_t           *payload_len_out,
                      const char      **content_type_out,
                      uint16_t         *status_code_out)
{
    if (!c || !key) return false;

    const time_t now = time(NULL);

    bool hit = false;

    pthread_rwlock_rdlock(&c->lock);

    uint64_t h = mm_hash(key) & (c->hsize - 1);
    cache_entry_t *e = c->htable[h];
    while (e && strcmp(e->key, key) != 0)
        e = e->hnext;

    if (e && !entry_is_expired(e, now))
    {
        /* Found and not expired */
        hit = true;

        if (payload_out)
        {
            *payload_out = malloc(e->payload_len);
            memcpy(*payload_out, e->payload, e->payload_len);
        }
        if (payload_len_out)  *payload_len_out  = e->payload_len;
        if (content_type_out) *content_type_out = e->content_type;
        if (status_code_out)  *status_code_out  = e->status_code;

        /* Upgrade to write lock to update LRU ordering */
        pthread_rwlock_unlock(&c->lock);
        pthread_rwlock_wrlock(&c->lock);

        lru_move_to_front(c, e);

        pthread_rwlock_unlock(&c->lock);

        mm_metrics_counter_inc("cache_hits_total", 1);
    }
    else
    {
        pthread_rwlock_unlock(&c->lock);
        mm_metrics_counter_inc("cache_misses_total", 1);
    }

    return hit;
}

bool
mm_response_cache_put(response_cache_t *c,
                      const char       *key,
                      const unsigned char *payload,
                      size_t            payload_len,
                      const char       *content_type,
                      uint16_t          status_code,
                      uint32_t          ttl_seconds)
{
    if (!c || !key || !payload || payload_len == 0) return false;

    time_t now = time(NULL);
    time_t expires_at = ttl_seconds ? now + ttl_seconds : 0;

    pthread_rwlock_wrlock(&c->lock);

    uint64_t h = mm_hash(key) & (c->hsize - 1);
    cache_entry_t *e = c->htable[h];
    while (e && strcmp(e->key, key) != 0)
        e = e->hnext;

    if (e) /* update existing */
    {
        free(e->payload);
        e->payload = malloc(payload_len);
        memcpy(e->payload, payload, payload_len);
        e->payload_len = payload_len;

        free(e->content_type);
        e->content_type = strdup(content_type ?: "application/octet-stream");
        e->status_code  = status_code;
        e->expires_at   = expires_at;

        lru_move_to_front(c, e);
    }
    else /* insert new */
    {
        if (c->size >= c->capacity)
            lru_evict_tail(c);

        e = calloc(1, sizeof *e);
        if (!e)
        {
            pthread_rwlock_unlock(&c->lock);
            return false;
        }

        e->key          = strdup(key);
        e->payload      = malloc(payload_len);
        memcpy(e->payload, payload, payload_len);
        e->payload_len  = payload_len;
        e->content_type = strdup(content_type ?: "application/octet-stream");
        e->status_code  = status_code;
        e->expires_at   = expires_at;

        /* insert into hash table */
        e->hnext = c->htable[h];
        c->htable[h] = e;

        /* push front in LRU list */
        e->prev = NULL;
        e->next = c->lru_head;
        if (c->lru_head) c->lru_head->prev = e;
        c->lru_head = e;
        if (!c->lru_tail) c->lru_tail = e;

        c->size++;
        mm_metrics_gauge_set("cache_entries", (double)c->size);
    }

    pthread_rwlock_unlock(&c->lock);

    mm_metrics_counter_inc("cache_writes_total", 1);

    /* Notify other subsystems (e.g., WebSocket live-update) */
    mm_event_publish("cache.entry.added", key);

    return true;
}

void
mm_response_cache_purge_expired(response_cache_t *c)
{
    if (!c) return;

    const time_t now = time(NULL);

    pthread_rwlock_wrlock(&c->lock);

    size_t purged = 0;

    for (size_t i = 0; i < c->hsize; ++i)
    {
        cache_entry_t *e = c->htable[i];
        cache_entry_t *prev = NULL;

        while (e)
        {
            if (entry_is_expired(e, now))
            {
                /* Evict from LRU list */
                if (e->prev) e->prev->next = e->next;
                if (e->next) e->next->prev = e->prev;
                if (c->lru_head == e) c->lru_head = e->next;
                if (c->lru_tail == e) c->lru_tail = e->prev;

                /* Remove from hash chain */
                if (prev)
                    prev->hnext = e->hnext;
                else
                    c->htable[i] = e->hnext;

                cache_entry_t *victim = e;
                e = e->hnext;

                free(victim->key);
                free(victim->payload);
                free(victim->content_type);
                free(victim);
                purged++;
                c->size--;
            }
            else
            {
                prev = e;
                e = e->hnext;
            }
        }
    }

    if (purged)
    {
        INFO("Purged %zu expired cache entries", purged);
        mm_metrics_counter_inc("cache_expired_total", purged);
        mm_metrics_gauge_set("cache_entries", (double)c->size);
    }

    pthread_rwlock_unlock(&c->lock);
}

/*
 * Invalidate cache entries whose keys begin with the given prefix (e.g.,
 * "/api/v1/catalog/products/").  Used when repository write events arrive on
 * the event bus.
 */
size_t
mm_response_cache_invalidate_prefix(response_cache_t *c, const char *prefix)
{
    if (!c || !prefix) return 0;

    size_t prefix_len = strlen(prefix);
    size_t invalidated = 0;

    pthread_rwlock_wrlock(&c->lock);

    for (size_t i = 0; i < c->hsize; ++i)
    {
        cache_entry_t *e = c->htable[i];
        cache_entry_t *prev = NULL;

        while (e)
        {
            if (strncmp(e->key, prefix, prefix_len) == 0)
            {
                /* unlink from LRU */
                if (e->prev) e->prev->next = e->next;
                if (e->next) e->next->prev = e->prev;
                if (c->lru_head == e) c->lru_head = e->next;
                if (c->lru_tail == e) c->lru_tail = e->prev;

                /* unlink from hash */
                if (prev)
                    prev->hnext = e->hnext;
                else
                    c->htable[i] = e->hnext;

                cache_entry_t *victim = e;
                e = e->hnext;

                free(victim->key);
                free(victim->payload);
                free(victim->content_type);
                free(victim);
                invalidated++;
                c->size--;
            }
            else
            {
                prev = e;
                e = e->hnext;
            }
        }
    }

    if (invalidated)
    {
        INFO("Invalidated %zu cache entries by prefix \"%s\"", invalidated, prefix);
        mm_metrics_counter_inc("cache_invalidations_total", invalidated);
        mm_metrics_gauge_set("cache_entries", (double)c->size);
        mm_event_publish("cache.invalidate.prefix", prefix);
    }

    pthread_rwlock_unlock(&c->lock);

    return invalidated;
}

/* -------------------------  Scheduled task hook  ---------------------------- */
/*
 * This function is registered with the global scheduler (see mm_scheduler.h).
 * The scheduler invokes it every minute to clean up expired entries.
 */
void
mm_response_cache_maintenance_job(void *userdata)
{
    (void)userdata;
    mm_response_cache_t *global_cache = mm_get_global_response_cache();
    mm_response_cache_purge_expired(global_cache);
}

/* -------------------------  Module self-test  ------------------------------- */
#ifdef MM_CACHE_SELFTEST
int main(void)
{
    response_cache_t *c = mm_response_cache_create(4, 8);
    const char *key1 = "/ping";
    const unsigned char body1[] = "pong";
    mm_response_cache_put(c, key1, body1, sizeof(body1), "text/plain", 200, 1);

    unsigned char *out;
    size_t len;
    const char *ctype;
    uint16_t code;
    if (mm_response_cache_get(c, key1, &out, &len, &ctype, &code))
    {
        printf("HIT %s (%zu bytes, %s, %d)\n", key1, len, ctype, code);
        free(out);
    }

    sleep(2); /* let it expire */
    mm_response_cache_purge_expired(c);

    bool again = mm_response_cache_get(c, key1, NULL, NULL, NULL, NULL);
    printf("After expire: %s\n", again ? "HIT" : "MISS");

    mm_response_cache_destroy(c);
    return 0;
}
#endif /* MM_CACHE_SELFTEST */
