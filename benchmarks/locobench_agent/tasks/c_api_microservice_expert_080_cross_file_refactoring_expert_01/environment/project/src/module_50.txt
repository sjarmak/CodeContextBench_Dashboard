/*
 * MercuryMonolith Commerce Hub â€“ Response Cache Module
 *
 * File:    src/module_50.txt   (compiled as C source)
 * Author:  MercuryMonolith Core Team
 *
 * Overview
 * --------
 * In-process, thread-safe response cache used by the API-Gateway layer to
 * accelerate frequently requested REST / GraphQL resources.  Implements an
 * LRU eviction policy with per-entry TTL and Prometheus-style metrics hooks.
 *
 * Public interface
 * ----------------
 *   mmch_response_cache_t *mmch_cache_create(size_t max_entries);
 *   void  mmch_cache_destroy(mmch_response_cache_t *cache);
 *   int   mmch_cache_put(mmch_response_cache_t *cache,
 *                        const char *key,
 *                        const void *payload,
 *                        size_t payload_sz,
 *                        uint32_t ttl_ms);
 *   int   mmch_cache_get(mmch_response_cache_t *cache,
 *                        const char *key,
 *                        void **out_payload,
 *                        size_t *out_payload_sz);
 *   void  mmch_cache_cleanup(mmch_response_cache_t *cache);
 *
 * Return codes follow <errno.h> semantics (0 on success).
 *
 * Build Notes
 * -----------
 *  - Requires POSIX threads.
 *  - `uthash.h` is bundled to avoid external dependency hell.
 *  - Metric & logging headers are forward-declared; they live elsewhere in
 *    the monorepo but are not needed for compilation of standalone mocks.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <pthread.h>

/*----------------------------------------------------------------------
 * 3rd-party, single-file hash-table implementation: uthash v2.3.0
 * ( https://troydhanson.github.io/uthash/ )
 *----------------------------------------------------------------------*/
/*  Start of inlined uthash.h *******************************************/
#ifndef UTHASH_H
#define UTHASH_H

#define uthash_malloc(sz) malloc(sz)
#define uthash_free(ptr,sz) free(ptr)

#define uthash_noexpand_fyi(tbl)          /* nop */
#define uthash_expand_fyi(tbl)            /* nop */

/* Hash handle structure */
#define HASH_FIND(hh,head,keyptr,keylen,out)                                           \
do {                                                                                   \
    out=NULL;                                                                          \
    if (head) {                                                                        \
        unsigned _hf_bkt,_hf_hashv;                                                    \
        HASH_FCN(keyptr,keylen, _hf_hashv);                                            \
        _hf_bkt = _hf_hashv & ((head)->hh.tbl->num_buckets - 1);                       \
        if (HASH_BLOOM_TEST((head)->hh.tbl, _hf_hashv))                                \
        HASH_FIND_IN_BKT((head)->hh.tbl, hh, (head)->hh.tbl->buckets[_hf_bkt],         \
                         keyptr,keylen,out);                                           \
    }                                                                                  \
} while(0)

/* Many more macros exist but we only need FIND, ADD, DELETE for this module       */
#define HASH_MAKE_TABLE(hh,head)
#define HASH_BLOOM_TEST(tbl,hashv) 1
#define HASH_FIND_IN_BKT(tbl, hh, head, keyptr, keylen, out)                           \
do {                                                                                   \
    if (head) {                                                                        \
        decltype(head) _hf_el = head;                                                  \
        do {                                                                           \
            if ((_hf_el)->key_len == keylen &&                                         \
                memcmp((_hf_el)->key, keyptr, keylen) == 0) {                          \
                out = _hf_el;                                                          \
                break;                                                                 \
            }                                                                          \
            _hf_el = (decltype(head))((_hf_el)->hh.next);                              \
        } while (_hf_el);                                                              \
    }                                                                                  \
} while (0)

#define HASH_ADD_KEYPTR(hh,head,keyptr,keylen_in,add)                                  \
do {                                                                                   \
    unsigned _ha_hashv;                                                                \
    HASH_FCN(keyptr,keylen_in,_ha_hashv);                                              \
    (add)->hh.hashv = _ha_hashv;                                                       \
    (add)->key     = (char*)keyptr;                                                    \
    (add)->key_len = (unsigned)keylen_in;                                              \
    (add)->hh.next = head;                                                             \
    head = add;                                                                        \
} while (0)

#define HASH_DELETE(hh,head,delptr)                                                    \
do {                                                                                   \
    if (head == delptr) {                                                              \
        head = (decltype(head))((delptr)->hh.next);                                    \
    } else {                                                                           \
        decltype(head) _hd_prev = head;                                                \
        while (_hd_prev && _hd_prev->hh.next != (UT_hash_handle*)delptr)               \
            _hd_prev = (decltype(head))(_hd_prev->hh.next);                            \
        if (_hd_prev)                                                                  \
            _hd_prev->hh.next = (delptr)->hh.next;                                     \
    }                                                                                  \
} while (0)

#define HASH_FCN(key,keylen,hashv)                                                     \
do {                                                                                   \
    const unsigned char *_hf_key = (const unsigned char*)(key);                        \
    unsigned _hf_i,_hf_hashv=5381;                                                     \
    for(_hf_i=0; _hf_i< keylen; _hf_i++)                                               \
        _hf_hashv = ((_hf_hashv << 5) + _hf_hashv) ^ _hf_key[_hf_i];                   \
    hashv = _hf_hashv;                                                                 \
} while(0)

typedef struct UT_hash_handle {
    struct UT_hash_table *tbl;
    struct UT_hash_handle *prev;      /* previous element in app order      */
    struct UT_hash_handle *next;      /* next element in app order          */
    unsigned                hashv;    /* hash value                         */
} UT_hash_handle;

#endif /* UTHASH_H */
/*  End of inlined uthash.h *********************************************/

/*----------------------------------------------------------------------
 * Forward-declarations for project-wide facilities
 *----------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" {
#endif

/* Centralised, structured logger (json / text). Not included here */
void mmch_log_error(const char *facility, const char *fmt, ...);
void mmch_log_debug(const char *facility, const char *fmt, ...);

/* Metrics abstraction (Prometheus). Not included here */
void mmch_metrics_inc_counter(const char *name);
void mmch_metrics_set_gauge(const char *name, double value);

#ifdef __cplusplus
}
#endif

/*----------------------------------------------------------------------
 * Module-local definitions
 *----------------------------------------------------------------------*/
#define MODULE_FACILITY "response_cache"
#define NSECS_IN_MSEC   1000000ULL

typedef struct mmch_cache_entry {
    char               *key;           /* immutable request hash / route */
    unsigned            key_len;

    void               *payload;       /* heap-allocated opaque blob    */
    size_t              payload_sz;

    struct timespec     expiry;        /* monotonic deadline            */
    struct timespec     last_access;   /* for LRU ordering              */

    /* intrusive data structures */
    UT_hash_handle      hh;            /* uthash handle (must be last?) */
    struct mmch_cache_entry *prev;     /* prev in LRU doubly list       */
    struct mmch_cache_entry *next;     /* next in LRU doubly list       */
} mmch_cache_entry_t;

typedef struct mmch_response_cache {
    mmch_cache_entry_t *table;         /* hash table root               */
    mmch_cache_entry_t *lru_head;      /* most-recently used            */
    mmch_cache_entry_t *lru_tail;      /* least-recently used           */

    size_t              max_entries;   /* capacity                      */
    size_t              curr_entries;  /* current load                  */

    pthread_rwlock_t    rwlock;        /* multi-reader / single writer  */
} mmch_response_cache_t;

/*----------------------------------------------------------------------
 * Helper utilities
 *----------------------------------------------------------------------*/

/* Return CLOCK_MONOTONIC time as struct timespec */
static inline void
_now(struct timespec *ts)
{
    clock_gettime(CLOCK_MONOTONIC, ts);
}

/* ts1 > ts2 ? */
static inline int
_ts_greater(const struct timespec *a, const struct timespec *b)
{
    return (a->tv_sec > b->tv_sec) ||
           (a->tv_sec == b->tv_sec && a->tv_nsec > b->tv_nsec);
}

/* ts_out = ts_in + delta_ms */
static inline void
_add_ms(struct timespec *out, const struct timespec *in, uint32_t delta_ms)
{
    out->tv_sec  = in->tv_sec + delta_ms / 1000;
    out->tv_nsec = in->tv_nsec + (delta_ms % 1000) * NSECS_IN_MSEC;
    if (out->tv_nsec >= 1000000000L) {
        out->tv_sec  += 1;
        out->tv_nsec -= 1000000000L;
    }
}

/*----------------------------------------------------------------------
 * LRU list helpers  (internal, caller must hold write-lock!)
 *----------------------------------------------------------------------*/
static void
_lru_move_to_front(mmch_response_cache_t *cache, mmch_cache_entry_t *entry)
{
    if (cache->lru_head == entry) return; /* already at front */

    /* detach */
    if (entry->prev) entry->prev->next = entry->next;
    if (entry->next) entry->next->prev = entry->prev;
    if (cache->lru_tail == entry) cache->lru_tail = entry->prev;

    /* insert at head */
    entry->prev = NULL;
    entry->next = cache->lru_head;
    if (cache->lru_head) cache->lru_head->prev = entry;
    cache->lru_head = entry;
    if (!cache->lru_tail) cache->lru_tail = entry;
}

static void
_lru_insert_front(mmch_response_cache_t *cache, mmch_cache_entry_t *entry)
{
    entry->prev = NULL;
    entry->next = cache->lru_head;
    if (cache->lru_head) cache->lru_head->prev = entry;
    cache->lru_head = entry;
    if (!cache->lru_tail) cache->lru_tail = entry;
}

static void
_lru_remove(mmch_response_cache_t *cache, mmch_cache_entry_t *entry)
{
    if (entry->prev) entry->prev->next = entry->next;
    if (entry->next) entry->next->prev = entry->prev;

    if (cache->lru_head == entry) cache->lru_head = entry->next;
    if (cache->lru_tail == entry) cache->lru_tail = entry->prev;

    entry->prev = entry->next = NULL;
}

/*----------------------------------------------------------------------
 * Public API
 *----------------------------------------------------------------------*/

/*
 * mmch_cache_create
 * -----------------
 * Allocate & initialise a new cache with a fixed max_entries capacity.
 * Returns pointer to cache object or NULL on allocation failure.
 */
mmch_response_cache_t *
mmch_cache_create(size_t max_entries)
{
    mmch_response_cache_t *cache = calloc(1, sizeof(*cache));
    if (!cache) return NULL;

    cache->max_entries = (max_entries == 0) ? 1024 : max_entries;
    pthread_rwlock_init(&cache->rwlock, NULL);

    mmch_metrics_set_gauge("response_cache_entries", 0.0);
    return cache;
}

/*
 * _evict_lru (internal)
 * ---------------------
 * Assumes caller holds write lock. Evicts one LRU entry (tail) from cache.
 */
static void
_evict_lru(mmch_response_cache_t *cache)
{
    if (!cache->lru_tail) return;

    mmch_cache_entry_t *victim = cache->lru_tail;

    _lru_remove(cache, victim);
    HASH_DELETE(hh, cache->table, victim);

    free(victim->key);
    free(victim->payload);
    free(victim);
    cache->curr_entries--;

    mmch_metrics_set_gauge("response_cache_entries",
                           (double)cache->curr_entries);
}

/*
 * mmch_cache_put
 * --------------
 * Stores (key,payload) in cache.  The payload is deep-copied.
 *
 * ttl_ms == 0  -> no expiry (discouraged, but supported).
 *
 * Returns:
 *   0  on success
 *  -ENOMEM  allocation failure
 *  -EINVAL  invalid args
 */
int
mmch_cache_put(mmch_response_cache_t *cache,
               const char *key,
               const void *payload,
               size_t payload_sz,
               uint32_t ttl_ms)
{
    if (!cache || !key || !payload || payload_sz == 0)
        return -EINVAL;

    int rc = 0;
    mmch_cache_entry_t *entry = NULL;

    /* pre-allocate outside lock to reduce contention */
    entry = calloc(1, sizeof(*entry));
    if (!entry) return -ENOMEM;

    entry->key = strndup(key, strlen(key));
    if (!entry->key) { free(entry); return -ENOMEM; }
    entry->key_len = (unsigned)strlen(key);

    entry->payload = malloc(payload_sz);
    if (!entry->payload) {
        free(entry->key); free(entry); return -ENOMEM;
    }
    memcpy(entry->payload, payload, payload_sz);
    entry->payload_sz = payload_sz;

    struct timespec now;
    _now(&now);
    _add_ms(&entry->expiry, &now, ttl_ms);
    entry->last_access = now;

    /* ---- critical section (write lock) ---- */
    pthread_rwlock_wrlock(&cache->rwlock);

    mmch_cache_entry_t *existing = NULL;
    HASH_FIND(hh, cache->table, key, strlen(key), existing);

    if (existing) {
        /* replace existing entry's payload & metadata */
        _lru_remove(cache, existing);          /* detach from LRU */

        free(existing->payload);
        existing->payload = entry->payload;
        existing->payload_sz = entry->payload_sz;
        existing->expiry     = entry->expiry;
        existing->last_access= entry->last_access;

        _lru_insert_front(cache, existing);    /* move to MRU */

        free(entry->key);  /* not used */
        free(entry);       /* transient container */
    } else {
        /* insert brand new */
        HASH_ADD_KEYPTR(hh, cache->table, entry->key, entry->key_len, entry);
        _lru_insert_front(cache, entry);
        cache->curr_entries++;
        mmch_metrics_set_gauge("response_cache_entries",
                               (double)cache->curr_entries);
    }

    /* enforce capacity */
    while (cache->curr_entries > cache->max_entries) {
        _evict_lru(cache);
    }

    pthread_rwlock_unlock(&cache->rwlock);
    /* --------  end critical section -------- */

    return rc;
}

/*
 * mmch_cache_get
 * --------------
 * Lookup cache by key.  On hit, a *copy* of the payload is returned that the
 * caller must free().  This avoids lifetime coupling with the cache that may
 * evict the entry concurrently.
 *
 * Returns:
 *   0          cache hit,  out_payload valid
 *   -ENOENT    cache miss
 *   -ETIMEDOUT entry expired
 *   -EINVAL    invalid args
 */
int
mmch_cache_get(mmch_response_cache_t *cache,
               const char *key,
               void **out_payload,
               size_t *out_payload_sz)
{
    if (!cache || !key || !out_payload || !out_payload_sz)
        return -EINVAL;

    int rc = 0;
    *out_payload = NULL;
    *out_payload_sz = 0;

    pthread_rwlock_rdlock(&cache->rwlock);
    mmch_cache_entry_t *entry = NULL;
    HASH_FIND(hh, cache->table, key, strlen(key), entry);
    if (!entry) {
        pthread_rwlock_unlock(&cache->rwlock);
        mmch_metrics_inc_counter("response_cache_miss_total");
        return -ENOENT;
    }

    struct timespec now;
    _now(&now);
    if (_ts_greater(&now, &entry->expiry)) {
        /* expired */
        pthread_rwlock_unlock(&cache->rwlock);

        /* upgrade to write lock to remove */
        pthread_rwlock_wrlock(&cache->rwlock);
        /* re-lookup in case another writer changed it */
        HASH_FIND(hh, cache->table, key, strlen(key), entry);
        if (entry) {
            _lru_remove(cache, entry);
            HASH_DELETE(hh, cache->table, entry);
            free(entry->key);
            free(entry->payload);
            free(entry);
            cache->curr_entries--;
            mmch_metrics_set_gauge("response_cache_entries",
                                   (double)cache->curr_entries);
        }
        pthread_rwlock_unlock(&cache->rwlock);

        mmch_metrics_inc_counter("response_cache_expired_total");
        return -ETIMEDOUT;
    }

    /* hit; promote LRU */
    pthread_rwlock_unlock(&cache->rwlock);

    /* Need write lock to update LRU pointers safely */
    pthread_rwlock_wrlock(&cache->rwlock);
    HASH_FIND(hh, cache->table, key, strlen(key), entry);
    if (entry) {
        _lru_move_to_front(cache, entry);
        _now(&entry->last_access);
    }
    pthread_rwlock_unlock(&cache->rwlock);

    /* deep copy payload */
    if (entry) {
        void *copy = malloc(entry->payload_sz);
        if (!copy) return -ENOMEM;
        memcpy(copy, entry->payload, entry->payload_sz);
        *out_payload     = copy;
        *out_payload_sz  = entry->payload_sz;
        mmch_metrics_inc_counter("response_cache_hit_total");
        rc = 0;
    } else {
        rc = -ENOENT; /* extremely unlikely */
    }

    return rc;
}

/*
 * mmch_cache_cleanup
 * ------------------
 * Walk cache and remove expired entries.  Intended to be called by a
 * background housekeeping thread or from event loop ticks.
 */
void
mmch_cache_cleanup(mmch_response_cache_t *cache)
{
    if (!cache) return;

    struct timespec now;
    _now(&now);

    pthread_rwlock_wrlock(&cache->rwlock);

    mmch_cache_entry_t *iter, *tmp;
    for (iter = cache->table; iter != NULL; /* nop */) {
        tmp = (mmch_cache_entry_t*)(iter->hh.next);
        if (_ts_greater(&now, &iter->expiry)) {
            _lru_remove(cache, iter);
            HASH_DELETE(hh, cache->table, iter);
            free(iter->key);
            free(iter->payload);
            free(iter);
            cache->curr_entries--;
        }
        iter = tmp;
    }
    pthread_rwlock_unlock(&cache->rwlock);
    mmch_metrics_set_gauge("response_cache_entries",
                           (double)cache->curr_entries);
}

/*
 * mmch_cache_destroy
 * ------------------
 * Free all resources.  Safe to call with NULL.
 */
void
mmch_cache_destroy(mmch_response_cache_t *cache)
{
    if (!cache) return;

    pthread_rwlock_wrlock(&cache->rwlock);
    mmch_cache_entry_t *iter, *tmp;
    for (iter = cache->table; iter != NULL; /* nop */) {
        tmp = (mmch_cache_entry_t*)(iter->hh.next);
        free(iter->key);
        free(iter->payload);
        free(iter);
        iter = tmp;
    }
    pthread_rwlock_unlock(&cache->rwlock);
    pthread_rwlock_destroy(&cache->rwlock);
    free(cache);
}

#ifdef UNIT_TEST_RESPONSE_CACHE /*------------------------------------------------*/
#include <assert.h>

static void
_test_basic()
{
    mmch_response_cache_t *c = mmch_cache_create(4);
    const char data[] = "hello";
    assert(mmch_cache_put(c, "/greet", data, sizeof data, 10000) == 0);

    void *out; size_t sz;
    assert(mmch_cache_get(c, "/greet", &out, &sz) == 0);
    assert(sz == sizeof data && memcmp(out, data, sz) == 0);
    free(out);

    mmch_cache_destroy(c);
    printf("basic test passed\n");
}

int main(void)
{
    _test_basic();
    return 0;
}
#endif /* UNIT_TEST_RESPONSE_CACHE */
