/*
 * MercuryMonolith Commerce Hub
 * ---------------------------------------------
 * Module 35: Response Cache (in-memory LRU with TTL)
 *
 * This module provides a thread-safe, instrumented response cache that
 * can be shared by all presentation-layer handlers (REST, GraphQL, gRPC).
 *
 * Features
 *  - O(1) look-ups via hash table (uthash)
 *  - Probabilistic LRU eviction (clock-hand algorithm)
 *  - Per-entry TTL with monotonic clock checks
 *  - Metrics hooks for Prometheus exporter
 *  - Structured logging with severity levels
 *  - Zero external allocations on hot path (small-buffer optimization)
 *
 * NOTE: This file purposefully does not expose HTTP specifics.  Serialisation
 * and ownership of payload memory remain responsibilities of callers.  The
 * cache merely stores opaque byte buffers.
 */

#include <errno.h>
#include <inttypes.h>
#include <pthread.h>
#include <stdatomic.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MMC_CACHE_LOG_TAG "response_cache"

/* ------------------------------------------------------------------------- *
 * Compile-time tuning knobs                                                 *
 * ------------------------------------------------------------------------- */

/* Size at which we stop using the small-buffer optimisation and malloc. */
#ifndef MMC_CACHE_SBO_THRESHOLD
#define MMC_CACHE_SBO_THRESHOLD 256U
#endif

/* How aggressive the eviction clock moves on every set (0-100%). */
#ifndef MMC_CACHE_EVICTION_PACE
#define MMC_CACHE_EVICTION_PACE 10U
#endif

/* ------------------------------------------------------------------------- *
 * Forward declarations of internal helpers                                  *
 * ------------------------------------------------------------------------- */
static uint64_t       monotonic_ms(void);
static void           eviction_run(void *ctx);
static void           metrics_emit_snapshot(void *ctx);
static void           log_debug(const char *fmt, ...);
static void           log_error(const char *fmt, ...);

/* ------------------------------------------------------------------------- *
 * uthash                                                                   *
 * ------------------------------------------------------------------------- */
/*
 * We vendor a cut-down copy of uthash 2.3.0 to avoid an external dependency.
 * Only the macros strictly required for this file have been retained.
 */
#ifndef UTHASH_H
#define UTHASH_H

#define uthash_fatal(msg) exit(-1)
#define HASH_FIND(hh, head, keyptr, keylen, out)                                \
    do {                                                                        \
        unsigned _hf_bkt;                                                       \
        out = NULL;                                                             \
        if (head) {                                                             \
            HASH_FCN(keyptr, keylen, (head)->hh.tbl->num_buckets, _hf_bkt);     \
            out = (head)->hh.tbl->buckets[_hf_bkt].hh_head;                     \
            while (out) {                                                       \
                if ((out)->hh.keylen == keylen &&                               \
                    memcmp(out->hh.key, keyptr, keylen) == 0) {                 \
                    break;                                                      \
                }                                                               \
                out = (out)->hh_next;                                           \
            }                                                                   \
        }                                                                       \
    } while (0)

#define HASH_ADD_KEYPTR(hh, head, keyptr, keylen, add)                          \
    do {                                                                        \
        uint32_t _ha_bkt;                                                       \
        (add)->hh.key = (char *)(keyptr);                                       \
        (add)->hh.keylen = (unsigned)(keylen);                                  \
        if (!(head)) {                                                          \
            (head) = (add);                                                     \
            (add)->hh.tbl = &((struct UT_hash_bucket *)calloc(1, sizeof(struct UT_hash_bucket)))[0]; \
            (add)->hh.tbl->num_buckets = 1;                                     \
            (add)->hh.tbl->buckets = (struct UT_hash_bucket *)calloc(1, sizeof(struct UT_hash_bucket)); \
        }                                                                       \
        HASH_FCN(keyptr, keylen, (head)->hh.tbl->num_buckets, _ha_bkt);         \
        (add)->hh_next = (head)->hh.tbl->buckets[_ha_bkt].hh_head;              \
        (head)->hh.tbl->buckets[_ha_bkt].hh_head = (UT_hash_handle *)(add);     \
    } while (0)

#define HASH_DEL(hh, head, delptr)                                              \
    do {                                                                        \
        unsigned _hd_bkt;                                                       \
        if ((head)) {                                                           \
            HASH_FCN((delptr)->hh.key, (delptr)->hh.keylen,                     \
                      (head)->hh.tbl->num_buckets, _hd_bkt);                    \
            if ((head)->hh.tbl->buckets[_hd_bkt].hh_head == (UT_hash_handle *)(delptr)) { \
                (head)->hh.tbl->buckets[_hd_bkt].hh_head = (delptr)->hh_next;   \
            } else {                                                            \
                UT_hash_handle *_tmp = (head)->hh.tbl->buckets[_hd_bkt].hh_head;\
                while (_tmp->hh_next && _tmp->hh_next != (UT_hash_handle *)(delptr)) \
                    _tmp = _tmp->hh_next;                                       \
                if (_tmp->hh_next)                                              \
                    _tmp->hh_next = (delptr)->hh_next;                          \
            }                                                                   \
        }                                                                       \
    } while (0)

typedef struct UT_hash_handle {
    struct UT_hash_table *tbl;
    void                 *prev;   /* previous element in app order      */
    void                 *next;   /* next element in app order          */
    struct UT_hash_handle *hh_prev; /* previous element in bucket order */
    struct UT_hash_handle *hh_next; /* next element in bucket order     */
    const void           *key;
    unsigned              keylen;
} UT_hash_handle;

typedef struct UT_hash_bucket {
    UT_hash_handle *hh_head;
} UT_hash_bucket;

typedef struct UT_hash_table {
    UT_hash_bucket    *buckets;
    unsigned           num_buckets;
} UT_hash_table;

/* Fowler–Noll–Vo hash implementation */
#define HASH_FCN(keyptr, keylen, num_bkts, bkt)                                 \
    do {                                                                        \
        const unsigned char *_hf_key = (const unsigned char *)(keyptr);         \
        unsigned _hf_len       = (unsigned)(keylen);                            \
        uint32_t _hf_hashv     = 2166136261u;                                   \
        unsigned _hf_i         = 0;                                             \
        for (; _hf_i < _hf_len; _hf_i++) {                                      \
            _hf_hashv ^= _hf_key[_hf_i];                                        \
            _hf_hashv *= 16777619u;                                             \
        }                                                                       \
        bkt = _hf_hashv % (num_bkts);                                           \
    } while (0)

#endif /* UTHASH_H */

/* ------------------------------------------------------------------------- *
 * Data Structures                                                           *
 * ------------------------------------------------------------------------- */

/* Statistical counters (exported via Prometheus) */
typedef struct mmc_cache_metrics_s {
    atomic_uint_fast64_t hits;
    atomic_uint_fast64_t misses;
    atomic_uint_fast64_t evictions;
    atomic_uint_fast64_t expired;
    atomic_uint_fast64_t inserts;
} mmc_cache_metrics_t;

/* A single cache entry */
typedef struct mmc_cache_entry_s {
    /* uthash handle MUST be first for pointer arithmetic compatibility */
    UT_hash_handle      hh;
    uint64_t            expires_at_ms;   /* absolute time in ms */
    uint32_t            size;           /* payload size in bytes */
    bool                accessed;       /* accessed bit for CLOCK algorithm */

    /* Flexible array member for payload (key and value follow) */
    unsigned char       data[];
} mmc_cache_entry_t;

/* Main cache handle */
typedef struct mmc_cache_s {
    pthread_mutex_t      lock;
    size_t               capacity;       /* max number of entries */
    size_t               count;          /* current number of entries */
    uint64_t             default_ttl_ms;
    mmc_cache_entry_t   *tbl;            /* uthash managed head */
    size_t               eviction_hand;  /* CLOCK pointer */
    mmc_cache_metrics_t  metrics;
} mmc_cache_t;

/* Public opaque handle */
typedef mmc_cache_t mmc_cache_handle_t;

/* Status codes */
typedef enum {
    MMC_CACHE_OK = 0,
    MMC_CACHE_ERR_KEY_TOO_LONG,
    MMC_CACHE_ERR_OOM,
    MMC_CACHE_ERR_NOT_FOUND,
    MMC_CACHE_ERR_INV_ARG,
} mmc_cache_status_t;

/* ------------------------------------------------------------------------- *
 * Helpers                                                                   *
 * ------------------------------------------------------------------------- */

/* Returns the current monotonic time in milliseconds */
static uint64_t monotonic_ms(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
    return ((uint64_t)ts.tv_sec * 1000ULL) + (ts.tv_nsec / 1000000ULL);
}

/* Trivial logger (placeholder for full logging framework) */
#include <stdarg.h>
static void vlog(const char *lvl, const char *fmt, va_list ap)
{
    fprintf(stderr, "%s [%s] ", lvl, MMC_CACHE_LOG_TAG);
    vfprintf(stderr, fmt, ap);
    fputc('\n', stderr);
}

static void log_debug(const char *fmt, ...)
{
#ifndef NDEBUG
    va_list ap;
    va_start(ap, fmt);
    vlog("DEBUG", fmt, ap);
    va_end(ap);
#endif
}

static void log_error(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vlog("ERROR", fmt, ap);
    va_end(ap);
}

/* ------------------------------------------------------------------------- *
 * Allocation helpers                                                        *
 * ------------------------------------------------------------------------- */
static mmc_cache_entry_t *entry_create(const char *key,
                                       size_t      keylen,
                                       const void *payload,
                                       size_t      payload_len,
                                       uint64_t    ttl_ms)
{
    const size_t total_sz =
        sizeof(mmc_cache_entry_t) + keylen + 1 /* NUL */ + payload_len;

    mmc_cache_entry_t *e = malloc(total_sz);
    if (!e)
        return NULL;

    memset(e, 0, sizeof(*e));
    e->expires_at_ms = monotonic_ms() + ttl_ms;
    e->size          = (uint32_t)payload_len;
    e->accessed      = true;

    /* Layout: [key][\0][payload] */
    memcpy(e->data, key, keylen);
    e->data[keylen] = '\0';
    memcpy(e->data + keylen + 1, payload, payload_len);

    return e;
}

static inline char *entry_key(const mmc_cache_entry_t *e)
{
    return (char *)e->data;
}

static inline const unsigned char *entry_payload(const mmc_cache_entry_t *e)
{
    size_t keylen = strlen((const char *)e->data);
    return e->data + keylen + 1;
}

/* ------------------------------------------------------------------------- *
 * Eviction (CLOCK algorithm)                                                *
 * ------------------------------------------------------------------------- */
static void cache_evict_one(mmc_cache_t *cache)
{
    if (!cache->tbl)
        return;

    size_t scanned = 0;
    mmc_cache_entry_t *e = cache->tbl;
    while (scanned < cache->count) {
        if (!e) {
            e = cache->tbl;
            continue;
        }

        if (e->accessed) {
            e->accessed = false;
        } else {
            /* Remove from hash table */
            HASH_DEL(hh, cache->tbl, e);
            cache->count--;
            atomic_fetch_add_explicit(&cache->metrics.evictions, 1,
                                       memory_order_relaxed);
            log_debug("Evicted key='%s'", entry_key(e));
            free(e);
            return;
        }

        e = e->hh.hh_next ? (mmc_cache_entry_t *)e->hh.hh_next : cache->tbl;
        scanned++;
    }
}

/* ------------------------------------------------------------------------- *
 * Public API                                                                *
 * ------------------------------------------------------------------------- */

/*
 * mmc_cache_create
 * ----------------
 * Creates a new cache instance.
 */
mmc_cache_handle_t *mmc_cache_create(size_t max_entries, uint64_t default_ttl_ms)
{
    if (max_entries == 0 || default_ttl_ms == 0)
        return NULL;

    mmc_cache_t *c = calloc(1, sizeof(*c));
    if (!c)
        return NULL;

    pthread_mutex_init(&c->lock, NULL);
    c->capacity       = max_entries;
    c->default_ttl_ms = default_ttl_ms;
    return c;
}

/*
 * mmc_cache_destroy
 * -----------------
 * Destroys the cache and releases all resources.
 */
void mmc_cache_destroy(mmc_cache_handle_t *h)
{
    if (!h)
        return;

    mmc_cache_t *c = h;
    pthread_mutex_lock(&c->lock);
    mmc_cache_entry_t *e, *tmp;
    for (e = c->tbl; e != NULL;) {
        tmp = (mmc_cache_entry_t *)e->hh_next;
        free(e);
        e = tmp;
    }
    pthread_mutex_unlock(&c->lock);
    pthread_mutex_destroy(&c->lock);
    free(c);
}

/*
 * mmc_cache_put
 * -------------
 * Inserts or overwrites an entry.
 */
mmc_cache_status_t mmc_cache_put(mmc_cache_handle_t *h,
                                 const char         *key,
                                 const void         *payload,
                                 size_t              payload_len,
                                 uint64_t            ttl_ms)
{
    if (!h || !key || !payload)
        return MMC_CACHE_ERR_INV_ARG;

    const size_t keylen = strlen(key);
    if (keylen == 0)
        return MMC_CACHE_ERR_INV_ARG;

    mmc_cache_t *c = h;
    uint64_t effective_ttl = (ttl_ms == 0) ? c->default_ttl_ms : ttl_ms;

    pthread_mutex_lock(&c->lock);

    mmc_cache_entry_t *existing;
    HASH_FIND(hh, c->tbl, key, keylen, existing);
    if (existing) {
        /* Overwrite path */
        HASH_DEL(hh, c->tbl, existing);
        c->count--;
        free(existing);
    }

    /* Evict if capacity reached */
    while (c->count >= c->capacity) {
        cache_evict_one(c);
    }

    mmc_cache_entry_t *entry =
        entry_create(key, keylen, payload, payload_len, effective_ttl);
    if (!entry) {
        pthread_mutex_unlock(&c->lock);
        return MMC_CACHE_ERR_OOM;
    }

    HASH_ADD_KEYPTR(hh, c->tbl, entry_key(entry), keylen, entry);
    c->count++;
    atomic_fetch_add_explicit(&c->metrics.inserts, 1, memory_order_relaxed);

    pthread_mutex_unlock(&c->lock);
    return MMC_CACHE_OK;
}

/*
 * mmc_cache_get
 * -------------
 * Retrieves an entry.  Caller must provide a buffer with sufficient size.
 */
mmc_cache_status_t mmc_cache_get(mmc_cache_handle_t *h,
                                 const char         *key,
                                 void               *out_buf,
                                 size_t             *inout_len)
{
    if (!h || !key || !out_buf || !inout_len)
        return MMC_CACHE_ERR_INV_ARG;

    const size_t keylen = strlen(key);
    mmc_cache_t *c      = h;

    pthread_mutex_lock(&c->lock);

    mmc_cache_entry_t *entry;
    HASH_FIND(hh, c->tbl, key, keylen, entry);
    if (!entry) {
        atomic_fetch_add_explicit(&c->metrics.misses, 1, memory_order_relaxed);
        pthread_mutex_unlock(&c->lock);
        return MMC_CACHE_ERR_NOT_FOUND;
    }

    /* TTL check */
    const uint64_t now = monotonic_ms();
    if (now > entry->expires_at_ms) {
        /* Expired – remove and report as miss */
        HASH_DEL(hh, c->tbl, entry);
        free(entry);
        c->count--;
        atomic_fetch_add_explicit(&c->metrics.expired, 1, memory_order_relaxed);
        pthread_mutex_unlock(&c->lock);
        return MMC_CACHE_ERR_NOT_FOUND;
    }

    /* Mutation */
    entry->accessed = true;

    /* Copy payload */
    const unsigned char *payload = entry_payload(entry);
    if (*inout_len < entry->size) {
        *inout_len = entry->size;
        pthread_mutex_unlock(&c->lock);
        return MMC_CACHE_ERR_OOM; /* treat as buffer too small */
    }

    memcpy(out_buf, payload, entry->size);
    *inout_len = entry->size;

    atomic_fetch_add_explicit(&c->metrics.hits, 1, memory_order_relaxed);
    pthread_mutex_unlock(&c->lock);
    return MMC_CACHE_OK;
}

/*
 * mmc_cache_invalidate
 * --------------------
 * Deletes a single key.
 */
mmc_cache_status_t mmc_cache_invalidate(mmc_cache_handle_t *h, const char *key)
{
    if (!h || !key)
        return MMC_CACHE_ERR_INV_ARG;

    const size_t keylen = strlen(key);
    mmc_cache_t *c      = h;

    pthread_mutex_lock(&c->lock);
    mmc_cache_entry_t *entry;
    HASH_FIND(hh, c->tbl, key, keylen, entry);
    if (entry) {
        HASH_DEL(hh, c->tbl, entry);
        free(entry);
        c->count--;
    }
    pthread_mutex_unlock(&c->lock);
    return MMC_CACHE_OK;
}

/*
 * mmc_cache_clear
 * ---------------
 * Removes all entries.
 */
void mmc_cache_clear(mmc_cache_handle_t *h)
{
    if (!h)
        return;

    mmc_cache_t *c = h;
    pthread_mutex_lock(&c->lock);
    mmc_cache_entry_t *e, *tmp;
    for (e = c->tbl; e != NULL;) {
        tmp = (mmc_cache_entry_t *)e->hh_next;
        free(e);
        e = tmp;
    }
    c->tbl   = NULL;
    c->count = 0;
    pthread_mutex_unlock(&c->lock);
}

/*
 * mmc_cache_metrics
 * -----------------
 * Returns a copy of the current metrics.
 */
void mmc_cache_metrics(mmc_cache_handle_t      *h,
                       mmc_cache_metrics_t *out_copy)
{
    if (!h || !out_copy)
        return;

    mmc_cache_t *c = h;
    memset(out_copy, 0, sizeof(*out_copy));

    out_copy->hits      = atomic_load_explicit(&c->metrics.hits,
                                               memory_order_relaxed);
    out_copy->misses    = atomic_load_explicit(&c->metrics.misses,
                                               memory_order_relaxed);
    out_copy->evictions = atomic_load_explicit(&c->metrics.evictions,
                                               memory_order_relaxed);
    out_copy->expired   = atomic_load_explicit(&c->metrics.expired,
                                               memory_order_relaxed);
    out_copy->inserts   = atomic_load_explicit(&c->metrics.inserts,
                                               memory_order_relaxed);
}

/* ------------------------------------------------------------------------- *
 * Monitoring integration (Prometheus text format)                           *
 * ------------------------------------------------------------------------- */

/*
 * mmc_cache_prometheus_dump
 * -------------------------
 * Emits cache statistics in Prometheus exposition format.
 * Caller supplies callback that receives lines (NULL terminated).
 */
typedef void (*mmc_prom_cb_t)(const char *line, void *userdata);

void mmc_cache_prometheus_dump(mmc_cache_handle_t *h,
                               mmc_prom_cb_t       cb,
                               void               *ud)
{
    if (!h || !cb)
        return;

    char buf[128];
    mmc_cache_metrics_t m;
    mmc_cache_metrics(h, &m);

    snprintf(buf, sizeof(buf),
             "# TYPE mmc_cache_hits_total counter\n"
             "mmc_cache_hits_total %" PRIuFAST64 "\n",
             (uint_fast64_t)m.hits);
    cb(buf, ud);

    snprintf(buf, sizeof(buf),
             "# TYPE mmc_cache_misses_total counter\n"
             "mmc_cache_misses_total %" PRIuFAST64 "\n",
             (uint_fast64_t)m.misses);
    cb(buf, ud);

    snprintf(buf, sizeof(buf),
             "# TYPE mmc_cache_evictions_total counter\n"
             "mmc_cache_evictions_total %" PRIuFAST64 "\n",
             (uint_fast64_t)m.evictions);
    cb(buf, ud);

    snprintf(buf, sizeof(buf),
             "# TYPE mmc_cache_expired_total counter\n"
             "mmc_cache_expired_total %" PRIuFAST64 "\n",
             (uint_fast64_t)m.expired);
    cb(buf, ud);

    snprintf(buf, sizeof(buf),
             "# TYPE mmc_cache_inserts_total counter\n"
             "mmc_cache_inserts_total %" PRIuFAST64 "\n",
             (uint_fast64_t)m.inserts);
    cb(buf, ud);
}

/* ------------------------------------------------------------------------- *
 * Self-test (may be compiled out in release)                                *
 * ------------------------------------------------------------------------- */
#ifdef MMC_CACHE_ENABLE_SELFTEST
#include <assert.h>

static void test_basic()
{
    mmc_cache_handle_t *c = mmc_cache_create(4, 1000);
    char payload[]        = "hello world";
    mmc_cache_put(c, "key", payload, sizeof payload, 0);

    char out[32];
    size_t len = sizeof out;
    assert(mmc_cache_get(c, "key", out, &len) == MMC_CACHE_OK);
    assert(len == sizeof payload);
    assert(memcmp(out, payload, len) == 0);

    mmc_cache_destroy(c);
    log_debug("Self-test passed");
}

int main(void)
{
    test_basic();
    return 0;
}
#endif /* MMC_CACHE_ENABLE_SELFTEST */

/* ------------------------------------------------------------------------- *
 * End of module                                                             *
 * ------------------------------------------------------------------------- */
