/*
 * MercuryMonolith Commerce Hub
 * ----------------------------------------
 * Module 53 – Response Cache (src/module_53.txt)
 *
 * This compilation unit implements an in-memory, thread-safe, TTL-aware,
 * Least-Recently-Used (LRU) cache optimised for caching HTTP/GraphQL
 * responses inside the monolithic process.  Although each logical API
 * “micro-service” (orders, inventory, billing, …) can instantiate an
 * independent cache with specialised TTLs and capacities, all instances
 * share the same implementation to guarantee consistent performance &
 * metric semantics across the Hub.
 *
 * Design notes
 * ------------
 *  • O(1) average-time look-ups via uthash
 *  • Doubly-linked list to maintain LRU ordering
 *  • per-instance pthread_rwlock_t to allow high-read/low-write workloads
 *  • Expiry (TTL) checked on read; background purging still available
 *  • Instrumented with Prometheus-style counters/gauges
 *
 * Dependencies
 * ------------
 *  uthash         : https://troydhanson.github.io/uthash/
 *  mmc_log.h      : house-style structured logger (debug/info/warn/error)
 *  mmc_metrics.h  : Prometheus exporter (mmc_metric_inc/dec/observe)
 *
 * Build flags
 * -----------
 *  cc … -lpthread -Wall -Wextra -pedantic
 */

#include <assert.h>
#include <errno.h>
#include <inttypes.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>

#include "uthash.h"            /* Third-party hash map                       */
#include "mmc_log.h"           /* Project-wide logging helpers               */
#include "mmc_metrics.h"       /* Project-wide Prometheus metric helpers     */
#include "mmc_response_cache.h"/* Public interface (forward-declared here)   */

/* ------------------------------------------------------------------------- *
 * Local helpers                                                             *
 * ------------------------------------------------------------------------- */

/* Return milliseconds since an unspecified epoch (monotonic). */
static inline uint64_t
now_ms(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ((uint64_t)ts.tv_sec * 1000ULL) + (ts.tv_nsec / 1000000ULL);
}

/* Thread-safe, allocation-checked strdup. */
static inline char *
mmc_xstrdup(const char *src)
{
    char *dup = strdup(src);
    if (dup == NULL) {
        mmc_log_fatal("response_cache", "Out of memory duplicating string");
        abort(); /* unrecoverable in production mode */
    }
    return dup;
}

/* ------------------------------------------------------------------------- *
 * Data structures                                                           *
 * ------------------------------------------------------------------------- */

typedef struct cache_entry
{
    char               *key;        /* UTF-8, NULL-terminated identifier   */
    void               *blob;       /* Response payload (heap-allocated)   */
    size_t              blob_size;  /* Size of payload in bytes            */
    uint64_t            expires_ms; /* TTL timestamp (now_ms())            */

    /* LRU list pointers */
    struct cache_entry *prev;
    struct cache_entry *next;

    UT_hash_handle      hh;         /* uthash linkage                      */
} cache_entry_t;

/* Cache instance */
struct mmc_response_cache
{
    cache_entry_t     *table;        /* Hash map (key → entry)             */
    cache_entry_t     *lru_head;     /* MRU                                */
    cache_entry_t     *lru_tail;     /* LRU                                */
    size_t             max_entries;  /* Capacity                           */
    uint32_t           default_ttl;  /* Fallback TTL in ms                 */

    pthread_rwlock_t   lock;         /* Read-mostly workload               */

    /* Metrics IDs (registered elsewhere) */
    mmc_metric_id      m_hit;
    mmc_metric_id      m_miss;
    mmc_metric_id      m_eviction;
    mmc_metric_id      m_items;
};

/* ------------------------------------------------------------------------- *
 * Forward declarations                                                      *
 * ------------------------------------------------------------------------- */
static void lru_move_to_front(struct mmc_response_cache *c, cache_entry_t *e);
static void lru_remove_tail(struct mmc_response_cache *c);
static void cache_entry_free(cache_entry_t *e);

/* ------------------------------------------------------------------------- *
 * Metric registration                                                       *
 * ------------------------------------------------------------------------- */
static void
register_metrics(struct mmc_response_cache *c, const char *namespace)
{
    /* Build fully-qualified metric names */
    char name[128];

    snprintf(name, sizeof name, "%s_cache_hit_total", namespace);
    c->m_hit = mmc_metric_counter_register(name, "Total cache hits");

    snprintf(name, sizeof name, "%s_cache_miss_total", namespace);
    c->m_miss = mmc_metric_counter_register(name, "Total cache misses");

    snprintf(name, sizeof name, "%s_cache_eviction_total", namespace);
    c->m_eviction = mmc_metric_counter_register(name, "Total LRU evictions");

    snprintf(name, sizeof name, "%s_cache_items", namespace);
    c->m_items = mmc_metric_gauge_register(name, "Number of items in cache");
}

/* ------------------------------------------------------------------------- *
 * Public interface                                                          *
 * ------------------------------------------------------------------------- */

mmc_response_cache_t *
mmc_cache_create(const char *metric_ns,
                 size_t      max_entries,
                 uint32_t    default_ttl_ms)
{
    if (max_entries == 0) {
        errno = EINVAL;
        return NULL;
    }

    mmc_response_cache_t *c = calloc(1, sizeof *c);
    if (!c) {
        return NULL;
    }

    c->max_entries  = max_entries;
    c->default_ttl  = default_ttl_ms;

    if (pthread_rwlock_init(&c->lock, NULL) != 0) {
        free(c);
        return NULL;
    }

    /* Prometheus metric registration (may log, but never fails) */
    register_metrics(c, metric_ns ? metric_ns : "mmc");

    mmc_log_info("response_cache",
                 "Created cache instance %p (max_entries=%zu, default_ttl=%ums)",
                 (void *)c,
                 max_entries,
                 default_ttl_ms);

    return c;
}

void
mmc_cache_destroy(mmc_response_cache_t *c)
{
    if (!c) return;

    pthread_rwlock_wrlock(&c->lock);

    cache_entry_t *cur, *tmp;
    HASH_ITER(hh, c->table, cur, tmp) {
        HASH_DEL(c->table, cur);
        cache_entry_free(cur);
    }

    pthread_rwlock_unlock(&c->lock);
    pthread_rwlock_destroy(&c->lock);
    free(c);

    mmc_log_info("response_cache", "Destroyed cache instance");
}

int
mmc_cache_put(mmc_response_cache_t *c,
              const char           *key,
              const void           *payload,
              size_t                payload_size,
              uint32_t              ttl_ms)
{
    if (!c || !key || !payload || payload_size == 0) {
        return EINVAL;
    }

    uint32_t ttl = ttl_ms ? ttl_ms : c->default_ttl;
    uint64_t expires = now_ms() + (uint64_t)ttl;

    pthread_rwlock_wrlock(&c->lock);

    /* Existing? → Replace */
    cache_entry_t *e = NULL;
    HASH_FIND_STR(c->table, key, e);
    if (e) {
        /* Replace payload */
        free(e->blob);
        e->blob       = mmc_xmemdup(payload, payload_size);
        e->blob_size  = payload_size;
        e->expires_ms = expires;
        lru_move_to_front(c, e);
        pthread_rwlock_unlock(&c->lock);
        return 0;
    }

    /* New entry */
    e = calloc(1, sizeof *e);
    if (!e) {
        pthread_rwlock_unlock(&c->lock);
        return ENOMEM;
    }

    e->key        = mmc_xstrdup(key);
    e->blob       = mmc_xmemdup(payload, payload_size);
    e->blob_size  = payload_size;
    e->expires_ms = expires;

    /* Insert into hash & LRU */
    HASH_ADD_KEYPTR(hh, c->table, e->key, strlen(e->key), e);
    mmc_metric_gauge_inc(c->m_items);

    /* LRU list: push front */
    e->prev    = NULL;
    e->next    = c->lru_head;
    if (c->lru_head) c->lru_head->prev = e;
    c->lru_head = e;
    if (!c->lru_tail) c->lru_tail = e;

    /* Evict if over capacity */
    if (HASH_COUNT(c->table) > c->max_entries) {
        lru_remove_tail(c);
        mmc_metric_counter_inc(c->m_eviction);
    }

    pthread_rwlock_unlock(&c->lock);
    return 0;
}

int
mmc_cache_get(mmc_response_cache_t *c,
              const char           *key,
              void                **payload_out,
              size_t               *payload_size_out)
{
    if (!c || !key || !payload_out || !payload_size_out) {
        return EINVAL;
    }

    *payload_out      = NULL;
    *payload_size_out = 0;

    pthread_rwlock_rdlock(&c->lock);
    cache_entry_t *e = NULL;
    HASH_FIND_STR(c->table, key, e);
    if (!e) {
        pthread_rwlock_unlock(&c->lock);
        mmc_metric_counter_inc(c->m_miss);
        return ENOENT;
    }

    uint64_t now = now_ms();
    if (e->expires_ms <= now) {
        /* Expired → upgrade to write lock and remove */
        pthread_rwlock_unlock(&c->lock);
        pthread_rwlock_wrlock(&c->lock);

        /* Re-validate under write lock */
        HASH_FIND_STR(c->table, key, e);
        if (e && e->expires_ms <= now) {
            HASH_DEL(c->table, e);
            lru_move_to_front(c, e); /* just to keep pointers consistent */
            cache_entry_free(e);
            mmc_metric_gauge_dec(c->m_items);
        }
        pthread_rwlock_unlock(&c->lock);
        mmc_metric_counter_inc(c->m_miss);
        return ENOENT;
    }

    /* Found & valid */
    void *copy = mmc_xmemdup(e->blob, e->blob_size);
    *payload_out      = copy;
    *payload_size_out = e->blob_size;

    /* Promote to MRU: requires write lock */
    pthread_rwlock_unlock(&c->lock);
    pthread_rwlock_wrlock(&c->lock);
    HASH_FIND_STR(c->table, key, e);
    if (e) lru_move_to_front(c, e);
    pthread_rwlock_unlock(&c->lock);

    mmc_metric_counter_inc(c->m_hit);
    return 0;
}

void
mmc_cache_purge_expired(mmc_response_cache_t *c)
{
    if (!c) return;
    uint64_t now = now_ms();

    pthread_rwlock_wrlock(&c->lock);

    cache_entry_t *cur, *tmp;
    HASH_ITER(hh, c->table, cur, tmp) {
        if (cur->expires_ms <= now) {
            HASH_DEL(c->table, cur);
            /* detach from LRU list */
            if (cur->prev) cur->prev->next = cur->next;
            if (cur->next) cur->next->prev = cur->prev;
            if (c->lru_head == cur) c->lru_head = cur->next;
            if (c->lru_tail == cur) c->lru_tail = cur->prev;

            cache_entry_free(cur);
            mmc_metric_gauge_dec(c->m_items);
        }
    }

    pthread_rwlock_unlock(&c->lock);
}

/* ------------------------------------------------------------------------- *
 * Internal helpers                                                          *
 * ------------------------------------------------------------------------- */

static void
lru_move_to_front(struct mmc_response_cache *c, cache_entry_t *e)
{
    if (c->lru_head == e) return;

    /* Detach */
    if (e->prev) e->prev->next = e->next;
    if (e->next) e->next->prev = e->prev;
    if (c->lru_tail == e) c->lru_tail = e->prev;

    /* Insert at head */
    e->prev       = NULL;
    e->next       = c->lru_head;
    if (c->lru_head) c->lru_head->prev = e;
    c->lru_head   = e;
    if (!c->lru_tail) c->lru_tail = e;
}

static void
lru_remove_tail(struct mmc_response_cache *c)
{
    cache_entry_t *victim = c->lru_tail;
    if (!victim) return;

    /* Remove from hash */
    HASH_DEL(c->table, victim);

    /* Remove from LRU list */
    if (victim->prev) victim->prev->next = NULL;
    c->lru_tail = victim->prev;
    if (!c->lru_tail) c->lru_head = NULL; /* cache becomes empty */

    cache_entry_free(victim);
    mmc_metric_gauge_dec(c->m_items);
}

static void
cache_entry_free(cache_entry_t *e)
{
    if (!e) return;
    free(e->key);
    free(e->blob);
    free(e);
}

/* ------------------------------------------------------------------------- *
 * Convenience utils (duplicating memory safely)                             *
 * ------------------------------------------------------------------------- */

void *
mmc_xmemdup(const void *src, size_t len)
{
    void *dup = malloc(len);
    if (!dup) {
        mmc_log_fatal("response_cache", "Out of memory duplicating blob");
        abort();
    }
    memcpy(dup, src, len);
    return dup;
}

/* ------------------------------------------------------------------------- *
 * End of file                                                               *
 * ------------------------------------------------------------------------- */
