```c
/**
 * File: tests/test_main.c
 * Project: MercuryMonolith Commerce Hub (api_microservice)
 * Purpose: High-level integration / unit tests that exercise the Order-Service
 *          happy-path and error-path logic, with special focus on the built-in
 *          read-through response-cache.  The tests are implemented with the
 *          Check framework so they can be executed by CTest / Meson / Make
 *          targets alike:
 *
 *              $ meson test         # Meson
 *              $ ctest -V           # CTest
 *              $ make check         # GNU-Make
 *
 * To keep the test self-contained we provide small, header-only *fakes* of the
 * repository and cache components that implement the same public surface as
 * the production modules.  Those fakes are wired into the service via the
 * standard dependency-injection hooks that are part of the real codebase
 * (`order_service_set_repository()`, `order_service_set_cache()`).
 *
 * IMPORTANT:
 *  – The tests may link against the real production objects when they are
 *    available on the linker path.  In that case the fakes will be discarded
 *    automatically because every symbol is annotated weak (`__attribute__((weak))`).
 *  – When the production objects are *not* present, the linker will fall back
 *    to the implementations in this file so the test binary is still
 *    compile-time and run-time complete.
 */

#define _GNU_SOURCE /* strdup() on glibc */
#include <check.h>
#include <errno.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* ---------------------------------------------------------------------------
 * Public headers from the main codebase
 * ------------------------------------------------------------------------- */
#include "order_service.h"      /* service façade */
#include "order_repository.h"   /* repository interface */
#include "response_cache.h"     /* LRU / TTL cache interface */

/* ---------------------------------------------------------------------------
 * Compile-time configuration
 * ------------------------------------------------------------------------- */
#ifndef TEST_DB_CAPACITY
#  define TEST_DB_CAPACITY   16  /* in-memory “database” size                */
#endif

#ifndef TEST_CACHE_CAPACITY
#  define TEST_CACHE_CAPACITY 8  /* in-memory “cache” size                   */
#endif

/* ---------------------------------------------------------------------------
 * Typedefs / simple model mirrors
 * ------------------------------------------------------------------------- */
typedef struct
{
    char    id[40];     /* UUID4 textual representation                     */
    char    sku[40];
    uint32_t quantity;
} order_t;

/* Production code usually provides this enum; duplicate for the stub build */
#ifndef ORDER_ERR_OK
typedef enum
{
    ORDER_ERR_OK = 0,
    ORDER_ERR_NOT_FOUND,
    ORDER_ERR_BACKEND,
    ORDER_ERR_INVALID_ARG
} order_err_e;
#endif /* ORDER_ERR_OK */

/* ---------------------------------------------------------------------------
 * Reference in-memory “database” (fake repository)
 * ------------------------------------------------------------------------- */

/* A naive array-backed store – good enough for tests                     */
static order_t      g_db[TEST_DB_CAPACITY];
static size_t       g_db_size = 0;

/* Simple counter for interaction verification                            */
static uint32_t     g_repo_get_invocations  = 0;

/* Insert helper                                                           */
static void
db_insert(const order_t *src)
{
    if (g_db_size >= TEST_DB_CAPACITY)
        ck_abort_msg("Fake DB capacity exhausted – increase TEST_DB_CAPACITY.");

    g_db[g_db_size++] = *src;
}

/* ---------------------------------------------------------------------------
 * Response-cache fake
 * ------------------------------------------------------------------------- */
typedef struct
{
    char    id[40];
    order_t ord;
    time_t  ts_insert;
} cache_entry_t;

static cache_entry_t g_cache[TEST_CACHE_CAPACITY];
static size_t        g_cache_size = 0;
static uint32_t      g_cache_hit  = 0;
static uint32_t      g_cache_miss = 0;

/* Time-To-Live constraint (seconds). */
#ifndef TEST_CACHE_TTL_SEC
#  define TEST_CACHE_TTL_SEC  3600
#endif

/* Fake implementations – marked weak so real objects override them
 * automatically when they exist in the final link set. */
__attribute__((weak))
order_err_e
response_cache_get(const char *id, order_t *out)
{
    time_t now = time(NULL);
    for (size_t i = 0; i < g_cache_size; ++i)
    {
        if (strcmp(g_cache[i].id, id) == 0)
        {
            /* Expired? */
            if ((now - g_cache[i].ts_insert) > TEST_CACHE_TTL_SEC)
            {
                /* Evict */
                memmove(&g_cache[i],
                        &g_cache[i + 1],
                        (g_cache_size - i - 1) * sizeof(cache_entry_t));
                --g_cache_size;
                ++g_cache_miss;
                return ORDER_ERR_NOT_FOUND;
            }

            *out = g_cache[i].ord;
            ++g_cache_hit;
            return ORDER_ERR_OK;
        }
    }
    ++g_cache_miss;
    return ORDER_ERR_NOT_FOUND;
}

__attribute__((weak))
order_err_e
response_cache_put(const order_t *ord)
{
    if (g_cache_size >= TEST_CACHE_CAPACITY)
    {
        /* Very small, simple eviction – throw away the oldest element */
        memmove(&g_cache[0], &g_cache[1], (g_cache_size - 1)*sizeof(cache_entry_t));
        --g_cache_size;
    }

    cache_entry_t *slot   = &g_cache[g_cache_size++];
    strcpy(slot->id, ord->id);
    slot->ord       = *ord;
    slot->ts_insert = time(NULL);

    return ORDER_ERR_OK;
}

/* ---------------------------------------------------------------------------
 * Fake repository implementing order_repository_i
 * ------------------------------------------------------------------------- */
static order_err_e
fake_repo_get_by_id(const char *id, order_t *out)
{
    ++g_repo_get_invocations;

    for (size_t i = 0; i < g_db_size; ++i)
    {
        if (strcmp(g_db[i].id, id) == 0)
        {
            *out = g_db[i];
            return ORDER_ERR_OK;
        }
    }
    return ORDER_ERR_NOT_FOUND;
}

static order_err_e
fake_repo_save(const order_t *in)
{
    db_insert(in);
    return ORDER_ERR_OK;
}

static order_repository_i g_fake_repo = {
    .get_by_id = fake_repo_get_by_id,
    .save      = fake_repo_save,
};

/* ---------------------------------------------------------------------------
 * Helper functions / fixtures
 * ------------------------------------------------------------------------- */
static void
setup(void)
{
    /* Reset in-memory structures */
    memset(g_db,    0, sizeof(g_db));
    memset(g_cache, 0, sizeof(g_cache));
    g_db_size             = 0;
    g_cache_size          = 0;
    g_repo_get_invocations = 0;
    g_cache_hit            = 0;
    g_cache_miss           = 0;

    /* Inject our fakes into the service under test */
    order_service_set_repository(&g_fake_repo);
    /* The cache uses global C-linkage symbols; nothing to configure. */
}

static void
teardown(void)
{
    /* Nothing to do for now */
}

/* ---------------------------------------------------------------------------
 * Test cases
 * ------------------------------------------------------------------------- */

/* Verify that a cache hit bypasses the repository and returns immediately */
START_TEST(test_cache_hit_short_circuits_repository)
{
    /* Arrange ------------------------------------------------------------ */
    order_t ord = {
        .id       = "ORDER-12345-CACHE-HIT",
        .sku      = "SKU-FOO-BAR",
        .quantity = 42
    };

    /* Put object directly into cache (simulate previous access). */
    ck_assert_int_eq(response_cache_put(&ord), ORDER_ERR_OK);

    /* Act ---------------------------------------------------------------- */
    order_t out = {0};
    order_err_e rc = order_service_get_order(ord.id, &out);

    /* Assert ------------------------------------------------------------- */
    ck_assert_int_eq(rc, ORDER_ERR_OK);
    ck_assert_int_eq(g_repo_get_invocations, 0);
    ck_assert_int_eq(g_cache_hit, 1);
    ck_assert_int_eq(out.quantity, 42);
    ck_assert_str_eq(out.sku, ord.sku);
}
END_TEST

/* Verify that a cache miss fetches from the repository and populates cache */
START_TEST(test_cache_miss_triggers_repo_and_backfills_cache)
{
    /* Arrange ------------------------------------------------------------ */
    order_t ord = {
        .id       = "ORDER-12345-CACHE-MISS",
        .sku      = "SKU-BAZ-QUX",
        .quantity = 99
    };
    db_insert(&ord);

    /* Act ---------------------------------------------------------------- */
    order_t out = {0};
    order_err_e rc = order_service_get_order(ord.id, &out);

    /* Assert part 1: repository path taken -------------------------------- */
    ck_assert_int_eq(rc, ORDER_ERR_OK);
    ck_assert_int_eq(g_repo_get_invocations, 1);
    ck_assert_int_eq(out.quantity, 99);

    /* Act again ----------------------------------------------------------- */
    order_t out2 = {0};
    rc = order_service_get_order(ord.id, &out2);

    /* Assert part 2: second access is served from cache ------------------- */
    ck_assert_int_eq(rc, ORDER_ERR_OK);
    ck_assert_int_eq(g_repo_get_invocations, 1); /* unchanged */
    ck_assert_int_eq(g_cache_hit, 1);
    ck_assert_int_eq(out2.quantity, 99);
}
END_TEST

/* Verify that error propagation works on “order not found” */
START_TEST(test_order_not_found_error_propagation)
{
    /* Arrange ------------------------------------------------------------ */
    const char *unknown_id = "ORDER-DOES-NOT-EXIST";
    order_t dummy          = {0};

    /* Act ---------------------------------------------------------------- */
    order_err_e rc = order_service_get_order(unknown_id, &dummy);

    /* Assert ------------------------------------------------------------- */
    ck_assert_int_eq(rc, ORDER_ERR_NOT_FOUND);
    ck_assert_int_eq(g_repo_get_invocations, 1);
    ck_assert_int_eq(g_cache_hit, 0);
    ck_assert_int_eq(g_cache_miss, 1);
}
END_TEST

/* ---------------------------------------------------------------------------
 * Test-suite bootstrap
 * ------------------------------------------------------------------------- */
static Suite *
order_service_suite(void)
{
    Suite *s     = suite_create("order_service");
    TCase *tc    = tcase_create("core");

    tcase_add_checked_fixture(tc, setup, teardown);

    tcase_add_test(tc, test_cache_hit_short_circuits_repository);
    tcase_add_test(tc, test_cache_miss_triggers_repo_and_backfills_cache);
    tcase_add_test(tc, test_order_not_found_error_propagation);

    suite_add_tcase(s, tc);
    return s;
}

int
main(void)
{
    int     failed;
    Suite  *s  = order_service_suite();
    SRunner *sr = srunner_create(s);

    srunner_run_all(sr, CK_ENV);  /* CK_ENV = use env-vars for verbosity    */
    failed = srunner_ntests_failed(sr);
    srunner_free(sr);

    return (failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}
```

