```rust
//! module_58 – Dynamic analysis-strategy manager for ChirpPulse.
//!
//! The code below demonstrates a production-ready implementation of the
//! Strategy-Pattern with hot-swapping capabilities, live configuration reloads,
//! built-in observability, and thorough error-handling.  The module can be
//! dropped into the wider ChirpPulse code-base and used by any downstream
//! micro-service that needs real-time social-event analysis.

use std::{
    collections::HashMap,
    fs,
    path::{Path, PathBuf},
    sync::{Arc, RwLock},
};

use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use notify::{Event, RecommendedWatcher, RecursiveMode, Watcher};
use serde::Deserialize;
use tokio::{
    sync::mpsc,
    task,
    time::{sleep, Duration},
};
use uuid::Uuid;

// ────────────────────────────────────────────────────────────────────────────────
// Domain Types
// ────────────────────────────────────────────────────────────────────────────────

/// A social event captured from an upstream ingestion micro-service.
#[derive(Debug, Clone)]
pub struct SocialEvent {
    pub id: Uuid,
    pub text: String,
    pub user_id: String,
    pub language: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

/// The result produced by a strategy after analyzing a social event.
#[derive(Debug, Clone)]
pub struct AnalysisResult {
    pub sentiment_score: f32,
    pub is_toxic: bool,
}

// ────────────────────────────────────────────────────────────────────────────────
// Strategy Trait
// ────────────────────────────────────────────────────────────────────────────────

/// Trait every analysis strategy must implement.
///
/// `AnalysisStrategy` is object-safe so that it can be stored in an
/// `Arc<dyn AnalysisStrategy>` and swapped at runtime.
#[async_trait]
pub trait AnalysisStrategy: Send + Sync + 'static {
    /// Human-readable name, used for metrics and debugging.
    fn name(&self) -> &'static str;

    /// Analyze a single [`SocialEvent`].  
    /// MUST be non-blocking; any expensive work should be awaited.
    async fn analyze(&self, event: &SocialEvent) -> AnalysisResult;
}

// ────────────────────────────────────────────────────────────────────────────────
// Built-in Strategies
// ────────────────────────────────────────────────────────────────────────────────

/// A simple lexicon-based sentiment strategy backed by an in-memory look-up.
pub struct LexiconStrategy {
    lexicon: HashMap<String, f32>,
}

impl LexiconStrategy {
    pub fn new() -> Self {
        let mut lexicon = HashMap::new();
        lexicon.insert("good".into(), 0.8);
        lexicon.insert("bad".into(), -0.8);
        lexicon.insert("awesome".into(), 1.0);
        lexicon.insert("terrible".into(), -1.0);
        Self { lexicon }
    }

    fn score(&self, text: &str) -> f32 {
        let mut score = 0.0;
        let mut hits = 0_u32;

        for token in text.split(|c: char| !c.is_alphanumeric()) {
            if let Some(&s) = self.lexicon.get(&token.to_ascii_lowercase()) {
                score += s;
                hits += 1;
            }
        }

        if hits == 0 {
            0.0
        } else {
            score / hits as f32
        }
    }
}

#[async_trait]
impl AnalysisStrategy for LexiconStrategy {
    fn name(&self) -> &'static str {
        "lexicon_v1"
    }

    async fn analyze(&self, event: &SocialEvent) -> AnalysisResult {
        let sentiment = self.score(&event.text);
        let is_toxic = sentiment < -0.7;

        AnalysisResult {
            sentiment_score: sentiment,
            is_toxic,
        }
    }
}

/// A placeholder Transformer-based strategy that simulates expensive inference.
pub struct TransformerStrategy;

#[async_trait]
impl AnalysisStrategy for TransformerStrategy {
    fn name(&self) -> &'static str {
        "transformer_v2"
    }

    async fn analyze(&self, event: &SocialEvent) -> AnalysisResult {
        // Simulate model latency.
        sleep(Duration::from_millis(3)).await;

        // Dummy logic that produces pseudo-random sentiment.
        let hash = fxhash::hash64(event.text.as_bytes());
        let sentiment = ((hash % 200) as f32 / 100.0) - 1.0;
        let is_toxic = sentiment < -0.5;

        AnalysisResult {
            sentiment_score: sentiment,
            is_toxic,
        }
    }
}

// ────────────────────────────────────────────────────────────────────────────────
// Configuration Schema
// ────────────────────────────────────────────────────────────────────────────────

#[derive(Debug, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum StrategyKind {
    Lexicon,
    Transformer,
}

impl StrategyKind {
    fn build(&self) -> Arc<dyn AnalysisStrategy> {
        match self {
            StrategyKind::Lexicon => Arc::new(LexiconStrategy::new()),
            StrategyKind::Transformer => Arc::new(TransformerStrategy),
        }
    }
}

#[derive(Debug, Deserialize)]
pub struct StrategyConfig {
    pub strategy: StrategyKind,
}

// ────────────────────────────────────────────────────────────────────────────────
// Registry — the hot-swappable Strategy holder
// ────────────────────────────────────────────────────────────────────────────────

/// Thread-safe holder for the currently active analysis strategy.
#[derive(Clone)]
pub struct StrategyRegistry {
    inner: Arc<RwLock<Arc<dyn AnalysisStrategy>>>,
}

impl StrategyRegistry {
    /// Create a new registry with the provided initial strategy.
    pub fn new(initial: Arc<dyn AnalysisStrategy>) -> Self {
        Self {
            inner: Arc::new(RwLock::new(initial)),
        }
    }

    /// Analyze an event using the currently active strategy.
    pub async fn analyze(&self, event: &SocialEvent) -> AnalysisResult {
        let strategy = {
            let guard = self.inner.read().expect("poisoned lock");
            guard.clone()
        };

        let name = strategy.name();
        let start = std::time::Instant::now();
        let result = strategy.analyze(event).await;
        let elapsed = start.elapsed();

        // Emit metrics.
        metrics::timing!("chirppulse.strategy.latency", elapsed, "strategy" => name);
        metrics::increment_counter!("chirppulse.strategy.calls", "strategy" => name);

        result
    }

    /// Atomically swap the current strategy, returning the name of the old one.
    pub fn swap_strategy(&self, new_strategy: Arc<dyn AnalysisStrategy>) -> String {
        let mut guard = self.inner.write().expect("poisoned lock");
        let old_name = guard.name().to_owned();
        *guard = new_strategy;

        metrics::gauge!("chirppulse.strategy.active", 1.0, "strategy" => guard.name());
        old_name
    }
}

// ────────────────────────────────────────────────────────────────────────────────
// Live Configuration Watcher
// ────────────────────────────────────────────────────────────────────────────────

/// Spawn a background task watching a YAML configuration file and swapping the
/// active strategy whenever the file changes.
///
/// Returns a `JoinHandle` so the caller can await or detach the task entirely.
pub fn spawn_file_watcher(
    registry: StrategyRegistry,
    config_path: PathBuf,
) -> Result<task::JoinHandle<()>> {
    if !config_path.exists() {
        return Err(anyhow!(
            "strategy config file does not exist: {}",
            config_path.display()
        ));
    }

    // Channel to receive events from `notify`.
    let (tx, mut rx) = mpsc::unbounded_channel::<Event>();

    // `notify` watcher must run on the current thread; we move events across.
    let mut watcher: RecommendedWatcher =
        Watcher::new_immediate(move |res| match res {
            Ok(event) => {
                let _ = tx.send(event);
            }
            Err(e) => {
                tracing::error!("file watcher error: {e}");
            }
        })
        .context("create file watcher")?;

    watcher
        .watch(&config_path, RecursiveMode::NonRecursive)
        .with_context(|| format!("watch {}", config_path.display()))?;

    let handle = task::spawn(async move {
        tracing::info!("strategy watcher started on {}", config_path.display());

        // First load so we start with whatever is on disk.
        match load_config(&config_path) {
            Ok(cfg) => {
                let _ = registry.swap_strategy(cfg.strategy.build());
            }
            Err(e) => {
                tracing::warn!("failed to load initial strategy config: {e:?}");
            }
        }

        while let Some(_event) = rx.recv().await {
            match load_config(&config_path) {
                Ok(cfg) => {
                    let new_strategy = cfg.strategy.build();
                    let old_name = registry.swap_strategy(new_strategy);
                    tracing::info!(
                        new_strategy = ?cfg.strategy,
                        old_strategy = %old_name,
                        "analysis strategy updated"
                    );
                }
                Err(e) => {
                    tracing::error!("failed to reload strategy config: {e:?}");
                }
            }
        }
    });

    Ok(handle)
}

// ────────────────────────────────────────────────────────────────────────────────
// Helpers
// ────────────────────────────────────────────────────────────────────────────────

fn load_config(path: &Path) -> Result<StrategyConfig> {
    let contents = fs::read_to_string(path)
        .with_context(|| format!("reading {}", path.display()))?;
    let cfg: StrategyConfig =
        serde_yaml::from_str(&contents).with_context(|| format!("parsing {}", path.display()))?;
    Ok(cfg)
}

// ────────────────────────────────────────────────────────────────────────────────
// Tests
// ────────────────────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn lexicon_basic_scores() {
        let strategy = LexiconStrategy::new();
        let pos_event = SocialEvent {
            id: Uuid::new_v4(),
            text: "awesome good".into(),
            user_id: "u".into(),
            language: None,
            timestamp: chrono::Utc::now(),
        };
        let neg_event = SocialEvent {
            id: Uuid::new_v4(),
            text: "bad terrible".into(),
            user_id: "u".into(),
            language: None,
            timestamp: chrono::Utc::now(),
        };

        let pos = strategy.analyze(&pos_event).await;
        let neg = strategy.analyze(&neg_event).await;

        assert!(pos.sentiment_score > 0.5);
        assert!(neg.sentiment_score < -0.5);
    }

    #[tokio::test(flavor = "multi_thread", worker_threads = 2)]
    async fn registry_swaps() {
        let registry = StrategyRegistry::new(Arc::new(LexiconStrategy::new()));
        let ev = SocialEvent {
            id: Uuid::new_v4(),
            text: "hello".into(),
            user_id: "u".into(),
            language: None,
            timestamp: chrono::Utc::now(),
        };

        let res1 = registry.analyze(&ev).await;
        registry.swap_strategy(Arc::new(TransformerStrategy));
        let res2 = registry.analyze(&ev).await;

        assert_ne!(res1.sentiment_score, res2.sentiment_score);
    }
}
```