```rust
//! src/module_8.rs
//!
//! Dynamic strategy-pattern runtime for hot-swappable analytics.
//
// NOTE: Rename the file to `module_8.rs` in your workspace; it is kept as
// `.txt` in this prompt only because of format-generation constraints.

use std::{
    collections::HashMap,
    fmt,
    sync::{Arc, RwLock},
    time::Duration,
};

use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use once_cell::sync::Lazy;
use rand::{distributions::Alphanumeric, Rng};
use serde::{Deserialize, Serialize};
use tokio::{
    select,
    sync::{mpsc, watch},
    task,
    time,
};
use tracing::{debug, error, info, instrument, warn};

////////////////////////////////////////////////////////////////////////////////////////////////////
// Domain types
////////////////////////////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SocialMessage {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub user_handle: String,
    pub text: String,
    pub language: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
pub struct AnalysisResult {
    pub message_id: String,
    pub analyser: String,
    pub payload: serde_json::Value,
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Strategy trait & registry
////////////////////////////////////////////////////////////////////////////////////////////////////

/// Analytics engines implement this trait so they can be hot-swapped at runtime.
#[async_trait]
pub trait AnalysisStrategy: Send + Sync + fmt::Debug + 'static {
    /// Name used to identify the strategy instance in logs & registry.
    fn name(&self) -> &'static str;

    /// Execute the analytics algorithm asynchronously.
    async fn analyze(&self, msg: &SocialMessage) -> Result<AnalysisResult>;
}

// Global, concurrent registry for strategies.
// â€¢ `RwLock` ensures low-latency read access; writes (registration) are rare.
// â€¢ Each strategy is kept behind an `Arc` so cloning is cheap.
static REGISTRY: Lazy<RwLock<HashMap<&'static str, Arc<dyn AnalysisStrategy>>>> =
    Lazy::new(|| RwLock::new(HashMap::new()));

/// Registers a strategy globally.
///
/// If `overwrite` is `false`, attempting to register a duplicate name errors.
pub fn register_strategy(
    strategy: Arc<dyn AnalysisStrategy>,
    overwrite: bool,
) -> Result<()> {
    let mut reg = REGISTRY
        .write()
        .map_err(|_| anyhow!("strategy registry poisoned"))?;
    let name = strategy.name();

    if reg.contains_key(name) && !overwrite {
        return Err(anyhow!("strategy `{name}` already registered"));
    }

    reg.insert(name, strategy);
    info!(strategy = name, "Strategy registered");
    Ok(())
}

/// Unregister a strategy by name.
pub fn unregister_strategy(name: &str) -> Result<()> {
    let mut reg = REGISTRY
        .write()
        .map_err(|_| anyhow!("strategy registry poisoned"))?;
    if reg.remove(name).is_none() {
        warn!(strategy = name, "Attempted to remove unknown strategy");
    } else {
        info!(strategy = name, "Strategy unregistered");
    }
    Ok(())
}

/// Retrieve a snapshot of all registered strategies.
pub fn available_strategies() -> Vec<&'static str> {
    REGISTRY
        .read()
        .map(|map| map.keys().copied().collect())
        .unwrap_or_default()
}

/// Borrow an individual strategy. Returns `None` if not found.
pub fn find_strategy(name: &str) -> Option<Arc<dyn AnalysisStrategy>> {
    REGISTRY
        .read()
        .ok()
        .and_then(|map| map.get(name).cloned())
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Concrete strategy implementations
////////////////////////////////////////////////////////////////////////////////////////////////////

#[derive(Debug)]
pub struct SentimentAnalysisStrategy;

#[async_trait]
impl AnalysisStrategy for SentimentAnalysisStrategy {
    fn name(&self) -> &'static str {
        "sentiment-v1"
    }

    #[instrument(skip(self, msg), fields(message_id = %msg.id))]
    async fn analyze(&self, msg: &SocialMessage) -> Result<AnalysisResult> {
        // --- Mock sentiment score generation ----------------------------------------------------
        let mut rng = rand::thread_rng();
        let score: f32 = rng.gen_range(-1.0..=1.0);
        let magnitude: f32 = rng.gen_range(0.0..=1.0);

        let payload = serde_json::json!({
            "score": score,
            "magnitude": magnitude,
            "language": msg.language
        });

        Ok(AnalysisResult {
            message_id: msg.id.clone(),
            analyser: self.name().into(),
            payload,
        })
    }
}

#[derive(Debug)]
pub struct ToxicityScoreStrategy;

#[async_trait]
impl AnalysisStrategy for ToxicityScoreStrategy {
    fn name(&self) -> &'static str {
        "toxicity-v1"
    }

    #[instrument(skip(self, msg), fields(message_id = %msg.id))]
    async fn analyze(&self, msg: &SocialMessage) -> Result<AnalysisResult> {
        // --- Mock toxicity score generation -----------------------------------------------------
        let mut rng = rand::thread_rng();
        let probability: f32 = rng.gen_range(0.0..=1.0);
        let is_toxic = probability >= 0.7;

        let payload = serde_json::json!({
            "probability": probability,
            "is_toxic": is_toxic,
        });

        Ok(AnalysisResult {
            message_id: msg.id.clone(),
            analyser: self.name().into(),
            payload,
        })
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Runtime stream processor
////////////////////////////////////////////////////////////////////////////////////////////////////

/// In a real microservice we would pull from Kafka; here we fake a generator.
async fn synthetic_social_stream(
    mut shutdown: watch::Receiver<()>,
    mut tx: mpsc::Sender<SocialMessage>,
) -> Result<()> {
    let mut interval = time::interval(Duration::from_millis(25));
    loop {
        select! {
            _ = shutdown.changed() => {
                info!("social stream shutting down");
                break;
            }
            _ = interval.tick() => {
                let msg = SocialMessage {
                    id: random_id(),
                    timestamp: Utc::now(),
                    user_handle: random_user(),
                    text: random_text(),
                    language: Some("en".into()),
                };

                if tx
                    .send(msg)
                    .await
                    .map_err(|_| anyhow!("consumer dropped"))?
                    .is_err()
                {
                    error!("failed to enqueue social message");
                }
            }
        }
    }
    Ok(())
}

/// Runs the analytics workers using either a fixed strategy or a strategy
/// dynamically selected per-message (via lambda).
pub async fn run_analytics_pipeline<F>(
    strategy_selector: F,
    worker_concurrency: usize,
    runtime: Duration,
) -> Result<()>
where
    F: Fn(&SocialMessage) -> Option<&'static str> + Send + Sync + 'static,
{
    let (shutdown_tx, shutdown_rx) = watch::channel::<()>(());
    let (msg_tx, mut msg_rx) = mpsc::channel::<SocialMessage>(1024);

    // Spawn synthetic stream producer
    task::spawn(synthetic_social_stream(shutdown_rx.clone(), msg_tx));

    // Spawn analytics workers
    let selector = Arc::new(strategy_selector);
    let (res_tx, mut res_rx) = mpsc::channel::<AnalysisResult>(2048);

    for worker_id in 0..worker_concurrency {
        let mut local_rx = msg_rx.clone();
        let local_res_tx = res_tx.clone();
        let selector = Arc::clone(&selector);

        task::spawn(async move {
            while let Some(msg) = local_rx.recv().await {
                if let Some(strategy_key) = (selector)(&msg) {
                    match find_strategy(strategy_key) {
                        Some(strategy) => match strategy.analyze(&msg).await {
                            Ok(res) => {
                                if let Err(e) = local_res_tx.send(res).await {
                                    error!(worker_id, error = %e, "Failed to send analysis result");
                                }
                            }
                            Err(e) => error!(worker_id, error = %e, "Analysis error"),
                        },
                        None => warn!(worker_id, strategy_key, "Strategy not found"),
                    }
                } else {
                    debug!(worker_id, "No strategy selected for message");
                }
            }
        });
    }

    // Collect results (in real life we would publish to Kafka / Iceberg)
    task::spawn(async move {
        while let Some(res) = res_rx.recv().await {
            debug!(
                "{} produced payload: {}",
                res.analyser,
                res.payload.to_string()
            );
        }
    });

    // Let the pipeline run for the requested duration
    time::sleep(runtime).await;
    // Signal shutdown
    let _ = shutdown_tx.send(());

    Ok(())
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Mock data helpers â€” replace with real ingestion in production
////////////////////////////////////////////////////////////////////////////////////////////////////

fn random_id() -> String {
    rand::thread_rng()
        .sample_iter(&Alphanumeric)
        .take(12)
        .map(char::from)
        .collect()
}

fn random_user() -> String {
    let idx: u8 = rand::thread_rng().gen_range(0..=100);
    format!("user_{idx}")
}

fn random_text() -> String {
    const SAMPLES: &[&str] = &[
        "Rust is amazing!",
        "AI will change the world.",
        "Why is the sky blue?",
        "Go sports team!!",
        "Launching my new product today ðŸš€",
    ];
    let idx = rand::thread_rng().gen_range(0..SAMPLES.len());
    SAMPLES[idx].to_string()
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Bootstrapping (for quick standalone demo)
// cargo run --example quickstart           (inside workspace)
////////////////////////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test(flavor = "multi_thread", worker_threads = 4)]
    async fn quick_demo() -> Result<()> {
        tracing_subscriber::fmt::try_init().ok();

        // Register strategies
        register_strategy(Arc::new(SentimentAnalysisStrategy), false)?;
        register_strategy(Arc::new(ToxicityScoreStrategy), false)?;

        // Simple round-robin selector between two strategies.
        let selector = {
            let mut toggle = false;
            move |_msg: &SocialMessage| {
                toggle = !toggle;
                Some(if toggle { "sentiment-v1" } else { "toxicity-v1" })
            }
        };

        run_analytics_pipeline(selector, 4, Duration::from_secs(3)).await
    }
}
```