```rust
//! ChirpPulse â€“ Sentiment Enrichment Micro-service
//!
//! This module owns a self-contained, production-grade micro-service that
//! 1. Consumes raw social events from a Kafka topic,
//! 2. Enriches each event with a sentiment score using a hot-swappable strategy,
//! 3. Publishes the enriched payload to a downstream topic,
//! 4. Live-reloads its strategy whenever `sentiment_strategy.yaml` changes on disk.
//!
//! The code demonstrates parallel processing, hot-swapping (Strategy Pattern),
//! resilient streaming (back-pressure aware), and strong observability.
//!
//! NOTE: This is intentionally written as a single file for the coding exercise;
//! in a real codebase these types would be split into focused modules.

use std::{
    fs::File,
    io::Read,
    path::Path,
    sync::Arc,
    time::Duration,
};

use anyhow::{anyhow, Context, Result};
use arc_swap::ArcSwap;
use futures::{StreamExt, TryStreamExt};
use notify::{RecommendedWatcher, RecursiveMode, Watcher};
use once_cell::sync::Lazy;
use rdkafka::{
    consumer::{CommitMode, Consumer, StreamConsumer},
    message::{BorrowedMessage, Headers, OwnedHeaders},
    producer::{FutureProducer, FutureRecord},
    ClientConfig, Message,
};
use serde::{Deserialize, Serialize};
use serde_json::json;
use tokio::{select, sync::mpsc, task, time};
use tracing::{error, info, instrument, warn};

////////////////////////////////////////////////////////////////////////////////
// Domain Types
////////////////////////////////////////////////////////////////////////////////

/// Simplified representation of a raw social event.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct RawEvent {
    pub id: String,
    pub text: String,
    #[serde(flatten)]
    pub extra: serde_json::Value,
}

/// Enriched event including sentiment.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct EnrichedEvent {
    pub id: String,
    pub text: String,
    pub sentiment: SentimentScore,
    #[serde(flatten)]
    pub extra: serde_json::Value,
}

/// Sentiment score returned by strategies.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SentimentScore {
    pub polarity: f32,   // -1.0 negative â€¦ 1.0 positive
    pub magnitude: f32,  // overall emotional strength
}

////////////////////////////////////////////////////////////////////////////////
// Strategy Pattern
////////////////////////////////////////////////////////////////////////////////

/// Behavior contract for a sentiment analysis strategy.
#[async_trait::async_trait]
pub trait SentimentStrategy: Send + Sync + 'static {
    async fn analyze(&self, text: &str) -> Result<SentimentScore>;
}

/// Rule-based fallback strategy.
///
/// NaÃ¯ve but explainable; can run locally without model files.
pub struct RuleBasedStrategy;

#[async_trait::async_trait]
impl SentimentStrategy for RuleBasedStrategy {
    async fn analyze(&self, text: &str) -> Result<SentimentScore> {
        // Very dumb example: positive if the word "love" appears, negative if "hate".
        let text_lower = text.to_lowercase();
        let polarity = match (
            text_lower.contains("love"),
            text_lower.contains("hate"),
        ) {
            (true, false) => 0.6,
            (false, true) => -0.6,
            (true, true) => 0.0,
            _ => 0.0,
        };
        Ok(SentimentScore {
            polarity,
            magnitude: polarity.abs(),
        })
    }
}

/// Placeholder for an ML-based strategy (e.g., Transformer via ONNX).
pub struct MlBasedStrategy {
    /// In real life, this would store the loaded model/graph.
    model_id: String,
}

#[async_trait::async_trait]
impl SentimentStrategy for MlBasedStrategy {
    async fn analyze(&self, text: &str) -> Result<SentimentScore> {
        // Pretend we run an expensive ML inference here.
        let hash = seahash::hash(text.as_bytes());
        let polarity = ((hash % 200) as f32 / 100.0) - 1.0; // range [-1, 1]
        Ok(SentimentScore {
            polarity,
            magnitude: polarity.abs(),
        })
    }
}

////////////////////////////////////////////////////////////////////////////////
// Strategy Registry & Hot-Swap Engine
////////////////////////////////////////////////////////////////////////////////

/// Deserializable configuration describing which strategy to load.
#[derive(Debug, Clone, Deserialize)]
#[serde(tag = "kind", rename_all = "snake_case")]
enum StrategyConfig {
    RuleBased,
    MlBased { model_id: String },
}

impl StrategyConfig {
    fn build(&self) -> Arc<dyn SentimentStrategy> {
        match self {
            StrategyConfig::RuleBased => Arc::new(RuleBasedStrategy),
            StrategyConfig::MlBased { model_id } => Arc::new(MlBasedStrategy {
                model_id: model_id.clone(),
            }),
        }
    }
}

/// Thread-safe holder for the active strategy.
static ACTIVE_STRATEGY: Lazy<ArcSwap<dyn SentimentStrategy>> =
    Lazy::new(|| ArcSwap::from_pointee(RuleBasedStrategy));

/// Load configuration from YAML file (blocking).
fn load_strategy_cfg_from_disk(path: &Path) -> Result<StrategyConfig> {
    let mut file = File::open(path)
        .with_context(|| format!("opening strategy config at {}", path.display()))?;
    let mut buf = String::new();
    file.read_to_string(&mut buf)?;
    let cfg: StrategyConfig = serde_yaml::from_str(&buf)
        .with_context(|| "parsing sentiment_strategy.yaml")?;
    Ok(cfg)
}

/// Spawn a background task that watches the config file and performs
/// hot-swapping via `ArcSwap`.
fn spawn_strategy_hot_reloader(config_path: &'static str) -> Result<()> {
    let path = Path::new(config_path).canonicalize().context("canonicalize")?;
    let (tx, mut rx) = mpsc::unbounded_channel();

    // File watcher runs in blocking threadpool because `notify` is sync.
    let mut watcher: RecommendedWatcher = Watcher::new_immediate(move |res| match res {
        Ok(event) => {
            if tx.send(event).is_err() {
                warn!("strategy reload channel closed");
            }
        }
        Err(e) => error!("watch error: {:?}", e),
    })?;
    watcher.watch(&path, RecursiveMode::NonRecursive)?;

    task::spawn(async move {
        info!("sentiment hot-reloader watching {}", path.display());
        while let Some(_event) = rx.recv().await {
            match load_strategy_cfg_from_disk(&path) {
                Ok(cfg) => {
                    ACTIVE_STRATEGY.store(cfg.build());
                    info!("ðŸ”„ sentiment strategy switched to {:?}", cfg);
                }
                Err(e) => error!("failed to reload strategy cfg: {:#}", e),
            }
        }
    });
    Ok(())
}

////////////////////////////////////////////////////////////////////////////////
// Kafka Streaming
////////////////////////////////////////////////////////////////////////////////

const RAW_TOPIC: &str = "chirppulse.raw.social";
const ENRICHED_TOPIC: &str = "chirppulse.enriched.sentiment";
const GROUP_ID: &str = "sentiment-enrichment-v1";

/// Create a configured Kafka consumer.
fn create_consumer(brokers: &str) -> Result<StreamConsumer> {
    let consumer: StreamConsumer = ClientConfig::new()
        .set("group.id", GROUP_ID)
        .set("bootstrap.servers", brokers)
        .set("enable.auto.commit", "false")
        .set("auto.offset.reset", "earliest")
        .create()
        .context("creating kafka consumer")?;
    consumer.subscribe(&[RAW_TOPIC])?;
    Ok(consumer)
}

/// Create a configured Kafka producer.
fn create_producer(brokers: &str) -> Result<FutureProducer> {
    let producer = ClientConfig::new()
        .set("bootstrap.servers", brokers)
        .create()
        .context("creating kafka producer")?;
    Ok(producer)
}

/// Process a single message: parse, enrich, and publish.
#[instrument(skip(msg, producer))]
async fn handle_message(
    msg: &BorrowedMessage<'_>,
    producer: &FutureProducer,
) -> Result<()> {
    // Parse raw event
    let payload = msg
        .payload_view::<str>()
        .ok_or_else(|| anyhow!("missing payload"))??;
    let raw: RawEvent = serde_json::from_str(payload).context("deserializing RawEvent")?;

    // Run sentiment analysis
    let strategy = ACTIVE_STRATEGY.load();
    let score = strategy.analyze(&raw.text).await?;

    // Build enriched event
    let enriched = EnrichedEvent {
        id: raw.id,
        text: raw.text,
        sentiment: score,
        extra: raw.extra,
    };
    let enriched_json = serde_json::to_string(&enriched)?;

    // Forward downstream
    let record = FutureRecord::to(ENRICHED_TOPIC)
        .key(&enriched.id)
        .payload(&enriched_json)
        .headers(
            OwnedHeaders::new()
                .add("source", "sentiment_service")
                .add("content_type", "application/json"),
        );
    producer
        .send(record, Duration::from_secs(0))
        .await
        .map_err(|(e, _)| anyhow!("failed to send: {:?}", e))?;

    Ok(())
}

////////////////////////////////////////////////////////////////////////////////
// Public Entrypoint
////////////////////////////////////////////////////////////////////////////////

/// Launch the asynchronous sentiment enrichment service.
///
/// This function never returns unless the Tokio runtime shuts down.
pub async fn run(brokers: &str, cfg_path: &'static str) -> Result<()> {
    // Init logging & other global infra.
    tracing_subscriber::fmt::init();

    // Hot-swap engine
    spawn_strategy_hot_reloader(cfg_path)?;

    // Kafka I/O
    let consumer = create_consumer(brokers)?;
    let producer = Arc::new(create_producer(brokers)?);

    // Stream loop
    info!("ðŸš€ sentiment service started; awaiting messages â€¦");
    let mut stream = consumer.stream();
    loop {
        select! {
            maybe_msg = stream.next() => match maybe_msg {
                Some(Ok(msg)) => {
                    let producer = producer.clone();
                    // Process concurrently but limit concurrency to protect resources.
                    task::spawn(async move {
                        if let Err(e) = handle_message(&msg, &producer).await {
                            error!("processing error: {:#}", e);
                        }
                    });
                    // Manual commit (at least once semantics).
                    if let Err(e) = consumer.commit_message(&msg, CommitMode::Async) {
                        error!("commit failed: {:?}", e);
                    }
                }
                Some(Err(e)) => {
                    error!("kafka error: {:?}", e);
                    time::sleep(Duration::from_secs(1)).await;
                }
                None => break, // stream closed
            },
            _ = time::sleep(Duration::from_secs(5)) => {
                // Trivial heartbeat:
                info!("still alive; strategy={}", std::any::type_name::<Arc<dyn SentimentStrategy>>());
            }
        }
    }

    Ok(())
}

////////////////////////////////////////////////////////////////////////////////
// Tests
////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[tokio::test]
    async fn rule_based_analyzer_works() {
        let strat = RuleBasedStrategy;
        let score = strat.analyze("I love Rust â¤ï¸").await.unwrap();
        assert!(score.polarity > 0.0);
    }

    #[tokio::test]
    async fn strategy_load_from_yaml() {
        let yaml = r#"
            kind: ml_based
            model_id: "sentiment-v2"
        "#;
        let cfg: StrategyConfig = serde_yaml::from_str(yaml).unwrap();
        matches!(cfg, StrategyConfig::MlBased { .. });
    }

    #[tokio::test]
    async fn enrichment_roundtrip() {
        let raw = RawEvent {
            id: "123".into(),
            text: "hello world".into(),
            extra: json!({ "lang": "en" }),
        };
        let strat = RuleBasedStrategy;
        let score = strat.analyze(&raw.text).await.unwrap();
        let enriched = EnrichedEvent {
            id: raw.id,
            text: raw.text,
            sentiment: score,
            extra: raw.extra,
        };
        let ser = serde_json::to_string(&enriched).unwrap();
        let de: EnrichedEvent = serde_json::from_str(&ser).unwrap();
        assert_eq!(de.text, "hello world");
    }
}
```