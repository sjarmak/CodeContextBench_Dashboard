```rust
//! src/module_1.rs
//!
//! A self-contained subset of the VisuTility Orchestrator that
//! 1. Implements a modality-aware pre-processing Factory
//! 2. Demonstrates Observer pattern for retraining triggers
//! 3. Provides idiomatic error handling with `thiserror`
//!
//! This module can be compiled independently and integrated into the
//! larger code-base through the public, stable trait interfaces.
//!
//! Dependencies (add to Cargo.toml when integrating):
//! ```toml
//! [dependencies]
//! anyhow      = "1"
//! async-trait = "0.1"
//! chrono      = { version = "0.4", features = ["serde"] }
//! once_cell   = "1"
//! thiserror   = "1"
//! ndarray     = "0.15"
//! serde       = { version = "1", features = ["derive"] }
//! tokio       = { version = "1", features = ["rt-multi-thread", "macros"] }
//! ```
//!
//! # Pattern Coverage
//! • Factory Pattern  – `PreprocessorFactory`
//! • Observer Pattern – `EventBus` + `Subscriber`
//!
//! # Example
//! ```no_run
//! use module_1::{CameraModality, PreprocessorFactory, EventBus, Event};
//! # #[tokio::main]
//! # async fn main() -> anyhow::Result<()> {
//! let rgb_pp = PreprocessorFactory::global().create(&CameraModality::Rgb)?;
//! let frame = module_1::test_util::dummy_frame_rgb();
//! let _clean = rgb_pp.preprocess(frame).await?;
//!
//! // Fire a retraining event that any component can subscribe to
//! EventBus::global().publish(Event::RetrainRequested);
//! # Ok(())
//! # }
//! ```

#![allow(dead_code)] // Kept for illustrative completeness

pub mod prelude {
    //! Convenience re-export so downstream crates can simply `use module_1::prelude::*;`
    pub use super::{
        CameraModality, Event, EventBus, PreprocessOutput, Preprocessor, PreprocessorFactory,
    };
}

use anyhow::Result;
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use ndarray::Array3;
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt::Debug;
use std::sync::{Arc, Mutex};
use thiserror::Error;

///////////////////////////
// Domain-level Data Types
///////////////////////////

/// Represents an incoming raw frame from any vision sensor.
#[derive(Debug, Clone)]
pub struct VideoFrame {
    pub timestamp: DateTime<Utc>,
    /// (channel, height, width) for typical CV parlance
    pub data: Array3<u8>,
    pub width: usize,
    pub height: usize,
}

/// The enum of sensor modalities the system understands.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum CameraModality {
    Rgb,
    Thermal,
    Depth,
    /// Catch-all for anything newer/unknown. Maintains forward compatibility.
    Unknown(String),
}

impl From<&str> for CameraModality {
    fn from(s: &str) -> Self {
        match s.to_ascii_lowercase().as_str() {
            "rgb" => CameraModality::Rgb,
            "thermal" => CameraModality::Thermal,
            "depth" => CameraModality::Depth,
            other => CameraModality::Unknown(other.to_owned()),
        }
    }
}

/// Output after pre-processing complete.
/// In a real system this would include masks, metadata, etc.
#[derive(Debug)]
pub struct PreprocessOutput {
    pub frame: VideoFrame,
    /// Additional artefacts (e.g. histograms, cloud points)
    pub artefacts: HashMap<String, String>,
}

///////////////////////////
// Error Types
///////////////////////////

#[derive(Error, Debug)]
pub enum PreprocessorError {
    #[error("Unsupported modality: {0:?}")]
    UnsupportedModality(CameraModality),
    #[error("Invalid frame data: {0}")]
    InvalidFrame(String),
    #[error("Processing failed: {0}")]
    ProcessingFailure(String),
}

#[derive(Error, Debug)]
pub enum FactoryError {
    #[error("No preprocessor registered for modality: {0:?}")]
    NotRegistered(CameraModality),
    #[error("Registry poisoned")]
    Poisoned,
    #[error(transparent)]
    Other(#[from] anyhow::Error),
}

///////////////////////////
// Preprocessor Trait
///////////////////////////

#[async_trait]
pub trait Preprocessor: Send + Sync + Debug {
    async fn preprocess(&self, frame: VideoFrame) -> Result<PreprocessOutput, PreprocessorError>;
}

/// Type alias for dynamic trait object.
pub type DynPreprocessor = dyn Preprocessor;

///////////////////////////
// Concrete Preprocessors
///////////////////////////

#[derive(Debug, Default)]
pub struct RgbPreprocessor;
#[derive(Debug, Default)]
pub struct ThermalPreprocessor;
#[derive(Debug, Default)]
pub struct DepthPreprocessor;

#[async_trait]
impl Preprocessor for RgbPreprocessor {
    async fn preprocess(&self, mut frame: VideoFrame) -> Result<PreprocessOutput, PreprocessorError> {
        // Example: Simple mean-subtraction normalisation
        let mean_val = 128u8;
        frame.data.mapv_inplace(|px| px.saturating_sub(mean_val));
        Ok(PreprocessOutput { frame, artefacts: HashMap::from([("normalised".into(), "true".into())]) })
    }
}

#[async_trait]
impl Preprocessor for ThermalPreprocessor {
    async fn preprocess(&self, frame: VideoFrame) -> Result<PreprocessOutput, PreprocessorError> {
        // Placeholder: In a real scenario perform temperature calibration
        Ok(PreprocessOutput { frame, artefacts: HashMap::new() })
    }
}

#[async_trait]
impl Preprocessor for DepthPreprocessor {
    async fn preprocess(&self, frame: VideoFrame) -> Result<PreprocessOutput, PreprocessorError> {
        // Placeholder: In a real scenario perform depth noise filtering
        Ok(PreprocessOutput { frame, artefacts: HashMap::new() })
    }
}

///////////////////////////
// Factory Pattern
///////////////////////////

/// Registry-backed factory for dynamic Preprocessor instantiation.
#[derive(Debug, Default)]
pub struct PreprocessorFactory {
    registry: Arc<Mutex<HashMap<CameraModality, Arc<dyn Fn() -> Box<DynPreprocessor> + Send + Sync>>>>,
}

impl PreprocessorFactory {
    /// Returns a lazily-initialised global singleton instance.
    pub fn global() -> &'static Self {
        static INSTANCE: Lazy<PreprocessorFactory> = Lazy::new(|| {
            let factory = PreprocessorFactory::default();
            factory.bootstrap_defaults();
            factory
        });
        &INSTANCE
    }

    /// Register stock processors shipped with the platform.
    fn bootstrap_defaults(&self) {
        // It's safe to unwrap because we're the only writer during bootstrap.
        let mut registry = self.registry.lock().unwrap();

        registry
            .entry(CameraModality::Rgb)
            .or_insert_with(|| Arc::new(|| Box::new(RgbPreprocessor::default())));

        registry
            .entry(CameraModality::Thermal)
            .or_insert_with(|| Arc::new(|| Box::new(ThermalPreprocessor::default())));

        registry
            .entry(CameraModality::Depth)
            .or_insert_with(|| Arc::new(|| Box::new(DepthPreprocessor::default())));
    }

    /// Creates a new processor based on modality.
    pub fn create(&self, modality: &CameraModality) -> Result<Box<DynPreprocessor>, FactoryError> {
        let registry = self.registry.lock().map_err(|_| FactoryError::Poisoned)?;
        registry
            .get(modality)
            .ok_or_else(|| FactoryError::NotRegistered(modality.clone()))
            .map(|maker| maker())
    }

    /// Allows runtime extension for custom modalities (e.g. LiDAR).
    pub fn register<F>(&self, modality: CameraModality, constructor: F) -> Result<(), FactoryError>
    where
        F: Fn() -> Box<DynPreprocessor> + Send + Sync + 'static,
    {
        let mut registry = self.registry.lock().map_err(|_| FactoryError::Poisoned)?;
        registry.insert(modality, Arc::new(constructor));
        Ok(())
    }
}

///////////////////////////
// Observer Pattern
///////////////////////////

/// Events emitted through the system. Extensible for more types.
#[derive(Debug, Clone)]
pub enum Event {
    RetrainRequested,
    HyperParameterUpdated(String),
}

/// Subscribers implement reaction logic for each event.
pub trait Subscriber: Send + Sync {
    fn on_event(&self, event: &Event);
}

/// Non-blocking, multi-subscriber event bus for intra-process usage.
/// (Distributed messaging handled elsewhere in the platform.)
#[derive(Debug, Default)]
pub struct EventBus {
    subs: Arc<Mutex<Vec<Arc<dyn Subscriber>>>>,
}

impl EventBus {
    pub fn global() -> &'static Self {
        static BUS: Lazy<EventBus> = Lazy::new(EventBus::default);
        &BUS
    }

    /// Register a subscriber to receive all future events.
    pub fn subscribe<S: Subscriber + 'static>(&self, sub: S) {
        let mut subs = self.subs.lock().expect("EventBus poisoned");
        subs.push(Arc::new(sub));
    }

    /// Immediately dispatch event to all subscribers.
    pub fn publish(&self, event: Event) {
        let subs = self.subs.lock().expect("EventBus poisoned").clone();
        for sub in subs {
            sub.on_event(&event);
        }
    }
}

///////////////////////////
// Example Subscriber
///////////////////////////

#[derive(Default)]
struct RetrainLogger;

impl Subscriber for RetrainLogger {
    fn on_event(&self, event: &Event) {
        if matches!(event, Event::RetrainRequested) {
            // In production, delegate to structured logging subsystem
            println!("[RetrainLogger] Retrain requested at {}", Utc::now());
        }
    }
}

// Auto-register default subscriber for demonstration.
static _LOGGER_REGISTERED: Lazy<()> = Lazy::new(|| {
    EventBus::global().subscribe(RetrainLogger::default());
});

///////////////////////////
// Test Utilities
///////////////////////////

#[cfg(test)]
mod tests {
    use super::*;
    use ndarray::Array;

    #[tokio::test]
    async fn factory_should_return_rgb_preprocessor() {
        let pp = PreprocessorFactory::global()
            .create(&CameraModality::Rgb)
            .expect("RGB preprocessor missing");
        let frame = crate::module_1::test_util::dummy_frame_rgb();
        let output = pp.preprocess(frame).await.unwrap();
        assert!(!output.artefacts.is_empty());
    }

    #[tokio::test]
    async fn event_bus_should_invoke_subscriber() {
        // Capture stdout for assertion if desired. For brevity we just publish.
        EventBus::global().publish(Event::RetrainRequested);
    }
}

/// Public helpers to be reused by other test modules.
pub mod test_util {
    use super::*;
    use ndarray::Array;

    /// Generates a 224x224 RGB dummy frame.
    pub fn dummy_frame_rgb() -> VideoFrame {
        let height = 224;
        let width = 224;
        let channels = 3;
        VideoFrame {
            timestamp: Utc::now(),
            data: Array::from_shape_simple_fn((channels, height, width), || rand::random::<u8>()),
            width,
            height,
        }
    }
}
```