```rust
//! module_26 – Metric Monitoring, Drift Detection, and Hyper-Parameter Tuning
//!
//! This module demonstrates how VisuTility Orchestrator wires together:
//!   1. An Observer pattern for model-metric broadcasting & drift detection
//!   2. A Strategy pattern for on-demand hyper-parameter tuning
//!
//! The code is **self-contained** and relies only on common ecosystem crates.
//! It can therefore be dropped into an existing crate or used as a reference
//! implementation for similar production systems.

use std::{
    collections::VecDeque,
    fmt,
    sync::{Arc, Mutex},
    time::{Duration, Instant},
};

use anyhow::{Context, Result};
use crossbeam_channel::{unbounded, Receiver, Sender};
use log::{debug, error, info, warn};
use rand::Rng;
use rand_distr::{Distribution, Normal};
use serde::{Deserialize, Serialize};

/// ------------------------------
/// Metric Subject / Event Section
/// ------------------------------

/// A single inference metric payload emitted after a batch or stream window.
///
/// The struct is intentionally lightweight so we can broadcast it with minimal overhead.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricsEvent {
    pub model_name:    String,
    pub model_version: String,
    pub timestamp:     Instant,
    pub accuracy:      f32,
    pub precision:     f32,
    pub recall:        f32,
    /// Any additional, model-specific information.
    pub extras:        serde_json::Value,
}

impl MetricsEvent {
    pub fn new(
        model_name: &str,
        model_version: &str,
        accuracy: f32,
        precision: f32,
        recall: f32,
        extras: serde_json::Value,
    ) -> Self {
        MetricsEvent {
            model_name: model_name.to_owned(),
            model_version: model_version.to_owned(),
            timestamp: Instant::now(),
            accuracy,
            precision,
            recall,
            extras,
        }
    }
}

/// A trait that observers implement in order to receive metric events.
pub trait MetricObserver: Send + Sync + 'static {
    /// Handle an incoming [`MetricsEvent`].
    fn on_event(&mut self, event: &MetricsEvent);
}

/// A subject that owns the list of observers and can broadcast metrics.
///
/// Thread-safe by construction (wrapped by `Arc<Mutex<_>>`), but writes should
/// be infrequent—reading metrics from hot paths is discouraged.
#[derive(Clone, Default)]
pub struct MetricBroadcaster {
    inner: Arc<Mutex<Vec<Box<dyn MetricObserver>>>>,
}

impl MetricBroadcaster {
    pub fn new() -> Self { Self::default() }

    /// Register a new observer.
    ///
    /// # Errors
    /// Returns an error if the lock is poisoned—this is unrecoverable in practice
    /// and signals severe issues in the calling code.
    pub fn register<O>(&self, observer: O) -> Result<()>
    where
        O: MetricObserver,
    {
        let mut observers = self
            .inner
            .lock()
            .map_err(|_| anyhow::anyhow!("metric broadcaster: poisoned mutex"))?;
        observers.push(Box::new(observer));
        Ok(())
    }

    /// Broadcast a metric event to all registered observers.  Failures inside
    /// observers are logged but do not interrupt the broadcast chain.
    pub fn broadcast(&self, event: &MetricsEvent) {
        let lock = match self.inner.lock() {
            Ok(l) => l,
            Err(e) => {
                error!(
                    "metric broadcaster: mutex poisoned during broadcast: {}",
                    e
                );
                return;
            }
        };

        for observer in lock.iter_mut() {
            observer.on_event(event);
        }
    }
}

/// ------------------------------
/// Drift Detection / Retraining
/// ------------------------------

/// When drift is detected, a retrain event is emitted downstream to a
/// `RetrainHandler`.
#[derive(Debug, Clone)]
pub struct RetrainEvent {
    pub model_name:    String,
    pub model_version: String,
    pub observed_drift: f32,
    pub triggered_at:  Instant,
}

/// Objects interested in being notified when a retrain request occurs
/// implement this trait.  It decouples the drift detector from concrete
/// scheduling or job-submission logic.
pub trait RetrainHandler: Send + Sync + 'static {
    fn trigger_retrain(&self, evt: RetrainEvent);
}

/// A simple channel-backed implementation of `RetrainHandler`.
///
/// In production, this could enqueue a job in Kubernetes, Apache Airflow,
/// or a custom orchestrator, but for demonstration purposes we just forward
/// the event over a channel.
pub struct ChannelRetrainHandler {
    tx: Sender<RetrainEvent>,
}

impl ChannelRetrainHandler {
    pub fn new(tx: Sender<RetrainEvent>) -> Self { Self { tx } }
}

impl RetrainHandler for ChannelRetrainHandler {
    fn trigger_retrain(&self, evt: RetrainEvent) {
        if let Err(e) = self.tx.send(evt.clone()) {
            error!("failed to forward retrain event over channel: {}", e);
        } else {
            info!(
                "retrain event dispatched for model {}:{} (drift={:.4})",
                evt.model_name, evt.model_version, evt.observed_drift
            );
        }
    }
}

/// Drift detector implementing `MetricObserver`.
///
/// The detector keeps a sliding window of the latest *N* accuracy values and
/// runs a simple 2-sample z-test to approximate statistical drift.
pub struct SlidingWindowDriftDetector<H>
where
    H: RetrainHandler,
{
    history:            VecDeque<f32>,
    max_window:         usize,
    min_samples:        usize,
    z_threshold:        f32,
    retrain_handler:    H,
    last_retrain_time:  Option<Instant>,
    cooldown:           Duration,
}

impl<H> SlidingWindowDriftDetector<H>
where
    H: RetrainHandler,
{
    pub fn new(retrain_handler: H) -> Self {
        Self {
            history: VecDeque::new(),
            max_window: 500,
            min_samples: 50,
            z_threshold: 3.0,            // ~0.3% two-tailed
            retrain_handler,
            last_retrain_time: None,
            cooldown: Duration::from_secs(60 * 30), // 30-min cool-down
        }
    }

    fn mean_and_std(&self) -> Option<(f32, f32)> {
        if self.history.len() < self.min_samples {
            return None;
        }

        let mean = self.history.iter().copied().sum::<f32>() / self.history.len() as f32;
        let var = self
            .history
            .iter()
            .map(|x| (*x - mean).powi(2))
            .sum::<f32>()
            / (self.history.len() as f32 - 1.0);
        Some((mean, var.sqrt()))
    }
}

impl<H> MetricObserver for SlidingWindowDriftDetector<H>
where
    H: RetrainHandler,
{
    fn on_event(&mut self, event: &MetricsEvent) {
        // Maintain sliding window.
        self.history.push_back(event.accuracy);
        if self.history.len() > self.max_window {
            self.history.pop_front();
        }

        let (mean, std) = match self.mean_and_std() {
            Some(v) => v,
            None => return, // Not enough data yet.
        };

        // Z-score of most recent accuracy vs. historical mean.
        let latest = *self.history.back().unwrap();
        let z_score = if std > f32::EPSILON {
            (latest - mean) / std
        } else {
            0.0
        };

        debug!(
            "drift detector – model={}:{}, latest_acc={:.4}, mean={:.4}, z={:.4}",
            event.model_name, event.model_version, latest, mean, z_score
        );

        if z_score.abs() > self.z_threshold {
            let now = Instant::now();
            if self
                .last_retrain_time
                .map(|t| now.duration_since(t) < self.cooldown)
                .unwrap_or(false)
            {
                warn!(
                    "drift detected for model {}:{}, but still in cooldown; skipping retrain trigger",
                    event.model_name, event.model_version
                );
                return;
            }

            let evt = RetrainEvent {
                model_name: event.model_name.clone(),
                model_version: event.model_version.clone(),
                observed_drift: z_score,
                triggered_at: now,
            };
            self.retrain_handler.trigger_retrain(evt);
            self.last_retrain_time = Some(now);
        }
    }
}

/// ------------------------------
/// Hyper-parameter Tuning Section
/// ------------------------------

/// The abstract tuning interface.
pub trait TuningStrategy: Send + Sync + fmt::Debug {
    /// Perform one tuning iteration returning the next parameter set.
    fn next_params(&mut self) -> Result<serde_json::Value>;
}

/// Random search strategy across a bounded parameter space.
///
/// This demonstrates a minimal yet practical tuning algorithm.  It can be
/// swapped at runtime because we communicate only via the `TuningStrategy`
/// trait.
#[derive(Debug)]
pub struct RandomSearchTuner {
    rng:          rand::rngs::ThreadRng,
    search_space: serde_json::Value,
}

impl RandomSearchTuner {
    pub fn new(search_space: serde_json::Value) -> Self {
        Self {
            rng: rand::thread_rng(),
            search_space,
        }
    }

    fn sample_numeric(&mut self, min: f64, max: f64) -> f64 {
        self.rng.gen_range(min..max)
    }
}

impl TuningStrategy for RandomSearchTuner {
    fn next_params(&mut self) -> Result<serde_json::Value> {
        // For demonstration we assume a flat search space containing numeric
        // bounds `{ "lr": [0.0001, 0.1], "dropout": [0.0, 0.5] }`.
        let mut params = serde_json::Map::new();
        let space = self
            .search_space
            .as_object()
            .context("search space must be a JSON object")?;

        for (key, val) in space.iter() {
            let arr = val
                .as_array()
                .context("search space values must be arrays")?;
            if arr.len() != 2 {
                anyhow::bail!("search space range for `{}` must contain 2 numbers", key);
            }
            let min = arr[0]
                .as_f64()
                .context("range entry must be numeric (f64)")?;
            let max = arr[1]
                .as_f64()
                .context("range entry must be numeric (f64)")?;

            params.insert(
                key.clone(),
                serde_json::Value::Number(
                    serde_json::Number::from_f64(self.sample_numeric(min, max))
                        .expect("f64 into JSON number"),
                ),
            );
        }

        Ok(serde_json::Value::Object(params))
    }
}

/// ------------------------------
/// Example Wire-Up
/// ------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;

    #[test]
    fn drift_detection_and_tuning_demo() -> Result<()> {
        // -------------- Metric broadcaster infrastructure --------------
        let broadcaster = MetricBroadcaster::new();

        // Channel for simulated retrain events.
        let (tx, rx): (Sender<RetrainEvent>, Receiver<RetrainEvent>) = unbounded();
        let retrain_handler = ChannelRetrainHandler::new(tx);

        // Sliding window detector registered as observer.
        broadcaster.register(SlidingWindowDriftDetector::new(retrain_handler))?;

        // -------------- Simulate metric stream --------------
        let normal = Normal::new(0.93, 0.01).unwrap();
        let mut rng = rand::thread_rng();

        // Most data points are from the "normal" distribution
        for _ in 0..600 {
            let acc = normal.sample(&mut rng) as f32;
            let ev = MetricsEvent::new(
                "object-detector",
                "v1.2.0",
                acc,
                0.9,
                0.88,
                serde_json::json!({}),
            );
            broadcaster.broadcast(&ev);
        }

        // Insert drift by lowering accuracy dramatically
        for _ in 0..50 {
            let ev = MetricsEvent::new(
                "object-detector",
                "v1.2.0",
                0.65,
                0.7,
                0.6,
                serde_json::json!({}),
            );
            broadcaster.broadcast(&ev);
        }

        // -------------- Assert retrain event was fired --------------
        let evt = rx
            .recv_timeout(Duration::from_secs(2))
            .context("expected retrain event")?;
        assert_eq!(evt.model_name, "object-detector");
        println!("retrain event: {:?}", evt);

        // -------------- Hyper-parameter tuning strategy --------------
        let mut tuner = RandomSearchTuner::new(serde_json::json!({
            "lr": [0.00001, 0.01],
            "dropout": [0.0, 0.5]
        }));

        for _ in 0..3 {
            let params = tuner.next_params()?;
            println!("sampled params: {}", params);
        }

        Ok(())
    }
}
```