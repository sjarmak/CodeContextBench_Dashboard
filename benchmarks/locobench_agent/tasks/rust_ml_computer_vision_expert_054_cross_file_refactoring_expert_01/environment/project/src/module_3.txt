```rust
//! VisuTility Orchestrator â€“ Model Registry & Observer Utilities
//! --------------------------------------------------------------
//! This module implements a production-ready in-memory model registry and an
//! Observer Pattern that allows external components (e.g., monitoring or
//! retraining daemons) to subscribe to model lifecycle events.
//!
//! The registry stores all model metadata in a thread-safe fashion, enforces
//! semantic versioning, and exposes ergonomically designed APIs for typical
//! Model-Ops workflows (register, promote, deprecate, fetch).
//!
//! Dependencies (add to Cargo.toml):
//! semver   = "1"
//! chrono   = "0.4"
//! sha2     = "0.10"
//! thiserror = "1"
//! parking_lot = "0.12"

use chrono::{DateTime, Utc};
use semver::Version;
use sha2::{Digest, Sha256};

use parking_lot::RwLock;
use std::{collections::HashMap, fs::File, io::Read, path::PathBuf, sync::Arc};

/// Domain errors returned by the registry.
#[derive(thiserror::Error, Debug)]
pub enum RegistryError {
    #[error("model `{0}` not found")]
    ModelNotFound(String),
    #[error("version `{1}` for model `{0}` not found")]
    VersionNotFound(String, Version),
    #[error("attempted to register an existing version `{1}` for model `{0}`")]
    DuplicateVersion(String, Version),
    #[error("I/O error while processing artifact: {0}")]
    Io(#[from] std::io::Error),
}

/// Metadata describing a single model artifact.
///
/// NOTE: In production this could contain arbitrary extra fields like
/// hyperparameters, training dataset signatures, and lineage.
#[derive(Clone, Debug)]
pub struct ModelEntry {
    pub version: Version,
    pub artifact_path: PathBuf,
    pub checksum: String,
    pub created_at: DateTime<Utc>,
    pub deprecated: bool,
}

impl ModelEntry {
    /// Compute SHA256 checksum for a file on disk.
    fn compute_checksum(path: &PathBuf) -> Result<String, RegistryError> {
        let mut file = File::open(path)?;
        let mut hasher = Sha256::new();
        let mut buffer = [0u8; 32 * 1024]; // 32 KB chunk

        loop {
            let read_bytes = file.read(&mut buffer)?;
            if read_bytes == 0 {
                break;
            }
            hasher.update(&buffer[..read_bytes]);
        }
        Ok(format!("{:x}", hasher.finalize()))
    }

    pub fn new(version: Version, artifact_path: PathBuf) -> Result<Self, RegistryError> {
        let checksum = Self::compute_checksum(&artifact_path)?;
        Ok(Self {
            version,
            artifact_path,
            checksum,
            created_at: Utc::now(),
            deprecated: false,
        })
    }
}

/// Event types emitted by the registry.
#[derive(Clone, Debug)]
pub enum RegistryEvent {
    Registered {
        model: String,
        entry: ModelEntry,
    },
    Deprecated {
        model: String,
        version: Version,
    },
}

/// Observer trait for model registry events.
pub trait RegistrySubscriber: Send + Sync + 'static {
    fn on_event(&self, event: &RegistryEvent);
}

/// Trait defining the public API of a model registry.
pub trait ModelRegistry: Send + Sync {
    fn register(
        &self,
        model_name: &str,
        entry: ModelEntry,
    ) -> Result<(), RegistryError>;

    fn latest(
        &self,
        model_name: &str,
        include_deprecated: bool,
    ) -> Result<ModelEntry, RegistryError>;

    fn get(
        &self,
        model_name: &str,
        version: &Version,
    ) -> Result<ModelEntry, RegistryError>;

    fn deprecate(
        &self,
        model_name: &str,
        version: &Version,
    ) -> Result<(), RegistryError>;

    fn subscribe(&self, subscriber: Arc<dyn RegistrySubscriber>);
}

/// A thread-safe, in-memory implementation of `ModelRegistry`.
///
/// For production, swap this with a persistent backend (PostgreSQL, S3, etc.).
#[derive(Default)]
pub struct InMemoryModelRegistry {
    store: RwLock<HashMap<String, Vec<ModelEntry>>>,
    subscribers: RwLock<Vec<Arc<dyn RegistrySubscriber>>>,
}

impl InMemoryModelRegistry {
    pub fn new() -> Self {
        Self {
            store: RwLock::new(HashMap::new()),
            subscribers: RwLock::new(Vec::new()),
        }
    }

    fn notify(&self, event: RegistryEvent) {
        for subscriber in self.subscribers.read().iter() {
            subscriber.on_event(&event);
        }
    }

    fn ensure_model_exists<'a>(
        &'a self,
        model_name: &str,
    ) -> Result<parking_lot::RwLockReadGuard<'a, Vec<ModelEntry>>, RegistryError> {
        RwLock::try_read(
            self.store
                .read()
                .get(model_name)
                .ok_or_else(|| RegistryError::ModelNotFound(model_name.into()))?,
        )
        .map_err(|_| RegistryError::ModelNotFound(model_name.into()))
    }
}

impl ModelRegistry for InMemoryModelRegistry {
    fn register(
        &self,
        model_name: &str,
        entry: ModelEntry,
    ) -> Result<(), RegistryError> {
        let mut map = self.store.write();
        let versions = map.entry(model_name.into()).or_default();

        if versions
            .iter()
            .any(|e| e.version == entry.version && !e.deprecated)
        {
            return Err(RegistryError::DuplicateVersion(
                model_name.into(),
                entry.version.clone(),
            ));
        }

        versions.push(entry.clone());
        self.notify(RegistryEvent::Registered {
            model: model_name.into(),
            entry,
        });

        Ok(())
    }

    fn latest(
        &self,
        model_name: &str,
        include_deprecated: bool,
    ) -> Result<ModelEntry, RegistryError> {
        let versions = self.ensure_model_exists(model_name)?;
        versions
            .iter()
            .filter(|e| include_deprecated || !e.deprecated)
            .max_by(|a, b| a.version.cmp(&b.version))
            .cloned()
            .ok_or_else(|| RegistryError::ModelNotFound(model_name.into()))
    }

    fn get(
        &self,
        model_name: &str,
        version: &Version,
    ) -> Result<ModelEntry, RegistryError> {
        let versions = self.ensure_model_exists(model_name)?;
        versions
            .iter()
            .find(|e| &e.version == version)
            .cloned()
            .ok_or_else(|| {
                RegistryError::VersionNotFound(model_name.into(), version.clone())
            })
    }

    fn deprecate(
        &self,
        model_name: &str,
        version: &Version,
    ) -> Result<(), RegistryError> {
        let mut map = self.store.write();
        let versions = map
            .get_mut(model_name)
            .ok_or_else(|| RegistryError::ModelNotFound(model_name.into()))?;

        let entry = versions
            .iter_mut()
            .find(|e| &e.version == version)
            .ok_or_else(|| {
                RegistryError::VersionNotFound(model_name.into(), version.clone())
            })?;

        entry.deprecated = true;
        self.notify(RegistryEvent::Deprecated {
            model: model_name.into(),
            version: version.clone(),
        });
        Ok(())
    }

    fn subscribe(&self, subscriber: Arc<dyn RegistrySubscriber>) {
        self.subscribers.write().push(subscriber)
    }
}

/// ---------------------------------------------------------------------------
/// Example Subscriber: Auto-Retraining Trigger
/// ---------------------------------------------------------------------------

/// Automatically triggers retraining when a model is deprecated, ensuring that
/// mission-critical endpoints always serve a non-deprecated model.
pub struct RetrainingDaemon;

impl RetrainingDaemon {
    pub fn new() -> Self {
        Self
    }

    fn spawn_retraining_job(&self, model: &str) {
        // In production, delegate to an async job queue / Kubernetes CronJob.
        tracing::info!(
            "Spawning retraining job for `{}` due to model deprecation",
            model
        );
    }
}

impl RegistrySubscriber for RetrainingDaemon {
    fn on_event(&self, event: &RegistryEvent) {
        match event {
            RegistryEvent::Deprecated { model, .. } => {
                self.spawn_retraining_job(model);
            }
            _ => { /* ignore */ }
        }
    }
}

/// ---------------------------------------------------------------------------
/// Tests (run with `cargo test --all`).
/// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    /// Helper to create a temp file containing `data`.
    fn tmp_file(name: &str, data: &[u8]) -> PathBuf {
        let dir = tempfile::tempdir().unwrap();
        let path = dir.path().join(name);
        fs::write(&path, data).unwrap();
        path
    }

    #[test]
    fn test_register_and_fetch() {
        let registry = InMemoryModelRegistry::new();
        let artifact = tmp_file("model.bin", b"dummy_model_bytes");
        let entry = ModelEntry::new(Version::parse("0.1.0").unwrap(), artifact).unwrap();

        registry.register("object_detector", entry.clone()).unwrap();
        let latest = registry.latest("object_detector", false).unwrap();
        assert_eq!(latest.version, entry.version);
    }

    #[test]
    fn test_deprecate_and_subscribe() {
        let registry = Arc::new(InMemoryModelRegistry::new());
        let daemon = Arc::new(RetrainingDaemon::new());
        registry.subscribe(daemon);

        let artifact = tmp_file("model.bin", b"v1");
        registry
            .register(
                "lane_detection",
                ModelEntry::new(Version::parse("1.0.0").unwrap(), artifact).unwrap(),
            )
            .unwrap();

        registry
            .deprecate("lane_detection", &Version::parse("1.0.0").unwrap())
            .unwrap();
    }
}
```