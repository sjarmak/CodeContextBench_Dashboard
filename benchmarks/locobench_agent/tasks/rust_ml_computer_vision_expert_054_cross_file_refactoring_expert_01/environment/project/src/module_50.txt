```rust
//! src/module_50.rs
//!
//! Model Registry implementation used by the VisuTility Orchestrator.
//! ------------------------------------------------------------------
//! This module provides a production-ready, in-memory model registry
//! tailored for computer-vision workloads.  Although the backing store is
//! memory-based for simplicity, the trait design allows alternative
//! persistent implementations (e.g., Postgres, S3, Redis) to be swapped in
//! without affecting downstream components.
//!
//! Architectural patterns illustrated:
//!   • Factory Pattern – via `ModelArtifactFactory`
//!   • Observer Pattern – consumers can subscribe to registry events
//!   • Strategy Pattern – pluggable version–resolution strategies
//!
//! Dependencies (add to Cargo.toml):
//!   anyhow        = "1"
//!   async-trait   = "0.1"
//!   chrono        = { version = "0.4", features = ["serde"] }
//!   semver        = "1"
//!   serde         = { version = "1.0", features = ["derive"] }
//!   tokio         = { version = "1", features = ["sync", "macros", "rt-multi-thread"] }
//!   uuid          = { version = "1", features = ["serde", "v4"] }

use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::Arc;

use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use semver::Version;
use serde::{Deserialize, Serialize};
use tokio::sync::{broadcast, RwLock};
use uuid::Uuid;

/// Event types emitted by the Model Registry.
///
/// Clients can subscribe to these events to trigger downstream actions,
/// such as cache invalidation, warm-start deployments, or model monitoring.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RegistryEvent {
    ModelAdded(ModelMetadata),
    ModelRemoved(Uuid),
    ModelUpdated(ModelMetadata),
}

/// Metadata describing a stored model artifact.
///
/// The struct is intentionally lightweight—heavyweight fields like
/// training metrics or confusion matrices are stored externally and
/// referenced through `artifact_path`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelMetadata {
    pub id: Uuid,
    pub name: String,
    pub version: Version,
    pub created_at: DateTime<Utc>,
    pub artifact_path: PathBuf,
    /// Optional map of metric key → value captured at registration time.
    pub metrics: HashMap<String, f64>,
}

impl ModelMetadata {
    /// Helper constructor that fills `created_at` automatically.
    pub fn new<N: Into<String>, P: Into<PathBuf>>(
        name: N,
        version: Version,
        artifact_path: P,
        metrics: HashMap<String, f64>,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            name: name.into(),
            version,
            created_at: Utc::now(),
            artifact_path: artifact_path.into(),
            metrics,
        }
    }
}

/// Strategy trait for resolving which model version should be considered
/// the “latest” when multiple are available (e.g., semantic versioning vs.
/// highest accuracy).
#[async_trait]
pub trait VersionResolutionStrategy: Send + Sync {
    async fn select<'a>(&self, candidates: &'a [ModelMetadata]) -> Option<&'a ModelMetadata>;
}

/// Default strategy – pick the highest semantic version.
pub struct HighestSemverStrategy;

#[async_trait]
impl VersionResolutionStrategy for HighestSemverStrategy {
    async fn select<'a>(&self, candidates: &'a [ModelMetadata]) -> Option<&'a ModelMetadata> {
        candidates
            .iter()
            .max_by(|a, b| a.version.cmp(&b.version))
    }
}

/// Interface for a Model Registry.
///
/// Methods are async because real-world implementations are likely to
/// perform I/O (databases, object stores, etc.).  Using `async_trait`
/// removes boilerplate from the trait definition.
#[async_trait]
pub trait ModelRegistry: Send + Sync {
    /// Register a new model artifact.
    async fn add_model(&self, metadata: ModelMetadata) -> Result<()>;

    /// Remove a model by its unique identifier.
    async fn remove_model(&self, id: Uuid) -> Result<()>;

    /// Retrieve metadata for a specific model version.
    async fn get_model(
        &self,
        name: &str,
        version: &Version,
    ) -> Result<Option<ModelMetadata>>;

    /// List all models with the given name.
    async fn list_models(&self, name: &str) -> Result<Vec<ModelMetadata>>;

    /// Get the “latest” model, according to the provided strategy.
    async fn latest_model(
        &self,
        name: &str,
        strategy: &dyn VersionResolutionStrategy,
    ) -> Result<Option<ModelMetadata>>;

    /// Subscribe to Registry events.
    ///
    /// Returns a broadcast receiver that streams `RegistryEvent`s.
    fn subscribe(&self) -> broadcast::Receiver<RegistryEvent>;
}

/// In-memory implementation primarily for testing or small-scale
/// single-node deployments.  Thread-safe via Tokio’s `RwLock`.
#[derive(Debug, Default)]
pub struct InMemoryModelRegistry {
    store: RwLock<HashMap<String, Vec<ModelMetadata>>>,
    tx: broadcast::Sender<RegistryEvent>,
}

impl InMemoryModelRegistry {
    pub fn new(buffer: usize) -> Self {
        let (tx, _) = broadcast::channel(buffer);
        Self {
            store: RwLock::new(HashMap::new()),
            tx,
        }
    }

    fn notify(&self, event: RegistryEvent) {
        // Ignore send errors if there are no active subscribers.
        let _ = self.tx.send(event);
    }
}

#[async_trait]
impl ModelRegistry for InMemoryModelRegistry {
    async fn add_model(&self, metadata: ModelMetadata) -> Result<()> {
        // Validate that artifact exists on disk.
        if !metadata.artifact_path.exists() {
            return Err(anyhow!(
                "Artifact path {} does not exist",
                metadata.artifact_path.display()
            ));
        }

        let mut guard = self.store.write().await;
        let entry = guard.entry(metadata.name.clone()).or_default();

        // Prevent duplicate semantic versions.
        if entry
            .iter()
            .any(|m| m.version == metadata.version)
        {
            return Err(anyhow!(
                "Model {} version {} already exists",
                metadata.name,
                metadata.version
            ));
        }

        entry.push(metadata.clone());
        drop(guard); // release write lock before broadcasting
        self.notify(RegistryEvent::ModelAdded(metadata));
        Ok(())
    }

    async fn remove_model(&self, id: Uuid) -> Result<()> {
        let mut guard = self.store.write().await;
        let mut removed: Option<ModelMetadata> = None;

        for models in guard.values_mut() {
            if let Some(pos) = models.iter().position(|m| m.id == id) {
                removed = Some(models.remove(pos));
                break;
            }
        }

        match removed {
            Some(meta) => {
                drop(guard);
                self.notify(RegistryEvent::ModelRemoved(meta.id));
                Ok(())
            }
            None => Err(anyhow!("Model id {} not found", id)),
        }
    }

    async fn get_model(
        &self,
        name: &str,
        version: &Version,
    ) -> Result<Option<ModelMetadata>> {
        let guard = self.store.read().await;
        Ok(guard
            .get(name)
            .and_then(|list| {
                list.iter()
                    .find(|m| &m.version == version)
                    .cloned()
            }))
    }

    async fn list_models(&self, name: &str) -> Result<Vec<ModelMetadata>> {
        let guard = self.store.read().await;
        Ok(guard
            .get(name)
            .map(|v| v.clone())
            .unwrap_or_default())
    }

    async fn latest_model(
        &self,
        name: &str,
        strategy: &dyn VersionResolutionStrategy,
    ) -> Result<Option<ModelMetadata>> {
        let guard = self.store.read().await;
        let list = guard.get(name).cloned().unwrap_or_default();
        Ok(strategy.select(&list).cloned())
    }

    fn subscribe(&self) -> broadcast::Receiver<RegistryEvent> {
        self.tx.subscribe()
    }
}

/// Factory for model artifacts – resolves the concrete registry backend
/// according to configuration (env variables, command-line flags, etc.).
///
/// For demonstration, only an in-memory option is provided.
pub enum RegistryBackend {
    InMemory,
    // Postgres, S3, Redis, etc. could be added here.
}

pub struct ModelArtifactFactory;

impl ModelArtifactFactory {
    pub fn build(backend: RegistryBackend) -> Arc<dyn ModelRegistry> {
        match backend {
            RegistryBackend::InMemory => Arc::new(InMemoryModelRegistry::new(1024)),
        }
    }
}

/// Example usage.
/// --------------
/// ```no_run
/// use visu_tility_orchestrator::module_50::{
///     ModelMetadata, ModelArtifactFactory, RegistryBackend, HighestSemverStrategy,
/// };
/// use semver::Version;
///
/// #[tokio::main]
/// async fn main() -> anyhow::Result<()> {
///     let registry = ModelArtifactFactory::build(RegistryBackend::InMemory);
///
///     let metadata = ModelMetadata::new(
///         "object_detector",
///         Version::new(1, 0, 0),
///         "/models/object_detector_v1.onnx",
///         Default::default(),
///     );
///
///     registry.add_model(metadata).await?;
///
///     let latest = registry
///         .latest_model("object_detector", &HighestSemverStrategy)
///         .await?
///         .expect("model not found");
///
///     println!("Latest model: {:?}", latest);
///     Ok(())
/// }
/// ```
```