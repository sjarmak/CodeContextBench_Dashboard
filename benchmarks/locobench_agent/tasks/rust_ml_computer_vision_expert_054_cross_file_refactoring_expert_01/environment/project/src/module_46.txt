```rust
//! src/module_46.rs
//!
//! Re-usable, production-grade Model-Monitoring sub-module for the VisuTility
//! Orchestrator.  Implements an Observer which listens to real-time prediction
//! events and maintains rolling latency / accuracy metrics per model version.
//!
//! Patterns employed:
//!   • Observer Pattern – decouples metric collection from inference runtime
//!   • Strategy Pattern – pluggable aggregation strategy (EMA by default)
//!   • Thread-safe, async-ready design using crossbeam channels
//!
//! The module purposely avoids any heavy dependencies (e.g. Prometheus client)
//! so it can be embedded in both embedded deployments and large-scale
//! micro-service topologies.  A thin facade can be written elsewhere to export
//! the metrics to Prometheus/OpenTelemetry, Kafka, or any custom sink.

use std::{
    collections::HashMap,
    fmt,
    hash::{Hash, Hasher},
    sync::{Arc, Mutex, RwLock},
    thread,
    time::{Duration, Instant},
};

use chrono::{DateTime, Utc};
use crossbeam_channel::{select, unbounded, Receiver, Sender};
use serde::{Deserialize, Serialize};
use thiserror::Error;

/// Results anywhere in the monitoring pipeline.
pub type Result<T> = std::result::Result<T, MonitorError>;

/// Unified error type for the module.
#[derive(Debug, Error)]
pub enum MonitorError {
    #[error("channel send failed: {0}")]
    SendError(String),
    #[error("channel receive failed: {0}")]
    RecvError(String),
    #[error("metrics not found for model: {0}")]
    MetricsNotFound(String),
    #[error("internal concurrency error")]
    Concurrency,
}

/// Unique identifier for a model (name + semantic version).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelId {
    pub name:    String,
    pub version: String,
}

impl fmt::Display for ModelId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", self.name, self.version)
    }
}

impl Hash for ModelId {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.name.hash(state);
        self.version.hash(state);
    }
}

impl PartialEq for ModelId {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name && self.version == other.version
    }
}

impl Eq for ModelId {}

/// Event sent from inference engines.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Event {
    Prediction(PredictionEvent),
    Heartbeat, // Reserved for future use (e.g., liveness / health-checks).
    Shutdown,
}

/// Detailed prediction data captured after each inference.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PredictionEvent {
    pub model_id:         ModelId,
    pub inference_ms:     u64,
    pub prediction:       serde_json::Value,
    pub ground_truth:     Option<serde_json::Value>,
    pub timestamp_utc:    DateTime<Utc>,
}

impl PredictionEvent {
    pub fn latency(&self) -> f64 {
        self.inference_ms as f64
    }

    /// Returns 1.0 if prediction==ground_truth else 0.0, or None when GT
    /// unavailable.
    pub fn accuracy_sample(&self) -> Option<f64> {
        self.ground_truth
            .as_ref()
            .map(|gt| if *gt == self.prediction { 1.0 } else { 0.0 })
    }
}

/* ------------------------------------------------------------------------ */
/* Observer Pattern Interfaces                                              */
/* ------------------------------------------------------------------------ */

/// Consumers interested in `Event`s implement this trait.
pub trait Observer: Send + Sync + 'static {
    fn on_event(&self, event: &Event);
}

/// Non-blocking publish-and-subscribe event-bus.
#[derive(Clone)]
pub struct EventBus {
    sender: Sender<Event>,
}

impl EventBus {
    /// Creates a new bus and begins background fan-out thread.
    pub fn new() -> Self {
        let (tx, rx) = unbounded::<Event>();
        let observers: Arc<RwLock<Vec<Arc<dyn Observer>>>> =
            Arc::new(RwLock::new(Vec::new()));

        // Fan-out thread
        {
            let observers = observers.clone();
            thread::Builder::new()
                .name("monitoring_event_bus".into())
                .spawn(move || {
                    loop {
                        match rx.recv() {
                            Ok(event) => {
                                if matches!(event, Event::Shutdown) {
                                    break;
                                }
                                for obs in observers.read().unwrap().iter() {
                                    obs.on_event(&event);
                                }
                            }
                            Err(err) => {
                                eprintln!("[EventBus] Receiver error: {err}");
                                break;
                            }
                        }
                    }
                })
                .expect("failed to spawn event-bus thread");
        }

        Self { sender: tx }
    }

    /// Register an observer.  Thread-safe.
    pub fn register<O>(&self, observer: O)
    where
        O: Observer,
    {
        // NOTE: We rely on the fact that each EventBus owns its own shared vec.
        // This simplification avoids needing a public handle to observers.
        let obs_arc: Arc<dyn Observer> = Arc::new(observer);
        // SAFETY: This unwrap is safe – poisoned lock => unrecoverable anyhow.
        let vec = self.observers();
        vec.write().unwrap().push(obs_arc);
    }

    /// Deregister by type name; convenient for tests.
    pub fn deregister_by_type<T>(&self)
    where
        T: Observer + 'static,
    {
        let vec = self.observers();
        vec.write()
            .unwrap()
            .retain(|obs| obs.type_id() != std::any::TypeId::of::<T>());
    }

    /// Send an event to all observers (non-blocking for callers).
    pub fn emit(&self, event: Event) -> Result<()> {
        self.sender
            .send(event.clone())
            .map_err(|e| MonitorError::SendError(e.to_string()))
    }

    fn observers(&self) -> Arc<RwLock<Vec<Arc<dyn Observer>>>> {
        // Internal helper to fetch the observers vector created in `new`.
        // We abuse the fact that the fan-out thread captured the Arc, so we
        // reach back using the channel's internal pointer.  For a production
        // system, you'd store the Arc directly – omitted for brevity.
        //
        // The only safe way to do this without unsafe code is to leak the
        // Arc inside a once-cell static.  For simplicity, we instead store the
        // Arc within the sender as an "internal" attribute via extensions.
        thread_local! {
            static OBS: std::cell::RefCell<Option<Arc<RwLock<Vec<Arc<dyn Observer>>>>>> =
                std::cell::RefCell::new(None);
        }
        OBS.with(|cell| cell.borrow().clone()).expect(
            "EventBus observers not initialized – use EventBus::new to create it",
        )
    }
}

/* ------------------------------------------------------------------------ */
/* Metrics Aggregation Strategy                                             */
/* ------------------------------------------------------------------------ */

/// Aggregation behaviour; can switch out at runtime (Strategy Pattern).
pub trait Aggregator: Send + Sync {
    fn update(&mut self, sample: f64);
    fn value(&self) -> f64;
}

/// Exponential Moving Average implementation.
#[derive(Debug, Clone)]
pub struct Ema {
    pub alpha:  f64,
    current:    Option<f64>,
}

impl Ema {
    pub fn new(alpha: f64) -> Self {
        assert!((0.0..=1.0).contains(&alpha), "alpha must be ∈ [0,1]");
        Self {
            alpha,
            current: None,
        }
    }
}

impl Aggregator for Ema {
    fn update(&mut self, sample: f64) {
        self.current = Some(
            match self.current {
                Some(prev) => self.alpha * sample + (1.0 - self.alpha) * prev,
                None => sample,
            },
        );
    }

    fn value(&self) -> f64 {
        self.current.unwrap_or(0.0)
    }
}

/// Rolling metrics maintained for a specific model version.
#[derive(Debug)]
struct ModelMetrics {
    latency_ema:       Box<dyn Aggregator>,
    accuracy_ema:      Box<dyn Aggregator>,
    last_updated:      Instant,
    total_samples:     u64,
}

impl ModelMetrics {
    fn new(alpha: f64) -> Self {
        Self {
            latency_ema:  Box::new(Ema::new(alpha)),
            accuracy_ema: Box::new(Ema::new(alpha)),
            last_updated: Instant::now(),
            total_samples: 0,
        }
    }

    fn ingest(&mut self, evt: &PredictionEvent) {
        self.latency_ema.update(evt.latency());
        if let Some(acc_sample) = evt.accuracy_sample() {
            self.accuracy_ema.update(acc_sample);
        }
        self.last_updated = Instant::now();
        self.total_samples += 1;
    }

    fn export(&self) -> ExportedMetrics {
        ExportedMetrics {
            latency_ms_ema:  self.latency_ema.value(),
            accuracy_ema:    self.accuracy_ema.value(),
            total_samples:   self.total_samples,
            last_updated:    self.last_updated,
        }
    }
}

/// Serializable snapshot of metrics.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExportedMetrics {
    pub latency_ms_ema: f64,
    pub accuracy_ema:   f64,
    pub total_samples:  u64,
    #[serde(with = "humantime_serde")]
    pub last_updated:   Instant,
}

/* ------------------------------------------------------------------------ */
/* ModelMonitor – the Observer implementation                               */
/* ------------------------------------------------------------------------ */

/// Centralized, thread-safe monitor for all models.
pub struct ModelMonitor {
    metrics:  Arc<Mutex<HashMap<ModelId, ModelMetrics>>>,
    alpha:    f64,
}

impl ModelMonitor {
    pub fn new(alpha: f64) -> Self {
        Self {
            metrics: Arc::new(Mutex::new(HashMap::new())),
            alpha,
        }
    }

    /// Returns a snapshot of current metrics for the requested model.
    pub fn get_metrics(&self, id: &ModelId) -> Result<ExportedMetrics> {
        let map = self.metrics.lock().map_err(|_| MonitorError::Concurrency)?;
        map.get(id)
            .map(|m| m.export())
            .ok_or_else(|| MonitorError::MetricsNotFound(id.to_string()))
    }

    /// Helper: returns all snapshots – useful for bulk export.
    pub fn all_metrics(&self) -> Result<HashMap<ModelId, ExportedMetrics>> {
        let map = self.metrics.lock().map_err(|_| MonitorError::Concurrency)?;
        Ok(map.iter().map(|(k, v)| (k.clone(), v.export())).collect())
    }
}

impl Observer for ModelMonitor {
    fn on_event(&self, event: &Event) {
        match event {
            Event::Prediction(pred_evt) => {
                let mut map =
                    self.metrics.lock().expect("monitor mutex poisoned");
                let entry =
                    map.entry(pred_evt.model_id.clone())
                        .or_insert_with(|| ModelMetrics::new(self.alpha));
                entry.ingest(pred_evt);
            }
            _ => {}
        }
    }
}

/* ------------------------------------------------------------------------ */
/* Convenience helper for inference runtime                                 */
/* ------------------------------------------------------------------------ */

/// Thin facade so inference code doesn't need to depend on channel crates.
#[derive(Clone)]
pub struct MonitoringHandle {
    pub(crate) bus: EventBus,
}

impl MonitoringHandle {
    /// Emit a prediction event (best-effort).
    pub fn record_prediction(
        &self,
        model_id: ModelId,
        inference_ms: u64,
        prediction: serde_json::Value,
        ground_truth: Option<serde_json::Value>,
    ) {
        let evt = Event::Prediction(PredictionEvent {
            model_id,
            inference_ms,
            prediction,
            ground_truth,
            timestamp_utc: Utc::now(),
        });
        // Ignore send failures – likely during shutdown.
        let _ = self.bus.emit(evt);
    }
}

/* ------------------------------------------------------------------------ */
/* Example setup & smoke-tests                                              */
/* ------------------------------------------------------------------------ */

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;

    #[test]
    fn test_monitoring_pipeline() {
        // Build components
        let bus = EventBus::new();
        let monitor = ModelMonitor::new(0.5);
        bus.register(monitor);

        let handle = MonitoringHandle { bus: bus.clone() };

        // Emit a few synthetic events
        let model_id = ModelId{
            name: "object_detector".into(),
            version:"1.2.1".into()
        };
        for i in 0..10 {
            handle.record_prediction(
                model_id.clone(),
                32 + i,                              // latency
                serde_json::json!({ "class": 1 }),  // prediction
                Some(serde_json::json!({ "class": if i % 2 == 0 {1}else{0} })),
            );
        }

        // Allow async fan-out to process.
        thread::sleep(Duration::from_millis(100));

        // Fetch metrics
        let metrics = monitor.get_metrics(&model_id).unwrap();
        assert!(metrics.total_samples == 10);
        assert!(metrics.latency_ms_ema > 0.0);
    }
}
```
