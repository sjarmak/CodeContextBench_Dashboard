```rust
//! VisuTility Orchestrator – Model-Monitoring & Auto-Retraining Module
//!
//! This module wires together a small but representative slice of the
//! Orchestrator’s Model-Ops layer:
//! 1. A lightweight event bus (Observer Pattern).
//! 2. Metric ingestion & health evaluation (Strategy Pattern).
//! 3. Automated retraining trigger that calls back into the broader
//!    Pipeline (illustrated via a trait ‑ `RetrainingStrategy`).
//!
//! The code is self-contained and designed to be embedded in the bigger
//! project without further modification.  All public items are placed
//! under the `mod model_watchdog` so they can be re-exported from the
//! project’s lib crate (`pub use model_watchdog::*;`).

use std::{
    fmt,
    sync::{
        atomic::{AtomicBool, Ordering},
        mpsc::{self, Receiver, Sender},
        Arc, Mutex,
    },
    thread,
    time::{Duration, Instant},
};

use anyhow::{Context, Result};
use chrono::{DateTime, Utc};
use log::{debug, error, info, warn};
use rand::Rng;
use serde::{Deserialize, Serialize};

/// Public re-exports for ergonomic downstream consumption.
pub use model_watchdog::{
    event_bus::{Bus, BusHandle},
    health::{HealthEvaluator, StaticThresholdEvaluator},
    retrain::{BatchRetrainingStrategy, RetrainingStrategy},
    watchdog::{ModelWatchdog, ModelWatchdogHandle},
};

/// Local sub-modules
mod model_watchdog {
    pub mod event_bus;
    pub mod health;
    pub mod retrain;
    pub mod watchdog;
}

//////////////////////////////////////
/// event_bus.rs
//////////////////////////////////////
pub mod event_bus {
    //! Very small in-process pub-sub implementation.
    //!
    //! While the production system employs either NATS or Kafka for the
    //! event backbone, a lightweight channel-based bus is useful for
    //! unit testing and local development.

    use super::*;

    /// Events emitted by the Model-Ops layer.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum Event {
        PerformanceDegraded(PerformanceMetrics),
        TrainingFinished {
            model_version: String,
            finished_at: DateTime<Utc>,
        },
        /// Generic catch-all.
        Custom(String),
    }

    /// Observable metrics returned by the runtime.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct PerformanceMetrics {
        pub model_name: String,
        pub model_version: String,
        pub window_start: DateTime<Utc>,
        pub window_end: DateTime<Utc>,
        pub accuracy: f32,
        pub precision: f32,
        pub recall: f32,
        pub f1_score: f32,
    }

    /// Clonable handle handed out to publishers & subscribers.
    /// Internally shares the same receiver list through `Arc<Mutex<_>>`.
    #[derive(Clone)]
    pub struct BusHandle {
        inner: Arc<Mutex<Vec<Sender<Event>>>>,
    }

    impl BusHandle {
        /// Broadcast an event to **all** subscribers.
        pub fn broadcast(&self, evt: Event) {
            let mut guard = self
                .inner
                .lock()
                .expect("poisoned event-bus mutex in broadcast");
            // Drain disconnected senders.
            guard.retain(|tx| tx.send(evt.clone()).is_ok());
        }

        /// Subscribe to the event stream. Returns a `Receiver`.
        pub fn subscribe(&self) -> Receiver<Event> {
            let (tx, rx) = mpsc::channel::<Event>();
            self.inner
                .lock()
                .expect("poisoned event-bus mutex in subscribe")
                .push(tx);
            rx
        }
    }

    /// Central event bus. Only one instance should be created per process.
    pub struct Bus {
        handle: BusHandle,
    }

    impl Bus {
        /// Create a new in-process event bus.
        pub fn new() -> Self {
            Self {
                handle: BusHandle {
                    inner: Arc::new(Mutex::new(Vec::new())),
                },
            }
        }

        /// Return a clonable handle.
        pub fn handle(&self) -> BusHandle {
            self.handle.clone()
        }
    }
}

//////////////////////////////////////
/// health.rs
//////////////////////////////////////
pub mod health {
    //! Health evaluation strategies for incoming performance metrics.

    use super::event_bus::PerformanceMetrics;

    /// Trait describing a health evaluator.
    pub trait HealthEvaluator: Send + Sync {
        /// Returns `true` when model is considered UNhealthy.
        fn is_model_degraded(&self, metrics: &PerformanceMetrics) -> bool;
    }

    /// Simple threshold-based evaluator.
    pub struct StaticThresholdEvaluator {
        threshold_f1: f32,
    }

    impl StaticThresholdEvaluator {
        pub fn new(threshold_f1: f32) -> Self {
            Self { threshold_f1 }
        }
    }

    impl HealthEvaluator for StaticThresholdEvaluator {
        fn is_model_degraded(&self, metrics: &PerformanceMetrics) -> bool {
            metrics.f1_score < self.threshold_f1
        }
    }
}

//////////////////////////////////////
/// retrain.rs
//////////////////////////////////////
pub mod retrain {
    //! Retraining strategy abstraction.
    //!
    //! Allows plugging different retraining implementations, ranging
    //! from local fine-tuning to triggering a remote Kubeflow job.

    use super::*;
    use uuid::Uuid;

    /// Trait implemented by all retraining strategies.
    pub trait RetrainingStrategy: Send + Sync {
        /// Kick off retraining and return the new model version if
        /// everything went well.
        fn retrain(&self, degraded_metrics: &event_bus::PerformanceMetrics) -> Result<String>;
    }

    /// Extremely simplified: spawns a blocking thread that simulates
    /// training and returns a random version hash.
    pub struct BatchRetrainingStrategy;

    impl RetrainingStrategy for BatchRetrainingStrategy {
        fn retrain(&self, metrics: &event_bus::PerformanceMetrics) -> Result<String> {
            info!(
                "Starting batch retraining for {}:{} \
                 (f1_score {:.3} below threshold)",
                metrics.model_name, metrics.model_version, metrics.f1_score
            );

            // In production, this would spin up workflow orchestrations, GPU pods, etc.
            // Here we just block for 3–5 seconds.
            let wait_ms = rand::thread_rng().gen_range(3000..5000);
            thread::sleep(Duration::from_millis(wait_ms));

            // Generate a fake new version.
            let new_version = Uuid::new_v4().to_string();
            info!(
                "Retraining finished – new version {} produced in {} ms",
                new_version, wait_ms
            );

            Ok(new_version)
        }
    }
}

//////////////////////////////////////
/// watchdog.rs
//////////////////////////////////////
pub mod watchdog {
    //! Coordinates metric evaluation and retraining triggers.

    use super::*;

    pub struct ModelWatchdog {
        evaluator: Box<dyn health::HealthEvaluator>,
        retraining_strategy: Box<dyn retrain::RetrainingStrategy>,
        bus: event_bus::BusHandle,
        /// Lifecycle flag – makes it possible to stop the internal loop.
        alive: Arc<AtomicBool>,
    }

    impl ModelWatchdog {
        pub fn new(
            evaluator: Box<dyn health::HealthEvaluator>,
            retraining_strategy: Box<dyn retrain::RetrainingStrategy>,
            bus: event_bus::BusHandle,
        ) -> Self {
            Self {
                evaluator,
                retraining_strategy,
                bus,
                alive: Arc::new(AtomicBool::new(false)),
            }
        }

        /// Spawns the long-lived monitoring thread.
        pub fn start(&mut self) -> ModelWatchdogHandle {
            if self
                .alive
                .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
                .is_err()
            {
                panic!("ModelWatchdog::start called twice");
            }

            let bus = self.bus.clone();
            let evaluator = self.evaluator.clone();
            let strategy = self.retraining_strategy.clone();
            let alive_flag = self.alive.clone();
            let join_handle = thread::spawn(move || {
                let rx = bus.subscribe();

                let backoff = Duration::from_secs(5);

                while alive_flag.load(Ordering::Relaxed) {
                    let evt = match rx.recv_timeout(Duration::from_millis(200)) {
                        Ok(evt) => evt,
                        Err(mpsc::RecvTimeoutError::Timeout) => continue,
                        Err(e) => {
                            error!("Watchdog: channel closed prematurely: {}", e);
                            break;
                        }
                    };

                    if let event_bus::Event::PerformanceDegraded(metrics) = evt {
                        debug!(
                            "Watchdog received metrics for {}:{} (f1 {:.3})",
                            metrics.model_name, metrics.model_version, metrics.f1_score
                        );

                        if evaluator.is_model_degraded(&metrics) {
                            warn!(
                                "Model {}:{} marked as degraded (f1 {:.3}). Triggering retraining.",
                                metrics.model_name, metrics.model_version, metrics.f1_score
                            );

                            // Retry loop with basic backoff in case retrain fails.
                            loop {
                                match strategy.retrain(&metrics) {
                                    Ok(new_version) => {
                                        bus.broadcast(event_bus::Event::TrainingFinished {
                                            model_version: new_version,
                                            finished_at: Utc::now(),
                                        });
                                        break;
                                    }
                                    Err(e) => {
                                        error!(
                                            "Retraining attempt failed: {}. \
                                             Retrying in {:?}.",
                                            e, backoff
                                        );
                                        thread::sleep(backoff);
                                    }
                                }
                            }
                        }
                    }
                }

                info!("ModelWatchdog thread exiting gracefully");
            });

            ModelWatchdogHandle {
                alive: self.alive.clone(),
                join_handle,
            }
        }
    }

    impl Drop for ModelWatchdog {
        fn drop(&mut self) {
            self.alive.store(false, Ordering::Relaxed);
        }
    }

    /// Handle that allows graceful shutdown.
    pub struct ModelWatchdogHandle {
        alive: Arc<AtomicBool>,
        join_handle: thread::JoinHandle<()>,
    }

    impl ModelWatchdogHandle {
        /// Stop event processing and join the thread.
        pub fn shutdown(self, timeout: Duration) -> Result<()> {
            self.alive.store(false, Ordering::Relaxed);
            let start = Instant::now();
            while start.elapsed() < timeout {
                if self.join_handle.is_finished() {
                    return self.join_handle.join().map_err(|e| {
                        anyhow::anyhow!("Join failed: {:?}", e)
                    });
                }
                thread::sleep(Duration::from_millis(50));
            }
            Err(anyhow::anyhow!(
                "Timeout waiting for ModelWatchdog thread to terminate"
            ))
        }
    }
}

//////////////////////////////////////
/// Unit tests
//////////////////////////////////////
#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;

    #[test]
    fn watchdog_triggers_retraining() {
        let bus = event_bus::Bus::new();
        let health = health::StaticThresholdEvaluator::new(0.9);
        let strategy = retrain::BatchRetrainingStrategy;

        let mut watchdog = watchdog::ModelWatchdog::new(
            Box::new(health),
            Box::new(strategy),
            bus.handle(),
        );

        let handle = watchdog.start();

        // Simulate degraded performance
        let metrics = event_bus::PerformanceMetrics {
            model_name: "object-detector".into(),
            model_version: "v1".into(),
            window_start: Utc::now(),
            window_end: Utc::now(),
            accuracy: 0.85,
            precision: 0.82,
            recall: 0.8,
            f1_score: 0.81,
        };

        bus.handle().broadcast(event_bus::Event::PerformanceDegraded(metrics));

        // Wait for watchdog to process and broadcast TrainingFinished
        let rx = bus.handle().subscribe();
        let mut received_training_finished = false;

        let start = Instant::now();
        while start.elapsed() < Duration::from_secs(10) {
            if let Ok(event_bus::Event::TrainingFinished { model_version, .. }) = rx.recv_timeout(Duration::from_millis(500)) {
                info!("Test received TrainingFinished with new version {}", model_version);
                received_training_finished = true;
                break;
            }
        }

        assert!(
            received_training_finished,
            "Did not receive TrainingFinished event"
        );

        // Shutdown
        handle.shutdown(Duration::from_secs(2)).unwrap();
    }
}
```