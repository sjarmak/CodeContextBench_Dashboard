```rust
// tests/test_utils.rs
//
// Integration tests for a subset of VisuTility Orchestrator’s public utility
// layer.  These tests exercise the Factory, Registry, and Observer patterns
// that underpin the platform.  They intentionally read like “black-box”
// contract tests: if an internal implementation detail changes, the tests
// should still pass as long as the public API continues to satisfy its
// documented behaviour.
//
// NOTE:  The production crate must expose the modules referenced below
// (factory, registry, events, preprocessing, and model).  The concrete
// structs used here (e.g. `RgbPreprocessor`) are assumed to be exported
// by the crate.  If your crate uses different names, update the imports
// accordingly.

use std::{
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc,
    },
    time::Duration,
};

use anyhow::Result;
use tokio::{sync::Mutex, time::timeout};

use visutility_orchestrator::{
    events::{EventBus, RetrainEvent},
    factory::{DataPreprocessorFactory, SensorModality},
    model::{MockModel, ModelId},
    preprocessing::{FrameBatch, Preprocessor},
    registry::{ModelMetadata, ModelRegistry, ModelVersion},
};

/// Helper that blocks until a condition is met or the timeout elapses.
/// This is useful when testing asynchronous Observer-pattern events.
async fn wait_until<F>(max_wait: Duration, condition: F) -> bool
where
    F: Fn() -> bool,
{
    timeout(max_wait, async {
        loop {
            if condition() {
                return true;
            }
            tokio::time::sleep(Duration::from_millis(5)).await;
        }
    })
    .await
    .unwrap_or(false)
}

#[tokio::test]
async fn test_preprocessor_factory_resolves_expected_concrete_types() -> Result<()> {
    // RGB
    let rgb: Box<dyn Preprocessor> =
        DataPreprocessorFactory::for_modality(SensorModality::Rgb)?;
    assert_eq!(rgb.name(), "RgbPreprocessor");

    // Thermal
    let thermal: Box<dyn Preprocessor> =
        DataPreprocessorFactory::for_modality(SensorModality::Thermal)?;
    assert_eq!(thermal.name(), "ThermalPreprocessor");

    // Depth
    let depth: Box<dyn Preprocessor> =
        DataPreprocessorFactory::for_modality(SensorModality::Depth)?;
    assert_eq!(depth.name(), "DepthPreprocessor");

    // Validate that each concrete type can process a dummy batch.
    let dummy_batch = FrameBatch::dummy(4);
    for proc in [rgb, thermal, depth] {
        let output = proc.preprocess(dummy_batch.clone()).await?;
        assert_eq!(output.len(), dummy_batch.len());
        assert!(
            output
                .iter()
                .all(|frame| frame.is_preprocessed()),
            "every frame should be flagged as pre-processed"
        );
    }

    Ok(())
}

#[tokio::test]
async fn test_model_registry_versioning_and_retrieval_roundtrip() -> Result<()> {
    // In a multi-tenant environment, each (tenant, model_name) pair gets its own sequence.
    let tenant_id = "acme-factory-42";
    let model_name = "conveyor-object-detector";

    let registry = ModelRegistry::new_in_memory();

    // Register 3 versions sequentially.
    for idx in 0..3 {
        let mock_model = MockModel::new(ModelId::new(format!("mock/v{}", idx)));
        let meta = ModelMetadata {
            name: model_name.into(),
            tenant: tenant_id.into(),
            description: Some(format!("unit-test version {}", idx)),
            artifact_path: format!("/tmp/mock_model_v{}.onnx", idx).into(),
            additional: None,
        };
        registry.register(mock_model, meta.clone()).await?;
    }

    // Latest should be version 3.
    let latest_entry = registry.latest(tenant_id, model_name).await?;
    assert_eq!(latest_entry.version, ModelVersion(3));

    // Query by explicit version.
    let v2_entry = registry
        .by_version(tenant_id, model_name, ModelVersion(2))
        .await?;
    assert_eq!(v2_entry.version, ModelVersion(2));

    // Attempting to fetch a non-existent version should error.
    let err = registry
        .by_version(tenant_id, model_name, ModelVersion(99))
        .await
        .expect_err("version 99 should not exist");
    assert!(
        err.to_string().contains("not found"),
        "error message should mention model not found"
    );

    Ok(())
}

#[tokio::test]
async fn test_retrain_event_bus_notifies_subscribers() -> Result<()> {
    // Shared assertion state.
    let counter = Arc::new(AtomicUsize::new(0));

    let bus = EventBus::default();

    // Create three independent subscribers.
    for _ in 0..3 {
        let c = counter.clone();
        let mut rx = bus.subscribe::<RetrainEvent>();
        tokio::spawn(async move {
            while let Ok(evt) = rx.recv().await {
                // Simple integrity checks.
                assert!(
                    !evt.tenant_id.is_empty() && !evt.model_name.is_empty(),
                    "event should carry identifying payload"
                );
                c.fetch_add(1, Ordering::SeqCst);
            }
        });
    }

    // Emit a single retrain event.
    let evt = RetrainEvent {
        tenant_id: "acme-factory-42".into(),
        model_name: "conveyor-object-detector".into(),
        triggered_at: chrono::Utc::now(),
        reason: Some("integration-test".into()),
    };
    bus.publish(evt).await?;

    // Wait until all listeners increment the counter or time out.
    let all_received = wait_until(Duration::from_secs(2), || counter.load(Ordering::SeqCst) == 3)
        .await;
    assert!(
        all_received,
        "all subscribers should have processed the event exactly once"
    );

    Ok(())
}
```