package com.wellsphere.connect.ui.main;

import android.Manifest;
import android.annotation.SuppressLint;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.location.Location;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.MainThread;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import androidx.biometric.BiometricManager;
import androidx.biometric.BiometricPrompt;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.lifecycle.Observer;
import androidx.lifecycle.ViewModelProvider;
import androidx.navigation.NavController;
import androidx.navigation.fragment.NavHostFragment;

import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.tasks.CancellationTokenSource;
import com.google.android.material.snackbar.Snackbar;
import com.wellsphere.connect.BuildConfig;
import com.wellsphere.connect.R;
import com.wellsphere.connect.data.model.UserSession;
import com.wellsphere.connect.di.ViewModelFactoryProvider;
import com.wellsphere.connect.ui.login.LoginActivity;
import com.wellsphere.connect.util.CrashReportingTree;
import com.wellsphere.connect.util.SingleLiveEvent;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

/**
 * MainActivity is the entry-point after biometric authentication and encapsulates all
 * navigation-level concerns (location permission gating, crash-reporting initialization, etc.).
 *
 * This Activity adheres to MVVM by delegating UI state to {@link MainViewModel}.
 */
public class MainActivity extends AppCompatActivity {

    private static final int REQUEST_CODE_BIOMETRIC = 0xB10;
    private static final int REQUEST_CODE_FINE_LOCATION = 0x1A1;

    private MainViewModel viewModel;
    private BiometricPrompt biometricPrompt;
    private FusedLocationProviderClient fusedLocationClient;
    private CancellationTokenSource locationCancellationSource;
    private NavController navController;

    /* ------------------------- Lifecycle ------------------------- */

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Boot‐strap crash reporting as early as possible.
        initCrashReporting();

        setContentView(R.layout.activity_main);
        setupToolbar();
        setupNavigation();

        // ViewModel via injectable factory (DI handled elsewhere).
        viewModel = new ViewModelProvider(
                this,
                ViewModelFactoryProvider.provideMainViewModelFactory(this)
        ).get(MainViewModel.class);

        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);
        locationCancellationSource = new CancellationTokenSource();

        observeViewModel();
        authenticateOrKick();
    }

    @Override
    protected void onDestroy() {
        if (locationCancellationSource != null && !locationCancellationSource.isCancellationRequested()) {
            locationCancellationSource.cancel();
        }
        super.onDestroy();
    }

    /* ------------------------- Setup Helpers ------------------------- */

    private void setupToolbar() {
        Toolbar toolbar = findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        toolbar.setOverflowIcon(ContextCompat.getDrawable(this, R.drawable.ic_overflow));
    }

    private void setupNavigation() {
        NavHostFragment navHost = (NavHostFragment) getSupportFragmentManager()
                .findFragmentById(R.id.nav_host_fragment);
        if (navHost == null) {
            throw new IllegalStateException("NavHostFragment not found. " +
                    "Check activity_main.xml for nav_host_fragment.");
        }
        navController = navHost.getNavController();
    }

    private void initCrashReporting() {
        // Plant crash reporting tree only in release builds.
        if (!BuildConfig.DEBUG) {
            CrashReportingTree plant = new CrashReportingTree();
            plant.plant();
        }
    }

    /* ------------------------- Biometric Auth ------------------------- */

    private void authenticateOrKick() {
        BiometricManager biometricManager = BiometricManager.from(this);
        if (biometricManager.canAuthenticate() == BiometricManager.BIOMETRIC_SUCCESS) {
            launchBiometricPrompt();
        } else {
            // Device doesn't support Biometrics — logout the user.
            kickUserToLogin("Biometric authentication unavailable on this device.");
        }
    }

    private void launchBiometricPrompt() {
        Executor executor = Executors.newSingleThreadExecutor();
        biometricPrompt = new BiometricPrompt(this,
                executor,
                new BiometricPrompt.AuthenticationCallback() {
                    @Override
                    public void onAuthenticationSucceeded(
                            @NonNull BiometricPrompt.AuthenticationResult result) {
                        super.onAuthenticationSucceeded(result);
                        runOnUiThread(() -> {
                            Toast.makeText(MainActivity.this,
                                    R.string.label_biometric_success,
                                    Toast.LENGTH_SHORT).show();
                            viewModel.onUserAuthenticated();
                        });
                    }

                    @Override
                    public void onAuthenticationFailed() {
                        super.onAuthenticationFailed();
                        runOnUiThread(() -> Snackbar.make(
                                findViewById(R.id.coordinator_layout),
                                R.string.label_biometric_failed,
                                Snackbar.LENGTH_SHORT).show());
                    }

                    @Override
                    public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) {
                        super.onAuthenticationError(errorCode, errString);
                        runOnUiThread(() ->
                                kickUserToLogin(getString(R.string.label_biometric_error, errString)));
                    }
                });

        BiometricPrompt.PromptInfo promptInfo = new BiometricPrompt.PromptInfo.Builder()
                .setTitle(getString(R.string.label_biometric_title))
                .setSubtitle(getString(R.string.label_biometric_subtitle))
                .setDeviceCredentialAllowed(false)
                .build();

        biometricPrompt.authenticate(promptInfo);
    }

    /* ------------------------- Permissions ------------------------- */

    private final ActivityResultLauncher<String> locationPermissionLauncher =
            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                if (isGranted) {
                    acquireUserLocation();
                } else {
                    Snackbar.make(findViewById(R.id.coordinator_layout),
                            R.string.label_location_permission_denied,
                            Snackbar.LENGTH_LONG).show();
                }
            });

    private void requestLocationPermission() {
        locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION);
    }

    @SuppressLint("MissingPermission")
    private void acquireUserLocation() {
        fusedLocationClient.getCurrentLocation(
                com.google.android.gms.location.Priority.PRIORITY_BALANCED_POWER_ACCURACY,
                locationCancellationSource.getToken()
        ).addOnSuccessListener(this::onLocationReceived)
         .addOnFailureListener(e -> {
             // Best-effort: location failures should not block the user.
             CrashReportingTree.logException(e);
         });
    }

    private void onLocationReceived(@Nullable Location location) {
        if (location == null) return;
        viewModel.updateLocation(location);
    }

    /* ------------------------- ViewModel Observation ------------------------- */

    private void observeViewModel() {
        viewModel.getUserSession().observe(this, this::onUserSessionChanged);
        viewModel.getShareEvent().observe(this, this::onShareTriggered);
        viewModel.getLocationRequestEvent().observe(this, locationRequest -> {
            if (locationRequest == null) return;
            if (ContextCompat.checkSelfPermission(this,
                    Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                acquireUserLocation();
            } else {
                requestLocationPermission();
            }
        });
    }

    private void onUserSessionChanged(@Nullable UserSession session) {
        if (session == null || !session.isValid()) {
            kickUserToLogin(getString(R.string.label_session_expired));
        }
    }

    private void onShareTriggered(String sharePayload) {
        if (sharePayload == null) return;
        Intent shareIntent = new Intent(Intent.ACTION_SEND)
                .setType("text/plain")
                .putExtra(Intent.EXTRA_TEXT, sharePayload);
        startActivity(Intent.createChooser(shareIntent,
                getString(R.string.label_share_with)));
    }

    /* ------------------------- Menu ------------------------- */

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.menu_main, menu);
        // Hide debug-only menu items
        if (!BuildConfig.DEBUG) {
            menu.findItem(R.id.menu_force_crash).setVisible(false);
        }
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(@NonNull MenuItem item) {
        switch (item.getItemId()) {
            case R.id.menu_logout:
                viewModel.logoutUser();
                return true;
            case R.id.menu_force_crash:
                throw new IllegalStateException("Forced crash for testing crash reporting.");
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    /* ------------------------- Helpers ------------------------- */

    @MainThread
    private void kickUserToLogin(@NonNull String message) {
        Snackbar.make(findViewById(R.id.coordinator_layout), message, Snackbar.LENGTH_LONG).show();
        new Handler(Looper.getMainLooper()).postDelayed(() -> {
            startActivity(new Intent(MainActivity.this, LoginActivity.class)
                    .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK));
            finish();
        }, 1500);
    }

    /* ==========================================================
     *  ViewModel definition (package-private for brevity)
     * ======================================================== */

    /**
     * MainViewModel wires UI intent to domain use-cases while exposing observable screens state.
     * Dependencies are injected through the constructor (see {@link ViewModelFactoryProvider}).
     */
    static class MainViewModel extends androidx.lifecycle.ViewModel {

        private final com.wellsphere.connect.domain.interactor.UserSessionInteractor sessionInteractor;
        private final com.wellsphere.connect.domain.interactor.LocationInteractor locationInteractor;
        private final com.wellsphere.connect.domain.interactor.ShareInteractor shareInteractor;

        private final SingleLiveEvent<String> shareEvent = new SingleLiveEvent<>();
        private final SingleLiveEvent<Void> locationRequestEvent = new SingleLiveEvent<>();
        private final androidx.lifecycle.MutableLiveData<UserSession> userSession = new androidx.lifecycle.MutableLiveData<>();

        MainViewModel(
                com.wellsphere.connect.domain.interactor.UserSessionInteractor sessionInteractor,
                com.wellsphere.connect.domain.interactor.LocationInteractor locationInteractor,
                com.wellsphere.connect.domain.interactor.ShareInteractor shareInteractor
        ) {
            this.sessionInteractor = sessionInteractor;
            this.locationInteractor = locationInteractor;
            this.shareInteractor = shareInteractor;
            bootstrap();
        }

        private void bootstrap() {
            // Load initial session snapshot
            com.wellsphere.connect.util.AppExecutors.diskIO().execute(() -> {
                UserSession session = sessionInteractor.getCachedSession();
                userSession.postValue(session);
            });
        }

        /* ---------- Public getters ---------- */

        androidx.lifecycle.LiveData<UserSession> getUserSession() {
            return userSession;
        }

        SingleLiveEvent<String> getShareEvent() {
            return shareEvent;
        }

        SingleLiveEvent<Void> getLocationRequestEvent() {
            return locationRequestEvent;
        }

        /* ---------- UI Intents ---------- */

        void onUserAuthenticated() {
            // Refresh tokens or fetch user data as needed.
            com.wellsphere.connect.util.AppExecutors.networkIO().execute(() -> {
                try {
                    UserSession refreshed = sessionInteractor.refreshSession();
                    userSession.postValue(refreshed);
                } catch (Exception e) {
                    CrashReportingTree.logException(e);
                    userSession.postValue(null);
                }
            });
        }

        void logoutUser() {
            com.wellsphere.connect.util.AppExecutors.diskIO().execute(() -> {
                sessionInteractor.clearSession();
                userSession.postValue(null);
            });
        }

        void updateLocation(@NonNull Location location) {
            com.wellsphere.connect.util.AppExecutors.diskIO().execute(() ->
                    locationInteractor.persistLocation(location));
        }

        void requestLocation() {
            locationRequestEvent.postValue(null);
        }

        void shareContent(String payload) {
            shareEvent.postValue(payload);
            shareInteractor.logShareEvent(payload);
        }

        @Override
        protected void onCleared() {
            super.onCleared();
            // Cancel ongoing work if needed.
        }
    }
}