package com.wellsphere.connect.domain.usecase.iap;

import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.schedulers.Schedulers;
import java.time.Instant;
import java.util.Objects;
import java.util.concurrent.Executor;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Syncs the user’s Google Play Billing subscription with the WellSphere backend.
 *
 * <p>This {@code UseCase} is invoked whenever:
 * <ul>
 *     <li>a purchase acknowledgement callback is received,</li>
 *     <li>the user manually performs a “Restore Purchases”, or</li>
 *     <li>the application starts up and the cache is considered stale.</li>
 * </ul>
 *
 * <p>The class sits in the domain layer and therefore does not depend on
 * the Play Billing SDK directly— all platform-specific APIs are abstracted
 * away behind {@link BillingRepository}.  This enables deterministic unit
 * testing and JVM-only instrumentation tests.
 *
 * <p>The logic, in order:
 * <ol>
 *     <li>Verify network availability.  If offline, short-circuit and rely on the
 *         last-known subscription state.</li>
 *     <li>Query local Play Billing cache for active purchases.</li>
 *     <li>POST purchase tokens to the backend for cryptographic verification
 *         (server-to-server with Play) and entitlement provisioning.</li>
 *     <li>Persist the backend’s canonical subscription status locally so that
 *         ViewModels can react via {@code LiveData} / {@code Flowable}s.</li>
 * </ol>
 *
 * <p>Error handling strategy:
 * <ul>
 *     <li>Network or API errors are mapped to {@link SyncResult#ERROR_REMOTE} but will not
 *     crash the app.</li>
 *     <li>Uncaught runtime exceptions are considered fatal because the domain layer
 *     should never throw in normal operation.</li>
 * </ul>
 */
public final class SyncPremiumSubscriptionUseCase {

    private static final Logger LOGGER =
            Logger.getLogger(SyncPremiumSubscriptionUseCase.class.getSimpleName());
    private static final long CACHE_TTL_MILLIS = 1000 * 60 * 60; // 1 hour

    private final BillingRepository billingRepository;
    private final SubscriptionRemoteDataSource remoteDataSource;
    private final SubscriptionLocalDataSource localDataSource;
    private final NetworkStatusProvider networkStatusProvider;
    private final Executor callbackExecutor;

    /**
     * Constructs a new use-case.
     *
     * @param billingRepository    abstraction over Play Billing
     * @param remoteDataSource     REST/gRPC client that talks to WellSphere backend
     * @param localDataSource      on-device persistence
     * @param networkStatusProvider connectivity monitor
     * @param callbackExecutor      thread on which {@link SyncResultCallback} is invoked
     */
    public SyncPremiumSubscriptionUseCase(
            BillingRepository billingRepository,
            SubscriptionRemoteDataSource remoteDataSource,
            SubscriptionLocalDataSource localDataSource,
            NetworkStatusProvider networkStatusProvider,
            Executor callbackExecutor) {

        this.billingRepository = Objects.requireNonNull(billingRepository);
        this.remoteDataSource = Objects.requireNonNull(remoteDataSource);
        this.localDataSource = Objects.requireNonNull(localDataSource);
        this.networkStatusProvider = Objects.requireNonNull(networkStatusProvider);
        this.callbackExecutor = Objects.requireNonNull(callbackExecutor);
    }

    /**
     * Triggers a background synchronisation.
     *
     * @param forceRefresh if {@code true}, ignores the local cache and always
     *                     contacts the backend
     * @param callback     result delivery, executed on {@code callbackExecutor}
     */
    public void execute(boolean forceRefresh, SyncResultCallback callback) {
        Single.defer(() -> shouldSkipRemoteCall(forceRefresh)
                        ? localDataSource.getCachedSubscription().toSingle()
                        : billingRepository
                                .queryActivePurchases()
                                .flatMap(tokens -> remoteDataSource.validatePurchases(tokens))
                                .doOnSuccess(localDataSource::cacheSubscription))
                .map(subscription -> subscription.isActive()
                        ? SyncResult.SUCCESS_ACTIVE
                        : SyncResult.SUCCESS_EXPIRED)
                .onErrorReturn(throwable -> {
                    LOGGER.log(Level.WARNING, "Failed to sync subscription", throwable);
                    return throwable instanceof OfflineException
                            ? SyncResult.ERROR_OFFLINE
                            : SyncResult.ERROR_REMOTE;
                })
                .subscribeOn(Schedulers.io())
                .observeOn(Schedulers.from(callbackExecutor))
                .subscribe(callback::onResult, callback::onFatalError);
    }

    private Single<Boolean> shouldSkipRemoteCall(boolean forceRefresh) {
        if (forceRefresh) {
            return Single.just(false);
        }
        return localDataSource.lastCacheTime()
                .map(last -> (Instant.now().toEpochMilli() - last) < CACHE_TTL_MILLIS)
                .onErrorReturnItem(false);
    }

    // -----------------------------------------------------------------------
    // Result types & collaborators
    // -----------------------------------------------------------------------

    /**
     * Callbacks for {@link #execute}.
     */
    @FunctionalInterface
    public interface SyncResultCallback {

        /**
         * Invoked on {@link SyncPremiumSubscriptionUseCase#callbackExecutor}.
         *
         * @param result never {@code null}
         */
        void onResult(SyncResult result);

        /**
         * Invoked only for programmer bugs (e.g. {@code NullPointerException}).
         * Unrecoverable at runtime.
         */
        default void onFatalError(Throwable fatal) {
            LOGGER.log(Level.SEVERE, "Fatal error while syncing purchases", fatal);
        }
    }

    /**
     * High-level outcome of a sync attempt, designed for UI consumption.
     */
    public enum SyncResult {
        SUCCESS_ACTIVE,
        SUCCESS_EXPIRED,
        ERROR_OFFLINE,
        ERROR_REMOTE
    }

    // -----------------------------------------------------------------------
    // Infrastructure-layer abstractions
    // -----------------------------------------------------------------------

    /**
     * Domain-layer abstraction for Google Play Billing interaction.
     */
    public interface BillingRepository {
        /**
         * Returns all owned purchase tokens that need server-side validation.
         */
        Single<String[]> queryActivePurchases();
    }

    /**
     * Backend gateway responsible for verifying purchase tokens and returning
     * the server’s canonical subscription model.
     */
    public interface SubscriptionRemoteDataSource {

        /**
         * Posts the purchase tokens for validation. The backend will perform
         * server-to-server verification against Google APIs and respond with the
         * authoritative subscription state.
         */
        Single<Subscription> validatePurchases(String[] purchaseTokens);
    }

    /**
     * Persists the most recent subscription for offline access.
     */
    public interface SubscriptionLocalDataSource {

        Completable cacheSubscription(Subscription subscription);

        /**
         * Emits the cached subscription, or an empty {@code Maybe} if none exists.
         */
        io.reactivex.rxjava3.core.Maybe<Subscription> getCachedSubscription();

        /**
         * Timestamp in millis when {@link #cacheSubscription} was last called.
         */
        Single<Long> lastCacheTime();
    }

    /**
     * Reports current network connectivity.
     */
    public interface NetworkStatusProvider {
        boolean isOnline();
    }

    /**
     * Plain value object representing subscription status.
     */
    public static final class Subscription {

        private final boolean active;
        private final Instant expiry;

        public Subscription(boolean active, Instant expiry) {
            this.active = active;
            this.expiry = expiry;
        }

        public boolean isActive() {
            return active && expiry.isAfter(Instant.now());
        }

        public Instant getExpiry() {
            return expiry;
        }
    }

    /**
     * Thrown when the device is offline and a remote operation is attempted.
     */
    public static final class OfflineException extends RuntimeException {
        public OfflineException() {
            super("No network connection");
        }
    }
}