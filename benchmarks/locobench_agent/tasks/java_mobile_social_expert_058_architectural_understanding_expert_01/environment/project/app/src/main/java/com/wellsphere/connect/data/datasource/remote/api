package com.wellsphere.connect.data.datasource.remote.api;

import android.content.Context;
import android.text.TextUtils;

import androidx.annotation.NonNull;
import androidx.annotation.VisibleForTesting;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.wellsphere.connect.BuildConfig;
import com.wellsphere.connect.core.auth.AuthManager;
import com.wellsphere.connect.core.di.Injector;
import com.wellsphere.connect.core.util.NetworkUtils;
import com.wellsphere.connect.data.model.AuthenticationRequest;
import com.wellsphere.connect.data.model.AuthenticationResponse;
import com.wellsphere.connect.data.model.FeedItem;
import com.wellsphere.connect.data.model.Vital;
import com.wellsphere.connect.data.model.WoundImageUploadResponse;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.TimeUnit;

import okhttp3.Authenticator;
import okhttp3.Cache;
import okhttp3.Call;
import okhttp3.Credentials;
import okhttp3.Interceptor;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.Route;
import okhttp3.logging.HttpLoggingInterceptor;
import retrofit2.Retrofit;
import retrofit2.CallAdapter;
import retrofit2.Converter;
import retrofit2.adapter.rxjava3.RxJava3CallAdapterFactory;
import retrofit2.converter.gson.GsonConverterFactory;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Multipart;
import retrofit2.http.POST;
import retrofit2.http.Part;
import retrofit2.http.Path;

/**
 * Production-ready network stack for WellSphere Connect.
 *
 * The {@link ApiClient} is responsible for constructing and providing a singleton instance of the
 * Retrofit-powered {@link WellSphereApi}. It applies a hardened OkHttp configuration that meets
 * HIPAA security requirements, supports offline caching, biometric authentication headers,
 * and auto-refreshes expired tokens via {@link TokenAuthenticator}.
 *
 * DO NOT instantiate {@link Retrofit} directly elsewhere—always go through this class
 * to guarantee consistent security posture and runtime behavior.
 */
@SuppressWarnings("WeakerAccess")
public final class ApiClient {

    // Retrofit singleton instance holder (lazy, thread-safe, double-checked locking)
    private static volatile ApiClient INSTANCE;

    private static final int CONNECT_TIMEOUT_SECONDS = 15;
    private static final int READ_TIMEOUT_SECONDS = 25;
    private static final int WRITE_TIMEOUT_SECONDS = 30;
    private static final int HTTP_CACHE_SIZE_MB = 10; // 10 MB

    // Endpoint interface
    private final WellSphereApi api;

    // VisibleForTesting to allow dependency injection in unit tests
    @VisibleForTesting
    ApiClient(@NonNull WellSphereApi api) {
        this.api = api;
    }

    /**
     * Initializes (if needed) and returns the singleton {@link ApiClient}.
     */
    public static ApiClient getInstance(@NonNull Context context) {
        if (INSTANCE == null) {
            synchronized (ApiClient.class) {
                if (INSTANCE == null) {
                    INSTANCE = buildApiClient(context);
                }
            }
        }
        return INSTANCE;
    }

    /**
     * Visible for instrumentation tests. Injects a mocked {@link WellSphereApi}.
     */
    @VisibleForTesting
    public static void injectMock(@NonNull WellSphereApi mockApi) {
        INSTANCE = new ApiClient(mockApi);
    }

    public WellSphereApi getApi() {
        return api;
    }

    // region Builders ----------------------------------------------------------------------------------------------

    private static ApiClient buildApiClient(Context appContext) {

        Gson gson = provideGson();
        Converter.Factory gsonConverter = GsonConverterFactory.create(gson);
        CallAdapter.Factory rxAdapter = RxJava3CallAdapterFactory.create();

        OkHttpClient okHttpClient = provideOkHttp(appContext);

        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(BuildConfig.API_BASE_URL)
                .client(okHttpClient)
                .addConverterFactory(gsonConverter)
                .addCallAdapterFactory(rxAdapter)
                .build();

        return new ApiClient(retrofit.create(WellSphereApi.class));
    }

    /**
     * Configure Gson with a deterministic field naming policy and ISO 8601 dates.
     */
    private static Gson provideGson() {
        return new GsonBuilder()
                .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
                .setDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
                .create();
    }

    /**
     * Constructs the hardened OkHttp client:
     *  - Enforces short timeouts so UI remains responsive
     *  - Adds HTTP response caching for offline workflows
     *  - Logs requests in DEBUG mode only
     *  - Injects auth headers and refreshes tokens when needed
     */
    private static OkHttpClient provideOkHttp(Context appContext) {
        File httpCacheDir = new File(appContext.getCacheDir(), "http-cache");
        Cache cache = new Cache(httpCacheDir, HTTP_CACHE_SIZE_MB * 1024L * 1024L);

        OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .cache(cache)
                .connectTimeout(CONNECT_TIMEOUT_SECONDS, TimeUnit.SECONDS)
                .readTimeout(READ_TIMEOUT_SECONDS, TimeUnit.SECONDS)
                .writeTimeout(WRITE_TIMEOUT_SECONDS, TimeUnit.SECONDS)
                .authenticator(new TokenAuthenticator())
                .addInterceptor(new OfflineCacheInterceptor(appContext))
                .addInterceptor(new AuthorizationInterceptor());

        if (BuildConfig.DEBUG) {
            HttpLoggingInterceptor logging =
                    new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY);
            builder.addInterceptor(logging);
        }

        // Certificate pinning and TLS configuration could be added here for even stronger security

        return builder.build();
    }

    // endregion

    // region OkHttp Interceptors / Authenticators -------------------------------------------------------------------

    /**
     * Adds JWT access token and additional security headers to each request.
     */
    private static class AuthorizationInterceptor implements Interceptor {

        @Override
        public Response intercept(@NonNull Chain chain) throws IOException {
            Request original = chain.request();

            // Retrieve current auth token from injected AuthManager (DI)
            AuthManager authManager = Injector.get().authManager();
            String accessToken = authManager.getAccessToken();

            Request.Builder builder = original.newBuilder()
                    .header("Accept", "application/json");

            if (!TextUtils.isEmpty(accessToken)) {
                builder.header("Authorization", "Bearer " + accessToken);
            }

            // Biometric sessions may also send a one-time challenge header
            String biometricHeader = authManager.getBiometricHeader();
            if (!TextUtils.isEmpty(biometricHeader)) {
                builder.header("X-Biometric-Session", biometricHeader);
            }

            return chain.proceed(builder.build());
        }
    }

    /**
     * Provides offline caching when device loses connectivity.
     * Stale content (up to 6 hours) is served if no network is available.
     */
    private static class OfflineCacheInterceptor implements Interceptor {

        private static final int MAX_STALE_HOURS = 6;

        private final Context context;

        OfflineCacheInterceptor(Context context) {
            this.context = context.getApplicationContext();
        }

        @Override
        public Response intercept(@NonNull Chain chain) throws IOException {
            Request request = chain.request();
            if (!NetworkUtils.isConnected(context)) {
                // Force cache when offline
                request = request.newBuilder()
                        .header("Cache-Control", "public, only-if-cached, max-stale=" + (MAX_STALE_HOURS * 60 * 60))
                        .build();
            }
            return chain.proceed(request);
        }
    }

    /**
     * Attempts to refresh access tokens when the server returns HTTP 401.
     */
    private static class TokenAuthenticator implements Authenticator {

        @Override
        public Request authenticate(Route route, @NonNull Response response) throws IOException {
            // Stop infinite retry loop
            if (responseCount(response) >= 2) {
                return null;
            }

            AuthManager authManager = Injector.get().authManager();
            synchronized (TokenAuthenticator.class) {
                String newAccessToken = authManager.refreshTokenBlocking();
                if (TextUtils.isEmpty(newAccessToken)) {
                    return null; // Give up, user needs to re-login
                }
                return response.request().newBuilder()
                        .header("Authorization", "Bearer " + newAccessToken)
                        .build();
            }
        }

        private static int responseCount(Response response) {
            int result = 1;
            while ((response = response.priorResponse()) != null) {
                result++;
            }
            return result;
        }
    }

    // endregion

    // region Retrofit Endpoint Spec ---------------------------------------------------------------------------------

    /**
     * Primary definition of all server endpoints consumed by the mobile client.
     *
     * Greater interface surface should be split into smaller, feature-specific
     * sub-interfaces—kept together here for brevity.
     */
    public interface WellSphereApi {

        /* --------------- Authentication --------------- */

        @POST("auth/biometric")
        retrofit2.Call<AuthenticationResponse> biometricLogin(@Body AuthenticationRequest request);

        /* --------------- Social Feed --------------- */

        @GET("feed")
        retrofit2.Call<List<FeedItem>> getFeed();

        @GET("feed/user/{userId}")
        retrofit2.Call<List<FeedItem>> getUserFeed(@Path("userId") String userId);

        /* --------------- Wound / Image Upload --------------- */

        @Multipart
        @POST("media/wound")
        retrofit2.Call<WoundImageUploadResponse> uploadWoundImage(
                @Part MultipartBody.Part filePart,
                @Header("X-Patient-Id") String patientId
        );

        /* --------------- Vitals --------------- */

        @GET("vitals")
        retrofit2.Call<List<Vital>> getVitals();

        @POST("vitals")
        retrofit2.Call<Void> submitVital(@Body Vital vital);
    }

    // endregion

    // region Helper Utilities (static) ------------------------------------------------------------------------------

    /**
     * Wraps a File into a Retrofit-friendly {@link MultipartBody.Part}.
     */
    public static MultipartBody.Part createMultipartPart(@NonNull File file, @NonNull String paramName) {
        MediaType mediaType = MediaType.parse("image/*");
        RequestBody fileBody = RequestBody.create(mediaType, file);
        return MultipartBody.Part.createFormData(paramName, file.getName(), fileBody);
    }

    /**
     * Executes a {@link retrofit2.Call} synchronously and converts the checked exception into
     * an unchecked one so callers can wrap into Rx or Kotlin Coroutines more easily.
     *
     * Example usage in a Repository:
     *
     *   FeedItem items = ApiClient.getInstance(ctx)
     *                               .getApi()
     *                               .getFeed()
     *                               .executeOrThrow();
     */
    public static <T> T executeOrThrow(@NonNull retrofit2.Call<T> call) {
        try {
            retrofit2.Response<T> rsp = call.execute();
            if (!rsp.isSuccessful()) {
                throw new IOException("HTTP " + rsp.code() + " " + rsp.message());
            }
            return rsp.body();
        } catch (IOException e) {
            throw new RuntimeException("Network call failed", e);
        }
    }

    // endregion
}