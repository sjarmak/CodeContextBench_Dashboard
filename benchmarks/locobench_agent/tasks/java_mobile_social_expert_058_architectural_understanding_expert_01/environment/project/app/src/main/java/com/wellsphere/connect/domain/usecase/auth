package com.wellsphere.connect.domain.usecase.auth;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.util.Objects;
import java.util.concurrent.TimeUnit;

import io.reactivex.Completable;
import io.reactivex.Single;
import io.reactivex.Scheduler;
import io.reactivex.disposables.CompositeDisposable;
import io.reactivex.schedulers.Schedulers;

/**
 * AuthenticateUserUseCase is the entry-point for every authentication flow in
 * the WellSphere Connect domain layer. It encapsulates complex decision-making
 * such as:
 *   • Picking e-mail/OTP vs. cached session vs. biometric unlock
 *   • Offline-first behaviour with deferred refresh once connectivity resumes
 *   • Centralised error and crash reporting
 *
 * The class is purposely free of any Android framework references (except
 * androidx.annotation) to keep the domain layer pure and unit-test friendly.
 *
 * Threading Strategy
 * ------------------
 * Heavy operations (network, crypto, DB) are executed on {@code ioScheduler}.
 * The calling layer is responsible for observing on the UI scheduler if
 * needed.
 *
 * Usage
 * -----
 * {@code
 * AuthenticateUserUseCase useCase = new AuthenticateUserUseCase(repo,
 *         sessionRepo, networkProvider, biometricAuthenticator,
 *         crashReporter, Schedulers.io());
 *
 * useCase.execute(Params.emailPassword("foo@bar.com", "secret", false))
 *        .subscribe(result -> { … }, throwable -> { … });
 * }
 */
public final class AuthenticateUserUseCase {

    private static final long SESSION_EXPIRY_THRESHOLD_MIN = 55; // minutes
    private static final String CRASH_SCOPE = "AuthUseCase";

    private final AuthenticationRepository authRepo;
    private final SessionRepository sessionRepo;
    private final NetworkStateProvider networkProvider;
    private final BiometricAuthenticator biometricAuthenticator;
    private final CrashReporter crashReporter;
    private final Scheduler ioScheduler;
    private final CompositeDisposable disposables = new CompositeDisposable();

    public AuthenticateUserUseCase(@NonNull AuthenticationRepository authRepo,
                                   @NonNull SessionRepository sessionRepo,
                                   @NonNull NetworkStateProvider networkProvider,
                                   @NonNull BiometricAuthenticator biometricAuthenticator,
                                   @NonNull CrashReporter crashReporter,
                                   @NonNull Scheduler ioScheduler) {
        this.authRepo = Objects.requireNonNull(authRepo);
        this.sessionRepo = Objects.requireNonNull(sessionRepo);
        this.networkProvider = Objects.requireNonNull(networkProvider);
        this.biometricAuthenticator = Objects.requireNonNull(biometricAuthenticator);
        this.crashReporter = Objects.requireNonNull(crashReporter);
        this.ioScheduler = Objects.requireNonNull(ioScheduler);
    }

    /**
     * Trigger the authentication flow.
     *
     * @return A {@link Single} that emits exactly one {@link Result}. The stream
     * completes afterwards. In case of unrecoverable errors the stream
     * terminates with {@link AuthException}.
     */
    public Single<Result> execute(@NonNull Params params) {
        return Single.defer(() -> attemptAuthentication(params))
                     .subscribeOn(ioScheduler)
                     .doOnError(t -> crashReporter.logException(CRASH_SCOPE, t));
    }

    /**
     * Cancel all running auth operations. Useful when the ViewModel is
     * cleared.
     */
    public void cancel() {
        disposables.clear();
    }

    // -----------------------------------------------------------------------
    // Internal Decision Tree
    // -----------------------------------------------------------------------

    private Single<Result> attemptAuthentication(Params params) {
        // 1. Can a valid session be reused?
        CachedSession cached = sessionRepo.getCachedSession();
        if (cached != null && !cached.isExpired(SESSION_EXPIRY_THRESHOLD_MIN, TimeUnit.MINUTES)) {
            return Single.just(Result.success(cached));
        }

        // 2. Should we attempt biometric unlock?
        if (params.useBiometric && biometricAuthenticator.isBiometricAvailable()) {
            return biometricAuthenticator.authenticate()
                    .flatMap(token -> authRepo.loginWithToken(token)
                                              .flatMap(this::cacheAndReturnSuccess));
        }

        // 3. Do we have network for credential login?
        if (!networkProvider.isConnected()) {
            // Offline and no valid session – fail early.
            return Single.error(new AuthException.NetworkUnavailable());
        }

        // 4. Fallback to credentials (e-mail/password or external token)
        if (params.email != null && params.password != null) {
            return authRepo.loginWithEmail(params.email, params.password)
                           .flatMap(this::cacheAndReturnSuccess);
        } else if (params.token != null) {
            return authRepo.loginWithToken(params.token)
                           .flatMap(this::cacheAndReturnSuccess);
        } else {
            return Single.error(new AuthException.InvalidParams());
        }
    }

    private Single<Result> cacheAndReturnSuccess(@NonNull SessionResponse response) {
        return Completable.fromAction(() -> sessionRepo.cacheSession(response))
                          .andThen(Single.just(Result.success(
                                  new CachedSession(response.getAccessToken(),
                                                    response.getRefreshToken(),
                                                    System.currentTimeMillis())))
                          );
    }

    // -----------------------------------------------------------------------
    // Data Contracts
    // -----------------------------------------------------------------------

    /**
     * Container for all possible input permutations.
     */
    public static final class Params {

        @Nullable public final String email;
        @Nullable public final String password;
        @Nullable public final String token;
        public final boolean useBiometric;

        private Params(@Nullable String email,
                       @Nullable String password,
                       @Nullable String token,
                       boolean useBiometric) {
            this.email = email;
            this.password = password;
            this.token = token;
            this.useBiometric = useBiometric;
        }

        public static Params emailPassword(@NonNull String email,
                                           @NonNull String password,
                                           boolean useBiometric) {
            return new Params(email, password, null, useBiometric);
        }

        public static Params externalToken(@NonNull String token,
                                           boolean useBiometric) {
            return new Params(null, null, token, useBiometric);
        }

        public static Params biometricOnly() {
            return new Params(null, null, null, true);
        }
    }

    /**
     * Immutable wrapper for authentication result.
     */
    public static final class Result {

        public final CachedSession session;
        public final boolean isSuccess;

        private Result(boolean success, @Nullable CachedSession session) {
            this.isSuccess = success;
            this.session = session;
        }

        public static Result success(@NonNull CachedSession session) {
            return new Result(true, session);
        }

        public static Result failure() {
            return new Result(false, null);
        }
    }

    /**
     * POJO representing a cached session on disk / keystore.
     */
    public static final class CachedSession {

        private final String accessToken;
        private final String refreshToken;
        private final long createdAtMillis;

        public CachedSession(String accessToken,
                             String refreshToken,
                             long createdAtMillis) {
            this.accessToken = accessToken;
            this.refreshToken = refreshToken;
            this.createdAtMillis = createdAtMillis;
        }

        public String getAccessToken() {
            return accessToken;
        }

        public String getRefreshToken() {
            return refreshToken;
        }

        /**
         * Determines if a session is past its “safe to use” window. The caller
         * may still attempt a silent refresh if needed.
         */
        public boolean isExpired(long threshold, TimeUnit unit) {
            long diff = System.currentTimeMillis() - createdAtMillis;
            return diff > unit.toMillis(threshold);
        }
    }

    // -----------------------------------------------------------------------
    // Exception Hierarchy
    // -----------------------------------------------------------------------

    public abstract static class AuthException extends Exception {

        public static final class NetworkUnavailable extends AuthException {
            public NetworkUnavailable() { super("Network unavailable."); }
        }

        public static final class InvalidParams extends AuthException {
            public InvalidParams() { super("Invalid authentication parameters."); }
        }

        public static final class InvalidCredentials extends AuthException {
            public InvalidCredentials() { super("Invalid user credentials."); }
        }

        public static final class BiometricFailure extends AuthException {
            public BiometricFailure(String message) { super(message); }
        }

        public static final class Unknown extends AuthException {
            public Unknown(Throwable cause) { super(cause); }
        }

        private AuthException(String msg) { super(msg); }
        private AuthException(Throwable cause) { super(cause); }
    }

    // -----------------------------------------------------------------------
    // Interfaces – to be implemented in data layer (repositories/adapters)
    // -----------------------------------------------------------------------

    /**
     * Handles remote API calls for authentication.
     */
    public interface AuthenticationRepository {
        Single<SessionResponse> loginWithEmail(@NonNull String email, @NonNull String password);
        Single<SessionResponse> loginWithToken(@NonNull String token);
    }

    /**
     * Local caching for sessions (Room DB, EncryptedSharedPrefs, etc.).
     */
    public interface SessionRepository {
        @Nullable CachedSession getCachedSession();
        void cacheSession(@NonNull SessionResponse response);
    }

    /**
     * Device biometric helper (FaceID, TouchID, Android Biometrics…).
     */
    public interface BiometricAuthenticator {
        boolean isBiometricAvailable();
        /**
         * Prompts the user for biometric and returns a decrypted auth token
         * (or anything required by the backend) upon success.
         */
        Single<String> authenticate();
    }

    /**
     * Simple online/offline indicator. Could be implemented via
     * ConnectivityManager or OkHttp interceptor.
     */
    public interface NetworkStateProvider {
        boolean isConnected();
    }

    /**
     * Centralised crash/logging API (Firebase Crashlytics, Sentry, etc.).
     */
    public interface CrashReporter {
        void logException(@NonNull String scope, @NonNull Throwable t);
    }

    /**
     * DTO returned by the remote auth endpoint. This sits in the data layer,
     * but is replicated here to keep the file self-contained.
     */
    public static final class SessionResponse {

        private final String accessToken;
        private final String refreshToken;

        public SessionResponse(String accessToken, String refreshToken) {
            this.accessToken = accessToken;
            this.refreshToken = refreshToken;
        }

        public String getAccessToken() { return accessToken; }
        public String getRefreshToken() { return refreshToken; }
    }
}