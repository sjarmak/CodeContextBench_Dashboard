package com.wellsphere.build.gradle;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.Proxy;
import java.net.URL;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Duration;
import java.util.Arrays;
import java.util.Objects;
import java.util.Properties;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.logging.ConsoleHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * A simplified, production-quality replica of the Gradle wrapper bootstrapper.
 * <p>
 * This class is purposely checked-in as <code>gradle/wrapper/gradle-wrapper.jar</code>
 * so that the canonical Gradle wrapper layout is preserved in VCS even though the real
 * JAR is normally a pre-built binary.  At build-time we compile this source into the
 * expected location and ship the byte-code instead.
 *
 * <p>Responsibilities:</p>
 * <ul>
 *     <li>Read <code>gradle-wrapper.properties</code></li>
 *     <li>Download the requested Gradle distribution if absent</li>
 *     <li>Verify expected checksum (SHA-256)</li>
 *     <li>Re-execute the build with the downloaded <code>gradle</code> launcher</li>
 * </ul>
 *
 * <p>
 * NOTE: This implementation is lean compared to Gradle’s official wrapper but demonstrates
 * realistic production concerns: checksum verification, proxy handling, async download,
 * progress feedback, and robust error handling.
 * </p>
 */
public final class GradleWrapper {

    private static final Logger LOG = Logger.getLogger(GradleWrapper.class.getName());

    private static final String PROPERTY_DISTRIBUTION_URL = "distributionUrl";
    private static final String PROPERTY_DISTRIBUTION_SHA256 = "distributionSha256";
    private static final String WRAPPER_PROPERTIES_PATH = "gradle/wrapper/gradle-wrapper.properties";
    private static final String DISTRIBUTION_DIR = "gradle/wrapper/dists";
    private static final int BUFFER_SIZE = 16 * 1024;

    static {
        // Configure root logger to be verbose when wrapper runs standalone
        ConsoleHandler handler = new ConsoleHandler();
        handler.setLevel(Level.INFO);
        LOG.addHandler(handler);
        LOG.setUseParentHandlers(false);
        LOG.setLevel(Level.INFO);
    }

    private GradleWrapper() {
        // util class
    }

    public static void main(String[] args) {
        try {
            new GradleWrapper().run(args);
        } catch (Exception e) {
            LOG.log(Level.SEVERE, "Gradle Wrapper failed: " + e.getMessage(), e);
            System.exit(1);
        }
    }

    private void run(String[] args) throws Exception {
        Properties props = loadWrapperProperties();

        String distributionUrl = props.getProperty(PROPERTY_DISTRIBUTION_URL);
        Objects.requireNonNull(distributionUrl,
                "gradle-wrapper.properties is missing property '" + PROPERTY_DISTRIBUTION_URL + '\'');
        String expectedSha256 = props.getProperty(PROPERTY_DISTRIBUTION_SHA256); // optional in older configs

        File distributionZip = prepareDistribution(distributionUrl, expectedSha256);

        // Delegate execution to the downloaded Gradle distribution.
        invokeGradleLauncher(distributionZip, args);
    }

    private Properties loadWrapperProperties() throws IOException {
        File propsFile = new File(WRAPPER_PROPERTIES_PATH);
        if (!propsFile.isFile()) {
            throw new IllegalStateException("Unable to locate " + WRAPPER_PROPERTIES_PATH + " (" + propsFile.getAbsolutePath() + ")");
        }

        Properties props = new Properties();
        try (InputStream in = new FileInputStream(propsFile)) {
            props.load(in);
        }
        LOG.info("Loaded wrapper properties.");
        return props;
    }

    private File prepareDistribution(String distributionUrl, String expectedSha256) throws Exception {
        URL url = new URL(distributionUrl);
        String filename = new File(url.getPath()).getName();
        File distDir = new File(DISTRIBUTION_DIR);
        if (!distDir.exists() && !distDir.mkdirs()) {
            throw new IOException("Unable to create directory: " + distDir.getAbsolutePath());
        }

        File target = new File(distDir, filename);
        if (target.isFile()) {
            LOG.info("Gradle distribution already present: " + target.getAbsolutePath());
            if (expectedSha256 != null && !expectedSha256.isBlank()) {
                verifyIntegrity(target, expectedSha256);
            }
            return target;
        }

        LOG.info("Gradle distribution not found. Downloading " + distributionUrl);
        downloadFile(url, target);
        if (expectedSha256 != null && !expectedSha256.isBlank()) {
            verifyIntegrity(target, expectedSha256);
        }
        return target;
    }

    private void downloadFile(URL url, File target) throws Exception {
        // Download in a background thread to keep CLI responsive for progress updates.
        Callable<Void> downloadTask = () -> {
            HttpURLConnection conn = (HttpURLConnection) (Proxy.NO_PROXY == null ? url.openConnection() : url.openConnection(Proxy.NO_PROXY));
            conn.setConnectTimeout((int) Duration.ofSeconds(30).toMillis());
            conn.setReadTimeout((int) Duration.ofMinutes(5).toMillis());
            conn.setRequestProperty("User-Agent", "WellSphere-Gradle-Wrapper/1.0");

            long contentLength = conn.getContentLengthLong();
            try (InputStream in = new BufferedInputStream(conn.getInputStream());
                 FileOutputStream out = new FileOutputStream(target)) {

                byte[] buffer = new byte[BUFFER_SIZE];
                long downloaded = 0;
                long lastReport = System.currentTimeMillis();
                int read;
                while ((read = in.read(buffer, 0, BUFFER_SIZE)) >= 0) {
                    out.write(buffer, 0, read);
                    downloaded += read;
                    long now = System.currentTimeMillis();
                    if (now - lastReport > 1500) { // update every ~1.5s
                        printProgress(downloaded, contentLength);
                        lastReport = now;
                    }
                }
            } finally {
                conn.disconnect();
            }
            printProgress(contentLength, contentLength); // final
            System.out.println(); // newline after progress
            return null;
        };

        Future<Void> future = Executors.newSingleThreadExecutor(r -> {
            Thread t = new Thread(r, "gradle-wrapper-download");
            t.setDaemon(true);
            return t;
        }).submit(downloadTask);

        future.get(); // block & surface exceptions
    }

    private void printProgress(long downloaded, long total) {
        if (total <= 0) {
            System.out.printf("\rDownloaded %d bytes", downloaded);
            return;
        }
        int percent = (int) ((downloaded * 100) / total);
        System.out.printf("\rDownloading Gradle: %3d%% (%d / %d MB)", percent,
                downloaded / (1024 * 1024), total / (1024 * 1024));
    }

    private void verifyIntegrity(File target, String expectedSha256) throws IOException, NoSuchAlgorithmException {
        LOG.info("Verifying SHA-256 for " + target.getName());
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        try (DigestInputStream dis = new DigestInputStream(new FileInputStream(target), digest)) {
            //noinspection StatementWithEmptyBody
            while (dis.read() != -1) {
                // digest updates automatically
            }
        }
        byte[] hash = digest.digest();
        String actual = toHex(hash);
        if (!actual.equalsIgnoreCase(expectedSha256)) {
            // Attempt to delete corrupt file so next build re-downloads
            Files.deleteIfExists(target.toPath());
            throw new SecurityException("Gradle distribution checksum mismatch. Expected: "
                    + expectedSha256 + ", Actual: " + actual);
        }
        LOG.info("Checksum verified successfully.");
    }

    private static String toHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 2);
        for (byte b : bytes) {
            sb.append(Character.forDigit((b >> 4) & 0xF, 16))
              .append(Character.forDigit(b & 0xF, 16));
        }
        return sb.toString();
    }

    private void invokeGradleLauncher(File distributionZip, String[] originalArgs) throws IOException, InterruptedException {
        // On first run the distribution may not yet be unpacked. We simply rely on Gradle’s own
        // wrapper scripts being included in the ZIP.  Therefore, we unpack the distribution once
        // and cache the directory.
        File unpackDir = new File(distributionZip.getParentFile(), stripExtension(distributionZip.getName()));
        if (!unpackDir.isDirectory()) {
            unpackGradleZip(distributionZip, unpackDir);
        }

        String gradleExe = isWindows() ? "gradle.bat" : "gradle";
        File launcher = new File(unpackDir, "bin/" + gradleExe);
        if (!launcher.canExecute()) {
            throw new IllegalStateException("Gradle launcher not found or not executable: " + launcher.getAbsolutePath());
        }

        LOG.info("Delegating to Gradle launcher: " + launcher.getAbsolutePath());
        ProcessBuilder pb = new ProcessBuilder();
        pb.command(buildCommandArray(launcher, originalArgs));
        pb.inheritIO(); // forward wrapper stdout/stderr to caller
        pb.environment().put("GRADLE_USER_HOME", new File(System.getProperty("user.home"), ".wellsphere-gradle").getAbsolutePath());

        Process process = pb.start();
        int exit = process.waitFor();
        if (exit != 0) {
            throw new IllegalStateException("Gradle process exited with code " + exit);
        }
    }

    private void unpackGradleZip(File zip, File destDir) throws IOException {
        LOG.info("Unpacking Gradle distribution...");
        java.util.zip.ZipFile zipFile = new java.util.zip.ZipFile(zip);
        try {
            zipFile.stream().forEach(entry -> {
                File out = new File(destDir, entry.getName());
                try {
                    if (entry.isDirectory()) {
                        if (!out.exists() && !out.mkdirs()) {
                            throw new IOException("Failed to create dir: " + out);
                        }
                    } else {
                        File parent = out.getParentFile();
                        if (!parent.exists() && !parent.mkdirs()) {
                            throw new IOException("Failed to create dir: " + parent);
                        }
                        try (InputStream in = zipFile.getInputStream(entry)) {
                            Files.copy(in, out.toPath(), StandardCopyOption.REPLACE_EXISTING);
                        }
                        if (!isWindows() && out.getName().endsWith(".sh")) {
                            out.setExecutable(true);
                        }
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            });
        } finally {
            closeQuietly(zipFile);
        }
        LOG.info("Gradle unpacked to " + destDir.getAbsolutePath());
    }

    private static String[] buildCommandArray(File launcher, String[] originalArgs) {
        String[] cmd = new String[originalArgs.length + 1];
        cmd[0] = launcher.getAbsolutePath();
        System.arraycopy(originalArgs, 0, cmd, 1, originalArgs.length);
        return cmd;
    }

    private static boolean isWindows() {
        return System.getProperty("os.name").toLowerCase().contains("win");
    }

    private static String stripExtension(String filename) {
        int idx = filename.lastIndexOf('.');
        return (idx >= 0) ? filename.substring(0, idx) : filename;
    }

    private static void closeQuietly(Closeable c) {
        try {
            if (c != null) c.close();
        } catch (IOException ignored) {
        }
    }
}