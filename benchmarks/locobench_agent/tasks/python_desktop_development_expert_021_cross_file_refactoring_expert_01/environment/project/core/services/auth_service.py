```python
"""
flockdesk.core.services.auth_service
====================================

Authentication/Authorisation service for the FlockDesk desktop suite.

Responsibilities
----------------
• Authenticate a user against the FlockDesk cloud API
• Persist/restore JSON-Web-Tokens (JWTs) securely via the OS keyring
• Transparently refresh access-tokens before they expire
• Broadcast login/logout/refresh events over the internal event-bus
• Expose helper APIs for signing outbound HTTP requests

All heavy lifting happens asynchronously in order to keep the UI thread
(Qt/PySide6) responsive.

The service is intentionally *headless*—the GUI layer subscribes to the
published events and updates its view-models accordingly.
"""

from __future__ import annotations

import asyncio
import contextlib
import json
import logging
import pathlib
import secrets
import sys
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Optional, final

import aiohttp
import jwt  # PyJWT
import keyring

# --------------------------------------------------------------------------------------
# Fallback stubs – the real implementations live elsewhere in the FlockDesk code-base.
# --------------------------------------------------------------------------------------
try:
    # Prefer the real event bus if we run inside the full application.
    from flockdesk.core.event_bus import EventBus, Event
except ModuleNotFoundError:  # pragma: no cover – unit-test/CI fallback
    class Event(str):
        """Simple event name placeholder."""

    class EventBus:  # pylint: disable=too-few-public-methods
        """Ultra-light pub/sub fallback (in-process, best-effort)."""

        def __init__(self) -> None:
            self._subscribers: Dict[str, list] = {}

        def subscribe(self, event: str, coro) -> None:
            self._subscribers.setdefault(event, []).append(coro)

        async def publish(self, event: str, payload: Any = None) -> None:
            for coro in self._subscribers.get(event, []):
                try:
                    await coro(payload)
                except Exception:  # pragma: no cover
                    logging.exception("Unhandled exception in local EventBus subscriber")

# --------------------------------------------------------------------------------------
# Configuration helpers
# --------------------------------------------------------------------------------------

def _load_runtime_config() -> dict[str, Any]:
    """
    Retrieve configuration from the generated runtime JSON file. During unit-tests
    we fall back to environment variables or sane defaults. In the actual desktop
    build the config is generated by the installer/auto-updater.
    """
    cfg_path = pathlib.Path.home() / ".flockdesk" / "runtime.json"
    if cfg_path.exists():
        try:
            return json.loads(cfg_path.read_text(encoding="utf-8"))
        except Exception:  # pragma: no cover
            logging.warning("Malformed runtime config: %s", cfg_path, exc_info=True)
    # Lightweight fallback
    return {
        "auth_api_url": "https://api.flockdesk.com/auth",
        "client_id": "flockdesk-desktop-dev",
        "token_grace_seconds": 30,
    }


_CFG = _load_runtime_config()

# --------------------------------------------------------------------------------------
# Exceptions
# --------------------------------------------------------------------------------------


class AuthError(RuntimeError):
    """Base-class for authentication related failures."""


class InvalidCredentials(AuthError):
    """Raised when the backend rejects the provided username/password."""


class TokenExpired(AuthError):
    """Raised when a refresh token has expired and a full login is required."""


# --------------------------------------------------------------------------------------
# Data-classes
# --------------------------------------------------------------------------------------


@dataclass(slots=True, frozen=True)
class JwtBundle:
    """Container for our access and refresh tokens."""

    access_token: str
    refresh_token: str
    expires_at: datetime  # UTC


# --------------------------------------------------------------------------------------
# Main AuthService
# --------------------------------------------------------------------------------------


@final
class AuthService:
    """
    The central authentication service. A single instance is created at
    application bootstrap and is exposed via the `get_auth_service()` helper.
    """

    # Key names for secure storage – use unique prefixes to avoid collisions.
    _KEYRING_SERVICE = "flockdesk_desktop"
    _KEY_ACCESS = "access_jwt"
    _KEY_REFRESH = "refresh_jwt"
    _KEY_EXPIRES = "access_expires_utc"

    # Event-bus topics
    EVT_LOGIN_SUCCEEDED = Event("auth/login/succeeded")
    EVT_LOGIN_FAILED = Event("auth/login/failed")
    EVT_LOGOUT = Event("auth/logout")
    EVT_TOKEN_REFRESHED = Event("auth/token/refreshed")

    def __init__(self, bus: EventBus, session: aiohttp.ClientSession | None = None) -> None:
        self._bus = bus
        self._log = logging.getLogger(self.__class__.__name__)
        self._session_external = session  # may be None – we create our own if necessary
        self._session: aiohttp.ClientSession | None = None
        self._token: Optional[JwtBundle] = None
        self._refresh_task: Optional[asyncio.Task] = None
        self._lock = asyncio.Lock()

        # On service start we attempt to restore a persisted session.
        with contextlib.suppress(Exception):
            self._token = self._load_tokens_from_keyring()
            if self._token:
                self._log.info("Restored cached credentials expiring at %s", self._token.expires_at)

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    @property
    def is_authenticated(self) -> bool:
        return self._token is not None

    async def login(self, username: str, password: str) -> None:
        """
        Authenticate against the backend. On success we persist the tokens
        and start the background refresh task.
        """
        async with self._lock:
            await self._ensure_session()

            payload = {
                "username": username,
                "password": password,
                "client_id": _CFG["client_id"],
            }

            self._log.debug("Attempting login for '%s'", username)
            try:
                async with self._session.post(f"{_CFG['auth_api_url']}/login", json=payload, timeout=10) as resp:
                    if resp.status == 401:
                        raise InvalidCredentials("Username or password incorrect.")

                    resp.raise_for_status()
                    data = await resp.json()
            except aiohttp.ClientResponseError as exc:
                self._log.error("Login failed: %s", exc)
                await self._bus.publish(self.EVT_LOGIN_FAILED, {"message": str(exc)})
                raise AuthError("Unable to contact authentication server.") from exc

            self._token = self._parse_server_response(data)
            self._store_tokens_to_keyring(self._token)
            self._schedule_refresh()

        self._log.info("User '%s' successfully logged in.", username)
        await self._bus.publish(self.EVT_LOGIN_SUCCEEDED, {"user": username})

    async def logout(self) -> None:
        """
        Clears credentials and stops the refresh loop. Does *not* call the backend
        in order to stay snappy; the server auto-expires tokens anyway.
        """
        async with self._lock:
            self._cancel_refresh()
            self._clear_keyring()
            self._token = None

        await self._bus.publish(self.EVT_LOGOUT)
        self._log.info("Local session terminated by user request.")

    async def sign_headers(self, extra_headers: Optional[Dict[str, str]] = None) -> Dict[str, str]:
        """
        Helper to enrich outbound HTTP requests with the `Authorization` header.
        Raises TokenExpired if no valid access token is present.
        """
        if not self._token:
            raise TokenExpired("No valid access-token. User must login first.")

        return {
            "Authorization": f"Bearer {self._token.access_token}",
            **(extra_headers or {}),
        }

    # ------------------------------------------------------------------
    # Token handling
    # ------------------------------------------------------------------

    def _parse_server_response(self, data: Dict[str, Any]) -> JwtBundle:
        try:
            access = data["access_token"]
            refresh = data["refresh_token"]
            expires_sec = int(data.get("expires_in", 3600))
        except (KeyError, ValueError) as exc:
            raise AuthError("Malformed response from authentication server.") from exc

        expires_at = datetime.now(timezone.utc) + timedelta(seconds=expires_sec)
        return JwtBundle(access_token=access, refresh_token=refresh, expires_at=expires_at)

    # ------------------------------------------------------------------
    # Background refresh logic
    # ------------------------------------------------------------------

    def _schedule_refresh(self) -> None:
        # Cancel old task (if any) and start a fresh one.
        self._cancel_refresh()
        self._refresh_task = asyncio.create_task(self._refresh_loop(), name="FD-AuthRefresh")
        self._refresh_task.add_done_callback(self._on_refresh_task_done)

    def _cancel_refresh(self) -> None:
        if self._refresh_task:
            self._refresh_task.cancel()
            self._refresh_task = None

    async def _refresh_loop(self) -> None:
        """
        Periodically refresh the access token using the stored refresh token.
        """
        assert self._token  # mypy happy →

        while True:
            # Sleep until `expires_at` minus some grace period
            now = datetime.now(timezone.utc)
            delta = (self._token.expires_at - now).total_seconds() - _CFG["token_grace_seconds"]
            delta = max(delta, 0)
            self._log.debug("Next token refresh in %.1f seconds.", delta)
            try:
                await asyncio.sleep(delta)
            except asyncio.CancelledError:
                self._log.debug("Refresh loop cancelled.")
                break

            async with self._lock:
                # Double-check state inside lock in case of race conditions
                if not self._token:
                    break
                await self._ensure_session()

                payload = {
                    "refresh_token": self._token.refresh_token,
                    "client_id": _CFG["client_id"],
                }
                try:
                    async with self._session.post(f"{_CFG['auth_api_url']}/refresh", json=payload, timeout=10) as resp:
                        if resp.status == 401:
                            raise TokenExpired("Refresh token invalid/expired.")

                        resp.raise_for_status()
                        data = await resp.json()
                except Exception as exc:  # broad on purpose – network/system errors
                    # If refresh fails we give it one more chance after grace period.
                    self._log.warning("Token refresh failed: %s", exc, exc_info=True)
                    await asyncio.sleep(5)
                    continue

                self._token = self._parse_server_response(data)
                self._store_tokens_to_keyring(self._token)

            self._log.info("Access token successfully refreshed; next expiry %s", self._token.expires_at)
            await self._bus.publish(self.EVT_TOKEN_REFRESHED)

    def _on_refresh_task_done(self, task: asyncio.Task) -> None:
        with contextlib.suppress(asyncio.CancelledError):
            exc = task.exception()
            if exc:
                self._log.error("Background refresh task stopped with error: %s", exc, exc_info=True)
                # If the task crashed, we re-schedule once.
                self._schedule_refresh()

    # ------------------------------------------------------------------
    # Keyring helpers
    # ------------------------------------------------------------------

    def _store_tokens_to_keyring(self, bundle: JwtBundle) -> None:
        """
        Persist tokens securely inside the system keyring. We use three
        separate entries to keep secrets and metadata decoupled.
        """
        keyring.set_password(self._KEYRING_SERVICE, self._KEY_ACCESS, bundle.access_token)
        keyring.set_password(self._KEYRING_SERVICE, self._KEY_REFRESH, bundle.refresh_token)
        keyring.set_password(
            self._KEYRING_SERVICE, self._KEY_EXPIRES, bundle.expires_at.isoformat()
        )

    def _load_tokens_from_keyring(self) -> Optional[JwtBundle]:
        access = keyring.get_password(self._KEYRING_SERVICE, self._KEY_ACCESS)
        refresh = keyring.get_password(self._KEYRING_SERVICE, self._KEY_REFRESH)
        expires_iso = keyring.get_password(self._KEYRING_SERVICE, self._KEY_EXPIRES)

        if not all((access, refresh, expires_iso)):
            return None

        try:
            expires_at = datetime.fromisoformat(expires_iso).astimezone(timezone.utc)
        except (ValueError, TypeError):  # pragma: no cover
            self._clear_keyring()
            return None

        if expires_at <= datetime.now(timezone.utc):
            self._log.info("Cached access token has already expired.")
            return None

        return JwtBundle(access_token=access, refresh_token=refresh, expires_at=expires_at)

    def _clear_keyring(self) -> None:
        for key in (self._KEY_ACCESS, self._KEY_REFRESH, self._KEY_EXPIRES):
            with contextlib.suppress(Exception):
                keyring.delete_password(self._KEYRING_SERVICE, key)

    # ------------------------------------------------------------------
    # Internals
    # ------------------------------------------------------------------

    async def _ensure_session(self) -> None:
        """
        Lazily create the aiohttp session to avoid creating event-loop
        dependent objects at import time.
        """
        if self._session:
            return

        if self._session_external:
            self._session = self._session_external
        else:
            self._session = aiohttp.ClientSession(
                json_serialize=lambda obj: json.dumps(obj, default=str)
            )

    async def shutdown(self) -> None:
        """
        Called by the application during graceful shutdown.
        """
        self._cancel_refresh()
        if self._session and not self._session_external:
            await self._session.close()
            self._session = None

    # ------------------------------------------------------------------
    # Decoding helpers (may be used by other services)
    # ------------------------------------------------------------------

    def get_claims(self, verify_signature: bool = False, key: str | None = None) -> Dict[str, Any]:
        """
        Decode the current access token and return its claims.

        Parameters
        ----------
        verify_signature:
            When True, the token signature is verified using the provided key.
        key:
            The public key or secret used for verification. Required if
            `verify_signature` is True.
        """
        if not self._token:
            raise AuthError("No active token.")

        options = {"verify_signature": verify_signature}
        try:
            return jwt.decode(
                self._token.access_token,
                key=key,
                algorithms=["HS256", "RS256"],
                options=options,
            )
        except jwt.PyJWTError as exc:
            raise AuthError("Invalid JWT.") from exc


# --------------------------------------------------------------------------------------
# Singleton helper – importing modules can call `get_auth_service()`.
# --------------------------------------------------------------------------------------

_auth_singleton: AuthService | None = None


def get_auth_service() -> AuthService:
    global _auth_singleton  # pylint: disable=global-statement
    if _auth_singleton is None:
        _auth_singleton = AuthService(bus=EventBus())
    return _auth_singleton


# --------------------------------------------------------------------------------------
# Quick stand-alone verification (run `python -m flockdesk.core.services.auth_service`).
# --------------------------------------------------------------------------------------

if __name__ == "__main__":  # pragma: no cover
    logging.basicConfig(level=logging.DEBUG, stream=sys.stdout)
    auth = get_auth_service()

    async def _demo() -> None:
        # Supply dummy credentials here or set environment variables
        try:
            await auth.login("demo@example.com", "hunter2")
        except InvalidCredentials:
            print("Invalid credentials")
        finally:
            await auth.shutdown()

    asyncio.run(_demo())
```