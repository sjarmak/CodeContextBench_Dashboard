```javascript
/**
 * PulseLearn Campus Hub
 * Auth-Service → User Model / Repository
 *
 * NOTE:
 * The file is named “user.prisma” in the legacy folder structure even
 * though it contains JavaScript.  A future migration will rename the
 * file to “user.repository.js” once the build-scripts are updated.
 */

import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';
import { randomUUID } from 'crypto';
import EventEmitter from 'events';

/* -------------------------------------------------------------------------- */
/*                         Prisma Singleton / Lazy Init                       */
/* -------------------------------------------------------------------------- */

let prisma = global.__pulselearn_prisma__;
if (!prisma) {
  prisma = new PrismaClient({
    log: ['error', 'warn'],
  });
  if (process.env.NODE_ENV !== 'production') {
    global.__pulselearn_prisma__ = prisma; // Prevent hot-reload multiple instances
  }
}

/* -------------------------------------------------------------------------- */
/*                               Event Emitter                                */
/* -------------------------------------------------------------------------- */
/**
 * In production, this EventEmitter is replaced by a Kafka / NATS adapter.
 * For the model layer we keep the interface minimal:
 *   eventBus.emit('DomainEvent', payload)
 */
export const eventBus = new EventEmitter();

/* -------------------------------------------------------------------------- */
/*                                 Constants                                  */
/* -------------------------------------------------------------------------- */

const SALT_ROUNDS = 12; // bcrypt cost factor
const DEFAULT_ROLE = 'STUDENT'; // fallback

/* -------------------------------------------------------------------------- */
/*                            Custom Error Classes                            */
/* -------------------------------------------------------------------------- */

export class UserAlreadyExistsError extends Error {
  constructor(message = 'User already exists.') {
    super(message);
    this.name = 'UserAlreadyExistsError';
  }
}

export class UserNotFoundError extends Error {
  constructor(message = 'User not found.') {
    super(message);
    this.name = 'UserNotFoundError';
  }
}

export class InvalidCredentialsError extends Error {
  constructor(message = 'Invalid email or password.') {
    super(message);
    this.name = 'InvalidCredentialsError';
  }
}

/* -------------------------------------------------------------------------- */
/*                                User Schema                                 */
/* -------------------------------------------------------------------------- */
/**
 * The Prisma schema for the `User` model is declared in
 *   prisma/schema.prisma
 *
 *  model User {
 *    id              String    @id @default(uuid())
 *    email           String?   @unique
 *    passwordHash    String?
 *    provider        String    // 'LOCAL' | 'GOOGLE' | 'FACEBOOK' | etc.
 *    providerId      String?   // social provider unique identifier
 *    displayName     String
 *    role            String
 *    isActive        Boolean   @default(true)
 *    lastLoginAt     DateTime?
 *    createdAt       DateTime  @default(now())
 *    updatedAt       DateTime  @updatedAt
 *  }
 */

/* -------------------------------------------------------------------------- */
/*                              Helper Functions                              */
/* -------------------------------------------------------------------------- */

/**
 * Hash a plain-text password
 */
async function hashPassword(plainPassword) {
  return bcrypt.hash(plainPassword, SALT_ROUNDS);
}

/**
 * Compare a plain-text password with a bcrypt hash
 */
async function verifyPassword(plainPassword, hash) {
  return bcrypt.compare(plainPassword, hash);
}

/* -------------------------------------------------------------------------- */
/*                           User Repository Class                            */
/* -------------------------------------------------------------------------- */

class UserRepository {
  /**
   * Create a local account (email + password)
   */
  async registerLocal({ email, password, displayName, role = DEFAULT_ROLE }) {
    // 1. Check for duplicates
    const existing = await prisma.user.findUnique({ where: { email } });
    if (existing) {
      throw new UserAlreadyExistsError();
    }

    // 2. Hash password
    const passwordHash = await hashPassword(password);

    // 3. Persist
    const user = await prisma.user.create({
      data: {
        id: randomUUID(),
        email,
        passwordHash,
        provider: 'LOCAL',
        displayName,
        role,
      },
    });

    // 4. Emit domain event
    eventBus.emit('UserRegistered', {
      userId: user.id,
      provider: 'LOCAL',
      occurredAt: new Date().toISOString(),
    });

    return user;
  }

  /**
   * Create or return a social login account.
   * If the user already exists (matched by provider + providerId), we
   * simply return it.  We intentionally DO NOT merge by email for security
   * reasons (duplicate emails across providers is possible).
   */
  async registerOrLoginSocial({
    provider,
    providerId,
    email = null,
    displayName,
    role = DEFAULT_ROLE,
  }) {
    const existing = await prisma.user.findFirst({
      where: { provider, providerId },
    });

    if (existing) {
      await prisma.user.update({
        where: { id: existing.id },
        data: { lastLoginAt: new Date() },
      });

      eventBus.emit('UserLoggedIn', {
        userId: existing.id,
        provider,
        occurredAt: new Date().toISOString(),
      });

      return existing;
    }

    // New social account
    const user = await prisma.user.create({
      data: {
        id: randomUUID(),
        email, // might be null if provider does not share email
        provider,
        providerId,
        displayName,
        role,
      },
    });

    eventBus.emit('UserRegistered', {
      userId: user.id,
      provider,
      occurredAt: new Date().toISOString(),
    });

    return user;
  }

  /**
   * Validate email/password credentials and return user
   */
  async loginLocal({ email, password }) {
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user || !user.passwordHash) {
      throw new InvalidCredentialsError();
    }

    const isValid = await verifyPassword(password, user.passwordHash);
    if (!isValid) {
      throw new InvalidCredentialsError();
    }

    await prisma.user.update({
      where: { id: user.id },
      data: { lastLoginAt: new Date() },
    });

    eventBus.emit('UserLoggedIn', {
      userId: user.id,
      provider: 'LOCAL',
      occurredAt: new Date().toISOString(),
    });

    return user;
  }

  /**
   * Fetch user by ID
   */
  async findById(id) {
    const user = await prisma.user.findUnique({ where: { id } });
    if (!user) throw new UserNotFoundError();
    return user;
  }

  /**
   * Fetch user by email (LOCAL accounts only)
   */
  async findByEmail(email) {
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) throw new UserNotFoundError();
    return user;
  }

  /**
   * Update mutable user information
   */
  async updateUser(id, data) {
    const user = await prisma.user.update({ where: { id }, data });
    eventBus.emit('UserUpdated', {
      userId: id,
      occurredAt: new Date().toISOString(),
      changes: Object.keys(data),
    });
    return user;
  }

  /**
   * Soft-delete (deactivate) a user
   */
  async deactivateUser(id) {
    const user = await prisma.user.update({
      where: { id },
      data: { isActive: false },
    });

    eventBus.emit('UserDeactivated', {
      userId: id,
      occurredAt: new Date().toISOString(),
    });

    return user;
  }

  /**
   * Remove a user permanently (admin-only)
   */
  async deleteUser(id) {
    // Cascading deletes are handled via Prisma “onDelete: Cascade”
    const user = await prisma.user.delete({ where: { id } });

    eventBus.emit('UserDeleted', {
      userId: id,
      occurredAt: new Date().toISOString(),
    });

    return user;
  }
}

/* -------------------------------------------------------------------------- */
/*                              Export Singleton                              */
/* -------------------------------------------------------------------------- */

export const userRepository = new UserRepository();
export default userRepository;

/* -------------------------------------------------------------------------- */
/*                               Graceful Exit                                */
/* -------------------------------------------------------------------------- */
if (process.env.NODE_ENV === 'production') {
  process.once('SIGTERM', async () => {
    await prisma.$disconnect();
    process.exit(0);
  });
}
```