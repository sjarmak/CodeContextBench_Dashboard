// ---------------------------------------
//  Prisma Schema for PulseLearn Campus Hub
//  Service  : Course Service
//  File Path: pulselearn-campus-hub/services/course-service/src/models/schema.prisma
//
//  NOTE:
//  1. This schema is scoped to its own Postgres schema (`course_service`) to
//     allow clean separation between micro-services while sharing the same DB.
//  2. The `EventOutbox` pattern is used to guarantee atomic writes between
//     domain data and integration events that will later be published to the
//     message bus (Kafka/NATS) by a separate worker.
//  3. Cross-service relations (e.g. `User`) are expressed as scalar foreign
//     keys without referential constraints because ownership lives in a
//     dedicated Auth/User service.
// ---------------------------------------

generator client {
  provider        = "prisma-client-js"
  previewFeatures = [
    "fullTextSearch",        // Enables Postgres full-text indices
    "interactiveTransactions",
    "referentialActions",
    "multiSchema"            // Each micro-service owns its own DB schema
  ]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  schemas   = ["course_service"]
}

// ------------
// Enumerations
// ------------

enum Role {
  STUDENT
  INSTRUCTOR
  ADMIN
}

enum CourseVisibility {
  PUBLIC
  PRIVATE
  INVITE_ONLY
}

enum AssignmentType {
  QUIZ
  PROJECT
  ESSAY
  PEER_REVIEW
}

enum EnrollmentStatus {
  ENROLLED
  COMPLETED
  WITHDRAWN
  BANNED
}

// ---------------
// Core Data Models
// ---------------

model Course {
  id             String            @id @default(uuid())
  slug           String            @unique
  code           String?           @db.VarChar(16)
  title          String            @db.VarChar(120)
  synopsis       String?           @db.VarChar(1024)
  description    String?
  coverImageUrl  String?           @db.VarChar(2048)
  visibility     CourseVisibility  @default(PUBLIC)
  language       String            @default("en") @db.Char(5)
  creditHours    Int               @default(0)
  published      Boolean           @default(false)
  publishedAt    DateTime?
  archivedAt     DateTime?
  ownerId        String            // FK → Auth Service `User`
  tags           CourseTag[]       // many-to-many
  categories     CourseCategory[]  // many-to-many
  modules        Module[]
  enrollments    Enrollment[]
  assignments    Assignment[]
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  @@index([ownerId])
  @@fulltext([title, synopsis, description])
}

model Module {
  id          String     @id @default(uuid())
  course      Course     @relation(fields: [courseId], references: [id], onDelete: Cascade)
  courseId    String
  sequence    Int        // 0-based ordering within the course
  title       String     @db.VarChar(120)
  overview    String?    @db.VarChar(1024)
  lessons     Lesson[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([courseId, sequence], map: "idx_module_course_sequence")
  @@unique([courseId, sequence], map: "uq_module_course_sequence")
}

model Lesson {
  id          String     @id @default(uuid())
  module      Module     @relation(fields: [moduleId], references: [id], onDelete: Cascade)
  moduleId    String
  sequence    Int
  title       String     @db.VarChar(120)
  contentMd   String?
  videoUrl    String?    @db.VarChar(2048)
  durationSec Int?       // for video lessons
  assignments Assignment[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([moduleId, sequence], map: "idx_lesson_module_sequence")
  @@unique([moduleId, sequence], map: "uq_lesson_module_sequence")
  @@fulltext([title, contentMd])
}

model Enrollment {
  // Composite primary key (courseId, studentId)
  courseId   String
  studentId  String
  status     EnrollmentStatus @default(ENROLLED)
  progress   Decimal          @db.Decimal(5, 2) // percentage 0.00-100.00
  startedAt  DateTime         @default(now())
  completedAt DateTime?
  withdrawnAt DateTime?

  course     Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@id([courseId, studentId])
  @@index([studentId], map: "idx_enrollment_student")
}

model Assignment {
  id            String          @id @default(uuid())
  courseId      String
  lessonId      String?
  type          AssignmentType  @default(PROJECT)
  title         String          @db.VarChar(120)
  instructions  String?
  dueAt         DateTime?
  maxScore      Int             @default(100)
  gradingSchema Json?
  metadata      Json?
  submissions   Submission[]
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  course        Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  lesson        Lesson?  @relation(fields: [lessonId], references: [id], onDelete: Cascade)

  @@index([courseId])
  @@index([lessonId])
  @@fulltext([title, instructions])
}

model Submission {
  id           String   @id @default(uuid())
  assignment   Assignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  assignmentId String
  studentId    String
  submittedAt  DateTime  @default(now())
  fileUrl      String?   @db.VarChar(2048)
  answerJson   Json?     // for quiz-type answers
  score        Decimal?  @db.Decimal(5, 2)
  feedback     String?
  gradedAt     DateTime?
  graderId     String?   // FK → User that graded

  @@unique([assignmentId, studentId], map: "uq_submission_assignment_student")
  @@index([studentId], map: "idx_submission_student")
}

model Tag {
  id        String      @id @default(uuid())
  name      String      @unique
  courses   CourseTag[]
  createdAt DateTime    @default(now())
}

model Category {
  id        String          @id @default(uuid())
  slug      String          @unique
  name      String          @db.VarChar(64)
  courses   CourseCategory[]
  createdAt DateTime        @default(now())
}

model CourseTag {
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
  courseId String
  tag      Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)
  tagId    String

  @@id([courseId, tagId])
  @@index([tagId], map: "idx_coursetag_tag")
}

model CourseCategory {
  course     Course    @relation(fields: [courseId], references: [id], onDelete: Cascade)
  courseId   String
  category   Category  @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId String

  @@id([courseId, categoryId])
  @@index([categoryId], map: "idx_coursecategory_category")
}

// -----------------------------
// Transactional Domain Outbox
// -----------------------------
//  Outbox entries are created within the same transaction as domain writes.
//  A separate worker polls unprocessed rows and publishes them to the
//  message bus, then sets `processedAt`.

model EventOutbox {
  id           String   @id @default(uuid())
  aggregateId  String   // e.g., Course/Enrollment UUID
  eventType    String   @db.VarChar(64) // e.g., "CourseCreated"
  topic        String   @db.VarChar(64) // Kafka/NATS topic
  payload      Json
  createdAt    DateTime @default(now())
  processedAt  DateTime?

  @@index([processedAt], map: "idx_outbox_processed")
}

// -------------
// Audit Logging
// -------------
//  Basic, tamper-evident audit log. Writes are append-only and immutable.

model AuditLog {
  id          BigInt    @id @default(autoincrement())
  actorId     String?   // User that performed the action
  actorRole   Role?
  action      String    @db.VarChar(64)  // e.g., "CREATE_COURSE"
  entity      String    @db.VarChar(64)  // e.g., "Course"
  entityId    String?   // UUID of the entity
  before      Json?     // snapshot diff
  after       Json?
  ipAddress   String?   @db.VarChar(46)
  userAgent   String?   @db.VarChar(256)
  createdAt   DateTime  @default(now())

  @@index([actorId], map: "idx_audit_actor")
  @@index([entity, entityId], map: "idx_audit_entity")
}