/************************************************************
 * File: frontend/public/favicon.ico
 * NOTE:
 *   Although the file extension is “.ico”, we deliberately
 *   place JavaScript inside the file so that it can be served
 *   by the front-end build system as a dynamic module while
 *   still being resolved as the browser’s favicon in
 *   production bundles.  The build pipeline renames /
 *   extracts the actual icon at compile‐time, while this
 *   source remains pure JavaScript for development.
 *
 *   Purpose:
 *     Dynamically generate and update the favicon to reflect
 *     live notification counts, user presence, or any other
 *     event-driven state emitted by the PulseLearn Campus Hub
 *     front-end.  This improves UX by providing at-a-glance
 *     feedback—even when the tab is in the background—without
 *     requiring intrusive push notifications.
 ************************************************************/

/* eslint-disable no-console */

import mitt from 'mitt';                  // 1-KB event-bus library
import debounce from 'lodash.debounce';   // battle-tested debouncer

/****************************************************************
 * Event Channel
 ****************************************************************/
const bus = mitt();

/**
 * PulseLearn publishes domain events (AssignmentSubmitted,
 * BadgeAwarded, etc.) on a server-side message bus.  On the
 * browser we mirror a subset of those events into this tiny
 * emitter to keep the favicon logic decoupled from any global
 * state manager (e.g. Redux/Pinia/VueX).  Other modules can
 * `bus.emit('notification', { count: n })` and this module will
 * react appropriately.
 */
export const faviconChannel = {
  on: bus.on,
  off: bus.off,
  emit: bus.emit
};

/****************************************************************
 * Constants
 ****************************************************************/
const DEFAULT_ICON_PATH = '/favicon.ico';  // Static icon bundled by Vite/Webpack
const CANVAS_SIZE = 64;                    // Browser will down-scale
const FONT_FAMILY = 'system-ui, sans-serif';
const BADGE_BG_COLOR = '#d0021b';          // Red badge
const BADGE_TEXT_COLOR = '#ffffff';

/****************************************************************
 * DOM Helpers
 ****************************************************************/

/**
 * Ensures there is a single <link rel="icon"> element and
 * returns it, creating one if necessary.
 */
function ensureIconLink() {
  let link = document.querySelector('link[rel="icon"]');
  if (!link) {
    link             = document.createElement('link');
    link.rel         = 'icon';
    link.type        = 'image/png';
    link.href        = DEFAULT_ICON_PATH;
    document.head.appendChild(link);
  }
  return link;
}

/****************************************************************
 * Renderer
 ****************************************************************/

/**
 * Draws a numeric badge on top of the base favicon and returns
 * a data URL that can be assigned to <link rel="icon">.
 *
 * @param {HTMLImageElement} baseIcon  Loaded favicon image
 * @param {number} count               Unread or pending count
 * @returns {string}                   data:image/png;base64,...
 */
function renderBadge(baseIcon, count) {
  // Clamp to 2-digit display (e.g., 99+)
  const label = count > 99 ? '99+' : String(count);

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_SIZE;
  canvas.height = CANVAS_SIZE;

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.warn('[favicon] Canvas context unavailable');
    return DEFAULT_ICON_PATH;
  }

  // Draw base icon
  ctx.drawImage(baseIcon, 0, 0, CANVAS_SIZE, CANVAS_SIZE);

  // Calculate badge position
  const badgeRadius = CANVAS_SIZE * 0.3;
  const centerX     = CANVAS_SIZE - badgeRadius;
  const centerY     = badgeRadius;

  // Badge background circle
  ctx.beginPath();
  ctx.arc(centerX, centerY, badgeRadius, 0, 2 * Math.PI);
  ctx.fillStyle = BADGE_BG_COLOR;
  ctx.fill();

  // Badge text
  ctx.font = `bold ${badgeRadius * 0.9}px ${FONT_FAMILY}`;
  ctx.fillStyle = BADGE_TEXT_COLOR;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, centerX, centerY);

  return canvas.toDataURL('image/png');
}

/****************************************************************
 * Favicon Service
 ****************************************************************/
class FaviconService {
  #baseIcon = null;   // Loaded HTMLImageElement
  #pendingCount = 0;
  #linkEl = null;

  constructor() {
    this.#linkEl = ensureIconLink();
    this.#loadBaseIcon()
      .then(() => this.#apply())    // draw initial icon
      .catch(console.error);

    // Listen for notification events
    faviconChannel.on('notification', this.#handleNotification);
    faviconChannel.on('session:logout', this.#handleSessionExpired);
  }

  destroy() {
    faviconChannel.off('notification', this.#handleNotification);
    faviconChannel.off('session:logout', this.#handleSessionExpired);
    this.#restoreDefault();
  }

  /**************************************************************
   * Event Handlers
   **************************************************************/
  #handleNotification = debounce(({ count = 0 }) => {
    this.#pendingCount = count;
    this.#apply();
  }, 100);

  #handleSessionExpired = () => {
    // PulseLearn business rule: display grayscale icon on logout
    this.#setGrayscale();
  };

  /**************************************************************
   * Private Helpers
   **************************************************************/
  async #loadBaseIcon() {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous'; // allow canvas pixel read
      img.src = this.#linkEl.href || DEFAULT_ICON_PATH;
      img.onload = () => {
        this.#baseIcon = img;
        resolve();
      };
      img.onerror = (e) => {
        console.error('[favicon] Failed to load base icon', e);
        reject(e);
      };
    });
  }

  #apply() {
    if (!this.#baseIcon) return;

    // If no unread count, revert to default
    if (this.#pendingCount <= 0) {
      this.#restoreDefault();
      return;
    }

    const url = renderBadge(this.#baseIcon, this.#pendingCount);
    this.#linkEl.href = url;
  }

  #restoreDefault() {
    this.#linkEl.href = DEFAULT_ICON_PATH;
  }

  #setGrayscale() {
    if (!this.#baseIcon) return;

    const canvas = document.createElement('canvas');
    canvas.width = this.#baseIcon.width;
    canvas.height = this.#baseIcon.height;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.drawImage(this.#baseIcon, 0, 0);

    // Simple grayscale conversion
    const imgData = ctx.getImageData(
      0,
      0,
      canvas.width,
      canvas.height
    );
    for (let i = 0; i < imgData.data.length; i += 4) {
      const avg =
        (imgData.data[i] +
          imgData.data[i + 1] +
          imgData.data[i + 2]) /
        3;
      imgData.data[i] = avg;
      imgData.data[i + 1] = avg;
      imgData.data[i + 2] = avg;
    }
    ctx.putImageData(imgData, 0, 0);
    this.#linkEl.href = canvas.toDataURL('image/png');
  }
}

/**************************************************************
 * Initialize service automatically in browser contexts
 **************************************************************/
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  // eslint-disable-next-line no-new
  new FaviconService();
}

/**************************************************************
 * Public API (optional)
 **************************************************************/
export function updateNotificationCount(count) {
  faviconChannel.emit('notification', { count });
}

export function signalSessionExpired() {
  faviconChannel.emit('session:logout');
}

/**
 * Usage Example (anywhere in front-end):
 *
 *   import { updateNotificationCount } from '/public/favicon.ico';
 *
 *   websocket.on('newMessage', () => {
 *     unreadMessages++;
 *     updateNotificationCount(unreadMessages);
 *   });
 *
 *   // On logout
 *   signalSessionExpired();
 *
 ****************************************************************/

