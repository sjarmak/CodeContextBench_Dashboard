```rust
//! src/module_23.rs
//!
//! Learning Pulse domain module.
//!
//! This module demonstrates a realistic slice of the EduPulse Live backend.  It
//! combines repository‐pattern persistence, a service layer that publishes
//! domain events, and a RabbitMQ-based event publisher.  All I/O is asynchronous
//! and instrumented for structured logging with `tracing`.
//!
//! The code is self-contained and can be wired into the rest of the workspace
//! by exposing the public types in `lib.rs`.

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use lapin::{
    options::{BasicPublishOptions, QueueDeclareOptions},
    types::FieldTable,
    BasicProperties, Channel, Connection, ConnectionProperties,
};
use serde::{Deserialize, Serialize};
use sqlx::{postgres::PgRow, PgPool, Row};
use std::{fmt, sync::Arc};
use thiserror::Error;
use tracing::{error, info};
use uuid::Uuid;

/// Generic error type for the module.
#[derive(Debug, Error)]
pub enum PulseError {
    #[error("database error: {0}")]
    Db(#[from] sqlx::Error),

    #[error("message broker error: {0}")]
    Broker(#[from] lapin::Error),

    #[error("validation error: {0}")]
    Validation(String),
}

/// Domain entity: a short activity or challenge posted by a teacher.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LearningPulse {
    pub id: Uuid,
    pub title: String,
    pub description: String,
    pub author_id: Uuid,
    pub created_at: DateTime<Utc>,
}

/// Factory + validation.
impl LearningPulse {
    pub fn new<T: Into<String>>(
        title: T,
        description: T,
        author_id: Uuid,
    ) -> Result<Self, PulseError> {
        let title = title.into();
        if title.trim().is_empty() || title.len() > 200 {
            return Err(PulseError::Validation(
                "title must be non-empty and ≤ 200 chars".into(),
            ));
        }

        let description = description.into();
        if description.trim().is_empty() {
            return Err(PulseError::Validation("description must be non-empty".into()));
        }

        Ok(Self {
            id: Uuid::new_v4(),
            title,
            description,
            author_id,
            created_at: Utc::now(),
        })
    }
}

/// Domain event emitted right after a pulse is created.
#[derive(Debug, Clone, Serialize)]
pub struct PulseCreated {
    pub pulse_id: Uuid,
    pub author_id: Uuid,
    pub occurred_at: DateTime<Utc>,
}

/// Marker trait for all outbound events.
pub trait DomainEvent: Serialize + Send + Sync {
    fn event_type(&self) -> &'static str;
}

impl DomainEvent for PulseCreated {
    fn event_type(&self) -> &'static str {
        "edu.pulse.created"
    }
}

/// Abstraction over event publishing.
#[async_trait]
pub trait EventPublisher: Send + Sync {
    async fn publish<E: DomainEvent>(&self, evt: &E) -> Result<(), PulseError>;
}

/// A RabbitMQ implementation of the EventPublisher.
/// Exchanges are of type `topic` and declared on creation.
pub struct RabbitMqPublisher {
    channel: Channel,
    exchange: String,
}

impl RabbitMqPublisher {
    pub async fn connect(uri: &str, exchange: &str) -> Result<Self, PulseError> {
        let conn = Connection::connect(uri, ConnectionProperties::default()).await?;
        let channel = conn.create_channel().await?;

        channel
            .exchange_declare(
                exchange,
                lapin::ExchangeKind::Topic,
                lapin::options::ExchangeDeclareOptions {
                    durable: true,
                    auto_delete: false,
                    ..Default::default()
                },
                FieldTable::default(),
            )
            .await?;

        Ok(Self {
            channel,
            exchange: exchange.to_owned(),
        })
    }
}

#[async_trait]
impl EventPublisher for RabbitMqPublisher {
    async fn publish<E: DomainEvent>(&self, evt: &E) -> Result<(), PulseError> {
        let routing_key = evt.event_type();
        let payload = serde_json::to_vec(evt).expect("serializing domain event cannot fail");

        self.channel
            .basic_publish(
                &self.exchange,
                routing_key,
                BasicPublishOptions::default(),
                &payload,
                BasicProperties::default().with_content_type("application/json".into()),
            )
            .await?
            .await?; // confirm

        info!(event = routing_key, "published domain event");
        Ok(())
    }
}

/// Repository for LearningPulse persistence.
#[async_trait]
pub trait LearningPulseRepository: Send + Sync {
    async fn create(&self, pulse: &LearningPulse) -> Result<(), PulseError>;
    async fn find(&self, pulse_id: Uuid) -> Result<Option<LearningPulse>, PulseError>;
}

/// PostgreSQL implementation using `sqlx`.
pub struct PostgresPulseRepository {
    pool: PgPool,
}

impl PostgresPulseRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl LearningPulseRepository for PostgresPulseRepository {
    async fn create(&self, pulse: &LearningPulse) -> Result<(), PulseError> {
        sqlx::query(
            r#"
            INSERT INTO learning_pulses (id, title, description, author_id, created_at)
            VALUES ($1, $2, $3, $4, $5)
            "#,
        )
        .bind(pulse.id)
        .bind(&pulse.title)
        .bind(&pulse.description)
        .bind(pulse.author_id)
        .bind(pulse.created_at)
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    async fn find(&self, pulse_id: Uuid) -> Result<Option<LearningPulse>, PulseError> {
        let maybe_row: Option<PgRow> = sqlx::query(
            r#"
            SELECT id, title, description, author_id, created_at
            FROM learning_pulses
            WHERE id = $1
            "#,
        )
        .bind(pulse_id)
        .fetch_optional(&self.pool)
        .await?;

        Ok(maybe_row.map(|row| LearningPulse {
            id: row.get("id"),
            title: row.get("title"),
            description: row.get("description"),
            author_id: row.get("author_id"),
            created_at: row.get("created_at"),
        }))
    }
}

/// Service layer that orchestrates creation and event publishing.
pub struct LearningPulseService<R, P>
where
    R: LearningPulseRepository,
    P: EventPublisher,
{
    repo: Arc<R>,
    publisher: Arc<P>,
}

impl<R, P> LearningPulseService<R, P>
where
    R: LearningPulseRepository,
    P: EventPublisher,
{
    pub fn new(repo: Arc<R>, publisher: Arc<P>) -> Self {
        Self { repo, publisher }
    }

    /// Creates a pulse, persists it, and publishes a `PulseCreated` event in a
    /// single transaction boundary (best-effort two-phase: DB commit happens
    /// first, followed by broker publish).
    ///
    /// If the broker is unavailable we surface the error so upper layers can
    /// decide whether to retry or place the event in an outbox.
    pub async fn create_pulse(
        &self,
        title: impl Into<String>,
        description: impl Into<String>,
        author_id: Uuid,
    ) -> Result<LearningPulse, PulseError> {
        let pulse = LearningPulse::new(title, description, author_id)?;

        self.repo.create(&pulse).await?;

        // Prepare and emit domain event
        let evt = PulseCreated {
            pulse_id: pulse.id,
            author_id: pulse.author_id,
            occurred_at: Utc::now(),
        };
        self.publisher.publish(&evt).await?;

        Ok(pulse)
    }

    pub async fn get_pulse(&self, id: Uuid) -> Result<Option<LearningPulse>, PulseError> {
        self.repo.find(id).await
    }
}

/* -------------------------------------------------------------------------- */
/*                                 Unit tests                                 */
/* -------------------------------------------------------------------------- */
#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::{Executor, PgPool};
    use std::env;
    use tokio::sync::Mutex;

    struct NoopPublisher;
    #[async_trait]
    impl EventPublisher for NoopPublisher {
        async fn publish<E: DomainEvent>(&self, _evt: &E) -> Result<(), PulseError> {
            Ok(())
        }
    }

    // A helper function to spin up an isolated in-memory Postgres instance
    // (via `testcontainers`). For brevity we assume an ENV var with a local
    // connection string.
    async fn setup_db() -> PgPool {
        let db_url =
            env::var("TEST_DATABASE_URL").expect("TEST_DATABASE_URL must be set for tests");
        let pool = PgPool::connect(&db_url).await.unwrap();

        // Idempotent schema for the tests.
        let schema = r#"
            CREATE TABLE IF NOT EXISTS learning_pulses (
                id UUID PRIMARY KEY,
                title TEXT NOT NULL,
                description TEXT NOT NULL,
                author_id UUID NOT NULL,
                created_at TIMESTAMPTZ NOT NULL
            )
        "#;
        pool.execute(schema).await.unwrap();

        pool
    }

    #[tokio::test]
    async fn pulse_roundtrip() {
        let pool = setup_db().await;
        let repo = Arc::new(PostgresPulseRepository::new(pool));
        let publisher = Arc::new(NoopPublisher);
        let service = LearningPulseService::new(repo, publisher);

        let author_id = Uuid::new_v4();
        let created = service
            .create_pulse("Test Title", "Some awesome description", author_id)
            .await
            .unwrap();

        assert_eq!(created.title, "Test Title");

        let fetched = service.get_pulse(created.id).await.unwrap().unwrap();
        assert_eq!(fetched.id, created.id);
    }
}
```