```rust
//! src/module_22.rs
//!
//! Learning Pulse domain module.
//!
//! This module owns the core workflow for creating and replying to
//! “learning pulses”.  It follows the Service-Layer + Repository pattern,
//! emits domain events, and is fully asynchronous.
//!
//! The implementation intentionally avoids leaking concrete I/O details
//! to ease unit testing—external concerns (SQL database, message broker)
//! are injected behind traits.
//!
//! Dependencies (add to Cargo.toml if missing):
//!   async-trait    = "0.1"
//!   chrono         = { version = "0.4", features = ["serde"] }
//!   serde          = { version = "1", features = ["derive"] }
//!   sqlx           = { version = "0.7", default-features = false, features = ["rustls","postgres","macros","chrono"] }
//!   thiserror      = "1"
//!
//! The rest of the crate is expected to provide real implementations of
//! `EventPublisher` and `PgPool`.

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::{postgres::PgRow, PgPool, Row};
use thiserror::Error;
use uuid::Uuid;

/// Domain object representing a learning pulse (challenge/activity).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LearningPulse {
    pub id: Uuid,
    pub author_id: Uuid,
    pub title: String,
    pub body: String,
    pub created_at: DateTime<Utc>,
    pub due_at: Option<DateTime<Utc>>,
    pub is_archived: bool,
}

/// Domain object for a student response to a pulse.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PulseResponse {
    pub id: Uuid,
    pub pulse_id: Uuid,
    pub responder_id: Uuid,
    pub content_uri: String,
    pub submitted_at: DateTime<Utc>,
}

/// Events the module can publish downstream.
///
/// NOTE: Versioned event naming scheme, e.g. `PulseCreated.v1`,
/// guarantees forward compatibility when the payload shape changes.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", content = "data")]
pub enum PulseEvent {
    #[serde(rename = "PulseCreated.v1")]
    PulseCreated {
        pulse_id: Uuid,
        author_id: Uuid,
        title: String,
    },
    #[serde(rename = "PulseResponded.v1")]
    PulseResponded {
        pulse_id: Uuid,
        responder_id: Uuid,
        response_id: Uuid,
        content_uri: String,
    },
}

/// Injectable message publisher for decoupling side-effects.
#[async_trait]
pub trait EventPublisher: Send + Sync + 'static {
    async fn publish(&self, event: PulseEvent) -> Result<(), PublishError>;
}

#[derive(Debug, Error)]
pub enum PublishError {
    #[error("broker disconnected")]
    Disconnected,
    #[error("serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
    #[error("unknown publish error: {0}")]
    Other(String),
}

/// Persistence layer errors.
#[derive(Debug, Error)]
pub enum RepositoryError {
    #[error("entity not found")]
    NotFound,
    #[error("database error: {0}")]
    Db(#[from] sqlx::Error),
}

/// Service-level error enumeration.
///
/// Explicit conversion From<RepositoryError> is implemented so
/// caller code can use `?` without additional noise.
#[derive(Debug, Error)]
pub enum PulseServiceError {
    #[error("input validation failed: {0}")]
    Validation(String),
    #[error(transparent)]
    Repository(#[from] RepositoryError),
    #[error(transparent)]
    Publisher(#[from] PublishError),
}

/// Repository abstraction for learning pulses.
#[async_trait]
pub trait PulseRepository: Send + Sync + 'static {
    async fn insert(&self, pulse: &LearningPulse) -> Result<(), RepositoryError>;
    async fn find(&self, id: Uuid) -> Result<LearningPulse, RepositoryError>;
    async fn archive(&self, id: Uuid) -> Result<(), RepositoryError>;
}

/// Repository abstraction for pulse responses.
#[async_trait]
pub trait ResponseRepository: Send + Sync + 'static {
    async fn insert(&self, resp: &PulseResponse) -> Result<(), RepositoryError>;
    async fn list_for_pulse(&self, pulse_id: Uuid) -> Result<Vec<PulseResponse>, RepositoryError>;
}

/// Concrete Postgres implementation of `PulseRepository`.
pub struct PgPulseRepository {
    pool: PgPool,
}

impl PgPulseRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl PulseRepository for PgPulseRepository {
    async fn insert(&self, pulse: &LearningPulse) -> Result<(), RepositoryError> {
        sqlx::query!(
            r#"
            INSERT INTO learning_pulses (id, author_id, title, body, created_at, due_at, is_archived)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            "#,
            pulse.id,
            pulse.author_id,
            pulse.title,
            pulse.body,
            pulse.created_at,
            pulse.due_at,
            pulse.is_archived
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    async fn find(&self, id: Uuid) -> Result<LearningPulse, RepositoryError> {
        let row: PgRow = sqlx::query(
            r#"
            SELECT id, author_id, title, body, created_at, due_at, is_archived
            FROM learning_pulses
            WHERE id = $1
            "#,
        )
        .bind(id)
        .fetch_one(&self.pool)
        .await?;

        Ok(LearningPulse {
            id: row.get("id"),
            author_id: row.get("author_id"),
            title: row.get("title"),
            body: row.get("body"),
            created_at: row.get("created_at"),
            due_at: row.try_get("due_at")?,
            is_archived: row.get("is_archived"),
        })
    }

    async fn archive(&self, id: Uuid) -> Result<(), RepositoryError> {
        let res = sqlx::query!(
            "UPDATE learning_pulses SET is_archived = TRUE WHERE id = $1",
            id
        )
        .execute(&self.pool)
        .await?;

        if res.rows_affected() == 0 {
            Err(RepositoryError::NotFound)
        } else {
            Ok(())
        }
    }
}

/// Concrete Postgres implementation of `ResponseRepository`.
pub struct PgResponseRepository {
    pool: PgPool,
}

impl PgResponseRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl ResponseRepository for PgResponseRepository {
    async fn insert(&self, resp: &PulseResponse) -> Result<(), RepositoryError> {
        sqlx::query!(
            r#"
            INSERT INTO pulse_responses (id, pulse_id, responder_id, content_uri, submitted_at)
            VALUES ($1, $2, $3, $4, $5)
            "#,
            resp.id,
            resp.pulse_id,
            resp.responder_id,
            resp.content_uri,
            resp.submitted_at
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    async fn list_for_pulse(&self, pulse_id: Uuid) -> Result<Vec<PulseResponse>, RepositoryError> {
        let rows = sqlx::query!(
            r#"
            SELECT id, pulse_id, responder_id, content_uri, submitted_at
            FROM pulse_responses
            WHERE pulse_id = $1
            "#,
            pulse_id
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(rows
            .into_iter()
            .map(|r| PulseResponse {
                id: r.id,
                pulse_id: r.pulse_id,
                responder_id: r.responder_id,
                content_uri: r.content_uri,
                submitted_at: r.submitted_at,
            })
            .collect())
    }
}

/// Service facade—entry point used by controllers / GraphQL resolvers.
pub struct PulseService<R: PulseRepository, S: ResponseRepository, P: EventPublisher> {
    pulses: R,
    responses: S,
    publisher: P,
}

impl<R: PulseRepository, S: ResponseRepository, P: EventPublisher> PulseService<R, S, P> {
    pub fn new(pulses: R, responses: S, publisher: P) -> Self {
        Self {
            pulses,
            responses,
            publisher,
        }
    }

    /// Creates a new learning pulse and publishes `PulseCreated` event.
    pub async fn create_pulse(
        &self,
        author_id: Uuid,
        title: &str,
        body: &str,
        due_at: Option<DateTime<Utc>>,
    ) -> Result<LearningPulse, PulseServiceError> {
        if title.trim().is_empty() {
            return Err(PulseServiceError::Validation(
                "title must not be empty".into(),
            ));
        }

        let pulse = LearningPulse {
            id: Uuid::new_v4(),
            author_id,
            title: title.trim().to_owned(),
            body: body.to_owned(),
            created_at: Utc::now(),
            due_at,
            is_archived: false,
        };

        self.pulses.insert(&pulse).await?;

        // Fire-and-forget the event; let caller decide whether to await or spawn.
        self.publisher
            .publish(PulseEvent::PulseCreated {
                pulse_id: pulse.id,
                author_id: pulse.author_id,
                title: pulse.title.clone(),
            })
            .await?;

        Ok(pulse)
    }

    /// Adds a student response to a pulse and publishes `PulseResponded`.
    pub async fn respond_to_pulse(
        &self,
        pulse_id: Uuid,
        responder_id: Uuid,
        content_uri: &str,
    ) -> Result<PulseResponse, PulseServiceError> {
        // Validate pulse existence.
        let pulse = self.pulses.find(pulse_id).await?;
        if pulse.is_archived {
            return Err(PulseServiceError::Validation(
                "Cannot respond to an archived pulse".into(),
            ));
        }

        if content_uri.trim().is_empty() {
            return Err(PulseServiceError::Validation(
                "content_uri must not be empty".into(),
            ));
        }

        let resp = PulseResponse {
            id: Uuid::new_v4(),
            pulse_id,
            responder_id,
            content_uri: content_uri.trim().to_owned(),
            submitted_at: Utc::now(),
        };

        self.responses.insert(&resp).await?;

        self.publisher
            .publish(PulseEvent::PulseResponded {
                pulse_id,
                responder_id,
                response_id: resp.id,
                content_uri: resp.content_uri.clone(),
            })
            .await?;

        Ok(resp)
    }

    /// Returns all responses for a given pulse.
    pub async fn list_responses(
        &self,
        pulse_id: Uuid,
    ) -> Result<Vec<PulseResponse>, PulseServiceError> {
        Ok(self.responses.list_for_pulse(pulse_id).await?)
    }

    /// Archives a learning pulse (soft-delete).
    pub async fn archive_pulse(&self, pulse_id: Uuid) -> Result<(), PulseServiceError> {
        self.pulses.archive(pulse_id).await?;
        // Future: publish `PulseArchived` event here
        Ok(())
    }
}

/* ------------------------------------------------------------
   Mock Implementations for Compilation & Unit Testing
   ------------------------------------------------------------ */

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::{Arc, Mutex};

    struct InMemPublisher(Arc<Mutex<Vec<PulseEvent>>>);

    #[async_trait]
    impl EventPublisher for InMemPublisher {
        async fn publish(&self, event: PulseEvent) -> Result<(), PublishError> {
            self.0.lock().unwrap().push(event);
            Ok(())
        }
    }

    struct InMemPulseRepo(Arc<Mutex<Vec<LearningPulse>>>);
    struct InMemRespRepo(Arc<Mutex<Vec<PulseResponse>>>);

    #[async_trait]
    impl PulseRepository for InMemPulseRepo {
        async fn insert(&self, pulse: &LearningPulse) -> Result<(), RepositoryError> {
            self.0.lock().unwrap().push(pulse.clone());
            Ok(())
        }

        async fn find(&self, id: Uuid) -> Result<LearningPulse, RepositoryError> {
            self.0
                .lock()
                .unwrap()
                .iter()
                .find(|p| p.id == id)
                .cloned()
                .ok_or(RepositoryError::NotFound)
        }

        async fn archive(&self, id: Uuid) -> Result<(), RepositoryError> {
            let mut guard = self.0.lock().unwrap();
            let p = guard
                .iter_mut()
                .find(|p| p.id == id)
                .ok_or(RepositoryError::NotFound)?;
            p.is_archived = true;
            Ok(())
        }
    }

    #[async_trait]
    impl ResponseRepository for InMemRespRepo {
        async fn insert(&self, resp: &PulseResponse) -> Result<(), RepositoryError> {
            self.0.lock().unwrap().push(resp.clone());
            Ok(())
        }

        async fn list_for_pulse(
            &self,
            pulse_id: Uuid,
        ) -> Result<Vec<PulseResponse>, RepositoryError> {
            Ok(self
                .0
                .lock()
                .unwrap()
                .iter()
                .filter(|r| r.pulse_id == pulse_id)
                .cloned()
                .collect())
        }
    }

    #[tokio::test]
    async fn create_and_respond_flow() -> anyhow::Result<()> {
        let pulses_repo = InMemPulseRepo(Arc::new(Mutex::new(vec![])));
        let resp_repo = InMemRespRepo(Arc::new(Mutex::new(vec![])));
        let publisher = InMemPublisher(Arc::new(Mutex::new(vec![])));

        let service = PulseService::new(pulses_repo, resp_repo, publisher);

        let author = Uuid::new_v4();
        let responder = Uuid::new_v4();

        let pulse = service
            .create_pulse(author, "Rust Ownership Quiz", "Explain ownership.", None)
            .await?;

        assert_eq!(pulse.title, "Rust Ownership Quiz");

        let response = service
            .respond_to_pulse(pulse.id, responder, "s3://bucket/resp1.md")
            .await?;

        assert_eq!(response.pulse_id, pulse.id);

        Ok(())
    }
}
```