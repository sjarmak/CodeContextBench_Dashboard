```rust
//! module_18 – Learning Pulse domain service
//!
//! This module implements the “Learning Pulse” workflow used in EduPulse
//! Live.  A learning-pulse is a short-lived activity posted by a teacher.
//! Students may submit one response; submissions are auto-scored by an
//! external workflow.  The code below orchestrates persistence, emits domain
//! events to the message broker, and follows Repository + Service patterns.
//!
//! NOTE: Actual SQL schema and broker configuration live elsewhere in the
//! repository.  This module is DB-agnostic beyond `sqlx` and broker-agnostic
//! behind the [`EventPublisher`] abstraction.

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::{Executor, PgPool, Postgres, Transaction};
use thiserror::Error;
use tokio::sync::Mutex;
use tracing::{error, info, instrument};
use uuid::Uuid;

/// Domain model for a Learning Pulse.
#[derive(Debug, Clone)]
pub struct LearningPulse {
    pub id: Uuid,
    pub author_id: Uuid,
    pub title: String,
    pub prompt: String,
    pub created_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
    pub max_score: i16,
}

/// Domain model for a submission to a pulse.
#[derive(Debug, Clone)]
pub struct PulseSubmission {
    pub id: Uuid,
    pub pulse_id: Uuid,
    pub learner_id: Uuid,
    pub artifact_uri: String,
    pub submitted_at: DateTime<Utc>,
    pub score: Option<i16>,
}

/// Domain events flowing through the broker.
#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum LearningPulseEvent {
    PulsePublished {
        pulse_id: Uuid,
        author_id: Uuid,
        published_at: DateTime<Utc>,
    },
    SubmissionReceived {
        submission_id: Uuid,
        pulse_id: Uuid,
        learner_id: Uuid,
        received_at: DateTime<Utc>,
    },
    SubmissionScored {
        submission_id: Uuid,
        pulse_id: Uuid,
        learner_id: Uuid,
        score: i16,
        scored_at: DateTime<Utc>,
    },
}

/// User-facing / API-layer errors.
#[derive(Debug, Error)]
pub enum ServiceError {
    #[error("learning pulse not found")]
    PulseNotFound,
    #[error("submission not found")]
    SubmissionNotFound,
    #[error("pulse expired")]
    PulseExpired,
    #[error("database error: {0}")]
    Db(#[from] sqlx::Error),
    #[error("event publisher error: {0}")]
    Publisher(#[from] PublisherError),
}

/// Errors returned by the event publisher stack.
#[derive(Debug, Error)]
pub enum PublisherError {
    #[error("unable to serialize event: {0}")]
    Serialization(#[from] serde_json::Error),
    #[error("broker I/O error: {0}")]
    Io(#[from] std::io::Error),
}

/// Abstraction over “whatever message broker we are using”.
#[async_trait]
pub trait EventPublisher: Send + Sync {
    async fn publish(&self, event: &LearningPulseEvent) -> Result<(), PublisherError>;
}

/// PostgreSQL implementation of the repository (simplified).
#[async_trait]
pub trait LearningPulseRepository: Send + Sync {
    async fn insert_pulse(
        &self,
        tx: &mut Transaction<'_, Postgres>,
        pulse: &LearningPulse,
    ) -> Result<(), sqlx::Error>;

    async fn get_pulse(&self, pool: &PgPool, pulse_id: Uuid)
        -> Result<LearningPulse, sqlx::Error>;

    async fn insert_submission(
        &self,
        tx: &mut Transaction<'_, Postgres>,
        submission: &PulseSubmission,
    ) -> Result<(), sqlx::Error>;

    async fn get_submission(
        &self,
        pool: &PgPool,
        submission_id: Uuid,
    ) -> Result<PulseSubmission, sqlx::Error>;

    async fn update_submission_score(
        &self,
        tx: &mut Transaction<'_, Postgres>,
        submission_id: Uuid,
        score: i16,
    ) -> Result<(), sqlx::Error>;
}

/// Concrete repository backed by sqlx Postgres.
pub struct PgLearningPulseRepository;

#[async_trait]
impl LearningPulseRepository for PgLearningPulseRepository {
    async fn insert_pulse(
        &self,
        tx: &mut Transaction<'_, Postgres>,
        pulse: &LearningPulse,
    ) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            INSERT INTO learning_pulses
                (id, author_id, title, prompt, created_at, expires_at, max_score)
            VALUES ($1,$2,$3,$4,$5,$6,$7)
            "#,
            pulse.id,
            pulse.author_id,
            pulse.title,
            pulse.prompt,
            pulse.created_at,
            pulse.expires_at,
            pulse.max_score
        )
        .execute(&mut **tx)
        .await?;
        Ok(())
    }

    async fn get_pulse(
        &self,
        pool: &PgPool,
        pulse_id: Uuid,
    ) -> Result<LearningPulse, sqlx::Error> {
        sqlx::query_as!(
            LearningPulse,
            r#"
            SELECT id, author_id, title, prompt, created_at, expires_at, max_score
            FROM learning_pulses
            WHERE id = $1
            "#,
            pulse_id
        )
        .fetch_one(pool)
        .await
    }

    async fn insert_submission(
        &self,
        tx: &mut Transaction<'_, Postgres>,
        submission: &PulseSubmission,
    ) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            INSERT INTO pulse_submissions
                (id, pulse_id, learner_id, artifact_uri, submitted_at, score)
            VALUES ($1,$2,$3,$4,$5,$6)
            "#,
            submission.id,
            submission.pulse_id,
            submission.learner_id,
            submission.artifact_uri,
            submission.submitted_at,
            submission.score
        )
        .execute(&mut **tx)
        .await?;
        Ok(())
    }

    async fn get_submission(
        &self,
        pool: &PgPool,
        submission_id: Uuid,
    ) -> Result<PulseSubmission, sqlx::Error> {
        sqlx::query_as!(
            PulseSubmission,
            r#"
            SELECT id, pulse_id, learner_id, artifact_uri, submitted_at, score
            FROM pulse_submissions
            WHERE id = $1
            "#,
            submission_id
        )
        .fetch_one(pool)
        .await
    }

    async fn update_submission_score(
        &self,
        tx: &mut Transaction<'_, Postgres>,
        submission_id: Uuid,
        score: i16,
    ) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE pulse_submissions
            SET score = $1
            WHERE id   = $2
            "#,
            score,
            submission_id
        )
        .execute(&mut **tx)
        .await?;
        Ok(())
    }
}

/// Service layer orchestrating pulses + submissions.
pub struct LearningPulseService<P: EventPublisher, R: LearningPulseRepository> {
    db: PgPool,
    repo: R,
    publisher: P,
    // Mutex ensures we don’t create duplicate submissions for same user/pulse.
    submission_guard: Mutex<()>,
}

impl<P, R> LearningPulseService<P, R>
where
    P: EventPublisher + 'static,
    R: LearningPulseRepository + 'static,
{
    pub fn new(db: PgPool, repo: R, publisher: P) -> Self {
        Self {
            db,
            repo,
            publisher,
            submission_guard: Mutex::new(()),
        }
    }

    /// Create a new learning pulse, persist it, and broadcast an event.
    #[instrument(skip(self))]
    pub async fn create_pulse(
        &self,
        author_id: Uuid,
        title: String,
        prompt: String,
        expires_at: DateTime<Utc>,
        max_score: i16,
    ) -> Result<Uuid, ServiceError> {
        let pulse = LearningPulse {
            id: Uuid::new_v4(),
            author_id,
            title,
            prompt,
            created_at: Utc::now(),
            expires_at,
            max_score,
        };

        let mut tx = self.db.begin().await?;
        self.repo.insert_pulse(&mut tx, &pulse).await?;
        tx.commit().await?;

        // Fire-and-forget publish; failure bubbles back so caller can retry.
        self.publisher
            .publish(&LearningPulseEvent::PulsePublished {
                pulse_id: pulse.id,
                author_id,
                published_at: pulse.created_at,
            })
            .await?;

        info!(pulse_id = %pulse.id, "learning pulse published");
        Ok(pulse.id)
    }

    /// Submit an artifact to a pulse; emits “SubmissionReceived”.
    #[instrument(skip(self))]
    pub async fn submit_response(
        &self,
        pulse_id: Uuid,
        learner_id: Uuid,
        artifact_uri: String,
    ) -> Result<Uuid, ServiceError> {
        let pulse = self
            .repo
            .get_pulse(&self.db, pulse_id)
            .await
            .map_err(|e| {
                if e == sqlx::Error::RowNotFound {
                    ServiceError::PulseNotFound
                } else {
                    e.into()
                }
            })?;

        // Cannot submit after expiry.
        if Utc::now() > pulse.expires_at {
            return Err(ServiceError::PulseExpired);
        }

        // Guard duplicates (cheap naïve approach).
        let _guard = self.submission_guard.lock().await;

        let submission = PulseSubmission {
            id: Uuid::new_v4(),
            pulse_id,
            learner_id,
            artifact_uri,
            submitted_at: Utc::now(),
            score: None,
        };

        let mut tx = self.db.begin().await?;
        self.repo.insert_submission(&mut tx, &submission).await?;
        tx.commit().await?;

        self.publisher
            .publish(&LearningPulseEvent::SubmissionReceived {
                submission_id: submission.id,
                pulse_id,
                learner_id,
                received_at: submission.submitted_at,
            })
            .await?;

        info!(
            submission_id = %submission.id,
            pulse_id = %pulse_id,
            learner_id = %learner_id,
            "submission stored"
        );
        Ok(submission.id)
    }

    /// Record an auto-scoring result; emits “SubmissionScored”.
    #[instrument(skip(self))]
    pub async fn score_submission(
        &self,
        submission_id: Uuid,
        score: i16,
    ) -> Result<(), ServiceError> {
        let mut tx = self.db.begin().await?;

        let submission = self
            .repo
            .get_submission(&self.db, submission_id)
            .await
            .map_err(|e| {
                if e == sqlx::Error::RowNotFound {
                    ServiceError::SubmissionNotFound
                } else {
                    e.into()
                }
            })?;

        self.repo
            .update_submission_score(&mut tx, submission_id, score)
            .await?;
        tx.commit().await?;

        self.publisher
            .publish(&LearningPulseEvent::SubmissionScored {
                submission_id,
                pulse_id: submission.pulse_id,
                learner_id: submission.learner_id,
                score,
                scored_at: Utc::now(),
            })
            .await?;

        info!(
            submission_id = %submission_id,
            score,
            "submission score updated"
        );
        Ok(())
    }
}

/// A minimal NATS publisher implementation used in production (TLS, auth, etc.)
/// lives in `infra/event_publisher`.  For testing we provide a stub.
pub struct NoopPublisher;

#[async_trait]
impl EventPublisher for NoopPublisher {
    async fn publish(&self, event: &LearningPulseEvent) -> Result<(), PublisherError> {
        // In tests we just log the event; production impl uses async-nats, Kafka, etc.
        let payload = serde_json::to_string(event)?;
        tracing::debug!("NOOP-PUBLISH: {}", payload);
        Ok(())
    }
}
```