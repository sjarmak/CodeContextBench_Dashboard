```rust
//! src/module_79.rs
//!
//! Learning Pulse domain + service layer
//! -------------------------------------
//! This module implements the domain model, repository abstraction, service
//! layer, and event-publishing infrastructure for the “Learning Pulse”
//! feature in the EduPulse Live platform.
//!
//! High-level design
//! -----------------
//! • Domain objects are simple, immutable data structures (DDD aggregate style).
//! • All write-operations go through the `LearningPulseService`.  
//!   The service persists state using a repository and emits a domain event
//!   through an external message broker (RabbitMQ in this example).
//! • An async trait (`EventPublisher`) decouples the service from the transport
//!   layer, making it straightforward to swap AMQP for Kafka, NATS, etc.
//!
//! Dependencies (add to Cargo.toml)
//! --------------------------------
//! thiserror      = "1"
//! async-trait    = "0.1"
//! serde          = { version = "1", features = ["derive"] }
//! serde_json     = "1"
//! uuid           = { version = "1", features = ["v4"] }
//! chrono         = { version = "0.4", features = ["serde"] }
//! sqlx           = { version = "0.7", features = ["postgres", "runtime-tokio", "chrono", "uuid"] }
//! lapin          = { version = "2", features = ["full", "executor"] }
//! tokio          = { version = "1", features = ["macros", "rt-multi-thread"] }

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use lapin::{
    options::{BasicPublishOptions, ConfirmSelectOptions},
    types::FieldTable,
    BasicProperties, Channel, Connection, ConnectionProperties,
};
use serde::{Deserialize, Serialize};
use sqlx::{postgres::PgRow, PgPool, Row};
use thiserror::Error;
use uuid::Uuid;

/// Domain model ‑ a 'Learning Pulse'
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LearningPulse {
    pub id:            Uuid,
    pub author_id:     Uuid,
    pub title:         String,
    pub description:   String,
    pub created_at:    DateTime<Utc>,
    pub expires_at:    DateTime<Utc>,
    pub response_count: i64,
}

/// Data needed to create a new pulse
#[derive(Debug, Clone)]
pub struct NewLearningPulse {
    pub author_id:   Uuid,
    pub title:       String,
    pub description: String,
    pub expires_at:  DateTime<Utc>,
}

/// Domain model ‑ a learner response to a pulse
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PulseResponse {
    pub id:          Uuid,
    pub pulse_id:    Uuid,
    pub responder_id: Uuid,
    pub body:        String,
    pub created_at:  DateTime<Utc>,
}

/// All possible domain events emitted by this module
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum DomainEvent {
    LearningPulseCreated { pulse: LearningPulse },
    PulseResponded       { response: PulseResponse },
}

/// Custom error type for the whole module
#[derive(Debug, Error)]
pub enum PulseError {
    #[error("database error: {0}")]
    Database(#[from] sqlx::Error),

    #[error("serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("AMQP error: {0}")]
    Amqp(#[from] lapin::Error),

    #[error("invalid input: {0}")]
    InvalidInput(String),
}

/// Repository abstraction — hides persistence technology
#[async_trait]
pub trait LearningPulseRepository: Send + Sync {
    async fn insert_pulse(
        &self,
        payload: NewLearningPulse,
    ) -> Result<LearningPulse, PulseError>;

    async fn insert_response(
        &self,
        response: PulseResponse,
    ) -> Result<(), PulseError>;

    async fn increment_response_count(&self, pulse_id: Uuid) -> Result<(), PulseError>;
}

/// PostgreSQL implementation of the repository
pub struct PgLearningPulseRepository {
    pool: PgPool,
}

impl PgLearningPulseRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl LearningPulseRepository for PgLearningPulseRepository {
    async fn insert_pulse(
        &self,
        payload: NewLearningPulse,
    ) -> Result<LearningPulse, PulseError> {
        let pulse_id = Uuid::new_v4();
        let now = Utc::now();

        let row: PgRow = sqlx::query(
            r#"
            INSERT INTO learning_pulses (id, author_id, title, description, created_at, expires_at, response_count)
            VALUES ($1, $2, $3, $4, $5, $6, 0)
            RETURNING id, author_id, title, description, created_at, expires_at, response_count
            "#,
        )
        .bind(pulse_id)
        .bind(payload.author_id)
        .bind(&payload.title)
        .bind(&payload.description)
        .bind(now)
        .bind(payload.expires_at)
        .fetch_one(&self.pool)
        .await?;

        Ok(LearningPulse {
            id:            row.get("id"),
            author_id:     row.get("author_id"),
            title:         row.get("title"),
            description:   row.get("description"),
            created_at:    row.get("created_at"),
            expires_at:    row.get("expires_at"),
            response_count: row.get("response_count"),
        })
    }

    async fn insert_response(
        &self,
        response: PulseResponse,
    ) -> Result<(), PulseError> {
        sqlx::query(
            r#"
            INSERT INTO pulse_responses (id, pulse_id, responder_id, body, created_at)
            VALUES ($1, $2, $3, $4, $5)
            "#,
        )
        .bind(response.id)
        .bind(response.pulse_id)
        .bind(response.responder_id)
        .bind(response.body)
        .bind(response.created_at)
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    async fn increment_response_count(&self, pulse_id: Uuid) -> Result<(), PulseError> {
        sqlx::query(
            r#"
            UPDATE learning_pulses
            SET response_count = response_count + 1
            WHERE id = $1
            "#,
        )
        .bind(pulse_id)
        .execute(&self.pool)
        .await?;
        Ok(())
    }
}

/// Event publisher abstraction (decouples service from specific broker)
#[async_trait]
pub trait EventPublisher: Send + Sync {
    async fn publish(&self, event: &DomainEvent) -> Result<(), PulseError>;
}

/// RabbitMQ implementation
pub struct RabbitMqPublisher {
    channel: Channel,
    exchange: String,
}

impl RabbitMqPublisher {
    /// Open a new connection and prepare publisher confirms.
    /// `uri` example: amqp://user:password@127.0.0.1:5672/%2f
    pub async fn connect(uri: &str, exchange: &str) -> Result<Self, PulseError> {
        let conn = Connection::connect(uri, ConnectionProperties::default()).await?;
        let channel = conn.create_channel().await?;
        channel.confirm_select(ConfirmSelectOptions::default()).await?;

        Ok(Self {
            channel,
            exchange: exchange.into(),
        })
    }
}

#[async_trait]
impl EventPublisher for RabbitMqPublisher {
    async fn publish(&self, event: &DomainEvent) -> Result<(), PulseError> {
        let payload = serde_json::to_vec(event)?;
        let routing_key = match event {
            DomainEvent::LearningPulseCreated { .. } => "pulse.created",
            DomainEvent::PulseResponded { .. } => "pulse.responded",
        };

        self.channel
            .basic_publish(
                &self.exchange,
                routing_key,
                BasicPublishOptions::default(),
                &payload,
                BasicProperties::default().with_content_type("application/json".into()),
            )
            .await?
            .await?; // wait for publisher confirms

        Ok(())
    }
}

/// Application service (use-case layer)
pub struct LearningPulseService<R, P> {
    repo: R,
    publisher: P,
}

impl<R, P> LearningPulseService<R, P>
where
    R: LearningPulseRepository,
    P: EventPublisher,
{
    pub fn new(repo: R, publisher: P) -> Self {
        Self { repo, publisher }
    }

    /// Create a new pulse and broadcast event
    pub async fn create_pulse(
        &self,
        payload: NewLearningPulse,
    ) -> Result<LearningPulse, PulseError> {
        // Validate
        if payload.expires_at <= Utc::now() {
            return Err(PulseError::InvalidInput(
                "expires_at must be in the future".into(),
            ));
        }

        let pulse = self.repo.insert_pulse(payload).await?;

        let evt = DomainEvent::LearningPulseCreated { pulse: pulse.clone() };
        self.publisher.publish(&evt).await?;

        Ok(pulse)
    }

    /// Learner submits a response
    pub async fn respond_to_pulse(
        &self,
        pulse_id: Uuid,
        responder_id: Uuid,
        body: String,
    ) -> Result<PulseResponse, PulseError> {
        if body.trim().is_empty() {
            return Err(PulseError::InvalidInput("response body cannot be empty".into()));
        }

        let response = PulseResponse {
            id: Uuid::new_v4(),
            pulse_id,
            responder_id,
            body,
            created_at: Utc::now(),
        };

        // Persist + side-effects
        self.repo.insert_response(response.clone()).await?;
        self.repo.increment_response_count(pulse_id).await?;

        // Fire event
        let evt = DomainEvent::PulseResponded { response: response.clone() };
        self.publisher.publish(&evt).await?;

        Ok(response)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    /// In-memory publisher for deterministic unit testing
    struct InMemoryPublisher {
        events: Arc<Mutex<Vec<DomainEvent>>>,
    }

    #[async_trait]
    impl EventPublisher for InMemoryPublisher {
        async fn publish(&self, event: &DomainEvent) -> Result<(), PulseError> {
            self.events.lock().await.push(event.clone());
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_create_pulse_validation() {
        let pool = PgPool::connect("postgres://postgres@localhost/ep_test")
            .await
            .expect("db");
        let repo = PgLearningPulseRepository::new(pool);

        let events = Arc::new(Mutex::new(vec![]));
        let publisher = InMemoryPublisher {
            events: events.clone(),
        };

        let service = LearningPulseService::new(repo, publisher);

        let past = Utc::now() - chrono::Duration::days(1);
        let result = service
            .create_pulse(NewLearningPulse {
                author_id: Uuid::new_v4(),
                title: "Bad Pulse".into(),
                description: "Already expired".into(),
                expires_at: past,
            })
            .await;

        assert!(matches!(result, Err(PulseError::InvalidInput(_))));
        assert!(events.lock().await.is_empty());
    }
}
```