```c
/**
 * @file palette_service.h
 * @author
 * @brief   Public interface for the SynestheticCanvas Palette Service.
 *
 *          The Palette Service is responsible for CRUD operations on color
 *          palettes, color-space conversions, and server-side pagination/
 *          filtering.  It is deliberately decoupled from any persistence or
 *          transport concerns via the Repository Pattern—callers inject a
 *          repository‐adapter instance that satisfies the `sc_ps_repository_t`
 *          virtual table found near the bottom of this header.
 *
 *          Thread safety: All functions are re-entrant so long as the caller
 *          serializes access to the same service instance.  Internally, the
 *          implementation only relies on thread-local data.
 *
 *          Error handling: Each function returns an `sc_ps_status_t` which is
 *          an enum of strongly-typed status codes.  No errno usage here.
 *
 *          Versioning: Applications may query the service’s semantic version
 *          at run-time with sc_ps_get_version().
 *
 *  ────────────────────────────────────────────────────────────────────────────
 *  Copyright (c) 2024
 *  Released under the MIT license.  See LICENSE for details.
 */
#ifndef SC_SYNESTHETIC_CANVAS_PALETTE_SERVICE_H
#define SC_SYNESTHETIC_CANVAS_PALETTE_SERVICE_H

/* ───────────────────────────────────────── System includes */
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ───────────────────────────────────────── Symbol visibility */
#if defined(_WIN32) && defined(SC_PS_BUILD_DLL)
#   define SC_PS_API __declspec(dllexport)
#elif defined(_WIN32)
#   define SC_PS_API __declspec(dllimport)
#else
#   define SC_PS_API __attribute__((visibility("default")))
#endif

/* ───────────────────────────────────────── Versioning */
#define SC_PS_VERSION_MAJOR 1
#define SC_PS_VERSION_MINOR 3
#define SC_PS_VERSION_PATCH 0

typedef struct {
    uint32_t major;
    uint32_t minor;
    uint32_t patch;
} sc_ps_version_t;

/* ───────────────────────────────────────── Status / Error codes */
typedef enum {
    SC_PS_OK = 0,
    SC_PS_EINVAL,            /* Invalid argument */
    SC_PS_ENOMEM,            /* Allocation failed  */
    SC_PS_ENOTFOUND,         /* Resource not found */
    SC_PS_ECONFLICT,         /* Duplicate name/id  */
    SC_PS_EREPOSITORY,       /* Repository I/O     */
    SC_PS_ERANGE,            /* Range / bounds     */
    SC_PS_ENOTIMPL,          /* Not implemented    */
    SC_PS_EINTERNAL          /* Should never happen*/
} sc_ps_status_t;

/* ───────────────────────────────────────── Color representation */
typedef struct {
    float r; /* 0.0 – 1.0 */
    float g;
    float b;
    float a;
} sc_color_t;

/* ───────────────────────────────────────── Palette entity */
typedef struct {
    uint64_t        id;           /* Globally unique id (generated by repo) */
    char           *name;         /* UTF-8, user-defined name               */
    sc_color_t     *colors;       /* Dynamic array                          */
    size_t          count;        /* Number of colors                       */
    char           *etag;         /* Opaque version tag for optimistic lock */
    uint64_t        created_at;   /* Unix ms                                */
    uint64_t        updated_at;   /* Unix ms                                */
} sc_palette_t;

/**
 * Pagination cursor container.
 * Callers may treat cursors as opaque strings.
 */
typedef struct {
    char   *next_cursor;      /* NULL if no further pages        */
    size_t  total_items;      /* Total number of items available */
} sc_ps_page_info_t;

/* ───────────────────────────────────────── Forward decls */
struct sc_ps_service;
typedef struct sc_ps_service sc_ps_service_t;

/* ───────────────────────────────────────── Repository adapter
 *
 * The service delegates persistent storage to a user-supplied repository
 * implementation via this vtable.  All calls are synchronous/blocking.
 */
typedef struct sc_ps_repository {
    void *impl; /* Opaque pointer for callee’s private data */

    sc_ps_status_t (*create_palette)(void          *impl,
                                     const sc_palette_t *in,
                                     sc_palette_t       *out);

    sc_ps_status_t (*get_palette)   (void   *impl,
                                     uint64_t palette_id,
                                     sc_palette_t *out);

    sc_ps_status_t (*update_palette)(void          *impl,
                                     const sc_palette_t *in,
                                     sc_palette_t       *out);

    sc_ps_status_t (*delete_palette)(void   *impl,
                                     uint64_t palette_id);

    sc_ps_status_t (*list_palettes) (void                 *impl,
                                     const char           *after_cursor,
                                     size_t                limit,
                                     sc_palette_t        **out_array,
                                     size_t               *out_count,
                                     sc_ps_page_info_t    *page_info);

    /* Optional, may be NULL.  Called once during service teardown. */
    void (*destroy)(void *impl);
} sc_ps_repository_t;

/* ───────────────────────────────────────── Logging callback */
typedef enum {
    SC_PS_LOG_TRACE,
    SC_PS_LOG_DEBUG,
    SC_PS_LOG_INFO,
    SC_PS_LOG_WARN,
    SC_PS_LOG_ERROR,
    SC_PS_LOG_FATAL
} sc_ps_log_level_t;

typedef void (*sc_ps_log_fn)(sc_ps_log_level_t level,
                             const char       *component,
                             const char       *fmt,
                             ...);

/* ───────────────────────────────────────── Service configuration */
typedef struct {
    size_t             max_palette_size;   /* colors per palette (0 = unlimited) */
    size_t             page_limit_default; /* default page size for listings     */
    sc_ps_repository_t repository;         /* injected repo adapter (mandatory)  */
    sc_ps_log_fn       logger;             /* optional logging delegate          */
} sc_ps_config_t;

/* ───────────────────────────────────────── Public API */

/**
 * sc_ps_get_version
 *
 * Obtain the compile-time semantic version of the library.
 */
SC_PS_API sc_ps_version_t
sc_ps_get_version(void);

/**
 * sc_ps_service_init
 *
 * Initialize a service instance. Call sc_ps_service_destroy() when finished.
 *
 * @param[out] service      Pointer to an uninitialized service handle.
 * @param[in]  cfg          Configuration struct (deep-copied by the callee).
 *
 * @return SC_PS_OK on success, otherwise an error code.
 */
SC_PS_API sc_ps_status_t
sc_ps_service_init(sc_ps_service_t **service,
                   const sc_ps_config_t *cfg);

/**
 * sc_ps_service_destroy
 *
 * Dispose of the service and all resources. Safe to pass NULL.
 */
SC_PS_API void
sc_ps_service_destroy(sc_ps_service_t *service);

/**
 * sc_ps_create_palette
 *
 * Persist a new palette.
 *
 * @param[in]  service      Initialized service handle.
 * @param[in]  palette_in   Palette without id/etag; the service will allocate
 *                          copies of deep members (name, colors, etc.).
 * @param[out] palette_out  Populated with the stored palette.
 */
SC_PS_API sc_ps_status_t
sc_ps_create_palette(sc_ps_service_t       *service,
                     const sc_palette_t    *palette_in,
                     sc_palette_t          *palette_out);

/**
 * sc_ps_get_palette
 *
 * Fetch a palette by id.
 */
SC_PS_API sc_ps_status_t
sc_ps_get_palette(sc_ps_service_t *service,
                  uint64_t         palette_id,
                  sc_palette_t    *palette_out);

/**
 * sc_ps_update_palette
 *
 * Update an existing palette using optimistic locking via the etag field.
 * If the provided etag does not match the current stored version, the function
 * returns SC_PS_ECONFLICT.
 */
SC_PS_API sc_ps_status_t
sc_ps_update_palette(sc_ps_service_t    *service,
                     const sc_palette_t *palette_in,
                     sc_palette_t       *palette_out);

/**
 * sc_ps_delete_palette
 *
 * Remove a palette by id.
 */
SC_PS_API sc_ps_status_t
sc_ps_delete_palette(sc_ps_service_t *service,
                     uint64_t         palette_id);

/**
 * sc_ps_list_palettes
 *
 * Cursor-based paginated listing of palettes.
 *
 * @param[in]  service        Service handle.
 * @param[in]  after_cursor   Cursor string returned from a previous call,
 *                            or NULL to start from the beginning.
 * @param[in]  limit          Maximum number of items to return. 0 = default.
 * @param[out] out_array      Allocated array of palettes (must be freed via
 *                            sc_ps_free_palette_array()).
 * @param[out] out_count      Number of palettes in out_array.
 * @param[out] page_info      Pagination metadata.
 */
SC_PS_API sc_ps_status_t
sc_ps_list_palettes(sc_ps_service_t  *service,
                    const char       *after_cursor,
                    size_t            limit,
                    sc_palette_t    **out_array,
                    size_t           *out_count,
                    sc_ps_page_info_t *page_info);

/**
 * sc_ps_free_palette
 *
 * Free heap-allocated members of a palette returned by any service function.
 * Safe to pass NULL.
 */
SC_PS_API void
sc_ps_free_palette(sc_palette_t *palette);

/**
 * sc_ps_free_palette_array
 *
 * Convenience helper to free an array returned by sc_ps_list_palettes().
 */
SC_PS_API void
sc_ps_free_palette_array(sc_palette_t *palettes, size_t count);

#ifdef __cplusplus
} /* extern "C" */
#endif
#endif /* SC_SYNESTHETIC_CANVAS_PALETTE_SERVICE_H */
```