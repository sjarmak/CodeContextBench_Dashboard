"""
GraphQL Schema for StellarStage Carnival: Interactive NFT Showrunner
===================================================================

This schema deliberately mirrors the domain-layer terminology used in the
Clean Architecture.  Every GraphQL type maps 1-to-1 to a domain entity or a
DTO that a use-case service (MintShowPass, DistributeLoot, etc.) returns.
The schema is designed for extensibility (future chains, protocols, media
types) and incorporates best practices such as:

• Role-based auth directive (@auth)  
• Relay-style pagination (Connection / Edge)  
• Subscription hooks for real-time UI updates  
• Custom scalars for blockchain-friendly data (BigInt, DateTime, JSON)  

NOTE:
Business logic, data-fetchers and pub-sub implementations live in the
corresponding resolver modules under  /src/presentation/graphql/resolvers.
"""

#  ---------------------------------------------------------------------------
#  Custom Scalars
#  ---------------------------------------------------------------------------

scalar DateTime      # ISO-8601 date-time string
scalar BigInt        # 256-bit unsigned integer, mapped to JS BigInt
scalar JSON          # Arbitrary JSON blob

#  ---------------------------------------------------------------------------
#  Auth Directive
#  ---------------------------------------------------------------------------

"""
Usage examples:
    type Mutation @auth(role: CREATOR) { … }
    fieldName: Type @auth(role: ADMIN)
"""
directive @auth(role: Role! = USER) on OBJECT | FIELD_DEFINITION

enum Role {
  ANON
  USER
  CREATOR
  ADMIN
}

#  ---------------------------------------------------------------------------
#  Root Operation Types
#  ---------------------------------------------------------------------------

type Query {
  # -------------------------------------------------------------------------
  # Shows
  # -------------------------------------------------------------------------

  """Fetch a single show by ID"""
  show(id: ID!): Show @auth(role: ANON)

  """Paginated list of shows (upcoming, live, archived)"""
  shows(
    status: ShowStatus
    first: Int = 20
    after: String
  ): ShowConnection @auth(role: ANON)

  # -------------------------------------------------------------------------
  # Passes
  # -------------------------------------------------------------------------

  """Retrieve a single show-pass (NFT)"""
  pass(id: ID!): Pass @auth(role: ANON)

  """All passes owned by the connected wallet/user"""
  myPasses(
    first: Int = 20
    after: String
  ): PassConnection @auth(role: USER)

  # -------------------------------------------------------------------------
  # Governance / Votes
  # -------------------------------------------------------------------------

  """Fetch an active or historical vote by ID"""
  vote(id: ID!): Vote @auth(role: ANON)

  """Votes associated with a particular show"""
  votesByShow(
    showId: ID!
    first: Int = 20
    after: String
  ): VoteConnection @auth(role: ANON)
}

type Mutation {
  # -------------------------------------------------------------------------
  # Pass Life-Cycle
  # -------------------------------------------------------------------------

  """Mint (purchase) a new Show Pass NFT"""
  mintShowPass(showId: ID!): TransactionReceipt! @auth(role: USER)

  """Upgrade the pass by redeeming an off-chain achievement or code"""
  upgradePass(
    passId: ID!
    key: String!        # e.g. "BACKSTAGE_WIN_STREAK"
    signature: String!  # Signed by achievement oracle contract
  ): Pass! @auth(role: USER)

  """Stake a pass to receive governance weight / yield"""
  stakePass(passId: ID!): StakeReceipt! @auth(role: USER)

  """Unstake a previously staked pass"""
  unstakePass(passId: ID!): StakeReceipt! @auth(role: USER)

  # -------------------------------------------------------------------------
  # Loot Distribution
  # -------------------------------------------------------------------------

  """Creator drops loot to eligible participants"""
  distributeLoot(
    showId: ID!
    payload: JSON!      # Arbitrary metadata (IPFS hash, rarity table, etc.)
  ): [Loot!]! @auth(role: CREATOR)

  # -------------------------------------------------------------------------
  # Governance Voting
  # -------------------------------------------------------------------------

  """Cast a vote in an active poll.  Pass ownership is checked server-side."""
  castLiveVote(
    voteId: ID!
    optionKey: String!
  ): VoteReceipt! @auth(role: USER)
}

type Subscription {
  # -------------------------------------------------------------------------
  # Real-time Show Events
  # -------------------------------------------------------------------------

  """Fired whenever show meta or status changes (start, pause, etc.)"""
  showUpdated(showId: ID!): ShowEvent! @auth(role: ANON)

  """Act-level progress updates (live performer actions)"""
  actProgressed(showId: ID!): ActEvent! @auth(role: ANON)

  # -------------------------------------------------------------------------
  # NFT / Pass Updates
  # -------------------------------------------------------------------------

  """Pass XP, level or trait mutations propagate here"""
  passUpdated(passId: ID!): PassEvent! @auth(role: USER)

  # -------------------------------------------------------------------------
  # Governance
  # -------------------------------------------------------------------------

  """Real-time vote tally stream"""
  voteResultUpdated(voteId: ID!): VoteResult! @auth(role: ANON)
}

#  ---------------------------------------------------------------------------
#  Domain Types
#  ---------------------------------------------------------------------------

type Show {
  id: ID!
  title: String!
  description: String!
  posterURL: String!
  startTime: DateTime!
  endTime: DateTime
  status: ShowStatus!
  totalPasses: Int!
  mintedPasses: Int!
  acts: [Act!]!
  creator: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ShowStatus {
  UPCOMING
  LIVE
  PAUSED
  ENDED
  CANCELLED
}

type Act {
  id: ID!
  title: String!
  performer: String!
  order: Int!
  mediaURL: String
  startTime: DateTime
  endTime: DateTime
  show: Show!
}

type Pass {
  id: ID!
  tokenId: BigInt!
  owner: User!
  show: Show!
  level: Int!
  xp: Int!
  rarityScore: Float!
  traits: [Trait!]!
  staked: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Trait {
  key: String!
  value: String!
  rarity: Float!     # 0..1 where lower = rarer
}

type Loot {
  id: ID!
  tokenId: BigInt!
  owner: User!
  show: Show!
  metadataURL: String!
  claimTxHash: String!
  createdAt: DateTime!
}

#  ---------------------------------------------------------------------------
#  Governance / Voting
#  ---------------------------------------------------------------------------

type Vote {
  id: ID!
  show: Show!
  question: String!
  options: [VoteOption!]!
  status: VoteStatus!
  results: [VoteResult!]!
  createdAt: DateTime!
  endTime: DateTime!
}

enum VoteStatus {
  PENDING
  ACTIVE
  CLOSED
}

type VoteOption {
  key: String!        # slug e.g. "BLUE_ENDING"
  description: String!
}

type VoteResult {
  optionKey: String!
  votes: BigInt!      # total weight
  percentage: Float!
}

type VoteReceipt {
  voteId: ID!
  optionKey: String!
  voter: User!
  weight: BigInt!
  txHash: String!
  timestamp: DateTime!
}

#  ---------------------------------------------------------------------------
#  Support Types
#  ---------------------------------------------------------------------------

type User {
  id: ID!
  walletAddress: String!
  username: String
  avatarURL: String
  role: Role!
  joinedAt: DateTime!
}

type TransactionReceipt {
  txHash: String!
  blockNumber: BigInt!
  timestamp: DateTime!
  gasUsed: BigInt!
}

type StakeReceipt {
  id: ID!
  pass: Pass!
  txHash: String!
  staked: Boolean!
  timestamp: DateTime!
}

#  ---------------------------------------------------------------------------
#  Events for Subscriptions
#  ---------------------------------------------------------------------------

interface Event {
  id: ID!
  timestamp: DateTime!
}

type ShowEvent implements Event {
  id: ID!
  timestamp: DateTime!
  show: Show!
}

type ActEvent implements Event {
  id: ID!
  timestamp: DateTime!
  act: Act!
  progress: Float!     # 0.0 – 1.0
}

type PassEvent implements Event {
  id: ID!
  timestamp: DateTime!
  pass: Pass!
}

#  ---------------------------------------------------------------------------
#  Pagination Types (Relay Spec)
#  ---------------------------------------------------------------------------

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
}

type ShowConnection {
  edges: [ShowEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ShowEdge {
  cursor: String!
  node: Show!
}

type PassConnection {
  edges: [PassEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PassEdge {
  cursor: String!
  node: Pass!
}

type VoteConnection {
  edges: [VoteEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type VoteEdge {
  cursor: String!
  node: Vote!
}

#  ---------------------------------------------------------------------------
#  End of schema.graphql
#  ---------------------------------------------------------------------------