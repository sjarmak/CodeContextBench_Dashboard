```proto
// Copyright © 2024 CanvasChain.
// SPDX-License-Identifier: Apache-2.0
//
// NOTE: This file is shared by *all* Symphony micro-services to guarantee ABI
// stability across language boundaries (Rust, Go, JS, Elixir). Do **NOT**
// introduce breaking changes without bumping MAJOR API version.
//
// CanvasChain ‑ Symphony / Minting gRPC API ‑ v1
//
// ‑ Purpose  :  Handles the life-cycle of NFT minting requests, including
//               on-chain metadata assembly, multi-layer asset packaging, VRF
//               proof verification, royalty splits and event streaming.
//
// ‑ Patterns :  Factory (contract templates), Event-Driven (mint-event bus),
//               Proxy (lazy-mint custodial wallets), Strategy (crypto curves).

syntax = "proto3";

package canvaschain.symphony.minting.v1;

// ------- Global language-specific package hints --------------------------------
option go_package     = "github.com/canvaschain/symphony/minting/v1;mintingpb";
option java_multiple_files = true;
option java_package   = "com.canvaschain.symphony.minting.v1";
option csharp_namespace = "CanvasChain.Symphony.Minting.V1";
// prost will place generated Rust code under this module path:
option (prost.package) = "ccs_proto::minting";

// ------- Common imports --------------------------------------------------------
import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";


// =============================================================================
// ENUMS
// =============================================================================

enum MintStatus {
  // Unknown/unspecified state. Should be treated as an error by clients.
  MINT_STATUS_UNSPECIFIED = 0;

  // Minting request has been queued but not yet processed by a composer node.
  MINT_STATUS_QUEUED      = 1;

  // Composer node is currently generating the NFT layers & metadata.
  MINT_STATUS_PROCESSING  = 2;

  // Layers & metadata have been generated; on-chain transaction is pending.
  MINT_STATUS_SIGNING     = 3;

  // Transaction has been submitted to the chain, awaiting finality.
  MINT_STATUS_SUBMITTED   = 4;

  // Transaction reached finality; NFT is officially minted.
  MINT_STATUS_FINALIZED   = 5;

  // Minting failed irrecoverably (e.g. insufficient gas, VRF mismatch).
  MINT_STATUS_FAILED      = 6;
}

//==============================================================================
// CORE DATA STRUCTURES
//==============================================================================

message RoyaltyInfo {
  // Blockchain address receiving royalty payouts
  string recipient = 1;
  // Basis points (1/100 of a percent) – e.g. 750 = 7.5 %
  uint32 bps       = 2;
}

message AssetLayer {
  // A short, human-readable identifier, e.g. "background", "melody".
  string name           = 1;
  // Raw bytes or an IPFS/Arweave content hash – type encoded in `uri_scheme`.
  string uri            = 2;
  // MIME type, e.g. "image/svg+xml", "audio/flac".
  string content_type   = 3;
  // Optionally encrypted symmetric key for private layers.
  bytes  encrypted_key  = 4;
}

message OnChainMetadata {
  // Display name of the minted artifact
  string title                           = 1;
  // Free-form description
  string description                     = 2;
  // Artist’s canonical wallet address
  string creator_address                 = 3;
  // Arbitrary attributes used by generative algorithms (rarity, traits, etc.)
  map<string, google.protobuf.Any> attrs = 4;
  // Multi-layered media definition – order matters
  repeated AssetLayer layers             = 5;
  // Royalty splits – one or more recipients
  repeated RoyaltyInfo royalties         = 6;
}

message VRFProof {
  // Compressed VRF output bytes
  bytes   output = 1;
  // Proof bytes validating `output`
  bytes   proof  = 2;
  // PubKey used – hex encoded
  string  pubkey = 3;
}

//==============================================================================
// REQUEST / RESPONSE MESSAGES
//==============================================================================

message MintRequest {
  // User-provided unique identifier (e.g. UUID v4). Used for idempotency.
  string client_request_id = 1;
  // Address that will own the freshly minted NFT
  string recipient_address = 2;
  // Full on-chain metadata packet (see above)
  OnChainMetadata metadata = 3;
  // Proof-of-Inspiration: VRF verifies randomness for generative art.
  VRFProof vrf_proof       = 4;
  // Optional block height – allows “mint at or after” semantics
  uint64 earliest_block    = 5;
}

message MintResponse {
  // Canonical chain-wide NFT identifier – e.g. substrate-style (class, id)
  string nft_id         = 1;
  // Status immediately after enqueue.
  MintStatus status     = 2;
  // Global event stream topic used for subsequent status updates.
  string event_topic    = 3;
}

message BatchMintRequest {
  repeated MintRequest requests = 1;
  // If true, the batch is executed atomically: all succeed or none.
  bool atomic                  = 2;
}

message BatchMintResponse {
  repeated MintResponse results = 1;
  // If `atomic` was requested and any child failed, `roll_back_tx_hash`
  // will contain the chain hash that reverted the batch.
  optional string roll_back_tx_hash = 2;
}

message MintStatusRequest {
  // Either client_request_id or nft_id must be provided
  string client_request_id = 1;
  string nft_id            = 2;
}

message MintStatusResponse {
  MintStatus status     = 1;
  // When status ≥ MINT_STATUS_SUBMITTED
  optional string tx_hash    = 2;
  // When status == MINT_STATUS_FINALIZED
  optional string block_hash = 3;
  // Updated at
  google.protobuf.Timestamp updated_at = 4;
  // If failed – human-readable reason
  optional string failure_reason = 5;
}

//==============================================================================
// STREAMING EVENTS
//==============================================================================

message MintEventStreamRequest {
  // Topic as returned by MintResponse.event_topic
  string topic = 1;
  // If provided, events start **after** this block height
  optional uint64 from_block = 2;
}

message MintEvent {
  MintStatusResponse snapshot = 1;
}

//==============================================================================
// SERVICE DEFINITION
//==============================================================================

service MintingService {
  // Submits a single NFT mint request.
  rpc Mint           (MintRequest)           returns (MintResponse);

  // Submits multiple NFT mint requests in a single call.
  rpc BatchMint      (BatchMintRequest)      returns (BatchMintResponse);

  // Polls for status of a previously submitted request.
  rpc GetMintingStatus (MintStatusRequest)   returns (MintStatusResponse);

  // Server-side streaming of mint status updates.
  rpc StreamMintingEvents (MintEventStreamRequest) returns (stream MintEvent);

  // Health-check – returns empty response if the service is operational.
  rpc Ping (google.protobuf.Empty)           returns (google.protobuf.Empty);
}
```