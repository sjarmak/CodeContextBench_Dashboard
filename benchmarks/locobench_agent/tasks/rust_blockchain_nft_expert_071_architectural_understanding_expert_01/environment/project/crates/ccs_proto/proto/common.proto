syntax = "proto3";

package ccs.common;

option java_multiple_files = true;
option java_package = "org.canvaschain.symphony.common";
option java_outer_classname = "CcsCommonProto";
option csharp_namespace = "CanvasChain.Symphony.Common";
option go_package = "github.com/canvaschain/symphony/ccs_proto/common;common";
option rust_package = "canvas_chain::proto::common";

//  ---------------------------------------------------------------------------
//  CanvasChain Symphony – Common Protobuf Definitions
//
//  This file contains data structures that are shared across all CanvasChain
//  micro-services (composition, minting, remixing, marketplace, governance,
//  staking, etc.). Keeping them in a single proto makes wire compatibility
//  guarantees explicit and promotes reuse across client SDKs generated in
//  multiple languages.
//
//  NOTE:  When adding new fields, use the smallest available tag numbers to
//  avoid hit-rate penalties in Protobuf’s varint encoding.  NEVER change
//  existing tag numbers or their semantics once they have been released.
//  ---------------------------------------------------------------------------

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

// -----------------------------------------------------------------------------
//  Enumerations
// -----------------------------------------------------------------------------

// Cryptographic curve families supported by CanvasChain.
// Strategy pattern in Rust code allows compile-time or run-time selection.
enum CurveType {
  CURVE_UNSPECIFIED = 0;
  CURVE_ED25519     = 1;
  CURVE_SECP256K1   = 2;
  CURVE_BLS12381    = 3;
  CURVE_PQC_FALCON  = 4; // Post-quantum (experimental)
}

// Canonical error codes aligned with gRPC status codes but
// extended for on-chain validation failures.
enum ErrorCode {
  ERROR_UNSPECIFIED           = 0;
  ERROR_INVALID_ARGUMENT      = 3;
  ERROR_NOT_FOUND             = 5;
  ERROR_ALREADY_EXISTS        = 6;
  ERROR_PERMISSION_DENIED     = 7;
  ERROR_RESOURCE_EXHAUSTED    = 8;
  ERROR_FAILED_PRECONDITION   = 9;
  ERROR_ABORTED               = 10;
  ERROR_OUT_OF_RANGE          = 11;
  ERROR_UNIMPLEMENTED         = 12;
  ERROR_INTERNAL              = 13;
  ERROR_UNAVAILABLE           = 14;
  ERROR_DATA_LOSS             = 15;
  ERROR_SIGNATURE_VERIFICATION_FAILED = 101;
  ERROR_SLASHED_VALIDATOR     = 102;
  ERROR_CONSENSUS_FAILURE     = 103;
}

// Execution context in which the request was issued.
enum NetworkEnvironment {
  NETWORK_UNSPECIFIED = 0;
  NETWORK_MAINNET     = 1;
  NETWORK_TESTNET     = 2;
  NETWORK_DEVNET      = 3;
  NETWORK_SIMNET      = 4;
}

// -----------------------------------------------------------------------------
//  Basic Value Objects
// -----------------------------------------------------------------------------

// A wrapped, network-scoped account or contract address.
// Using bytes makes it flexible for 20- or 32-byte addresses.
message Address {
  bytes value = 1;
  NetworkEnvironment network = 2;
}

// Compact UUIDv7 wrapper for globally unique identifiers.
// String representation is used for better JSON interop.
message Uuid {
  string value = 1; // RFC 4122-encoded UUID string.
}

// RFC 3339 / Protobuf timestamp wrapper for semantic clarity.
message ChainTimestamp {
  google.protobuf.Timestamp utc = 1;
}

// Arbitrary large unsigned integer represented as big-endian bytes.
// Prost can map this to `num_bigint::BigUint` via custom traits.
message BigUInt {
  bytes value = 1; // big-endian, no leading zeros.
}

// Arbitrary large signed integer as big-endian two’s complement.
message BigInt {
  bytes value = 1;
}

// -----------------------------------------------------------------------------
//  Cryptography Primitives
// -----------------------------------------------------------------------------

// Public key with flexible curve support using a oneof.
message PublicKey {
  CurveType curve = 1;

  oneof key {
    bytes ed25519     = 2; // 32 bytes
    bytes secp256k1   = 3; // 33 bytes (compressed)
    bytes bls12381    = 4; // 48 bytes G1
    bytes pqc_falcon  = 5; // variable length
  }
}

// Signature wrapper intentionally de-coupled from PublicKey
// to allow detached signature streams.
message Signature {
  CurveType curve = 1;

  oneof sig {
    bytes ed25519     = 2; // 64 bytes
    bytes secp256k1   = 3; // 65 bytes (r,s,v)
    bytes bls12381    = 4; // 96 bytes G2
    bytes pqc_falcon  = 5; // variable length
  }
}

// -----------------------------------------------------------------------------
//  Pagination & Range Helpers
// -----------------------------------------------------------------------------

// Cursor-based pagination adopted by all collection RPCs.
message CursorPaging {
  uint32 page_size = 1;      // max 500 recommended
  string cursor    = 2;      // opaque, encoded state
}

// Inclusive range of block heights or revisions.
message HeightRange {
  uint64 from = 1; // inclusive
  uint64 to   = 2; // inclusive
}

// -----------------------------------------------------------------------------
//  Envelope Structures
// -----------------------------------------------------------------------------

// Generic request header appended to every service RPC.
// Auth, tracing, replay protection, etc.
message RequestHeader {
  Uuid            request_id      = 1;
  PublicKey       caller_pubkey   = 2;
  Signature       caller_sig      = 3;
  NetworkEnvironment network      = 4;
  uint64          nonce           = 5; // monotonic per-account
  google.protobuf.Timestamp submitted_at = 6;
}

// Generic response wrapper for non-streaming RPCs.
// The payload is an `Any` to preserve type information.
message ResponseEnvelope {
  ResponseStatus          status   = 1;
  google.protobuf.Any     payload  = 2; // optional
}

// Detailed response status for rich error handling.
message ResponseStatus {
  bool       ok           = 1;
  ErrorCode  code         = 2;
  string     message      = 3; // human-readable
  repeated google.protobuf.Any details = 4;
}

// -----------------------------------------------------------------------------
//  Off-chain Signature Verification Requests
//  (used by wallet integration service)
// -----------------------------------------------------------------------------

message VerifySignatureRequest {
  bytes      message   = 1;
  PublicKey  pubkey    = 2;
  Signature  signature = 3;
}

message VerifySignatureResponse {
  bool valid = 1;
  ResponseStatus status = 2;
}

// -----------------------------------------------------------------------------
//  File Checksum & Integrity
// -----------------------------------------------------------------------------

// SHA-256 hash of arbitrary content.
message Sha256Hash {
  bytes value = 1; // 32 bytes
}

// Integrity proof containing hash & signature.
// Used when side-loading large multimedia blobs.
message IntegrityProof {
  Sha256Hash content_hash = 1;
  Signature  signer_sig   = 2;
  PublicKey  signer_key   = 3;
}

// -----------------------------------------------------------------------------
//  Reserved tags for forward compatibility.
// -----------------------------------------------------------------------------
reserved 500 to 999;   // Internal use only – do not reuse in public APIs.

