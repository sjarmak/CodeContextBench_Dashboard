syntax = "proto3";

//
// CanvasChain Symphony – Node Protocol
//
// This file defines the low-level gRPC contract used by CanvasChain
// validator / composer / observer nodes.  Messages here are intentionally
// generic so they can be shared among the Rust, Go, TypeScript and Python
// SDKs that power community-run frontends and data indexers.
//
// Copyright © 2023-2024 CanvasChain Contributors
//

package canvaschain.ccs.node.v1;

// Target-specific namespaces for language generators.
//
// The Go package path MUST match the module name used by `go.mod` so that
// `protoc-gen-go-grpc` resolves imports correctly.  The Rust annotation
// matches the crate where the generated code will live so that other
// micro-crates can `use ccs_proto::node::v1::*;`.
option go_package   = "github.com/canvaschain/ccs/proto/node/v1;nodev1";
option rust_package = "ccs_proto::node::v1";

import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";


//--------------------------------------------------------------------
//  Enumerations
//--------------------------------------------------------------------

enum NodeRole {
  NODE_ROLE_UNSPECIFIED = 0;
  NODE_ROLE_VALIDATOR   = 1; // Participates in consensus & staking
  NODE_ROLE_COMPOSER    = 2; // Authorised to publish generative art updates
  NODE_ROLE_OBSERVER    = 3; // Read-only node used for indexing / analytics
  NODE_ROLE_ARCHIVER    = 4; // Long-term storage of historical blobs
}

enum SignatureScheme {
  SIGNATURE_SCHEME_UNSPECIFIED = 0;
  SIGNATURE_SCHEME_ED25519     = 1;
  SIGNATURE_SCHEME_BLS12_381   = 2;
  SIGNATURE_SCHEME_DILITHIUM   = 3; // Post-quantum (experimental)
}

enum VotePhase {
  VOTE_PHASE_UNSPECIFIED = 0;
  VOTE_PHASE_PREVOTE     = 1;
  VOTE_PHASE_PRECOMMIT   = 2;
  VOTE_PHASE_COMMIT      = 3;
}

//--------------------------------------------------------------------
//  Basic value objects
//--------------------------------------------------------------------

message NodeId {
  // Bech32-encoded public identifier (e.g. ccsval1…)
  string value = 1;
}

message PublicKey {
  bytes            key_bytes = 1;
  SignatureScheme  scheme    = 2;
}

message Version {
  uint32 major = 1;
  uint32 minor = 2;
  uint32 patch = 3;
}

//--------------------------------------------------------------------
//  Node metadata & liveness
//--------------------------------------------------------------------

message NodeInfo {
  NodeId           id                 = 1;
  PublicKey        public_key         = 2;
  NodeRole         role               = 3;
  Version          software_version   = 4;
  repeated string  supported_features = 5; // e.g. ["bls","defi","governance"]
}

// One-way streaming heartbeat from node → peers (or monitoring daemon).
message HeartbeatRequest {
  NodeInfo                    node      = 1;
  google.protobuf.Timestamp   timestamp = 2;
  uint64                      height    = 3; // Current chain height
  bytes                       app_hash  = 4; // Application state hash
}

message HeartbeatResponse {
  bool   ok        = 1;
  string message   = 2;
}

//--------------------------------------------------------------------
//  Consensus messages (Proof-of-Inspiration)
//--------------------------------------------------------------------

message ConsensusProposal {
  // A VRF-generated round identifier (unique within height)
  string                     round_id   = 1;
  uint64                     height     = 2;
  bytes                      block_hash = 3;
  NodeId                     proposer   = 4;
  google.protobuf.Timestamp  timestamp  = 5;
}

message ProposalVote {
  NodeId                     voter      = 1;
  string                     round_id   = 2;
  VotePhase                  phase      = 3;
  bytes                      signature  = 4;
  google.protobuf.Timestamp  timestamp  = 5;
}

//--------------------------------------------------------------------
//  Generative Art Updates
//--------------------------------------------------------------------

message ArtLayerDiff {
  // The layer within the NFT being updated (0 = base layer).
  uint32     layer_index = 1;

  // Binary patch, e.g. LZ4-compressed PNG diff, GLSL shader code,
  // audio buffer or JSON describing procedural parameters.
  bytes      diff_bytes  = 2;

  // MIME type so frontends can render quickly without introspection.
  string     media_type  = 3;
}

message ArtUpdate {
  string                     nft_id        = 1;  // ERC-721 / CW-721 token id
  repeated ArtLayerDiff      diffs         = 2;
  uint64                     gas_price     = 3;  // Wei
  NodeId                     composer      = 4;
  google.protobuf.Timestamp  timestamp     = 5;
}

message ArtUpdateAck {
  // Empty ok==true response confirms network acceptance.
  bool   ok       = 1;
  string message  = 2;
}

//--------------------------------------------------------------------
//  Event stream (push from node)
//--------------------------------------------------------------------

message NodeEvent {
  google.protobuf.Timestamp  timestamp = 1;

  oneof payload {
    HeartbeatRequest  heartbeat   = 2;
    ConsensusProposal proposal    = 3;
    ProposalVote      vote        = 4;
    ArtUpdate         art_update  = 5;
    google.protobuf.Any custom    = 6; // For experimental extensions
  }
}

//--------------------------------------------------------------------
//  gRPC Service
//--------------------------------------------------------------------

service NodeService {

  // Liveness & health-check
  rpc Ping(google.protobuf.Empty) returns (HeartbeatResponse);

  // Bi-directional heartbeat stream used to keep connections warm.
  rpc StreamHeartbeat(stream HeartbeatRequest)
      returns (stream HeartbeatResponse);

  // Submit a consensus proposal (broadcast by proposer node).
  rpc BroadcastProposal(ConsensusProposal) returns (google.protobuf.Empty);

  // Submit a vote for a previously received proposal.
  rpc SubmitVote(ProposalVote) returns (google.protobuf.Empty);

  // Publish a generative art update after winning a composer slot.
  rpc PublishArtUpdate(ArtUpdate) returns (ArtUpdateAck);

  // Long-lived SSE / WebSocket-like stream for indexers and UI gateways.
  rpc SubscribeEvents(google.protobuf.Empty) returns (stream NodeEvent);

  // Retrieve static information about a node (e.g. from address book).
  rpc GetNodeInfo(NodeId) returns (NodeInfo);
}