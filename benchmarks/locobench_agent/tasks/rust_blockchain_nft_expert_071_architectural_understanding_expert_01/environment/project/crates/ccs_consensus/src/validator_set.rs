```rust
//! Consensus ‒ Validator Set
//!
//! This module defines a thread–safe validator set used by the CanvasChain
//! Symphony consensus (Proof-of-Inspiration).  Besides bookkeeping of
//! validator metadata and stake, it implements a *weighted, verifiable*
//! validator election algorithm that deterministically maps an epoch-wide
//! random seed to the next “composer” (block author).  The smallest
//! stake-adjusted hash wins, which guarantees liveness while preserving
//! proportional fairness.
//!
//! NOTE:  In a full-blown implementation the VRF proof would be generated by
//! the validator itself.  For the sake of simplicity we compute it here by
//! hashing `(epoch_seed || public_key)`.  The resulting 32-byte array can be
//! verified by every replica and therefore acts as a cheap stand-in for a
//! proper VRF proof.

#![allow(clippy::cast_possible_truncation)] // intentional for stake math

use std::{
    collections::hash_map::Entry,
    fmt,
    sync::{Arc, RwLock},
    time::SystemTime,
};

use ed25519_dalek::PublicKey;
use indexmap::IndexMap;
use rand::{rngs::OsRng, RngCore};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use thiserror::Error;

/// Alias for 32-byte public key.  A fixed-size array is hashable and can be
/// used as an `IndexMap` key.
pub type PublicKeyBytes = [u8; 32];

/// Chain block number.
pub type BlockNumber = u64;

/// Unique, monotonically increasing identifier assigned to each validator.
pub type ValidatorId = u64;

/// Amount of tokens staked (in the smallest denomination).
pub type Tokens = u128;

/// Errors that can occur while mutating or querying the validator set.
#[derive(Debug, Error)]
pub enum ValidatorSetError {
    #[error("validator already exists")]
    AlreadyExists,
    #[error("validator not found")]
    NotFound,
    #[error("validator is jailed until block {0}")]
    Jailed(BlockNumber),
    #[error("validator not active")]
    NotActive,
    #[error("stake underflow")]
    StakeUnderflow,
}

/// Status of a validator, relevant for eligibility during selection.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ValidatorStatus {
    /// Fully participating validator.
    Active,
    /// Temporarily punished validator.  Contains the block height until which
    /// the validator is excluded from selection.
    Jailed { until: BlockNumber },
    /// Permanently removed validator.  No further state changes allowed.
    Tombstoned,
}

/// Validator metadata stored on chain.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Validator {
    pub id: ValidatorId,
    pub pub_key: PublicKeyBytes,
    pub stake: Tokens,
    pub metadata: Option<String>,
    pub status: ValidatorStatus,
    pub last_composed: Option<BlockNumber>,
    pub registered_at: SystemTime,
}

impl Validator {
    fn is_active_at(&self, current_block: BlockNumber) -> bool {
        match self.status {
            ValidatorStatus::Active => true,
            ValidatorStatus::Jailed { until } => current_block >= until,
            ValidatorStatus::Tombstoned => false,
        }
    }
}

/// The winning validator together with its proof and score.
#[derive(Debug, Clone)]
pub struct ComposerSelection {
    pub validator: Validator,
    /// 256-bit hash proving deterministic selection.
    pub proof: [u8; 32],
    /// The value after dividing by stake.  Lower is better.
    pub score: u128,
}

/// Thread-safe validator set.
#[derive(Clone, Default)]
pub struct ValidatorSet {
    /// Shared, mutable state.
    inner: Arc<RwLock<Inner>>,
}

#[derive(Default)]
struct Inner {
    validators: IndexMap<PublicKeyBytes, Validator>,
    next_id: ValidatorId,
}

impl ValidatorSet {
    /// Create a new, empty set.
    pub fn new() -> Self {
        Self {
            inner: Arc::new(RwLock::new(Inner::default())),
        }
    }

    /// Register a validator.  Fails if the public key already exists.
    pub fn add_validator(
        &self,
        pub_key: PublicKey,
        initial_stake: Tokens,
        metadata: Option<String>,
    ) -> Result<ValidatorId, ValidatorSetError> {
        let mut guard = self.inner.write().expect("poisoned lock");

        match guard.validators.entry(pub_key.to_bytes()) {
            Entry::Occupied(_) => Err(ValidatorSetError::AlreadyExists),
            Entry::Vacant(v) => {
                let id = guard.next_id;
                guard.next_id = guard
                    .next_id
                    .checked_add(1)
                    .expect("validator id overflow");

                let validator = Validator {
                    id,
                    pub_key: pub_key.to_bytes(),
                    stake: initial_stake,
                    metadata,
                    status: ValidatorStatus::Active,
                    last_composed: None,
                    registered_at: SystemTime::now(),
                };
                v.insert(validator);
                Ok(id)
            }
        }
    }

    /// Remove a validator completely (tombstone).  Jailed validators can be
    /// removed as well.
    pub fn remove_validator(
        &self,
        pub_key: &PublicKeyBytes,
    ) -> Result<Validator, ValidatorSetError> {
        let mut guard = self.inner.write().expect("poisoned lock");

        guard
            .validators
            .remove(pub_key)
            .map(|mut v| {
                v.status = ValidatorStatus::Tombstoned;
                v
            })
            .ok_or(ValidatorSetError::NotFound)
    }

    /// Add (positive) or subtract (negative) from the validator's stake.
    /// Returns the updated stake.
    pub fn adjust_stake(
        &self,
        pub_key: &PublicKeyBytes,
        delta: i128,
    ) -> Result<Tokens, ValidatorSetError> {
        let mut guard = self.inner.write().expect("poisoned lock");
        let validator = guard
            .validators
            .get_mut(pub_key)
            .ok_or(ValidatorSetError::NotFound)?;

        if validator.status == ValidatorStatus::Tombstoned {
            return Err(ValidatorSetError::NotActive);
        }

        if delta.is_negative() {
            let abs = delta.unsigned_abs() as Tokens;
            if abs > validator.stake {
                return Err(ValidatorSetError::StakeUnderflow);
            }
            validator.stake -= abs;
        } else {
            validator.stake = validator.stake.saturating_add(delta as Tokens);
        }

        Ok(validator.stake)
    }

    /// Temporarily jail a validator until the provided block number.
    pub fn jail(
        &self,
        pub_key: &PublicKeyBytes,
        until: BlockNumber,
    ) -> Result<(), ValidatorSetError> {
        let mut guard = self.inner.write().expect("poisoned lock");
        let val = guard
            .validators
            .get_mut(pub_key)
            .ok_or(ValidatorSetError::NotFound)?;

        if matches!(val.status, ValidatorStatus::Tombstoned) {
            return Err(ValidatorSetError::NotActive);
        }

        val.status = ValidatorStatus::Jailed { until };
        Ok(())
    }

    /// Restore a jailed validator early (e.g. on governance vote).
    pub fn unjail(&self, pub_key: &PublicKeyBytes) -> Result<(), ValidatorSetError> {
        let mut guard = self.inner.write().expect("poisoned lock");
        let val = guard
            .validators
            .get_mut(pub_key)
            .ok_or(ValidatorSetError::NotFound)?;

        match val.status {
            ValidatorStatus::Jailed { .. } => {
                val.status = ValidatorStatus::Active;
                Ok(())
            }
            _ => Err(ValidatorSetError::NotActive),
        }
    }

    /// Return the total stake of *active* validators at the given block.
    pub fn total_stake(&self, current_block: BlockNumber) -> Tokens {
        let guard = self.inner.read().expect("poisoned lock");
        guard
            .validators
            .values()
            .filter(|v| v.is_active_at(current_block))
            .map(|v| v.stake)
            .sum()
    }

    /// Deterministically select the next composer from all active validators.
    /// Returns `None` when no validator is eligible (e.g. genesis).
    pub fn select_composer(
        &self,
        epoch_seed: &[u8; 32],
        current_block: BlockNumber,
    ) -> Option<ComposerSelection> {
        let guard = self.inner.read().expect("poisoned lock");

        guard
            .validators
            .values()
            .filter(|v| v.is_active_at(current_block) && v.stake > 0)
            .map(|v| {
                // Proof is SHA256(epoch_seed || pub_key)
                let mut hasher = Sha256::new();
                hasher.update(epoch_seed);
                hasher.update(&v.pub_key);
                let proof = hasher.finalize();
                let hash_bytes: [u8; 32] = proof.into();

                // Use the first 16 bytes for comparison to fit in u128.
                let raw = u128::from_be_bytes(hash_bytes[0..16].try_into().unwrap());
                // Lower stake_weighted score wins.
                let score = raw / v.stake.max(1);

                (score, hash_bytes, v.clone())
            })
            .min_by_key(|(score, _, _)| *score)
            .map(|(score, proof, validator)| ComposerSelection {
                validator,
                proof,
                score,
            })
    }

    /// Return a snapshot of all validators (for RPC/explorer).
    pub fn snapshot(&self) -> Vec<Validator> {
        let guard = self.inner.read().expect("poisoned lock");
        guard.validators.values().cloned().collect()
    }
}

impl fmt::Debug for ValidatorSet {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let guard = self.inner.read().expect("poisoned lock");
        f.debug_struct("ValidatorSet")
            .field("validators", &guard.validators.len())
            .finish()
    }
}

// -----------------------------------------------------------------------------
// Utilities
// -----------------------------------------------------------------------------

/// Generate a random 32-byte epoch seed.  Real-world deployments use
/// verifiable randomness (e.g. beacon chain).
pub fn random_epoch_seed() -> [u8; 32] {
    let mut seed = [0u8; 32];
    OsRng.fill_bytes(&mut seed);
    seed
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------
#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::{Keypair, Signer};

    fn generate_key() -> PublicKey {
        Keypair::generate(&mut OsRng {}).public
    }

    #[test]
    fn add_and_snapshot() {
        let set = ValidatorSet::new();
        let k1 = generate_key();
        let k2 = generate_key();

        assert!(set.add_validator(k1, 1_000, None).is_ok());
        assert!(set.add_validator(k2, 5_000, Some("artist".into())).is_ok());

        let snapshot = set.snapshot();
        assert_eq!(snapshot.len(), 2);
    }

    #[test]
    fn composer_selection_is_deterministic() {
        let set = ValidatorSet::new();
        let k1 = generate_key();
        let k2 = generate_key();
        set.add_validator(k1, 10_000, None).unwrap();
        set.add_validator(k2, 10_000, None).unwrap();

        let seed = random_epoch_seed();
        let sel1 = set.select_composer(&seed, 0).unwrap();
        let sel2 = set.select_composer(&seed, 0).unwrap();
        assert_eq!(sel1.validator.id, sel2.validator.id);
        assert_eq!(sel1.proof, sel2.proof);
    }

    #[test]
    fn stake_weight_affects_probability() {
        let set = ValidatorSet::new();
        let rich = generate_key();
        let poor = generate_key();
        set.add_validator(rich, 10_000, None).unwrap();
        set.add_validator(poor, 1, None).unwrap();

        let mut rich_wins = 0u32;
        // Run multiple rounds with random seeds.
        for _ in 0..100 {
            let seed = random_epoch_seed();
            let sel = set.select_composer(&seed, 0).unwrap();
            if sel.validator.pub_key == rich.to_bytes() {
                rich_wins += 1;
            }
        }
        // Rich validator should win the majority of the time.
        assert!(rich_wins > 80, "rich_wins={rich_wins}");
    }
}
```