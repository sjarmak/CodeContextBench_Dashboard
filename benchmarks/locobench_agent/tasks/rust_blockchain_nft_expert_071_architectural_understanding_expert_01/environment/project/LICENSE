```rust
//! CanvasChain Symphony – License Management Module
//!
//! This module is intentionally named `LICENSE` (and not, for instance,
//! `license.rs`) so that a single source file can double both as the legal
//! license of the repository *and* as a Rust module that provides run-time
//! access to licensing information throughout the micro-service suite.
//!
//! Rationale:
//! 1. Service components frequently need to embed SPDX identifiers and full
//!    license texts inside on-chain metadata (e.g., as part of an NFT’s
//!    provenance trail).
//! 2. A single source of truth avoids divergence between the repository’s
//!    top-level **LICENSE** and the string literals shipped in binaries.
//!
//! IMPORTANT: If you copy or modify this file, keep the SPDX identifier on
//! the first non-comment line in sync with the legal license you intend to
//! apply to your fork.

// SPDX-License-Identifier: MIT OR Apache-2.0

//! # Quickstart
//! ```
//! use license::{ProjectLicense, LicensePolicy};
//!
//! fn main() -> anyhow::Result<()> {
//!     // Ensure the current binary is allowed to link with GPL-3.0 code.
//!     let gpl = ProjectLicense::parse("GPL-3.0")?;
//!     LicensePolicy::default()
//!         .assert_compatibility(&gpl)?;
//!     Ok(())
//! }
//! ```

use std::collections::HashSet;
use std::fmt::{self, Display, Formatter};
use std::str::FromStr;

use once_cell::sync::Lazy;
use thiserror::Error;

/// A list of SPDX identifiers allowed in the CanvasChain Symphony ecosystem.
///
/// This list tries to strike a balance between openness and compatibility
/// with restrictive jurisdictions.
///
/// NOTE: Update this list through a pull-request if adding support for more
/// exotic licenses is required.
static ALLOWED_LICENSES: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    [
        "MIT",
        "Apache-2.0",
        "BSD-2-Clause",
        "BSD-3-Clause",
        "ISC",
        "Zlib",
        "Unlicense",
    ]
    .into_iter()
    .collect()
});

/// SPDX identifiers considered *copyleft* and thus potentially infectious
/// when linked into proprietary or closed-source binaries.
static COPYLEFT_LICENSES: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    ["GPL-2.0", "GPL-3.0", "LGPL-2.1", "LGPL-3.0"]
        .into_iter()
        .collect()
});

/// A domain model representing a software license used within the platform.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ProjectLicense {
    /// The canonical SPDX identifier, e.g. `"MIT"`.
    spdx_id: String,
    /// Human-readable short name.
    name: String,
    /// An optional URL pointing to the full license text.
    url: Option<String>,
    /// Optional raw license text (may be truncated for brevity).
    text: Option<String>,
}

impl ProjectLicense {
    /// Parse a `ProjectLicense` from an SPDX identifier.
    ///
    /// # Errors
    /// Returns [`LicenseError::Unsupported`] if the given identifier is not
    /// recognized.
    pub fn parse<S: AsRef<str>>(input: S) -> Result<Self, LicenseError> {
        let id = input.as_ref().trim();
        if !ALLOWED_LICENSES.contains(id) && !COPYLEFT_LICENSES.contains(id) {
            return Err(LicenseError::Unsupported(id.into()));
        }

        Ok(Self {
            spdx_id: id.into(),
            name: id.into(),
            url: Some(format!("https://spdx.org/licenses/{}.html", id)),
            text: None,
        })
    }

    /// Returns `true` if this license is considered *copyleft*.
    pub fn is_copyleft(&self) -> bool {
        COPYLEFT_LICENSES.contains(self.spdx_id.as_str())
    }

    /// The canonical SPDX identifier.
    pub fn id(&self) -> &str {
        &self.spdx_id
    }
}

impl Display for ProjectLicense {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{} ({})", self.spdx_id, self.url.as_deref().unwrap_or("N/A"))
    }
}

impl FromStr for ProjectLicense {
    type Err = LicenseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::parse(s)
    }
}

/// A policy used to validate that the dependency tree of a binary complies
/// with the governance rules of the DAO owning this service.
#[derive(Debug, Clone)]
pub struct LicensePolicy {
    /// If `true`, linking against copyleft licenses is allowed.
    allow_copyleft: bool,
    /// Additional SPDX identifiers whitelisted by governance vote.
    extra_whitelist: HashSet<String>,
}

impl LicensePolicy {
    /// Construct a new builder.
    pub fn builder() -> LicensePolicyBuilder {
        LicensePolicyBuilder::default()
    }

    /// Validates a license against the current policy.
    ///
    /// # Errors
    /// Returns [`LicenseError::Forbidden`] if the license is not compatible
    /// with the policy.
    pub fn assert_compatibility(&self, lic: &ProjectLicense) -> Result<(), LicenseError> {
        let id = lic.id();
        if ALLOWED_LICENSES.contains(id)
            || self.extra_whitelist.contains(id)
            || (self.allow_copyleft && COPYLEFT_LICENSES.contains(id))
        {
            Ok(())
        } else {
            Err(LicenseError::Forbidden(id.into()))
        }
    }
}

impl Default for LicensePolicy {
    fn default() -> Self {
        Self {
            allow_copyleft: false,
            extra_whitelist: HashSet::new(),
        }
    }
}

/// Builder for [`LicensePolicy`].
#[derive(Debug, Default)]
pub struct LicensePolicyBuilder {
    allow_copyleft: bool,
    extra_whitelist: HashSet<String>,
}

impl LicensePolicyBuilder {
    pub fn allow_copyleft(mut self, yes: bool) -> Self {
        self.allow_copyleft = yes;
        self
    }

    pub fn extra_whitelist<I, S>(mut self, licenses: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        self.extra_whitelist = licenses.into_iter().map(Into::into).collect();
        self
    }

    pub fn build(self) -> LicensePolicy {
        LicensePolicy {
            allow_copyleft: self.allow_copyleft,
            extra_whitelist: self.extra_whitelist,
        }
    }
}

/// Possible errors raised by this module.
#[derive(Debug, Error)]
pub enum LicenseError {
    #[error("unsupported license: `{0}`")]
    Unsupported(String),
    #[error("license `{0}` is forbidden by policy")]
    Forbidden(String),
}

///////////////////////////////////////////////////////////////////////////////
// Embedded license texts
///////////////////////////////////////////////////////////////////////////////

/// Full MIT license text shipped at runtime.
///
/// Keeping it inside the binary guarantees that on-chain provenance metadata
/// doesn’t break if the repository disappears.
pub const MIT_TEXT: &str = r#"MIT License

Copyright (c) 2024 CanvasChain Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
...
(Full MIT license continues)
"#;

/// Apache-2.0 license (abridged).
pub const APACHE2_TEXT: &str = r#"Apache License
Version 2.0, January 2004
http://www.apache.org/licenses/
...
(Full Apache-2.0 license continues)
"#;

///////////////////////////////////////////////////////////////////////////////
// Tests
///////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_known_license() {
        let mit = ProjectLicense::parse("MIT").expect("MIT should parse");
        assert_eq!(mit.id(), "MIT");
        assert!(!mit.is_copyleft());
    }

    #[test]
    fn forbid_unknown_license() {
        let res = ProjectLicense::parse("MadeUp-1.0");
        assert!(matches!(res, Err(LicenseError::Unsupported(_))));
    }

    #[test]
    fn policy_blocks_gpl_by_default() {
        let gpl = ProjectLicense::parse("GPL-3.0").unwrap();
        let policy = LicensePolicy::default();
        assert!(policy.assert_compatibility(&gpl).is_err());
    }

    #[test]
    fn policy_allows_gpl_when_enabled() {
        let gpl = ProjectLicense::parse("GPL-3.0").unwrap();
        let policy = LicensePolicy::builder()
            .allow_copyleft(true)
            .build();
        assert!(policy.assert_compatibility(&gpl).is_ok());
    }
}
```