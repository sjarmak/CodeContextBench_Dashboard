```rust
//! CanvasChain Symphony – Minting Service
//! --------------------------------------
//! This micro–service is responsible for turning user–submitted artwork
//! metadata into freshly‐minted multilayer NFTs.  It exposes a gRPC API
//! to the outside world and broadcasts `nft.minted` events on the shared
//! message bus so that the other Symphony components (royalty streaming,
//! marketplace, on-chain governance, …) can react in real-time.
//
//  ┌───────────────────────────────┐
//  │  External gRPC Clients        │
//  └──────────────┬────────────────┘
//                 │  MintRequest
//  ┌──────────────▼────────────────┐      ┌───────────────────────────┐
//  │  Minting gRPC Service         │─────▶│  NATS Event Bus           │
//  └──────────────┬────────────────┘      └───────────────┬───────────┘
//                 │                                        │  nft.minted
//  ┌──────────────▼────────────────┐                       │
//  │  Local Signer (Ed25519/…)     │                       │
//  └──────────────┬────────────────┘                       │
//                 │                                        │
//        ┌────────▼────────┐                               │
//        │  Sqlite KV-DB   │                               │
//        └─────────────────┘                               ▼
//
//  Implementation highlights
//  • gRPC transport: tonic
//  • Event bus:      async-nats
//  • Signing:        Strategy pattern (Ed25519 now, pluggable for future)
//
//  ---------------------------------------------------------
//  NOTE: This is a stand-alone single-file example.  In a real production
//  crate you would split models, config, gRPC definitions and service
//  logic into dedicated modules / crates.
//  ---------------------------------------------------------

#![warn(clippy::all, rust_2018_idioms)]

use std::{net::SocketAddr, sync::Arc, time::SystemTime};

use async_nats::ConnectOptions;
use blake3::Hasher;
use once_cell::sync::OnceCell;
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::sync::Mutex;
use tokio_stream::StreamExt;
use tonic::{transport::Server, Request, Response, Status};
use tracing::{error, info, instrument, warn};

//
// ============ gRPC API (auto-generated by prost / tonic) ==================
//
pub mod proto {
    // The build script normally compiles .proto files and places the generated
    // Rust into OUT_DIR.  For this single-file example we embed a tiny schema
    // directly with `tonic::include_proto!`.
    tonic::include_proto!("minting");
}

use proto::{
    minting_server::{Minting, MintingServer},
    MintRequest, MintResponse,
};

//
// =========================== Configuration =================================
//
#[derive(Debug, Clone, Deserialize)]
struct AppConfig {
    grpc_addr: String,
    nats_url: String,
    signing_strategy: SigningStrategyCfg,
}

impl AppConfig {
    /// Load configuration from environment variables (prefixed with `MINT_`)
    /// or fall back to sane defaults.
    fn from_env() -> Result<Self, ConfigError> {
        let mut cfg = config::Config::builder()
            .set_default("grpc_addr", "0.0.0.0:54050")?
            .set_default("nats_url", "nats://127.0.0.1:4222")?
            .build()?;

        // Environment overrides
        cfg.merge(config::Environment::with_prefix("MINT").separator("__"))?;

        Ok(cfg.try_deserialize()?)
    }
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "snake_case")]
enum SigningStrategyCfg {
    Ed25519,
    // bls, pqc, …
}

//
// ========================= Strategy: Signer =================================
//
#[derive(Debug, Error)]
enum SigningError {
    #[error("ed25519 error: {0}")]
    Ed25519(#[from] ed25519_dalek::SignatureError),
    #[error("unsupported signing strategy")]
    Unsupported,
}

trait Signer: Send + Sync {
    fn sign(&self, data: &[u8]) -> Result<Vec<u8>, SigningError>;
    fn public_key(&self) -> Vec<u8>;
}

type DynSigner = Arc<dyn Signer>;

struct Ed25519Signer {
    key: ed25519_dalek::Keypair,
}

impl Ed25519Signer {
    fn new() -> Result<Self, SigningError> {
        use rand::rngs::OsRng;
        Ok(Self {
            key: ed25519_dalek::Keypair::generate(&mut OsRng),
        })
    }
}

impl Signer for Ed25519Signer {
    fn sign(&self, data: &[u8]) -> Result<Vec<u8>, SigningError> {
        Ok(self.key.sign(data).to_bytes().to_vec())
    }

    fn public_key(&self) -> Vec<u8> {
        self.key.public.to_bytes().to_vec()
    }
}

//
// ======================= Domain & Persistence ==============================
//
#[derive(Debug, Clone, Serialize, Deserialize)]
struct NftMetadata {
    name: String,
    description: String,
    creator_wallet: String,
    layers: Vec<String>,
    timestamp: u64,
}

impl TryFrom<MintRequest> for NftMetadata {
    type Error = Status;

    fn try_from(req: MintRequest) -> Result<Self, Self::Error> {
        serde_json::from_slice(&req.metadata_json)
            .map_err(|e| Status::invalid_argument(format!("invalid metadata: {e}")))
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct MintedEvent {
    token_id: String,
    owner: String,
    signature: String,
    metadata: NftMetadata,
}

//
// Very light-weight store based on rusqlite for the prototype
//
#[derive(Debug)]
struct KvStore {
    conn: rusqlite::Connection,
}

impl KvStore {
    fn new(path: &str) -> rusqlite::Result<Self> {
        let conn = rusqlite::Connection::open(path)?;
        conn.execute_batch(
            "CREATE TABLE IF NOT EXISTS nft (
               token_id    TEXT PRIMARY KEY,
               owner       TEXT NOT NULL,
               metadata    TEXT NOT NULL
             );",
        )?;
        Ok(Self { conn })
    }

    fn insert_nft(
        &self,
        token_id: &str,
        owner: &str,
        metadata: &NftMetadata,
    ) -> rusqlite::Result<()> {
        let json = serde_json::to_string(metadata)?;
        self.conn.execute(
            "INSERT INTO nft (token_id, owner, metadata) VALUES (?1, ?2, ?3)",
            rusqlite::params![token_id, owner, json],
        )?;
        Ok(())
    }
}

//
// ========================= Event Publisher =================================
//
#[derive(Debug)]
struct EventBus {
    client: async_nats::Client,
}

impl EventBus {
    async fn new(url: &str) -> Result<Self, EventBusError> {
        let options = ConnectOptions::new().name("minting_service");
        let client = options.connect(url).await?;
        Ok(Self { client })
    }

    async fn publish(&self, subject: &str, payload: impl Into<Vec<u8>>) -> Result<(), EventBusError> {
        self.client
            .publish(subject.into(), payload.into())
            .await?;
        Ok(())
    }
}

#[derive(Debug, Error)]
enum EventBusError {
    #[error("nats: {0}")]
    Nats(#[from] async_nats::Error),
}

//
// ======================== Minting Service ==================================
//
#[derive(Debug)]
struct MintingSvc {
    cfg: AppConfig,
    signer: DynSigner,
    store: Arc<KvStore>,
    bus: Arc<EventBus>,
}

impl MintingSvc {
    async fn new(cfg: AppConfig, signer: DynSigner) -> Result<Self, StartupError> {
        let store = Arc::new(KvStore::new("minting.db")?);
        let bus = Arc::new(EventBus::new(&cfg.nats_url).await?);
        Ok(Self {
            cfg,
            signer,
            store,
            bus,
        })
    }

    /// Derive a deterministic token id from NFT content.
    fn compute_token_id(metadata: &NftMetadata) -> String {
        let mut h = Hasher::new();
        h.update(metadata.name.as_bytes());
        h.update(metadata.description.as_bytes());
        h.update(metadata.creator_wallet.as_bytes());
        for layer in &metadata.layers {
            h.update(layer.as_bytes());
        }
        h.update(&metadata.timestamp.to_le_bytes());
        format!("0x{}", h.finalize().to_hex())
    }
}

#[tonic::async_trait]
impl Minting for MintingSvc {
    #[instrument(skip(self, request))]
    async fn mint(
        &self,
        request: Request<MintRequest>,
    ) -> Result<Response<MintResponse>, Status> {
        let req = request.into_inner();
        let metadata: NftMetadata = req.try_into()?;
        let token_id = Self::compute_token_id(&metadata);

        // Sign the token id so that other nodes can verify authenticity.
        let signature = self
            .signer
            .sign(token_id.as_bytes())
            .map_err(|e| Status::internal(format!("signing failed: {e}")))?;

        // Persist locally.
        if let Err(e) = self
            .store
            .insert_nft(&token_id, &metadata.creator_wallet, &metadata)
        {
            error!(?e, "DB insert failed");
            return Err(Status::internal("internal DB error"));
        }

        // Broadcast event.
        let event = MintedEvent {
            token_id: token_id.clone(),
            owner: metadata.creator_wallet.clone(),
            signature: base64::encode(&signature),
            metadata: metadata.clone(),
        };
        let payload = serde_json::to_vec(&event).expect("serialize");
        if let Err(e) = self.bus.publish("nft.minted", payload).await {
            warn!(?e, "failed to publish nft.minted event");
        }

        let resp = MintResponse {
            token_id,
            signature: signature.into(),
            public_key: self.signer.public_key(),
        };
        Ok(Response::new(resp))
    }
}

//
// =============================== Errors ====================================
//
#[derive(Debug, Error)]
enum StartupError {
    #[error("config: {0}")]
    Config(#[from] ConfigError),
    #[error("signing: {0}")]
    Signing(#[from] SigningError),
    #[error("db: {0}")]
    Db(#[from] rusqlite::Error),
    #[error("event bus: {0}")]
    EventBus(#[from] EventBusError),
}

#[derive(Debug, Error)]
#[error("configuration error: {0}")]
struct ConfigError(#[from] config::ConfigError);

//
// ============================== Bootstrap ==================================
//
static TRACING: OnceCell<()> = OnceCell::new();

fn init_tracing() {
    TRACING.get_or_init(|| {
        tracing_subscriber::fmt()
            .with_env_filter("info,minting_service=debug")
            .init();
    });
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    init_tracing();

    // 1. Load configuration
    let cfg = match AppConfig::from_env() {
        Ok(c) => c,
        Err(e) => {
            error!(?e, "invalid configuration");
            std::process::exit(1);
        }
    };

    // 2. Instantiate signer (strategy pattern)
    let signer: DynSigner = match cfg.signing_strategy {
        SigningStrategyCfg::Ed25519 => Arc::new(Ed25519Signer::new()?),
    };

    // 3. Compose service
    let svc = MintingSvc::new(cfg.clone(), signer)
        .await
        .map_err(|e| {
            error!(?e, "failed to start service");
            e
        })?;

    // 4. Run gRPC server
    let addr: SocketAddr = cfg.grpc_addr.parse()?;
    info!("MintingService listening on {addr}");
    Server::builder()
        .add_service(MintingServer::new(svc))
        .serve(addr)
        .await?;

    Ok(())
}
```