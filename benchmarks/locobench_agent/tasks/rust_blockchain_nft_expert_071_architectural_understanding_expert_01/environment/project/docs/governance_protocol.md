```markdown
<!--
    File: docs/governance_protocol.md
    Project: CanvasChain Symphony â€“ rust_blockchain_nft_expert_071
    --------------------------------------------------------------
    This document is the single source-of-truth for the on-chain
    governance mechanism that drives protocol evolution, curator
    incentives, and generative-art movements across the Symphony.
    It is intended for core developers, tooling authors, auditors,
    and NFT collectives who integrate directly with the runtime.
-->

# CanvasChain Symphony Governance Protocol

CanvasChain Symphony is governed entirely on-chain through a
token-weighted, stake-weighted process that combines **Proof-of-
Inspiration (PoI)** with a modular on-chain council and an open
referenda system.  
The protocol is implemented in Rust and compiled to WebAssembly
for deterministic smart-contract execution, while the **Governance
Microservice** orchestrates off-chain tasks and gRPC messaging.

---

## Table of Contents

1. Goals & Principles
2. Governing Token: `CNOTE`
3. Proposal Lifecycle
4. Voting & Delegation Model
5. Smart-Contract Interface (Rust/ink!)
6. Governance gRPC Microservice
7. Event Bus Topics
8. Slashing, Rewards & Game-Theory
9. Upgrade & Migration Path
10. Security Considerations

---

## 1. Goals & Principles

* **Artist-Centric** â€“ Parameters must empower creators to evolve
  their work without centralised gatekeepers.
* **Modularity** â€“ Every rule is a smart contract that can be
  hot-swapped under strict upgrade procedures.
* **Transparency** â€“ All governance data is stored on-chain and
  emitted as signed events to the public event bus.
* **Safety** â€“ Slashing and veto-timelocks minimise malicious or
  rushed protocol changes.

---

## 2. Governing Token: `CNOTE` ðŸŽ¼

Symbol            | `CNOTE`
------------------|----------------------------
Type              | ERC-20-compatible substrate asset
Use-cases         | Voting, staking, fee rebate, slashing collateral
Inflation Model   | Dynamic, linked to generative movement cadence
Initial Supply    | `10 000 000.0000 CNOTE`

### 2.1 Staking for PoI

Staked `CNOTE` participates in **Proof-of-Inspiration** to elect the
next *Composer Node*. During the same epoch, these staking positions
also determine governance voting power.

---

## 3. Proposal Lifecycle

```
Draft â†’ Review â†’ Voting â†’ Enactment (â†» or â›”)
```

Phase        | Duration | Key Actors                    | Abort â‚¬
-------------|----------|------------------------------|--------
Draft        | âˆž        | Author                       | Free
Review       | 48 h     | Council (optional)           | Â±0.1 C
Voting       | 72 h     | Token-Holders & Delegates    | Bond
Enactment    | 24 h     | Runtime Scheduler + VRF      | â€“

*Abort fee is burned to discourage spam.*

### 3.1 State Machine

The following Rust enum matches the state machine stored on-chain:

```rust
/// Governance proposal lifecycle.
#[derive(scale::Encode, scale::Decode, Clone, Copy, PartialEq, Eq)]
pub enum ProposalStage {
    Draft,
    Review { started_at: BlockNumber },
    Voting { ends_at: BlockNumber },
    Enactment { scheduled_for: BlockNumber },
    Rejected,
    Executed,
}
```

---

## 4. Voting & Delegation Model

1 `CNOTE` staked = **1 voting unit**.  
Voters may **delegate** to any on-chain account (wallet, DAO
multisig, or artist profile). Delegations are *revocable* at any
time before the snapshot block.

### 4.1 Conviction Escalation

Inspired by Polkadotâ€™s conviction-voting, longer lockups multiply
weight:

Lockup (blocks) | Multiplier
---------------|-----------
0              | Ã—1
80 k (â‰ˆ1 week) | Ã—2
320 k          | Ã—3
1 280 k        | Ã—4

---

## 5. Smart-Contract Interface

Below is the canonical ink! interface shipped in the **governance**
pallet. Forks can use the Factory pattern to spawn customised
instances.

```rust
//! ink! smart contract generated by `cargo contract new`.
#![cfg_attr(not(feature = "std"), no_std)]

#[ink::contract]
mod symphony_governance {
    use ink::storage::Mapping;
    use scale::{Decode, Encode};

    /// Unique identifier for on-chain proposals.
    pub type ProposalId = u64;

    #[derive(Debug, Copy, Clone, PartialEq, Eq, Encode, Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
    pub enum VoteKind {
        /// Approve the proposal.
        Aye,
        /// Reject the proposal.
        Nay,
        /// Abstainâ€”counts for quorum, not for tally.
        Abstain,
    }

    #[derive(Debug, Encode, Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
    pub struct Proposal {
        author: AccountId,
        ipfs_hash: [u8; 46], // IPFS CIDv1 (base58)
        stage: ProposalStage,
        aye: u128,
        nay: u128,
        abstain: u128,
        vetoed: bool,
    }

    #[derive(Debug, Copy, Clone, PartialEq, Eq, Encode, Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
    pub enum ProposalStage {
        Draft,
        Review,
        Voting,
        Enactment,
        Executed,
        Rejected,
    }

    #[ink(storage)]
    pub struct Governance {
        proposals: Mapping<ProposalId, Proposal>,
        next_id: ProposalId,
        council: Vec<AccountId>,
    }

    impl Governance {
        #[ink(constructor)]
        pub fn new(council: Vec<AccountId>) -> Self {
            Self {
                proposals: Mapping::default(),
                next_id: 0,
                council,
            }
        }

        /// Submit an initial draft. Requires a small bond.
        #[ink(message, payable)]
        pub fn submit_proposal(&mut self, ipfs_hash: [u8; 46]) -> ProposalId {
            // Bond check
            assert!(
                self.env().transferred_balance() >= 10_000_000_000, // 0.01 CNOTE
                "Insufficient bond"
            );

            let author = self.env().caller();
            let id = self.next_id;
            self.next_id += 1;

            let proposal = Proposal {
                author,
                ipfs_hash,
                stage: ProposalStage::Draft,
                aye: 0,
                nay: 0,
                abstain: 0,
                vetoed: false,
            };

            self.proposals.insert(id, &proposal);
            self.env().emit_event(NewProposal { id, author });
            id
        }

        /// Cast a vote with conviction weight.
        #[ink(message)]
        pub fn vote(
            &mut self,
            id: ProposalId,
            kind: VoteKind,
            weight: u128,
        ) -> Result<(), GovernanceError> {
            let mut p = self
                .proposals
                .get(id)
                .ok_or(GovernanceError::ProposalMissing)?;

            ensure!(
                p.stage == ProposalStage::Voting,
                GovernanceError::NotInVoting
            );

            match kind {
                VoteKind::Aye => p.aye += weight,
                VoteKind::Nay => p.nay += weight,
                VoteKind::Abstain => p.abstain += weight,
            }

            self.proposals.insert(id, &p);
            self.env().emit_event(VoteCast {
                id,
                voter: self.env().caller(),
                kind,
                weight,
            });
            Ok(())
        }

        // Additional methods: advance_stage, veto, execute, etc.
    }

    /// EVENTS -----------------------------------------------------
    #[ink(event)]
    pub struct NewProposal {
        #[ink(topic)]
        id: ProposalId,
        #[ink(topic)]
        author: AccountId,
    }

    #[ink(event)]
    pub struct VoteCast {
        #[ink(topic)]
        id: ProposalId,
        #[ink(topic)]
        voter: AccountId,
        kind: VoteKind,
        weight: u128,
    }

    /// ERRORS -----------------------------------------------------
    #[derive(Debug, Encode, Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
    pub enum GovernanceError {
        ProposalMissing,
        NotInVoting,
        Unauthorized,
    }

    fn ensure(cond: bool, err: GovernanceError) -> Result<(), GovernanceError> {
        if cond {
            Ok(())
        } else {
            Err(err)
        }
    }
}
```

---

## 6. Governance gRPC Microservice

The **`gov-orchestrator`** microservice bridges off-chain tools, the
event bus, and on-chain ink! contracts.

### 6.1 Proto Definition (`proto/gov.proto`)

```proto
syntax = "proto3";

package symphony.gov;

service Governance {
  rpc SubmitProposal (SubmitProposalRequest) returns (ProposalReply);
  rpc CastVote       (CastVoteRequest)       returns (VoteReply);
  rpc Subscribe      (SubscribeRequest)      returns (stream GovEvent);
}

message SubmitProposalRequest {
  bytes ipfs_cid = 1;
  uint64 bond    = 2;
}

message CastVoteRequest {
  uint64 proposal_id = 1;
  VoteKind kind      = 2;
  uint128 weight     = 3;
}

enum VoteKind {
  AYE      = 0;
  NAY      = 1;
  ABSTAIN  = 2;
}

message SubscribeRequest {}

message GovEvent {
  oneof event {
    NewProposal new_proposal = 1;
    VoteCast    vote_cast    = 2;
  }
}

message ProposalReply { uint64 proposal_id = 1; }
message VoteReply     { bool   accepted     = 1; }
```

### 6.2 Tonic Implementation (excerpt)

```rust
pub struct GovernanceService {
    contract: ink_wrapper::GovernanceClient,
    event_tx: broadcast::Sender<GovEvent>,
}

#[tonic::async_trait]
impl Governance for GovernanceService {
    async fn submit_proposal(
        &self,
        req: Request<SubmitProposalRequest>,
    ) -> Result<Response<ProposalReply>, Status> {
        let caller = extract_signer(&req)?;
        let id = self
            .contract
            .with(caller)
            .submit_proposal(req.get_ref().ipfs_cid, req.get_ref().bond)
            .await
            .map_err(map_contract_err)?;
        Ok(Response::new(ProposalReply { proposal_id: id }))
    }

    // â€¦ other RPC handlers â€¦
}
```

---

## 7. Event Bus Topics

Topic                 | Payload Struct             | Source
----------------------|----------------------------|--------
`gov.proposal.new`    | `NewProposal`              | ink! contract
`gov.vote.cast`       | `VoteCast`                 | ink! contract
`gov.stage.changed`   | `StageChanged`             | orchestrator
`gov.composer.elected`| `ComposerElected(Addr)`    | consensus

All events are signed with the nodeâ€™s Ed25519 key and published via
NATS.

---

## 8. Slashing, Rewards & Game-Theory

â€¢ **Spam Slashing** â€“ Malformed or empty proposals forfeit their
bond.  
â€¢ **Composer Misconduct** â€“ Composer nodes that fail to publish an
assigned movement within the VRF epoch lose 5 % of stake.  
â€¢ **Participation Rewards** â€“ 0.5 % of epoch inflation is
distributed pro-rata to addresses that voted on >=75 % of proposals
during the epoch.

Mathematical model: see `/research/slashing_model.ipynb`.

---

## 9. Upgrade & Migration Path

1. `Upgrade` proposal passes with 2/3 super-majority.  
2. New runtime WASM is stored on-chain (`set_code`).  
3. 24-hour timelock triggers.  
4. All microservices auto-download the new ABI via gRPC call
   `GetRuntimeMeta`.  
5. If â‰¥30 % of stake sends `veto_upgrade`, the scheduler aborts.

---

## 10. Security Considerations

* Re-entrancy guarded by ink! `#[modifier(non_reentrant)]`.
* All cross-contract calls use **Weight Metering** to prevent DoS.
* gRPC endpoints enforce **mTLS** with per-microservice certificates.
* Formal verification of the governance contract with `cargo-prove`
  (K-framework).

---

### Appendix A â€“ CLI Usage

```bash
# Submit a proposal (assumes youâ€™re on the Polkadot.js CLI)
symphony-cli gov submit \
  --ipfs QmQz... \
  --bond 0.01

# Cast an AYE vote with Ã—2 conviction
symphony-cli gov vote 42 --aye --lock 1w

# Follow governance events
symphony-cli events tail gov.*
```

---

_Â© 2024 CanvasChain Symphony Core. MIT-Apache-2.0 licensed._
```