package com.opsforge.nexus.fileconverter.domain.model;

import java.io.Serial;
import java.io.Serializable;
import java.net.URI;
import java.time.Duration;
import java.time.OffsetDateTime;
import java.util.*;

/**
 * Domain object representing the outcome of a file–format conversion use-case.
 * <p>
 * This model is deliberately framework-agnostic so it can live at the
 * innermost “domain” layer of the hexagonal architecture.  Application
 * services, REST controllers, GraphQL resolvers, or any other adapters
 * should depend on this class, never the other way around.
 * <p>
 * Instances are immutable and are produced via the {@link Builder}.  The
 * {@link #equals(Object)} and {@link #hashCode()} implementations rely on
 * {@link #conversionId} so that a {@code ConversionResult} can safely be used
 * as a Map key or set member without accidentally duplicating logical
 * conversion runs.
 */
public final class ConversionResult implements Serializable {

    @Serial
    private static final long serialVersionUID = 3115672235588848291L;

    /**
     * Stable identifier for the conversion run.  Generated by the application
     * service and used as correlation metadata for distributed tracing.
     */
    private final UUID conversionId;

    /**
     * File name provided by the client.  Never {@code null}; may be blank if
     * the client did not specify a name.
     */
    private final String originalFileName;

    /**
     * MIME type of the source file, e.g. {@code application/pdf}.
     */
    private final String sourceMediaType;

    /**
     * Desired target MIME type, e.g. {@code image/png}.
     */
    private final String targetMediaType;

    /**
     * Outcome status for the conversion run.
     */
    private final Status status;

    /**
     * When the conversion task started.
     */
    private final OffsetDateTime startedAt;

    /**
     * When the conversion task finished—regardless of success or failure.
     */
    private final OffsetDateTime completedAt;

    /**
     * Location from which the converted file can be downloaded.  Present only
     * if the conversion succeeded or yielded partial output.
     */
    private final Optional<URI> outputFileLocation;

    /**
     * Checksums generated during / after the conversion process keyed by
     * algorithm name—for example, {@code sha256}=abcd..., {@code md5}=efgh...
     */
    private final Map<String, String> checksums;

    /**
     * Non-fatal or fatal errors captured during conversion.  Empty list means
     * the run completed without error.
     */
    private final List<ConversionError> errors;

    private ConversionResult(Builder builder) {
        this.conversionId = builder.conversionId;
        this.originalFileName = builder.originalFileName;
        this.sourceMediaType = builder.sourceMediaType;
        this.targetMediaType = builder.targetMediaType;
        this.status = builder.status;
        this.startedAt = builder.startedAt;
        this.completedAt = builder.completedAt;
        this.outputFileLocation = Optional.ofNullable(builder.outputFileLocation);
        this.checksums = Collections.unmodifiableMap(new LinkedHashMap<>(builder.checksums));
        this.errors = Collections.unmodifiableList(new ArrayList<>(builder.errors));
    }

    // -----------------------------------------------------------------------
    // Business helpers
    // -----------------------------------------------------------------------

    /**
     * Returns {@code true} if the conversion finished successfully without
     * errors, {@code false} otherwise.
     */
    public boolean isSuccessful() {
        return status == Status.SUCCEEDED;
    }

    /**
     * Calculates the duration between {@link #startedAt} and
     * {@link #completedAt}. If either timestamp is {@code null} the result is
     * {@link Duration#ZERO}.
     */
    public Duration duration() {
        if (startedAt == null || completedAt == null) {
            return Duration.ZERO;
        }
        return Duration.between(startedAt, completedAt);
    }

    // -----------------------------------------------------------------------
    // Standard accessors
    // -----------------------------------------------------------------------

    public UUID getConversionId() {
        return conversionId;
    }

    public String getOriginalFileName() {
        return originalFileName;
    }

    public String getSourceMediaType() {
        return sourceMediaType;
    }

    public String getTargetMediaType() {
        return targetMediaType;
    }

    public Status getStatus() {
        return status;
    }

    public OffsetDateTime getStartedAt() {
        return startedAt;
    }

    public OffsetDateTime getCompletedAt() {
        return completedAt;
    }

    public Optional<URI> getOutputFileLocation() {
        return outputFileLocation;
    }

    public Map<String, String> getChecksums() {
        return checksums;
    }

    public List<ConversionError> getErrors() {
        return errors;
    }

    // -----------------------------------------------------------------------
    // Equality & representation
    // -----------------------------------------------------------------------

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof ConversionResult that)) return false;
        return Objects.equals(conversionId, that.conversionId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(conversionId);
    }

    @Override
    public String toString() {
        return "ConversionResult{" +
                "conversionId=" + conversionId +
                ", originalFileName='" + originalFileName + '\'' +
                ", sourceMediaType='" + sourceMediaType + '\'' +
                ", targetMediaType='" + targetMediaType + '\'' +
                ", status=" + status +
                ", startedAt=" + startedAt +
                ", completedAt=" + completedAt +
                ", outputFileLocation=" + outputFileLocation +
                ", checksums=" + checksums +
                ", errors=" + errors +
                '}';
    }

    // -----------------------------------------------------------------------
    // Builder
    // -----------------------------------------------------------------------

    /**
     * Fluent builder that enforces mandatory fields and performs basic
     * validation before creating a {@link ConversionResult}.
     */
    public static final class Builder {

        private UUID conversionId;
        private String originalFileName = "";
        private String sourceMediaType;
        private String targetMediaType;
        private Status status;
        private OffsetDateTime startedAt;
        private OffsetDateTime completedAt;
        private URI outputFileLocation;
        private final Map<String, String> checksums = new LinkedHashMap<>();
        private final List<ConversionError> errors = new ArrayList<>();

        public Builder conversionId(UUID conversionId) {
            this.conversionId = Objects.requireNonNull(conversionId, "conversionId");
            return this;
        }

        public Builder originalFileName(String originalFileName) {
            this.originalFileName = Objects.requireNonNullElse(originalFileName, "");
            return this;
        }

        public Builder sourceMediaType(String sourceMediaType) {
            this.sourceMediaType = Objects.requireNonNull(sourceMediaType, "sourceMediaType");
            return this;
        }

        public Builder targetMediaType(String targetMediaType) {
            this.targetMediaType = Objects.requireNonNull(targetMediaType, "targetMediaType");
            return this;
        }

        public Builder status(Status status) {
            this.status = Objects.requireNonNull(status, "status");
            return this;
        }

        public Builder startedAt(OffsetDateTime startedAt) {
            this.startedAt = Objects.requireNonNull(startedAt, "startedAt");
            return this;
        }

        public Builder completedAt(OffsetDateTime completedAt) {
            this.completedAt = Objects.requireNonNull(completedAt, "completedAt");
            return this;
        }

        public Builder outputFileLocation(URI outputFileLocation) {
            this.outputFileLocation = outputFileLocation;
            return this;
        }

        public Builder addChecksum(String algorithm, String value) {
            Objects.requireNonNull(algorithm, "algorithm");
            Objects.requireNonNull(value, "value");
            this.checksums.put(algorithm.toLowerCase(Locale.ROOT), value);
            return this;
        }

        public Builder addError(String code, String message) {
            this.errors.add(new ConversionError(code, message));
            return this;
        }

        public ConversionResult build() {
            // -- Defensive validation -------------------------------------------------
            if (conversionId == null) {
                throw new IllegalStateException("conversionId must be set");
            }
            if (sourceMediaType == null) {
                throw new IllegalStateException("sourceMediaType must be set");
            }
            if (targetMediaType == null) {
                throw new IllegalStateException("targetMediaType must be set");
            }
            if (status == null) {
                throw new IllegalStateException("status must be set");
            }
            if (startedAt == null) {
                throw new IllegalStateException("startedAt must be set");
            }
            if (completedAt == null) {
                throw new IllegalStateException("completedAt must be set");
            }
            if (completedAt.isBefore(startedAt)) {
                throw new IllegalStateException("completedAt cannot be before startedAt");
            }

            if (status == Status.SUCCEEDED && outputFileLocation == null) {
                throw new IllegalStateException("Successful conversion must have outputFileLocation");
            }
            if (status == Status.FAILED && errors.isEmpty()) {
                throw new IllegalStateException("Failed conversion must include at least one error");
            }
            // ------------------------------------------------------------------------

            return new ConversionResult(this);
        }
    }

    // -----------------------------------------------------------------------
    // Supporting types
    // -----------------------------------------------------------------------

    /**
     * Conversion outcome status.
     */
    public enum Status {
        SUCCEEDED,
        FAILED,
        PARTIAL
    }

    /**
     * Value object describing a conversion error.  Independent of any
     * transport or logging library.
     *
     * @param code    machine-readable error code
     * @param message human-readable summary
     */
    public record ConversionError(String code, String message) implements Serializable {
        @Serial
        private static final long serialVersionUID = 5883277119212783946L;

        public ConversionError {
            Objects.requireNonNull(code, "code");
            Objects.requireNonNull(message, "message");
        }
    }
}