```csharp
// File: src/module_8.txt
// Project: TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// Language: C#
//
// This file contains the core ScheduledPublishingService domain component.
// The service is pure domain logic and therefore lives in the Core layer.
// All infrastructure concerns (database persistence, message brokers, etc.)
// are exposed through ports so that adapters can be swapped without touching
// this code.  ── Hexagonal Architecture FTW! ──

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Core.Publishing
{
    #region Value Objects & Domain Types

    /// <summary>
    /// Strong-typed identifier for Posts (prevents accidental cross-type assignment).
    /// </summary>
    public readonly record struct PostId(Guid Value)
    {
        public static PostId New() => new(Guid.NewGuid());

        public override string ToString() => Value.ToString();
    }

    /// <summary>
    /// Current lifecycle stage of a Post.
    /// We purposefully keep states immutable ― transitions are explicit
    /// and validated in domain services (such as <see cref="ScheduledPublishingService"/>).
    /// </summary>
    public enum PostStatus
    {
        Draft           = 0,
        Scheduled       = 1,
        Published       = 2,
        PublicationFail = 3
    }

    /// <summary>
    /// Aggregate root for Blog Posts.
    /// Only minimum properties are modeled here; the real model
    /// lives in <c>TempoScribePro.Core.Content.Post.cs</c>.
    /// </summary>
    public sealed class Post
    {
        public PostId      Id                 { get; }
        public string      Slug               { get; private set; }
        public string      Title              { get; private set; }
        public DateTimeOffset? ScheduledAtUtc { get; private set; }
        public PostStatus  Status             { get; private set; }

        // Required by some ORMs
        private Post() {}

        public Post(PostId id, string slug, string title, DateTimeOffset? scheduledAtUtc)
        {
            Id             = id;
            Slug           = slug;
            Title          = title;
            ScheduledAtUtc = scheduledAtUtc;
            Status         = scheduledAtUtc is null ? PostStatus.Draft : PostStatus.Scheduled;
        }

        public void MarkPublished()       => Status = PostStatus.Published;
        public void MarkPublicationFail() => Status = PostStatus.PublicationFail;
    }

    #endregion

    #region Ports (Interfaces)

    /// <summary>
    /// Abstraction over persistence (SQL/NoSQL/Graph).
    /// </summary>
    public interface IPublishingScheduleRepository
    {
        /// <summary>
        /// Retrieves all posts scheduled for publishing on or before the provided <paramref name="utcNow"/>.
        /// </summary>
        Task<IReadOnlyCollection<Post>> GetPostsDueAsync(DateTimeOffset utcNow, CancellationToken ct);

        /// <summary>
        /// Persist post state changes. Should be part of a single atomic unit
        /// (transaction) where possible.
        /// </summary>
        Task UpdateAsync(Post post, CancellationToken ct);
    }

    /// <summary>
    /// Adapter-backed service that actually publishes the Post to the public site,
    /// invalidates caches, etc.
    /// </summary>
    public interface IPostPublisher
    {
        Task PublishAsync(Post post, CancellationToken ct);
    }

    /// <summary>
    /// Cross-cutting notification port (email, in-app, web-push, etc.).
    /// </summary>
    public interface INotificationPort
    {
        Task NotifyAuthorPostPublishedAsync(Post post, CancellationToken ct);
        Task NotifyAuthorPublicationFailedAsync(Post post, string reason, CancellationToken ct);
    }

    /// <summary>
    /// Deterministic time provider so tests can travel in time.
    /// </summary>
    public interface IDateTimeProvider
    {
        DateTimeOffset UtcNow { get; }
    }

    #endregion

    #region Service Result Objects

    /// <summary>
    /// Result of executing a scheduled publish batch.
    /// </summary>
    public sealed record PublishBatchResult(
        int Attempted,
        int Published,
        int Failed
    )
    {
        public static readonly PublishBatchResult Empty = new(0, 0, 0);

        public PublishBatchResult Merge(PublishBatchResult other) =>
            new(Attempted + other.Attempted, Published + other.Published, Failed + other.Failed);
    }

    #endregion

    #region Domain Service

    /// <summary>
    /// Coordinates the scheduled publishing workflow.
    /// Implements pure domain logic; infrastructural concerns are delegated to ports.
    /// </summary>
    public sealed class ScheduledPublishingService
    {
        private readonly IPublishingScheduleRepository _repository;
        private readonly IPostPublisher                _publisher;
        private readonly INotificationPort             _notifier;
        private readonly IDateTimeProvider             _clock;
        private readonly ILogger<ScheduledPublishingService> _logger;

        public ScheduledPublishingService(
            IPublishingScheduleRepository repository,
            IPostPublisher                publisher,
            INotificationPort             notifier,
            IDateTimeProvider             clock,
            ILogger<ScheduledPublishingService> logger)
        {
            _repository = repository  ?? throw new ArgumentNullException(nameof(repository));
            _publisher  = publisher   ?? throw new ArgumentNullException(nameof(publisher));
            _notifier   = notifier    ?? throw new ArgumentNullException(nameof(notifier));
            _clock      = clock       ?? throw new ArgumentNullException(nameof(clock));
            _logger     = logger      ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Executes scheduled publishing for all posts that are due at <see cref="IDateTimeProvider.UtcNow"/>.
        /// </summary>
        /// <remarks>
        /// The method is idempotent: if a post has already transitioned to <see cref="PostStatus.Published"/>
        /// it will be ignored; failed posts remain in <see cref="PostStatus.PublicationFail"/> to allow manual
        /// retry / triage.
        /// </remarks>
        public async Task<PublishBatchResult> PublishDuePostsAsync(CancellationToken ct = default)
        {
            var utcNow = _clock.UtcNow;
            _logger.LogInformation("Starting scheduled publish run at {UtcNow}", utcNow);

            IReadOnlyCollection<Post> duePosts;

            try
            {
                duePosts = await _repository.GetPostsDueAsync(utcNow, ct).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to fetch scheduled posts from repository");
                throw; // escalate — upstream orchestrator knows what to do (retry, alert)
            }

            if (!duePosts.Any())
            {
                _logger.LogInformation("No scheduled posts due at this time.");
                return PublishBatchResult.Empty;
            }

            _logger.LogInformation("{Count} scheduled post(s) loaded for publishing", duePosts.Count);

            // Parallelism is limited to avoid exhausting resources or tripping database deadlocks.
            const int MaxDegreeOfParallelism = 4;
            using var semaphore = new SemaphoreSlim(MaxDegreeOfParallelism);

            var tasks = duePosts.Select(post => PublishSingleAsync(post, semaphore, ct)).ToArray();
            await Task.WhenAll(tasks).ConfigureAwait(false);

            // Aggregate individual results
            return tasks.Select(t => t.Result)
                        .Aggregate(PublishBatchResult.Empty, (acc, r) => acc.Merge(r));
        }

        private async Task<PublishBatchResult> PublishSingleAsync(Post post, SemaphoreSlim semaphore, CancellationToken ct)
        {
            await semaphore.WaitAsync(ct).ConfigureAwait(false);

            try
            {
                // Idempotency check
                if (post.Status == PostStatus.Published)
                    return new PublishBatchResult(0, 0, 0);

                _logger.LogDebug("Publishing post {PostId} ({Title})", post.Id, post.Title);

                try
                {
                    await _publisher.PublishAsync(post, ct).ConfigureAwait(false);

                    post.MarkPublished();
                    await _repository.UpdateAsync(post, ct).ConfigureAwait(false);
                    await _notifier.NotifyAuthorPostPublishedAsync(post, ct).ConfigureAwait(false);

                    _logger.LogInformation("Post {PostId} ({Title}) published successfully", post.Id, post.Title);

                    return new PublishBatchResult(1, 1, 0);
                }
                catch (Exception ex) // Infrastructure or validation exception
                {
                    post.MarkPublicationFail();
                    await _repository.UpdateAsync(post, ct).ConfigureAwait(false);

                    var reason = ex.GetBaseException().Message;
                    await _notifier.NotifyAuthorPublicationFailedAsync(post, reason, ct).ConfigureAwait(false);

                    _logger.LogError(ex, "Failed to publish post {PostId}", post.Id);

                    return new PublishBatchResult(1, 0, 1);
                }
            }
            finally
            {
                semaphore.Release();
            }
        }
    }

    #endregion
}
```