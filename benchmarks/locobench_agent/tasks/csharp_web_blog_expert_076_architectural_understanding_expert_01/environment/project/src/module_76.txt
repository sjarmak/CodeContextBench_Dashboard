```csharp
// ============================================================================
//  TempoScribe Pro – Hexagonal Productivity Blog Suite
//  ----------------------------------------------------
//  Module: Redis-based Preview-Diff Cache Adapter
//  Layer : Infrastructure / Adapters
//  File  : src/module_76.txt
//  Author: ChatGPT Code-Gen (2024)
// ============================================================================

using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Polly;
using Polly.Retry;
using StackExchange.Redis;

#nullable enable

namespace TempoScribePro.Infrastructure.Caching
{
    /// <summary>
    /// Hexagonal port that the domain layer depends on when reading/writing
    /// cached preview diffs. Infrastructure provides concrete implementation.
    /// </summary>
    public interface IPreviewDiffCachePort
    {
        Task<PreviewDiff?> GetAsync(PostId postId, CancellationToken ct = default);
        Task SetAsync(PostId postId, PreviewDiff diff, TimeSpan? absoluteExpiration = null, CancellationToken ct = default);
        Task InvalidateAsync(PostId postId, CancellationToken ct = default);
    }

    /// <summary>
    /// Redis-backed adapter implementing <see cref="IPreviewDiffCachePort"/>.
    /// Guarantees at-most-once writes with exponential-backoff retry policy
    /// and graceful degradation when the cache is unavailable.
    /// </summary>
    public sealed class RedisPreviewDiffCacheAdapter : IPreviewDiffCachePort, IAsyncDisposable
    {
        private readonly IDatabase _redis;
        private readonly ILogger<RedisPreviewDiffCacheAdapter> _logger;
        private readonly DistributedCacheEntryOptions _defaultOptions;
        private readonly JsonSerializerOptions _serializerOptions;
        private readonly AsyncRetryPolicy _retryPolicy;

        private const string RedisKeyPrefix = "TempoScribe:PreviewDiff:";

        public RedisPreviewDiffCacheAdapter(
            IConnectionMultiplexer connectionMultiplexer,
            IOptions<PreviewDiffCacheOptions> options,
            ILogger<RedisPreviewDiffCacheAdapter> logger)
        {
            _redis  = connectionMultiplexer.GetDatabase();
            _logger = logger;

            var opts = options.Value;

            _defaultOptions = new DistributedCacheEntryOptions
            {
                SlidingExpiration  = opts.SlidingExpiration ?? TimeSpan.FromMinutes(30),
                AbsoluteExpirationRelativeToNow = opts.AbsoluteExpirationRelativeToNow ?? TimeSpan.FromHours(4)
            };

            _serializerOptions = new JsonSerializerOptions
            {
                PropertyNamingPolicy             = JsonNamingPolicy.CamelCase,
                DefaultIgnoreCondition           = JsonIgnoreCondition.WhenWritingNull,
                Converters                       = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) },
                WriteIndented                    = false
            };

            // Retry policy: 3 attempts, exponential backoff (100ms, 200ms, 400ms)
            _retryPolicy = Policy
                .Handle<RedisException>()
                .Or<TimeoutException>()
                .WaitAndRetryAsync(
                    retryCount: 3,
                    sleepDurationProvider: attempt => TimeSpan.FromMilliseconds(100 * Math.Pow(2, attempt - 1)),
                    (ex, ts, i, ctx) =>
                    {
                        _logger.LogWarning(ex,
                            "Redis operation failed (attempt {Attempt}/3). Waiting {Delay} before retry.",
                            i, ts);
                    });
        }

        public async Task<PreviewDiff?> GetAsync(PostId postId, CancellationToken ct = default)
        {
            var key = BuildRedisKey(postId);

            try
            {
                var value = await _retryPolicy.ExecuteAsync(
                    async token => await _redis.StringGetAsync(key).ConfigureAwait(false),
                    ct);

                if (value.HasValue)
                {
                    return JsonSerializer.Deserialize<PreviewDiff>(value!, _serializerOptions);
                }
            }
            catch (Exception ex) when (IsTransient(ex))
            {
                _logger.LogError(ex, "Failed to read preview diff from Redis for PostId={PostId}", postId);
                // Graceful degradation – fail open
            }

            return null;
        }

        public async Task SetAsync(PostId postId, PreviewDiff diff, TimeSpan? absoluteExpiration = null, CancellationToken ct = default)
        {
            var key   = BuildRedisKey(postId);
            var value = JsonSerializer.Serialize(diff, _serializerOptions);
            var expiry = absoluteExpiration ?? _defaultOptions.AbsoluteExpirationRelativeToNow;

            try
            {
                await _retryPolicy.ExecuteAsync(async token =>
                {
                    await _redis.StringSetAsync(key, value, expiry).ConfigureAwait(false);
                }, ct);
            }
            catch (Exception ex) when (IsTransient(ex))
            {
                _logger.LogError(ex,
                    "Failed to write preview diff to Redis for PostId={PostId}. Proceeding without cache.",
                    postId);
                // fail open
            }
        }

        public async Task InvalidateAsync(PostId postId, CancellationToken ct = default)
        {
            var key = BuildRedisKey(postId);
            try
            {
                await _retryPolicy.ExecuteAsync(async token =>
                {
                    await _redis.KeyDeleteAsync(key).ConfigureAwait(false);
                }, ct);
            }
            catch (Exception ex) when (IsTransient(ex))
            {
                _logger.LogWarning(ex,
                    "Failed to invalidate preview diff cache for PostId={PostId}.", postId);
            }
        }

        private static bool IsTransient(Exception ex) =>
            ex is RedisException or TimeoutException
            || ex.InnerException is RedisException;

        private static string BuildRedisKey(PostId postId) => $"{RedisKeyPrefix}{postId.Value:N}";

        public ValueTask DisposeAsync()
        {
            // IDatabase does not require disposal, but we can dispose Connection
            // if we own it. In this adapter we assume it is managed by DI container.
            return ValueTask.CompletedTask;
        }
    }

    /// <summary>
    /// Strongly-typed settings loaded from IConfiguration (e.g. appsettings.json).
    /// </summary>
    public sealed class PreviewDiffCacheOptions
    {
        /// <summary>
        /// Sliding expiration applied when specific expiration is not provided.
        /// </summary>
        public TimeSpan? SlidingExpiration { get; init; }

        /// <summary>
        /// Absolute expiration relative to now applied when specific expiration is not provided.
        /// </summary>
        public TimeSpan? AbsoluteExpirationRelativeToNow { get; init; }
    }

    // ------------------------------------------------------------------------
    //  Dependency Injection Helpers
    // ------------------------------------------------------------------------

    public static class RedisPreviewDiffCacheAdapterRegistrationExtensions
    {
        /// <summary>
        /// Registers the Redis preview-diff cache adapter and its options.
        /// </summary>
        public static IServiceCollection AddRedisPreviewDiffCacheAdapter(
            this IServiceCollection services,
            Action<PreviewDiffCacheOptions>? configureOptions = null)
        {
            if (configureOptions is not null)
            {
                services.Configure(configureOptions);
            }

            return services.AddSingleton<IPreviewDiffCachePort, RedisPreviewDiffCacheAdapter>();
        }
    }

    // ------------------------------------------------------------------------
    //  Domain Value Objects (duplicated lightweight representations to keep
    //  this sample self-contained; in real code these would come from the
    //  domain assembly referenced by this project).
    // ------------------------------------------------------------------------

    public readonly record struct PostId(Guid Value)
    {
        public static PostId New() => new(Guid.NewGuid());
        public override string ToString() => Value.ToString("N");
        public static implicit operator Guid(PostId id) => id.Value;
        public static implicit operator PostId(Guid guid) => new(guid);
    }

    public sealed record PreviewDiff(
        string HtmlSnapshot,
        DateTimeOffset GeneratedAtUtc,
        string? CssChecksum = null);
}
```