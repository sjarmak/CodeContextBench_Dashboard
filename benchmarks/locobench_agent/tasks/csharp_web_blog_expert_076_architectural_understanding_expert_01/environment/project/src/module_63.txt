```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Analytics
{
    #region Ports (Interfaces)

    /// <summary>
    /// Port (hexagonal interface) that exposes high–level editorial productivity metrics.
    /// </summary>
    public interface IEditorialAnalyticsPort
    {
        /// <summary>
        /// Generates a productivity snapshot for the requested period.
        /// </summary>
        /// <param name="from">Inclusive start date (UTC).</param>
        /// <param name="to">Inclusive end date (UTC).</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        Task<ProductivitySnapshot> BuildSnapshotAsync(
            DateTimeOffset from,
            DateTimeOffset to,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Abstraction over read–only repository operations.
    /// </summary>
    public interface IReadOnlyRepository<T>
        where T : class
    {
        Task<IReadOnlyList<T>> ListAsync(
            Func<T, bool>? predicate,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Port for accessing payment data without coupling to any particular gateway.
    /// </summary>
    public interface IPaymentRevenueProvider
    {
        /// <summary>
        /// Returns the gross premium revenue collected in the specified period.
        /// </summary>
        Task<decimal> GetPremiumRevenueAsync(
            DateTimeOffset from,
            DateTimeOffset to,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Simple asynchronous cache abstraction to keep the domain independent of any concrete cache provider.
    /// </summary>
    public interface ICacheAdapter
    {
        Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default);
        Task SetAsync<T>(string key, T value, TimeSpan ttl, CancellationToken cancellationToken = default);
    }

    #endregion

    #region DTOs

    /// <summary>
    /// Aggregated metrics covering editorial throughput and monetization.
    /// Immutable record for value semantics.
    /// </summary>
    public record ProductivitySnapshot(
        int TotalPosts,
        int PublishedPosts,
        double AverageTimeToPublishHours,
        int TotalWorkSessions,
        double AverageSessionDurationMinutes,
        decimal PremiumRevenue);

    #endregion

    #region Entities (Simplified)

    // NOTE:
    // The real entities live in domain-centric projects and are richer.
    // Here we define a minimal subset so the file remains compilable in isolation.

    public sealed class PostEntity
    {
        public Guid Id { get; init; }
        public DateTimeOffset CreatedAt { get; init; }
        public DateTimeOffset? PublishedAt { get; init; }
        public bool IsPremium { get; init; }
    }

    public sealed class WorkSessionEntity
    {
        public Guid Id { get; init; }
        public DateTimeOffset StartedAt { get; init; }
        public TimeSpan Duration { get; init; }
    }

    #endregion

    #region Service (Adapter to Port)

    /// <summary>
    /// Domain service that aggregates analytics from different data sources,
    /// applying caching and defensive–coding best practices.
    /// </summary>
    public sealed class EditorialAnalyticsService : IEditorialAnalyticsPort
    {
        private const string CacheKeyTemplate = "analytics:snapshot:{0:o}:{1:o}";
        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(5);

        private readonly IReadOnlyRepository<PostEntity> _postRepository;
        private readonly IReadOnlyRepository<WorkSessionEntity> _workSessionRepository;
        private readonly IPaymentRevenueProvider _paymentRevenueProvider;
        private readonly ICacheAdapter _cache;
        private readonly ILogger<EditorialAnalyticsService> _logger;

        public EditorialAnalyticsService(
            IReadOnlyRepository<PostEntity> postRepository,
            IReadOnlyRepository<WorkSessionEntity> workSessionRepository,
            IPaymentRevenueProvider paymentRevenueProvider,
            ICacheAdapter cache,
            ILogger<EditorialAnalyticsService> logger)
        {
            _postRepository = postRepository ?? throw new ArgumentNullException(nameof(postRepository));
            _workSessionRepository = workSessionRepository ?? throw new ArgumentNullException(nameof(workSessionRepository));
            _paymentRevenueProvider = paymentRevenueProvider ?? throw new ArgumentNullException(nameof(paymentRevenueProvider));
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task<ProductivitySnapshot> BuildSnapshotAsync(
            DateTimeOffset from,
            DateTimeOffset to,
            CancellationToken cancellationToken = default)
        {
            if (from > to)
            {
                throw new ArgumentException("'from' date must be earlier than or equal to 'to' date.");
            }

            string cacheKey = string.Format(CacheKeyTemplate, from, to);

            // Try the fast path first: read from cache
            var cached = await _cache.GetAsync<ProductivitySnapshot>(cacheKey, cancellationToken);
            if (cached is not null)
            {
                _logger.LogDebug("Returning cached productivity snapshot for period {From} – {To}.", from, to);
                return cached;
            }

            _logger.LogInformation("Building productivity snapshot for period {From} – {To}.", from, to);

            // Fire off queries in parallel to minimise wall–clock latency.
            Task<IReadOnlyList<PostEntity>> postsTask = _postRepository.ListAsync(
                p => p.CreatedAt >= from && p.CreatedAt <= to,
                cancellationToken);

            Task<IReadOnlyList<WorkSessionEntity>> sessionsTask = _workSessionRepository.ListAsync(
                s => s.StartedAt >= from && s.StartedAt <= to,
                cancellationToken);

            Task<decimal> revenueTask = _paymentRevenueProvider.GetPremiumRevenueAsync(
                from,
                to,
                cancellationToken);

            await Task.WhenAll(postsTask, sessionsTask, revenueTask);

            IReadOnlyList<PostEntity> posts = postsTask.Result;
            IReadOnlyList<WorkSessionEntity> sessions = sessionsTask.Result;
            decimal premiumRevenue = revenueTask.Result;

            int totalPosts = posts.Count;
            int publishedPosts = posts.Count(p => p.PublishedAt.HasValue && p.PublishedAt.Value <= to);

            double averageTimeToPublishHours = posts
                .Where(p => p.PublishedAt.HasValue)
                .Select(p => (p.PublishedAt!.Value - p.CreatedAt).TotalHours)
                .DefaultIfEmpty(0)
                .Average();

            int totalSessions = sessions.Count;
            double averageSessionDurationMinutes = sessions
                .Select(s => s.Duration.TotalMinutes)
                .DefaultIfEmpty(0)
                .Average();

            var snapshot = new ProductivitySnapshot(
                TotalPosts: totalPosts,
                PublishedPosts: publishedPosts,
                AverageTimeToPublishHours: Math.Round(averageTimeToPublishHours, 2),
                TotalWorkSessions: totalSessions,
                AverageSessionDurationMinutes: Math.Round(averageSessionDurationMinutes, 2),
                PremiumRevenue: premiumRevenue);

            // Cache result for subsequent callers.
            await _cache.SetAsync(cacheKey, snapshot, CacheTtl, cancellationToken);

            _logger.LogInformation(
                "Snapshot generated: {Snapshot}. Cached for {CacheTtl}.",
                snapshot,
                CacheTtl);

            return snapshot;
        }
    }

    #endregion
}
```