```csharp
// File: src/module_62.cs
// NOTE: This file was auto-generated by the TempoScribe Pro build script.
// It wires the core Monetization domain to a concrete Stripe adapter,
// adds Redis-based caching and Polly resilience policies, and exposes a
// single façade service (PaymentProcessingService) for use by the Service
// Layer. Because this sits behind IPaymentGateway and ICacheProvider,
// no calling code needs to reference Stripe’s SDK directly.

// ReSharper disable ClassNeverInstantiated.Global – Instantiated via DI
// ReSharper disable MemberCanBePrivate.Global – Port visibility

using System;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Polly;
using Polly.Retry;
using StackExchange.Redis;
using Stripe;
using TempoScribePro.Domain.Monetization;
using TempoScribePro.Domain.Primitives;
using TempoScribePro.Infrastructure.Caching;
using TempoScribePro.Infrastructure.Data;

namespace TempoScribePro.Infrastructure.Payments
{
    #region Configuration Records

    /// <summary>
    /// Strongly-typed configuration record for Stripe integration.
    /// </summary>
    public sealed record StripeSettings
    {
        public string ApiKey { get; init; } = string.Empty;
        public string WebhookSecret { get; init; } = string.Empty;
        /// <summary>
        /// Set to <c>true</c> to log Stripe invoices in sandbox mode.
        /// </summary>
        public bool IsSandbox { get; init; } = false;
    }

    #endregion

    #region Ports

    /// <summary>
    /// Outbound port for charging a user through an external payment gateway.
    /// </summary>
    public interface IPaymentGateway
    {
        Task<PaymentResult> ChargeAsync(PaymentRequest request, CancellationToken ct = default);
    }

    /// <summary>
    /// Façade service used by the application layer to initiate payments.
    /// </summary>
    public interface IPaymentProcessingService
    {
        Task<PaymentResult> ProcessPaymentAsync(
            PostId postId,
            UserId userId,
            Money amount,
            string currency,
            CancellationToken ct = default);
    }

    /// <summary>
    /// Simple abstraction for a distributed cache.
    /// </summary>
    public interface ICacheProvider
    {
        Task<T?> GetAsync<T>(string key, CancellationToken ct = default);
        Task SetAsync<T>(string key, T value, TimeSpan ttl, CancellationToken ct = default);
        Task RemoveAsync(string key, CancellationToken ct = default);
    }

    #endregion

    #region DTOs

    /// <summary>
    /// Parameters required to charge a user.
    /// </summary>
    public sealed record PaymentRequest(
        Guid ExternalCustomerId,
        Money Amount,
        string Currency,
        string Description,
        PostId PostId,
        UserId UserId);

    /// <summary>
    /// Result of a payment attempt.
    /// </summary>
    public sealed record PaymentResult(
        bool IsSuccessful,
        string TransactionId,
        string? ErrorCode,
        string? ErrorMessage);

    #endregion

    #region Stripe Adapter

    /// <summary>
    /// Adapter that bridges <see cref="IPaymentGateway"/> to Stripe.
    /// </summary>
    public sealed class StripePaymentGateway : IPaymentGateway
    {
        private readonly ILogger<StripePaymentGateway> _logger;
        private readonly StripeSettings _settings;
        private readonly RetryPolicy<PaymentResult> _retryPolicy;

        public StripePaymentGateway(
            ILogger<StripePaymentGateway> logger,
            IOptions<StripeSettings> settings)
        {
            _logger = logger;
            _settings = settings.Value;

            StripeConfiguration.ApiKey = _settings.ApiKey;

            _retryPolicy = Policy<PaymentResult>
                .Handle<StripeException>(ex =>
                {
                    // Retry only for transient scenarios (e.g., network issues).
                    return ex.HttpStatusCode == HttpStatusCode.BadGateway
                           || ex.HttpStatusCode == HttpStatusCode.GatewayTimeout;
                })
                .WaitAndRetryAsync(
                    retryCount: 3,
                    sleepDurationProvider: attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)),
                    onRetry: (exception, _, attempt, _) =>
                    {
                        _logger.LogWarning(exception, "Stripe retry attempt {Attempt}", attempt);
                    });
        }

        public async Task<PaymentResult> ChargeAsync(PaymentRequest request, CancellationToken ct = default)
        {
            return await _retryPolicy.ExecuteAsync(async token =>
            {
                var options = new PaymentIntentCreateOptions
                {
                    Amount = (long)request.Amount.Value * 100, // Convert to cents
                    Currency = request.Currency,
                    Description = request.Description,
                    Customer = request.ExternalCustomerId.ToString(),
                    Metadata = new()
                    {
                        { "postId", request.PostId.Value.ToString() },
                        { "userId", request.UserId.Value.ToString() }
                    }
                };

                try
                {
                    var service = new PaymentIntentService();
                    var intent  = await service.CreateAsync(options, null, token);

                    _logger.LogInformation(
                        "Stripe payment succeeded: {IntentId} for Post {PostId} User {UserId}",
                        intent.Id, request.PostId.Value, request.UserId.Value);

                    return new PaymentResult(
                        IsSuccessful: true,
                        TransactionId: intent.Id,
                        ErrorCode: null,
                        ErrorMessage: null);
                }
                catch (StripeException ex)
                {
                    _logger.LogError(ex,
                        "Stripe payment failed for Post {PostId} User {UserId}. Code: {Code}",
                        request.PostId.Value, request.UserId.Value, ex.StripeError?.Code);

                    return new PaymentResult(
                        IsSuccessful: false,
                        TransactionId: string.Empty,
                        ErrorCode: ex.StripeError?.Code,
                        ErrorMessage: ex.StripeError?.Message);
                }
            }, ct);
        }
    }

    #endregion

    #region Redis Cache Provider

    /// <summary>
    /// Redis-backed implementation for <see cref="ICacheProvider"/>.
    /// Designed to be registered as a singleton.
    /// </summary>
    public sealed class RedisCacheProvider : ICacheProvider, IDisposable
    {
        private readonly ConnectionMultiplexer _redis;
        private readonly IDatabase _db;
        private readonly ILogger<RedisCacheProvider> _logger;

        public RedisCacheProvider(
            string connectionString,
            ILogger<RedisCacheProvider> logger)
        {
            _logger = logger;
            _redis  = ConnectionMultiplexer.Connect(connectionString);
            _db     = _redis.GetDatabase();
        }

        public async Task<T?> GetAsync<T>(string key, CancellationToken ct = default)
        {
            var value = await _db.StringGetAsync(key);
            if (!value.HasValue) return default;

            try
            {
                if (typeof(T) == typeof(string))
                    return (T)(object)value.ToString();

                return System.Text.Json.JsonSerializer.Deserialize<T>(value!);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to deserialize cached value for key {Key}", key);
                await _db.KeyDeleteAsync(key);
                return default;
            }
        }

        public async Task SetAsync<T>(string key, T value, TimeSpan ttl, CancellationToken ct = default)
        {
            var serialized = typeof(T) == typeof(string)
                ? value!.ToString()
                : System.Text.Json.JsonSerializer.Serialize(value);

            await _db.StringSetAsync(key, serialized, ttl);
        }

        public async Task RemoveAsync(string key, CancellationToken ct = default)
        {
            await _db.KeyDeleteAsync(key);
        }

        public void Dispose()
        {
            _redis.Dispose();
        }
    }

    #endregion

    #region Payment Processing Service

    /// <summary>
    /// High-level application service that orchestrates payment requests through
    /// the selected <see cref="IPaymentGateway"/> implementation and stores a snapshot
    /// via the generic repository. Utilises Redis to deduplicate duplicate payments
    /// (e.g., accidental double-clicks) within a short TTL.
    /// </summary>
    public sealed class PaymentProcessingService : IPaymentProcessingService
    {
        private const int DeduplicationTtlSeconds = 90;
        private readonly IPaymentGateway _gateway;
        private readonly IRepository<PaymentRecord> _repo;
        private readonly ICacheProvider _cache;
        private readonly ILogger<PaymentProcessingService> _logger;

        public PaymentProcessingService(
            IPaymentGateway gateway,
            IRepository<PaymentRecord> repo,
            ICacheProvider cache,
            ILogger<PaymentProcessingService> logger)
        {
            _gateway = gateway;
            _repo    = repo;
            _cache   = cache;
            _logger  = logger;
        }

        public async Task<PaymentResult> ProcessPaymentAsync(
            PostId postId,
            UserId userId,
            Money amount,
            string currency,
            CancellationToken ct = default)
        {
            var dedupKey = PaymentCacheKeys.ForPostUser(postId, userId);

            // Check for duplicate payment within TTL
            var cachedResult = await _cache.GetAsync<PaymentResult>(dedupKey, ct);
            if (cachedResult is { IsSuccessful: true })
            {
                _logger.LogInformation("Returning cached payment result for Post {PostId} User {UserId}",
                    postId.Value, userId.Value);
                return cachedResult;
            }

            var request = new PaymentRequest(
                ExternalCustomerId: userId.Value,
                Amount: amount,
                Currency: currency,
                Description: $"Unlock premium content for Post {postId.Value}",
                PostId: postId,
                UserId: userId);

            var result = await _gateway.ChargeAsync(request, ct);

            if (result.IsSuccessful)
            {
                var record = new PaymentRecord(
                    postId: postId,
                    userId: userId,
                    transactionId: result.TransactionId,
                    amount: amount,
                    currency: currency,
                    timestamp: DateTimeOffset.UtcNow);

                await _repo.AddAsync(record, ct);
                await _repo.UnitOfWork.SaveChangesAsync(ct);

                // Cache successful payment to prevent duplicates in a small time window
                await _cache.SetAsync(dedupKey, result, TimeSpan.FromSeconds(DeduplicationTtlSeconds), ct);
            }

            // Publish domain events (simplified)
            DomainEvents.Dispatch(result.IsSuccessful
                ? new PaymentSucceededEvent(postId, userId, amount)
                : new PaymentFailedEvent(postId, userId, result.ErrorCode, result.ErrorMessage));

            return result;
        }
    }

    #endregion

    #region Helper Classes & Records

    /// <summary>
    /// Cache key helpers for payment deduplication.
    /// </summary>
    internal static class PaymentCacheKeys
    {
        public static string ForPostUser(PostId postId, UserId userId)
            => $"payments:{postId.Value}:{userId.Value}";
    }

    /// <summary>
    /// Aggregate root representing a persisted payment transaction.
    /// </summary>
    public sealed class PaymentRecord : Entity<Guid>
    {
        // EF Core or Dapper will require a parameterless constructor
        private PaymentRecord() { }

        public PaymentRecord(PostId postId, UserId userId, string transactionId, Money amount, string currency,
            DateTimeOffset timestamp)
        {
            Id            = Guid.NewGuid();
            PostId        = postId;
            UserId        = userId;
            TransactionId = transactionId;
            Amount        = amount;
            Currency      = currency;
            Timestamp     = timestamp;
        }

        public PostId PostId { get; private set; }
        public UserId UserId { get; private set; }
        public string TransactionId { get; private set; } = default!;
        public Money Amount { get; private set; }
        public string Currency { get; private set; } = default!;
        public DateTimeOffset Timestamp { get; private set; }
    }

    /// <summary>
    /// Domain event raised when a payment is successfully processed.
    /// </summary>
    public sealed record PaymentSucceededEvent(PostId PostId, UserId UserId, Money Amount) : IDomainEvent;

    /// <summary>
    /// Domain event raised when a payment attempt fails.
    /// </summary>
    public sealed record PaymentFailedEvent(
        PostId PostId,
        UserId UserId,
        string? ErrorCode,
        string? ErrorMessage) : IDomainEvent;

    #endregion
}
```