```csharp
// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ScheduledPublishingService.cs">
//   TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
//   © 2023–2024 TempoScribe Inc. All rights reserved.
// 
//   This source code is part of the technology-agnostic domain layer. NOTHING in
//   this file must depend on any external framework, database driver, or UI tech.
//   Only standard .NET BCL references are allowed. Concrete implementations live
//   in adapters under TempoScribe.Adapters.*
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace TempoScribe.Domain.Publishing
{
    #region Public Interfaces (Ports)

    /// <summary>
    ///     Repository abstraction for querying and persisting <see cref="Post" /> aggregates.
    /// </summary>
    public interface IPostRepository
    {
        /// <summary>
        ///     Retrieves posts in <see cref="PostStatus.Scheduled" /> state whose scheduled publish time
        ///     is less than or equal to the supplied point-in-time.
        /// </summary>
        Task<IReadOnlyCollection<Post>> FindDueScheduledPostsAsync(DateTimeOffset at, CancellationToken ct);

        /// <summary>
        ///     Persists changes to the supplied post instance.
        ///     Implementations SHOULD employ optimistic concurrency checking.
        /// </summary>
        Task UpdateAsync(Post post, CancellationToken ct);
    }

    /// <summary>
    ///     Abstraction for emitting domain events. Implementations may forward events to a message
    ///     broker, real-time signal hub, or simply enqueue them for later processing.
    /// </summary>
    public interface IDomainEventBus
    {
        Task PublishAsync(IDomainEvent @event, CancellationToken ct);
    }

    /// <summary>
    ///     Provides the current point-in-time.  A wrapper around DateTimeOffset.UtcNow that aids deterministic
    ///     testing and multi-timezone future scheduling.
    /// </summary>
    public interface IClock
    {
        DateTimeOffset UtcNow { get; }
    }

    /// <summary>
    ///     Lightweight logging abstraction.  Mapped at runtime to Serilog, Microsoft.Extensions.Logging,
    ///     or any other logging library.
    /// </summary>
    public interface ILogger
    {
        void Debug(string messageTemplate, params object[] args);
        void Info(string messageTemplate, params object[] args);
        void Warn(string messageTemplate, params object[] args);
        void Error(Exception ex, string messageTemplate, params object[] args);
    }

    #endregion

    #region Domain Model

    /// <summary>
    ///     Aggregate root that represents a content item authored in TempoScribe Pro.
    ///     Simplified for brevity. In production this lives in its own file and namespace.
    /// </summary>
    public sealed class Post
    {
        private readonly List<IDomainEvent> _uncommittedEvents = new();

        public Guid Id { get; init; }
        public string Slug { get; private set; } = default!;
        public string Title { get; private set; } = default!;
        public PostStatus Status { get; private set; }
        public DateTimeOffset? ScheduledPublishAtUtc { get; private set; }
        public DateTimeOffset? PublishedAtUtc { get; private set; }

        #region Behaviors

        /// <summary>
        ///     Transition the post into <see cref="PostStatus.Published" /> state, capturing audit timestamps
        ///     and registering a <see cref="PostPublishedEvent" /> to be dispatched once the Unit-of-Work is complete.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown when post is not scheduled or already published.</exception>
        public void Publish(DateTimeOffset publishedAtUtc)
        {
            if (Status != PostStatus.Scheduled)
                throw new InvalidOperationException(
                    $"Cannot publish post {Id} because its status is {Status}.");

            Status           = PostStatus.Published;
            PublishedAtUtc   = publishedAtUtc;
            ScheduledPublishAtUtc = null;

            // Record a domain event for subscribers downstream (e.g., cache invalidation, search re-index, etc.)
            var domainEvent = new PostPublishedEvent(Id, Slug, Title, publishedAtUtc);
            _uncommittedEvents.Add(domainEvent);
        }

        /// <summary>
        ///     Dequeues and returns events not yet persisted/emitted.
        /// </summary>
        public IEnumerable<IDomainEvent> DequeueUncommittedEvents() =>
            _uncommittedEvents.ToArray().Also(_ => _uncommittedEvents.Clear());

        #endregion
    }

    public enum PostStatus
    {
        Draft,
        Scheduled,
        Published,
        Archived,
        Deleted
    }

    /// <summary>
    ///     Marker interface for all domain events.
    /// </summary>
    public interface IDomainEvent { }

    /// <summary>
    ///     Raised when a scheduled post is successfully published.
    /// </summary>
    public record PostPublishedEvent(
        Guid PostId,
        string Slug,
        string Title,
        DateTimeOffset PublishedAtUtc
    ) : IDomainEvent;

    #endregion

    #region Service

    /// <summary>
    ///     Scans for posts whose scheduled publish time has elapsed, transitions them
    ///     to <see cref="PostStatus.Published" />, and emits corresponding domain events.
    ///     Intended to be invoked by a background worker or triggered function every minute.
    /// </summary>
    public sealed class ScheduledPublishingService
    {
        private readonly IPostRepository  _postRepository;
        private readonly IDomainEventBus  _eventBus;
        private readonly IClock           _clock;
        private readonly ILogger          _logger;

        public ScheduledPublishingService(
            IPostRepository postRepository,
            IDomainEventBus eventBus,
            IClock clock,
            ILogger logger)
        {
            _postRepository = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _eventBus       = eventBus        ?? throw new ArgumentNullException(nameof(eventBus));
            _clock          = clock           ?? throw new ArgumentNullException(nameof(clock));
            _logger         = logger          ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        ///     Executes the publishing workflow.
        /// </summary>
        public async Task RunAsync(CancellationToken ct = default)
        {
            var now = _clock.UtcNow;
            _logger.Debug("Scheduled publishing job started at {Now}", now);

            IReadOnlyCollection<Post> duePosts;

            try
            {
                duePosts = await _postRepository.FindDueScheduledPostsAsync(now, ct)
                                                .ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Failed to query due scheduled posts at {Now}", now);
                throw;
            }

            if (duePosts.Count == 0)
            {
                _logger.Debug("No posts scheduled for publication at {Now}", now);
                return;
            }

            _logger.Info("Found {Count} post(s) to publish.", duePosts.Count);

            var tasks = duePosts.Select(post => PublishInternalAsync(post, now, ct));
            await Task.WhenAll(tasks).ConfigureAwait(false);

            _logger.Info("Scheduled publishing job finished at {Now}", _clock.UtcNow);
        }

        #region Private Helpers

        private async Task PublishInternalAsync(Post post, DateTimeOffset now, CancellationToken ct)
        {
            try
            {
                post.Publish(now);

                await _postRepository.UpdateAsync(post, ct).ConfigureAwait(false);

                foreach (var domainEvent in post.DequeueUncommittedEvents())
                    await _eventBus.PublishAsync(domainEvent, ct).ConfigureAwait(false);

                _logger.Info("Post {Id} successfully published.", post.Id);
            }
            catch (InvalidOperationException ex)
            {
                // Domain rule violation; log and skip.
                _logger.Warn("Business rule violation while publishing post {Id}: {Message}", post.Id, ex.Message);
            }
            catch (Exception ex)
            {
                // Infrastructure failure; rethrow to let caller decide (e.g., retry policy).
                _logger.Error(ex, "Unexpected error while publishing post {Id}", post.Id);
                throw;
            }
        }

        #endregion
    }

    #endregion

    #region Internal Utilities

    internal static class Extensions
    {
        /// <summary>
        ///     Extension method that executes an action on the instance then returns it.
        ///     Used to clear event collections fluently.
        /// </summary>
        public static T Also<T>(this T @this, Action<T> action)
        {
            action(@this);
            return @this;
        }
    }

    #endregion
}
```