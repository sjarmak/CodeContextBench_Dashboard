```csharp
// -----------------------------------------------------------------------------
// File:       src/module_33.txt  (yes, code lives in a .txt for historical reasons)
// Project:    TempoScribe Pro – Hexagonal Productivity Blog Suite
// Purpose:    Periodically scans the data-store for posts that are ready to be
//             published and executes the publishing workflow while honoring the
//             Ports & Adapters architecture.
// -----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using TempoScribePro.Core.Domain.Posts;
using TempoScribePro.Core.Domain.Shared;
using TempoScribePro.Core.Ports.Cache;
using TempoScribePro.Core.Ports.Events;
using TempoScribePro.Core.Ports.Repositories;
using TempoScribePro.Core.Ports.Services;

#nullable enable

namespace TempoScribePro.Core.Application.Services
{
    /// <summary>
    ///     Background service that publishes posts whose <see cref="Post.PublishAtUtc"/> timestamp
    ///     has elapsed and transitions them from Scheduled → Published. This class lives
    ///     inside the Application layer, orchestrating domain operations without leaking
    ///     infrastructure-specific details (e.g., SQL queries, HTTP calls, etc.).
    /// </summary>
    public sealed class ScheduledPublishingService : BackgroundService, IScheduledPublishingService
    {
        private readonly IPostRepository _postRepository;
        private readonly IDateTimeProvider _dateTimeProvider;
        private readonly IEnumerable<IPublishingHook> _publishingHooks;
        private readonly IEventBus _eventBus;
        private readonly ICache _cache;
        private readonly ILogger<ScheduledPublishingService> _logger;
        private readonly TimeSpan _scanInterval;
        private readonly SemaphoreSlim _gate = new(1, 1);

        public ScheduledPublishingService(
            IPostRepository postRepository,
            IDateTimeProvider dateTimeProvider,
            IEnumerable<IPublishingHook> publishingHooks,
            IEventBus eventBus,
            ICache cache,
            ILogger<ScheduledPublishingService> logger,
            TimeSpan? scanInterval = null)
        {
            _postRepository = postRepository ?? throw new ArgumentNullException(nameof(postRepository));
            _dateTimeProvider = dateTimeProvider ?? throw new ArgumentNullException(nameof(dateTimeProvider));
            _publishingHooks = publishingHooks ?? throw new ArgumentNullException(nameof(publishingHooks));
            _eventBus = eventBus ?? throw new ArgumentNullException(nameof(eventBus));
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            // Default to a 60-second sweep if the caller does not override.
            _scanInterval = scanInterval ?? TimeSpan.FromSeconds(60);
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("ScheduledPublishingService started. Sweep every {Interval}.", _scanInterval);

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    await PublishDuePostsAsync(stoppingToken).ConfigureAwait(false);
                }
                catch (Exception ex)
                {
                    // We never want an exception here to bring down the host.
                    _logger.LogError(ex, "An unhandled exception occurred during scheduled publishing sweep.");
                }

                try
                {
                    await Task.Delay(_scanInterval, stoppingToken).ConfigureAwait(false);
                }
                catch (TaskCanceledException)
                {
                    // Expected when the host is shutting down.
                }
            }

            _logger.LogInformation("ScheduledPublishingService is stopping.");
        }

        /// <inheritdoc />
        public async Task PublishDuePostsAsync(CancellationToken cancellationToken = default)
        {
            // Prevent multiple overlapping sweeps in clustered hosting scenarios where
            // the DI container might accidentally spawn more than one instance.
            if (!await _gate.WaitAsync(0, cancellationToken).ConfigureAwait(false))
            {
                _logger.LogDebug("A publishing sweep is already in progress. Skipping this run.");
                return;
            }

            try
            {
                var now = _dateTimeProvider.UtcNow;
                IReadOnlyCollection<Post> duePosts = await _postRepository
                    .FindDueScheduledPostsAsync(now, cancellationToken)
                    .ConfigureAwait(false);

                if (duePosts.Count == 0)
                {
                    _logger.LogDebug("No scheduled posts due for publishing at {Timestamp:u}.", now);
                    return;
                }

                _logger.LogInformation("Found {Count} post(s) ready for publishing.", duePosts.Count);

                foreach (var post in duePosts.OrderBy(p => p.PublishAtUtc))
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await PublishAsync(post, cancellationToken).ConfigureAwait(false);
                }
            }
            finally
            {
                _gate.Release();
            }
        }

        private async Task PublishAsync(Post post, CancellationToken cancellationToken)
        {
            _logger.LogInformation("Publishing PostId={PostId}…", post.Id);

            try
            {
                // 1. Transition domain state.
                post.MarkAsPublished(_dateTimeProvider.UtcNow);

                // 2. Persist changes.
                await _postRepository.UpdateAsync(post, cancellationToken).ConfigureAwait(false);

                // 3. Invalidate caches.
                await _cache.RemoveAsync(CacheKeys.PostById(post.Id), cancellationToken).ConfigureAwait(false);

                // 4. Execute publishing hooks (e.g., Slack notifications, e-mail digests, etc.).
                foreach (var hook in _publishingHooks)
                {
                    try
                    {
                        await hook.OnPostPublishedAsync(post, cancellationToken).ConfigureAwait(false);
                    }
                    catch (Exception hookEx)
                    {
                        // Hooks should never break the entire publishing pipeline.
                        _logger.LogWarning(hookEx,
                                           "Publishing hook {HookType} failed for PostId={PostId}.",
                                           hook.GetType().FullName,
                                           post.Id);
                    }
                }

                // 5. Raise PostPublished event.
                await _eventBus.PublishAsync(new PostPublishedEvent(post), cancellationToken).ConfigureAwait(false);

                _logger.LogInformation("Successfully published PostId={PostId}.", post.Id);
            }
            catch (DomainException dex)
            {
                _logger.LogWarning(dex, "Domain error when publishing PostId={PostId}.", post.Id);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error when publishing PostId={PostId}.", post.Id);
                // Re-throw to be caught by ExecuteAsync and logged once more at the outer scope.
                throw;
            }
        }

        public override void Dispose()
        {
            _gate.Dispose();
            base.Dispose();
        }
    }

    // -------------------------------------------------------------------------
    // Supporting infrastructure-agnostic abstractions that may be defined in
    // other modules. They are replicated here as internal records/interfaces to
    // keep this file self-contained for illustration/testing purposes. In the
    // real codebase, these live in dedicated projects/namespaces.
    // -------------------------------------------------------------------------

    /// <summary>
    ///     Provides the current date/time, allowing tests to inject a fixed clock.
    /// </summary>
    public interface IDateTimeProvider
    {
        DateTime UtcNow { get; }
    }

    /// <summary>
    ///     Publishes integration events to other bounded contexts (e.g., Search, Billing).
    /// </summary>
    public interface IEventBus
    {
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken cancellationToken = default);
    }

    /// <summary>
    ///     Lightweight cache abstraction (e.g., Redis, in-memory).
    /// </summary>
    public interface ICache
    {
        Task RemoveAsync(string key, CancellationToken cancellationToken = default);
    }

    /// <summary>
    ///     Hooks that run after a post is published but before the transaction completes.
    ///     Typical examples: Slack messages, analytics pings, static-site exports, etc.
    /// </summary>
    public interface IPublishingHook
    {
        Task OnPostPublishedAsync(Post post, CancellationToken cancellationToken = default);
    }

    /// <summary>
    ///     Marker interface for DI registrations & testing.
    /// </summary>
    public interface IScheduledPublishingService
    {
        Task PublishDuePostsAsync(CancellationToken cancellationToken = default);
    }

    /// <summary>
    ///     Domain event emitted when a post transitions to <c>Published</c>.
    /// </summary>
    /// <param name="Post">The post that was published.</param>
    public sealed record PostPublishedEvent(Post Post);

    /// <summary>
    ///     Static cache key helpers to avoid string duplication.
    /// </summary>
    internal static class CacheKeys
    {
        public static string PostById(Guid id) => $"post:{id:N}";
    }

    // -------------------------------------------------------------------------
    // Minimal domain artifacts to make this file compile without referencing the
    // entire domain assembly. In production, they already exist elsewhere.
    // -------------------------------------------------------------------------

    namespace TempoScribePro.Core.Domain.Shared
    {
        /// <summary>
        ///     Root exception type for business-rule violations.
        /// </summary>
        public sealed class DomainException : Exception
        {
            public DomainException(string message) : base(message) { }
        }
    }

    namespace TempoScribePro.Core.Domain.Posts
    {
        public enum PostStatus
        {
            Draft = 0,
            Scheduled = 1,
            Published = 2,
            Archived = 3
        }

        public sealed class Post
        {
            public Guid Id { get; init; } = Guid.NewGuid();
            public PostStatus Status { get; private set; } = PostStatus.Draft;
            public DateTime? PublishAtUtc { get; private set; }

            public void Schedule(DateTime publishAtUtc)
            {
                if (Status != PostStatus.Draft)
                    throw new DomainException("Only drafts can be scheduled.");

                PublishAtUtc = publishAtUtc;
                Status = PostStatus.Scheduled;
            }

            public void MarkAsPublished(DateTime publishedAtUtc)
            {
                if (Status != PostStatus.Scheduled)
                    throw new DomainException("Only scheduled posts can be published.");

                if (PublishAtUtc > publishedAtUtc)
                    throw new DomainException("Cannot publish before the scheduled time.");

                Status = PostStatus.Published;
            }
        }
    }

    namespace TempoScribePro.Core.Ports.Repositories
    {
        /// <summary>
        ///     Repository abstraction for posts.
        /// </summary>
        public interface IPostRepository
        {
            Task<IReadOnlyCollection<Post>> FindDueScheduledPostsAsync(
                DateTime asOfUtc,
                CancellationToken cancellationToken = default);

            Task UpdateAsync(Post post, CancellationToken cancellationToken = default);
        }
    }

    namespace TempoScribePro.Core.Ports.Services
    {
        // Empty marker namespace for DI scanning, intentionally left blank.
    }
}
```