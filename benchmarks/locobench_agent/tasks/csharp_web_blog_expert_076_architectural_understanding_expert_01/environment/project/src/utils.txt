```csharp
/***********************************************************************************
 * TempoScribe Pro – Hexagonal Productivity Blog Suite
 * -------------------------------------------------------------------------------
 * File:      src/utils.txt  (C# source)
 * Purpose:   Shared infrastructure-level helpers that can be consumed from any
 *            layer (Domain, Application, Adapters) without introducing new
 *            dependencies.  Typical use-cases include:
 *              • generating SEO-friendly slugs for Post titles
 *              • standardized retry policy for transient faults
 *              • scoped stopwatch for high-resolution perf metrics
 *              • cache-key helpers for deterministic Redis look-ups
 *
 * NOTE: Despite having a “.txt” suffix, this file is compiled as C# via the
 *       project’s MSBuild wildcard include rule:  <Compile Include="**\*.txt" />
 ***********************************************************************************/

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace TempoScribePro.Utility
{
    /// <summary>
    /// Contract for the system-wide logger abstraction.
    /// The real implementation lives in the logging adapter (Serilog).
    /// </summary>
    public interface IAppLogger
    {
        void Trace(string message);
        void Info(string message);
        void Warn(string message, Exception? ex = null);
        void Error(string message, Exception? ex = null);
    }

    /// <summary>
    /// Provides a high-resolution execution scope useful for self-contained
    /// performance measurements.  Usage pattern:
    /// <code>
    /// using (var s = PerfScope.Start("RenderPost", _logger))
    /// {
    ///     await _htmlRenderer.RenderAsync(post, token);
    /// }
    /// </code>
    /// </summary>
    public sealed class PerfScope : IDisposable
    {
        private readonly string _operation;
        private readonly IAppLogger _logger;
        private readonly Stopwatch _sw;
        private bool _disposed;

        private PerfScope(string operation, IAppLogger logger)
        {
            _operation = operation;
            _logger = logger;
            _sw = Stopwatch.StartNew();
            _logger.Trace($"[Perf] → {_operation} started.");
        }

        public static PerfScope Start(string operation, IAppLogger logger) =>
            new PerfScope(operation, logger);

        public void Dispose()
        {
            if (_disposed) return;

            _sw.Stop();
            _logger.Trace($"[Perf] ← {_operation} finished in {_sw.ElapsedMilliseconds} ms.");
            _disposed = true;
        }
    }

    /// <summary>
    /// Exponential back-off retry helper. Can be used by any adapter that needs
    /// resiliency against transient faults (e.g., SQL, Redis, HTTP, Stripe).
    /// </summary>
    public static class RetryPolicy
    {
        public const int DefaultMaxRetryCount = 3;
        private static readonly TimeSpan DefaultInitialDelay = TimeSpan.FromMilliseconds(200);
        private const double BackoffMultiplier = 2.0;
        private static readonly Random JitterSource = new();

        /// <summary>
        /// Executes the supplied <paramref name="operation"/> with retry semantics.
        /// </summary>
        public static async Task<T> ExecuteAsync<T>(
            Func<CancellationToken, Task<T>> operation,
            IAppLogger logger,
            int maxRetries = DefaultMaxRetryCount,
            CancellationToken cancellationToken = default)
        {
            if (operation is null) throw new ArgumentNullException(nameof(operation));

            var attempt = 0;
            Exception? lastException = null;
            var delay = DefaultInitialDelay;

            while (attempt <= maxRetries && !cancellationToken.IsCancellationRequested)
            {
                try
                {
                    if (attempt > 0)
                        logger.Warn($"Retry attempt #{attempt} for {operation.Method.Name}");

                    return await operation(cancellationToken).ConfigureAwait(false);
                }
                catch (Exception ex) when (IsTransient(ex))
                {
                    lastException = ex;
                    attempt++;

                    if (attempt > maxRetries)
                        break;

                    var jitter = TimeSpan.FromMilliseconds(JitterSource.Next(25, 75));
                    var finalDelay = delay + jitter;

                    logger.Warn($"Transient fault detected. Waiting {finalDelay.TotalMilliseconds} ms before retry.", ex);
                    await Task.Delay(finalDelay, cancellationToken).ConfigureAwait(false);
                    delay = TimeSpan.FromMilliseconds(delay.TotalMilliseconds * BackoffMultiplier);
                }
            }

            logger.Error($"Operation {operation.Method.Name} failed after {attempt} retries.", lastException);
            throw lastException ?? new InvalidOperationException("Unknown failure occurred during retry policy execution.");
        }

        /// <summary>
        /// Determines whether the exception is classified as transient. Can be
        /// expanded to inspect inner exceptions or custom exception types.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IsTransient(Exception ex) =>
            ex is TimeoutException || ex is OperationCanceledException;
    }

    /// <summary>
    /// Generates deterministic cache keys used by the caching layer (e.g., Redis).
    /// Keys are namespaced to avoid collisions between environments or bounded contexts.
    /// </summary>
    public static class CacheKeyBuilder
    {
        private const string NamespacePrefix = "TempoScribePro";

        public static string ForPost(Guid postId) => $"{NamespacePrefix}:Post:{postId:N}";
        public static string ForUser(Guid userId) => $"{NamespacePrefix}:User:{userId:N}";
        public static string ForSearch(string query, int page) =>
            $"{NamespacePrefix}:Search:{Slug.MakeSlug(query)}:p{page}";
    }

    /// <summary>
    /// Provides slug generation according to RFC3986 (URI safe).
    /// </summary>
    public static class Slug
    {
        private static readonly Regex InvalidChars = new(@"[^a-z0-9\-]", RegexOptions.Compiled | RegexOptions.IgnoreCase);
        private static readonly Regex MultipleDashes = new(@"-{2,}", RegexOptions.Compiled);

        /// <summary>
        /// Generates a stable slug for the supplied <paramref name="value"/>.
        /// </summary>
        public static string MakeSlug(string value, int maxLength = 80)
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("Value cannot be null or whitespace.", nameof(value));

            var normalized = value.Trim().ToLowerInvariant();

            // Replace spaces with dashes
            normalized = Regex.Replace(normalized, @"\s+", "-");

            // Remove invalid characters
            normalized = InvalidChars.Replace(normalized, string.Empty);

            // Collapse consecutive dashes
            normalized = MultipleDashes.Replace(normalized, "-");

            // Trim to max length
            if (normalized.Length > maxLength)
                normalized = normalized[..maxLength];

            // Ensure it doesn't end with a dash
            return normalized.Trim('-');
        }
    }

    /// <summary>
    /// Provides extension helpers for asynchronous operations.
    /// </summary>
    public static class TaskExtensions
    {
        /// <summary>
        /// Fire-and-forget helper that captures unobserved exceptions and publishes
        /// them to the global logger. Designed for top-level events like metrics
        /// pushes where awaiting would block.
        /// </summary>
        public static void SafeFireAndForget(this Task task, IAppLogger logger)
        {
            if (task is null) throw new ArgumentNullException(nameof(task));

            task.ContinueWith(
                t =>
                {
                    if (t.IsFaulted && t.Exception != null)
                        logger.Error("Unhandled exception in fire-and-forget task.", t.Exception.Flatten());
                },
                TaskContinuationOptions.OnlyOnFaulted |
                TaskContinuationOptions.ExecuteSynchronously);
        }

        /// <summary>
        /// Allows composing a task with a timeout. Throws <see cref="TimeoutException"/>
        /// if the operation does not complete within the specified <paramref name="timeout"/>.
        /// </summary>
        public static async Task<T> WithTimeout<T>(this Task<T> task, TimeSpan timeout, string? operationName = null)
        {
            if (task is null) throw new ArgumentNullException(nameof(task));

            using var cts = new CancellationTokenSource(timeout);
            var completedTask = await Task.WhenAny(task, Task.Delay(Timeout.InfiniteTimeSpan, cts.Token));

            if (completedTask != task)
            {
                throw new TimeoutException($"The operation {(operationName ?? "task")} exceeded the timeout of {timeout}.");
            }

            return await task.ConfigureAwait(false); // Propagate any exceptions
        }
    }

    /// <summary>
    /// Thread-safe cache for mapping file extensions to MIME types (used by
    /// attachment handling in the Content Delivery Adapter).
    /// </summary>
    public static class MimeLookup
    {
        private static readonly ConcurrentDictionary<string, string> _cache = new(StringComparer.OrdinalIgnoreCase)
        {
            [".png"] = "image/png",
            [".jpg"] = "image/jpeg",
            [".jpeg"] = "image/jpeg",
            [".gif"] = "image/gif",
            [".svg"] = "image/svg+xml",
            [".md"] = "text/markdown",
            [".pdf"] = "application/pdf"
        };

        public static string GetMime(string fileName)
        {
            if (string.IsNullOrWhiteSpace(fileName))
                throw new ArgumentException("Invalid file name.", nameof(fileName));

            var ext = System.IO.Path.GetExtension(fileName);
            if (string.IsNullOrEmpty(ext))
                return "application/octet-stream";

            return _cache.GetOrAdd(ext, _ => "application/octet-stream");
        }
    }
}
```