```csharp
// ================================================================
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// Module 56 – Scheduled Publishing Core Service & Ports
//
// This file belongs to the technology-agnostic Domain layer and
// must remain free of infrastructure-specific concerns. All I/O
// operations are expressed through ports that concrete adapters
// (SQL, Redis, etc.) will implement elsewhere.
// ================================================================

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Publishing
{
    #region Value Objects & Basic Types

    /// <summary>
    /// Strongly-typed identifier for a blog post.
    /// </summary>
    public readonly struct PostId : IEquatable<PostId>
    {
        public Guid Value { get; }

        public PostId(Guid value)
        {
            if (value == Guid.Empty)
                throw new ArgumentException("PostId cannot be empty.", nameof(value));

            Value = value;
        }

        public bool Equals(PostId other) => Value.Equals(other.Value);
        public override bool Equals(object? obj) => obj is PostId other && Equals(other);
        public override int GetHashCode() => Value.GetHashCode();
        public override string ToString() => Value.ToString();
        public static implicit operator Guid(PostId id) => id.Value;
        public static explicit operator PostId(Guid value) => new PostId(value);
    }

    /// <summary>
    /// Lifecycle status of a blog post.
    /// </summary>
    public enum PostStatus
    {
        Draft          = 0,
        Scheduled      = 1,
        Published      = 2,
        Archived       = 3,
        PublicationFailed = 4
    }

    #endregion

    #region Entities

    /// <summary>
    /// Aggregate root representing a blog post in the domain.
    /// </summary>
    public sealed class Post
    {
        private readonly List<string> _domainErrors = new();

        public PostId            Id                    { get; }
        public string            Title                 { get; private set; }
        public string            Slug                  { get; private set; }
        public string            MarkdownBody          { get; private set; }
        public bool              IsPremium             { get; private set; }
        public PostStatus        Status                { get; private set; }
        public DateTimeOffset?   ScheduledPublishAtUtc { get; private set; }
        public DateTimeOffset?   PublishedAtUtc        { get; private set; }

        public IReadOnlyCollection<string> DomainErrors => _domainErrors;

        public Post(
            PostId id,
            string title,
            string slug,
            string markdownBody,
            bool isPremium,
            PostStatus status,
            DateTimeOffset? scheduledPublishAtUtc,
            DateTimeOffset? publishedAtUtc)
        {
            Id                    = id;
            Title                 = title;
            Slug                  = slug;
            MarkdownBody          = markdownBody;
            IsPremium             = isPremium;
            Status                = status;
            ScheduledPublishAtUtc = scheduledPublishAtUtc;
            PublishedAtUtc        = publishedAtUtc;
        }

        /// <summary>
        /// Publishes the post and transitions its state, validating invariants.
        /// </summary>
        public void Publish(DateTimeOffset publishTimestampUtc)
        {
            if (Status != PostStatus.Scheduled)
                AddError($"Cannot publish post in status '{Status}'.");

            if (ScheduledPublishAtUtc is not null && publishTimestampUtc < ScheduledPublishAtUtc.Value)
                AddError("Attempted to publish the post before its scheduled time.");

            if (_domainErrors.Count > 0)
                throw new DomainValidationException(Id, _domainErrors);

            Status         = PostStatus.Published;
            PublishedAtUtc = publishTimestampUtc;
        }

        private void AddError(string message) => _domainErrors.Add(message);
    }

    #endregion

    #region Domain Exceptions

    /// <summary>
    /// Represents a failure to satisfy business invariants.
    /// </summary>
    public sealed class DomainValidationException : Exception
    {
        public PostId PostId { get; }

        public DomainValidationException(PostId postId, IEnumerable<string> errors)
            : base($"Domain validation failed for post {postId}: {string.Join("; ", errors)}")
        {
            PostId = postId;
        }
    }

    #endregion

    #region Ports (Interfaces)

    /// <summary>
    /// Repository abstraction for persisting and querying posts.
    /// </summary>
    public interface IPostRepository
    {
        Task<IReadOnlyList<Post>> GetPostsDueForPublishAsync(
            DateTimeOffset executeBeforeUtc,
            CancellationToken cancellationToken);

        Task UpdateAsync(Post post, CancellationToken cancellationToken);
    }

    /// <summary>
    /// Cache abstraction. Implementations may use Redis, in-memory, etc.
    /// </summary>
    public interface ICache
    {
        Task RemoveAsync(string key, CancellationToken cancellationToken);
    }

    /// <summary>
    /// Asynchronous domain event dispatcher.
    /// </summary>
    public interface IEventDispatcher
    {
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken cancellationToken)
            where TEvent : class;
    }

    /// <summary>
    /// Distributed lock manager to avoid duplicate work across nodes.
    /// </summary>
    public interface IDistributedLock
    {
        Task<IDisposable?> TryAcquireAsync(
            string lockKey,
            TimeSpan ttl,
            CancellationToken cancellationToken);
    }

    #endregion

    #region Events

    public sealed record PostPublishedEvent(PostId PostId, DateTimeOffset PublishedAtUtc);

    #endregion

    #region Service Data Contracts

    /// <summary>
    /// Result object returned by the scheduled publish service.
    /// </summary>
    public sealed class PublishResult
    {
        public int               PublishedCount { get; set; }
        public List<PostId>      FailedPostIds  { get; } = new();
        public TimeSpan          ExecutionTime  { get; set; }

        /// <summary>
        /// Indicates whether the operation completed without failures.
        /// </summary>
        public bool IsSuccessful => FailedPostIds.Count == 0;
    }

    #endregion

    #region Service Port

    /// <summary>
    /// Application service port for publishing scheduled posts.
    /// </summary>
    public interface IScheduledPublishService
    {
        Task<PublishResult> PublishDuePostsAsync(
            DateTimeOffset executionTimestampUtc,
            CancellationToken cancellationToken = default);
    }

    #endregion

    #region Service Implementation

    /// <summary>
    /// Application service that orchestrates scheduled publishing.
    /// </summary>
    public sealed class ScheduledPublishService : IScheduledPublishService
    {
        private const string DistributedLockKey = "tempo:scheduled:publisher";

        private readonly IPostRepository   _postRepository;
        private readonly ICache            _cache;
        private readonly IEventDispatcher  _eventDispatcher;
        private readonly IDistributedLock  _distributedLock;
        private readonly ILogger<ScheduledPublishService> _logger;

        public ScheduledPublishService(
            IPostRepository  postRepository,
            ICache           cache,
            IEventDispatcher eventDispatcher,
            IDistributedLock distributedLock,
            ILogger<ScheduledPublishService> logger)
        {
            _postRepository  = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _cache           = cache           ?? throw new ArgumentNullException(nameof(cache));
            _eventDispatcher = eventDispatcher ?? throw new ArgumentNullException(nameof(eventDispatcher));
            _distributedLock = distributedLock ?? throw new ArgumentNullException(nameof(distributedLock));
            _logger          = logger          ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc/>
        public async Task<PublishResult> PublishDuePostsAsync(
            DateTimeOffset executionTimestampUtc,
            CancellationToken cancellationToken = default)
        {
            using var perf = new ExecutionTimer();

            // Acquire the distributed lock so we do not double-publish in a cluster.
            await using var lockHandle = await _distributedLock.TryAcquireAsync(
                DistributedLockKey,
                ttl: TimeSpan.FromMinutes(5),
                cancellationToken);

            if (lockHandle is null)
            {
                _logger.LogInformation("Another node already owns the scheduled-publish lock.");
                return new PublishResult { ExecutionTime = perf.Elapsed };
            }

            IReadOnlyList<Post> duePosts =
                await _postRepository.GetPostsDueForPublishAsync(executionTimestampUtc, cancellationToken);

            var publishResult = new PublishResult();

            if (duePosts.Count == 0)
            {
                _logger.LogDebug("No posts due for publishing at {Timestamp:u}", executionTimestampUtc);
                publishResult.ExecutionTime = perf.Elapsed;
                return publishResult;
            }

            _logger.LogInformation("Publishing {PostCount} scheduled post(s)…", duePosts.Count);

            foreach (var post in duePosts)
            {
                cancellationToken.ThrowIfCancellationRequested();

                try
                {
                    post.Publish(executionTimestampUtc);
                    await _postRepository.UpdateAsync(post, cancellationToken);

                    // Evict stale cache entries to guarantee fresh reads.
                    await _cache.RemoveAsync(CacheKeys.ForPost(post.Id), cancellationToken);

                    // Notify listeners. DO NOT await inside loop to avoid head-of-line blocking.
                    _ = _eventDispatcher.PublishAsync(
                        new PostPublishedEvent(post.Id, executionTimestampUtc),
                        CancellationToken.None);

                    publishResult.PublishedCount++;
                }
                catch (DomainValidationException dvx)
                {
                    // Domain error – mark the post as failed but continue processing.
                    await MarkPostAsFailedAsync(post, dvx, cancellationToken);
                    publishResult.FailedPostIds.Add(post.Id);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Unexpected error while publishing post {PostId}", post.Id);
                    await MarkPostAsFailedAsync(post, ex, cancellationToken);
                    publishResult.FailedPostIds.Add(post.Id);
                }
            }

            publishResult.ExecutionTime = perf.Elapsed;
            _logger.LogInformation(
                "Scheduled publish cycle finished in {Elapsed:g}. " +
                "Published: {Published}. Failed: {Failed}.",
                publishResult.ExecutionTime,
                publishResult.PublishedCount,
                publishResult.FailedPostIds.Count);

            return publishResult;
        }

        private async Task MarkPostAsFailedAsync(Post post, Exception ex, CancellationToken ct)
        {
            // We pessimistically set status to failed so that manual review is required.
            post.GetType().GetProperty("Status")!
                .SetValue(post, PostStatus.PublicationFailed);

            await _postRepository.UpdateAsync(post, ct);
            _logger.LogWarning(ex,
                "Post {PostId} marked as PublicationFailed due to an error.",
                post.Id);
        }
    }

    #endregion

    #region Utility

    internal static class CacheKeys
    {
        public static string ForPost(PostId id) => $"post:{id}";
    }

    /// <summary>
    /// Simple disposable that measures elapsed time of a code block.
    /// </summary>
    internal sealed class ExecutionTimer : IDisposable
    {
        private readonly DateTime _started = DateTime.UtcNow;
        public  TimeSpan  Elapsed => DateTime.UtcNow - _started;
        public void Dispose() { /* no op – just syntactic sugar */ }
    }

    #endregion
}
```