```csharp
// --------------------------------------------------------------------------------------------------------------------
// <copyright>
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// File:        src/module_48.txt      (yes, source files have .txt extension for domain transparency reviews)
// Author:      TempoScribe Pro Engineering Team
// Description: Core Payment Processing Service (Domain-centric, technology-agnostic, Port & Adapter compliant).
// --------------------------------------------------------------------------------------------------------------------
// NOTE: This file lives inside the “Domain” assembly and **MUST NOT** reference any technology specific packages
//       (e.g. Stripe SDK, EF Core, Redis, etc.). Those details belong in Adapters.  Only BCL + abstractions allowed.
// --------------------------------------------------------------------------------------------------------------------

#nullable enable
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;

namespace TempoScribePro.Domain.Payments
{
    /// <summary>
    /// Immutable value-object representing a monetary amount.
    /// </summary>
    public readonly struct Money : IEquatable<Money>, IComparable<Money>
    {
        public decimal Amount { get; }
        public string Currency { get; }

        public Money(decimal amount, string currency)
        {
            if (string.IsNullOrWhiteSpace(currency))
                throw new ArgumentException("Currency code must be provided", nameof(currency));

            if (amount < 0)
                throw new ArgumentOutOfRangeException(nameof(amount), "Amount cannot be negative");

            Currency = currency.ToUpper(CultureInfo.InvariantCulture);
            Amount   = decimal.Round(amount, 2, MidpointRounding.AwayFromZero);
        }

        public override string ToString() => $"{Amount:0.00} {Currency}";
        public bool Equals(Money other)    => Amount == other.Amount && Currency == other.Currency;
        public override bool Equals(object? obj) => obj is Money m && Equals(m);
        public override int GetHashCode()  => HashCode.Combine(Amount, Currency);
        public int CompareTo(Money other)
        {
            if (Currency != other.Currency)
                throw new InvalidOperationException("Cannot compare Money with different currencies");
            return Amount.CompareTo(other.Amount);
        }

        public static Money operator +(Money a, Money b)
        {
            EnsureSameCurrency(a, b);
            return new Money(a.Amount + b.Amount, a.Currency);
        }

        public static Money operator -(Money a, Money b)
        {
            EnsureSameCurrency(a, b);
            if (a.Amount - b.Amount < 0)
                throw new InvalidOperationException("Resulting money amount cannot be negative");
            return new Money(a.Amount - b.Amount, a.Currency);
        }

        private static void EnsureSameCurrency(Money a, Money b)
        {
            if (a.Currency != b.Currency)
                throw new InvalidOperationException("Currency mismatch in Money operation");
        }
    }

    /// <summary>
    /// Enumerates allowed payment providers.
    /// </summary>
    public enum PaymentProvider
    {
        Stripe,
        PayPal,
        MockGateway // Used for testing/demo environments.
    }

    /// <summary>
    /// Data transfer object capturing outcome of a payment attempt.
    /// </summary>
    public sealed record PaymentResult(
        PaymentTransaction Transaction,
        bool IsSuccessful,
        string ProviderReference,
        IReadOnlyDictionary<string, string>? Metadata,
        string? FailureReason = null);

    /// <summary>
    /// Aggregate root representing a single payment transaction for a premium post, subscription, etc.
    /// </summary>
    public sealed class PaymentTransaction
    {
        public Guid   TransactionId { get; }
        public Guid   UserId        { get; }
        public string TargetId      { get; } // e.g. PostId, SubscriptionId, etc.
        public Money  Amount        { get; }
        public PaymentProvider Provider   { get; }
        public DateTimeOffset CreatedAt   { get; }
        public TransactionStatus Status   { get; private set; }

        private readonly List<DomainEvent> _domainEvents = new();

        public IReadOnlyCollection<DomainEvent> DomainEvents => _domainEvents.AsReadOnly();

        internal PaymentTransaction(
            Guid userId,
            string targetId,
            Money amount,
            PaymentProvider provider)
        {
            TransactionId = Guid.NewGuid();
            UserId        = userId;
            TargetId      = targetId;
            Amount        = amount;
            Provider      = provider;
            CreatedAt     = DateTimeOffset.UtcNow;
            Status        = TransactionStatus.Pending;
        }

        public void MarkAuthorized(string providerReference)
        {
            if (Status != TransactionStatus.Pending)
                throw new InvalidOperationException("Only pending transactions can be authorized.");

            Status = TransactionStatus.Authorized;
            _domainEvents.Add(new TransactionAuthorizedEvent(TransactionId, providerReference, DateTimeOffset.UtcNow));
        }

        public void MarkFailed(string reason)
        {
            if (Status is TransactionStatus.Authorized or TransactionStatus.Settled)
                throw new InvalidOperationException("Cannot fail a transaction that has been finalized.");

            Status = TransactionStatus.Failed;
            _domainEvents.Add(new TransactionFailedEvent(TransactionId, reason, DateTimeOffset.UtcNow));
        }

        public void MarkSettled(string providerReference)
        {
            if (Status != TransactionStatus.Authorized)
                throw new InvalidOperationException("Only authorized transactions can be settled.");

            Status = TransactionStatus.Settled;
            _domainEvents.Add(new TransactionSettledEvent(TransactionId, providerReference, DateTimeOffset.UtcNow));
        }
    }

    public enum TransactionStatus
    {
        Pending,
        Authorized,
        Settled,
        Failed
    }

    #region Domain Events

    /// <summary>Base class for payment domain events.</summary>
    public abstract record DomainEvent(Guid TransactionId, DateTimeOffset OccurredOn);

    public sealed record TransactionAuthorizedEvent(Guid TransactionId, string ProviderReference, DateTimeOffset OccurredOn)
        : DomainEvent(TransactionId, OccurredOn);

    public sealed record TransactionFailedEvent(Guid TransactionId, string Reason, DateTimeOffset OccurredOn)
        : DomainEvent(TransactionId, OccurredOn);

    public sealed record TransactionSettledEvent(Guid TransactionId, string ProviderReference, DateTimeOffset OccurredOn)
        : DomainEvent(TransactionId, OccurredOn);

    #endregion

    #region Ports

    /// <summary>
    /// Port through which the domain requests payment operations from an external provider (adapter).
    /// </summary>
    public interface IPaymentGateway
    {
        Task<GatewayAuthorizationResponse> AuthorizeAsync(
            PaymentTransaction transaction,
            CancellationToken cancellationToken = default);

        Task<GatewaySettlementResponse> CaptureAsync(
            PaymentTransaction transaction,
            string providerReference,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Abstraction for domain persistence of transactions.
    /// </summary>
    public interface IPaymentTransactionRepository
    {
        Task AddAsync(PaymentTransaction transaction, CancellationToken cancellationToken = default);
        Task<PaymentTransaction?> GetByIdAsync(Guid transactionId, CancellationToken cancellationToken = default);
        Task UpdateAsync(PaymentTransaction transaction, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Outbound port to publish domain events (used by adapters for messaging, logs, etc.).
    /// </summary>
    public interface IDomainEventPublisher
    {
        Task PublishAsync(IEnumerable<DomainEvent> events, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Response for an authorization call to a payment gateway.
    /// </summary>
    public sealed record GatewayAuthorizationResponse(
        bool IsAuthorized,
        string ProviderReference,
        string? DeclineReason = null);

    /// <summary>
    /// Response for the capture/settlement call to a payment gateway.
    /// </summary>
    public sealed record GatewaySettlementResponse(
        bool IsSettled,
        string ProviderReference,
        string? FailureReason = null);

    #endregion

    #region Service

    /// <summary>
    /// Core payment orchestrator. Contains domain logic only, delegating
    /// infrastructure details to injected ports/adapters.
    /// </summary>
    public sealed class PaymentService
    {
        private readonly IPaymentGateway               _paymentGateway;
        private readonly IPaymentTransactionRepository _transactionRepository;
        private readonly IDomainEventPublisher         _domainEventPublisher;

        public PaymentService(
            IPaymentGateway paymentGateway,
            IPaymentTransactionRepository transactionRepository,
            IDomainEventPublisher domainEventPublisher)
        {
            _paymentGateway        = paymentGateway  ?? throw new ArgumentNullException(nameof(paymentGateway));
            _transactionRepository = transactionRepository ?? throw new ArgumentNullException(nameof(transactionRepository));
            _domainEventPublisher  = domainEventPublisher ?? throw new ArgumentNullException(nameof(domainEventPublisher));
        }

        /// <summary>
        /// Creates, authorizes, and settles a payment in a single high-level operation.
        /// If authorization succeeds but settlement fails, caller can retry capture separately.
        /// </summary>
        public async Task<PaymentResult> PayAsync(
            Guid userId,
            string targetId,
            Money amount,
            PaymentProvider provider,
            CancellationToken cancellationToken = default)
        {
            // 1. Build a new transaction aggregate.
            var transaction = new PaymentTransaction(userId, targetId, amount, provider);

            // 2. Persist initial state (pending).
            await _transactionRepository.AddAsync(transaction, cancellationToken).ConfigureAwait(false);

            // 3. Request authorization from chosen gateway.
            var authResponse = await _paymentGateway.AuthorizeAsync(transaction, cancellationToken)
                                                     .ConfigureAwait(false);

            if (!authResponse.IsAuthorized)
            {
                // Authorization failed — mark and publish domain events.
                transaction.MarkFailed($"Authorization declined: {authResponse.DeclineReason}");
                await PersistAndPublishAsync(transaction, cancellationToken).ConfigureAwait(false);

                return new PaymentResult(
                    transaction,
                    IsSuccessful: false,
                    ProviderReference: authResponse.ProviderReference,
                    Metadata: new Dictionary<string, string>
                    {
                        ["auth_decline_reason"] = authResponse.DeclineReason ?? "unknown"
                    },
                    FailureReason: authResponse.DeclineReason);
            }

            // 4. Update transaction as authorized.
            transaction.MarkAuthorized(authResponse.ProviderReference);
            await _transactionRepository.UpdateAsync(transaction, cancellationToken).ConfigureAwait(false);

            // 5. Attempt capture / settlement.
            var settleResponse = await _paymentGateway.CaptureAsync(
                transaction,
                authResponse.ProviderReference,
                cancellationToken).ConfigureAwait(false);

            if (!settleResponse.IsSettled)
            {
                // Settlement failed — we keep transaction in Authorized state for potential retry.
                await _domainEventPublisher.PublishAsync(transaction.DomainEvents, cancellationToken)
                                            .ConfigureAwait(false);

                return new PaymentResult(
                    transaction,
                    IsSuccessful: false,
                    ProviderReference: settleResponse.ProviderReference,
                    Metadata: new Dictionary<string, string>
                    {
                        ["capture_failure_reason"] = settleResponse.FailureReason ?? "unknown"
                    },
                    FailureReason: settleResponse.FailureReason);
            }

            // 6. Mark settled and persist final state.
            transaction.MarkSettled(settleResponse.ProviderReference);
            await PersistAndPublishAsync(transaction, cancellationToken).ConfigureAwait(false);

            return new PaymentResult(
                transaction,
                IsSuccessful: true,
                ProviderReference: settleResponse.ProviderReference,
                Metadata: null);
        }

        /// <summary>
        /// Attempts to capture a previously authorized payment.
        /// </summary>
        public async Task<PaymentResult> CaptureAsync(
            Guid transactionId,
            CancellationToken cancellationToken = default)
        {
            var transaction = await _transactionRepository.GetByIdAsync(transactionId, cancellationToken)
                                                          .ConfigureAwait(false)
                ?? throw new PaymentNotFoundException(transactionId);

            if (transaction.Status != TransactionStatus.Authorized)
                throw new InvalidOperationException("Only authorized transactions can be captured.");

            // We assume provider reference exists in domain events; look for it.
            var authEvent = transaction.DomainEvents
                                       .FirstOrDefault(e => e is TransactionAuthorizedEvent) as TransactionAuthorizedEvent
                ?? throw new InvalidOperationException("Missing authorization event reference.");

            var settleResponse = await _paymentGateway.CaptureAsync(
                transaction,
                authEvent.ProviderReference,
                cancellationToken).ConfigureAwait(false);

            if (!settleResponse.IsSettled)
            {
                transaction.MarkFailed($"Capture failed: {settleResponse.FailureReason}");
                await PersistAndPublishAsync(transaction, cancellationToken).ConfigureAwait(false);

                return new PaymentResult(
                    transaction,
                    IsSuccessful: false,
                    ProviderReference: settleResponse.ProviderReference,
                    Metadata: new Dictionary<string, string>
                    {
                        ["capture_failure_reason"] = settleResponse.FailureReason ?? "unknown"
                    },
                    FailureReason: settleResponse.FailureReason);
            }

            transaction.MarkSettled(settleResponse.ProviderReference);
            await PersistAndPublishAsync(transaction, cancellationToken).ConfigureAwait(false);

            return new PaymentResult(transaction, true, settleResponse.ProviderReference, null);
        }

        #region Private helpers

        private async Task PersistAndPublishAsync(PaymentTransaction transaction, CancellationToken token)
        {
            await _transactionRepository.UpdateAsync(transaction, token).ConfigureAwait(false);
            await _domainEventPublisher.PublishAsync(transaction.DomainEvents, token).ConfigureAwait(false);
        }

        #endregion
    }

    #endregion

    #region Exceptions

    /// <summary>
    /// Thrown when a payment transaction cannot be located in persistence layer.
    /// </summary>
    public sealed class PaymentNotFoundException : Exception
    {
        public PaymentNotFoundException(Guid transactionId)
            : base($"Payment transaction '{transactionId}' could not be found.") { }
    }

    #endregion
}

```