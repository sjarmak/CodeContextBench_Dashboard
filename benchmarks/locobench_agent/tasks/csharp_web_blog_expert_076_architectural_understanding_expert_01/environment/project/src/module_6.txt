```csharp
// --------------------------------------------------------------------------------------------------------------------
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// File: src/module_6.txt (intentionally kept as *.txt so the build pipe can relocate it into the correct project) 
//
// Description:
//     ScheduledPublisher is an application-layer service that scans for posts whose
//     PublishAt timestamp has elapsed and safely transitions them from “Scheduled” to “Published”.
//     It raises a PostPublishedEvent so that out-of-process adapters (e.g. WebSocket push,
//     e-mail notifications, or cache warmers) can react without the core domain knowing about them.
//
//     This module demonstrates the Ports & Adapters mentality: the domain model is
//     completely ignorant of data stores, message buses, and schedulers. All those
//     concerns are funneled through abstract ports.
//
// --------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Application.Publishing
{
    #region Domain & Port Abstractions

    /// <summary>
    /// Simplified aggregate root representing a blog post.
    /// Only the properties required for scheduled publishing are included.
    /// </summary>
    public sealed class Post
    {
        private readonly List<IDomainEvent> _domainEvents = new();

        public Guid   Id          { get; private init; }
        public string Title       { get; private set; } = string.Empty;
        public string Slug        { get; private set; } = string.Empty;
        public DateTimeOffset? PublishAt  { get; private set; }
        public DateTimeOffset? PublishedAt { get; private set; }
        public PostStatus Status  { get; private set; }
        public byte[] RowVersion  { get; private set; } = Array.Empty<byte>();

        // Factory method for ORMs / mappers
        private Post() { }

        public Post(Guid id, string title, string slug, DateTimeOffset publishAt)
        {
            Id        = id;
            Title     = title;
            Slug      = slug;
            PublishAt = publishAt;
            Status    = PostStatus.Scheduled;
        }

        /// <summary>
        /// Transitions the aggregate to “Published” and records domain events.
        /// Validation is performed to guarantee aggregate invariants.
        /// </summary>
        /// <exception cref="InvalidPostStateException"/>
        public void Publish(DateTimeOffset utcNow)
        {
            if (Status == PostStatus.Published)
                throw new InvalidPostStateException("Post is already published.");

            if (Status != PostStatus.Scheduled)
                throw new InvalidPostStateException($"Cannot publish post in '{Status}' status.");

            if (PublishAt.HasValue && PublishAt.Value > utcNow)
                throw new InvalidPostStateException("Cannot publish before the scheduled date.");

            PublishedAt = utcNow;
            Status      = PostStatus.Published;

            AddEvent(new PostPublishedEvent(Id, PublishedAt.Value));
        }

        public IReadOnlyCollection<IDomainEvent> CollectEvents()
        {
            var events = _domainEvents.AsReadOnly();
            _domainEvents.Clear();
            return events;
        }

        private void AddEvent(IDomainEvent @event) => _domainEvents.Add(@event);
    }

    public enum PostStatus
    {
        Draft      = 0,
        Scheduled  = 1,
        Published  = 2,
        Archived   = 3
    }

    /// <summary>
    /// Base marker interface for all domain events.
    /// </summary>
    public interface IDomainEvent { }

    /// <summary>
    /// Emitted after a post transitions from “Scheduled” to “Published”.
    /// </summary>
    public sealed record PostPublishedEvent(Guid PostId, DateTimeOffset PublishedAt) : IDomainEvent;

    /// <summary>
    /// Repository port for retrieving & persisting Post aggregates.
    /// Implemented in the infrastructure layer (e.g. EF Core, Dapper, MongoDB).
    /// </summary>
    public interface IPostRepository
    {
        /// <summary>
        /// Returns posts that should be published at or before <paramref name="utcThreshold"/>.
        /// </summary>
        Task<IReadOnlyCollection<Post>> FindScheduledBeforeAsync(
            DateTimeOffset utcThreshold,
            int batchSize,
            CancellationToken ct = default);

        Task UpdateAsync(Post post, CancellationToken ct = default);
    }

    /// <summary>
    /// Port to wrap transaction boundaries so the publisher can treat persistence as atomic.
    /// </summary>
    public interface IUnitOfWork : IAsyncDisposable
    {
        Task CommitAsync(CancellationToken ct = default);
    }

    /// <summary>
    /// Port for publishing domain events. Implementations can forward to MediatR,
    /// an in-house event bus, or an external message queue (RabbitMQ, Kafka, etc.).
    /// </summary>
    public interface IDomainEventDispatcher
    {
        Task DispatchAsync(IDomainEvent @event, CancellationToken ct = default);
    }

    /// <summary>
    /// Port for time retrieval to keep the code deterministic and testable.
    /// </summary>
    public interface IClock
    {
        DateTimeOffset UtcNow { get; }
    }

    #endregion

    #region Exceptions

    public sealed class InvalidPostStateException : Exception
    {
        public InvalidPostStateException(string message) : base(message) { }
    }

    /// <summary>
    /// Thrown when a scheduled publish attempt fails after max retries
    /// so the error handler (Hangfire / Quartz) can bubble it up.
    /// </summary>
    public sealed class ScheduledPublishFailureException : Exception
    {
        public ScheduledPublishFailureException(string message, Exception? inner = null)
            : base(message, inner) { }
    }

    #endregion

    #region Application Service

    /// <summary>
    /// Application service invoked by a background job scheduler (Hangfire, Quartz, Azure Function, etc.).
    /// Scans for scheduled posts and publishes them in transactional batches.
    /// </summary>
    public sealed class ScheduledPublisher
    {
        private const int DefaultBatchSize = 250;
        private const int MaxRetryAttempts = 3;

        private readonly IPostRepository           _postRepo;
        private readonly IUnitOfWork               _uow;
        private readonly IDomainEventDispatcher    _dispatcher;
        private readonly IClock                    _clock;
        private readonly ILogger<ScheduledPublisher> _logger;

        public ScheduledPublisher(
            IPostRepository postRepo,
            IUnitOfWork uow,
            IDomainEventDispatcher dispatcher,
            IClock clock,
            ILogger<ScheduledPublisher> logger)
        {
            _postRepo   = postRepo  ?? throw new ArgumentNullException(nameof(postRepo));
            _uow        = uow       ?? throw new ArgumentNullException(nameof(uow));
            _dispatcher = dispatcher?? throw new ArgumentNullException(nameof(dispatcher));
            _clock      = clock     ?? throw new ArgumentNullException(nameof(clock));
            _logger     = logger    ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Entry point executed by the scheduler.
        /// </summary>
        public async Task ExecuteAsync(CancellationToken ct = default)
        {
            _logger.LogInformation("ScheduledPublisher started at {UtcNow}", _clock.UtcNow);

            DateTimeOffset threshold = _clock.UtcNow;

            IReadOnlyCollection<Post> candidates;
            try
            {
                candidates = await _postRepo.FindScheduledBeforeAsync(threshold, DefaultBatchSize, ct);
            }
            catch (Exception dbEx)
            {
                _logger.LogError(dbEx, "Failed to retrieve scheduled posts.");
                throw new ScheduledPublishFailureException("Database read failure.", dbEx);
            }

            if (candidates.Count == 0)
            {
                _logger.LogInformation("No posts eligible for publishing at this time.");
                return;
            }

            _logger.LogInformation("Found {Count} post(s) scheduled for publishing.", candidates.Count);

            foreach (var post in candidates)
            {
                // Publish each post in isolation so failure of one does not cancel the entire batch
                bool success = await PublishWithRetriesAsync(post, ct);
                if (!success)
                {
                    _logger.LogWarning("Failed to publish post {PostId} after {MaxAttempts} attempts.", post.Id, MaxRetryAttempts);
                }
            }

            _logger.LogInformation("ScheduledPublisher finished at {UtcNow}", _clock.UtcNow);
        }

        private async Task<bool> PublishWithRetriesAsync(Post post, CancellationToken ct)
        {
            for (int attempt = 1; attempt <= MaxRetryAttempts; attempt++)
            {
                try
                {
                    await PublishPostAsync(post, ct);
                    return true;
                }
                catch (InvalidPostStateException invalidEx)
                {
                    // Invariant violation – there is no point retrying
                    _logger.LogWarning(invalidEx, 
                        "Invariant violation while publishing post {PostId}. Skipping retry.",
                        post.Id);
                    return false;
                }
                catch (Exception ex) when (attempt < MaxRetryAttempts)
                {
                    _logger.LogWarning(ex,
                        "Attempt {Attempt} failed for post {PostId}. Retrying...",
                        attempt, post.Id);

                    await Task.Delay(TimeSpan.FromMilliseconds(200 * attempt), ct);
                }
                catch (Exception finalEx)
                {
                    _logger.LogError(finalEx,
                        "Final attempt failed for post {PostId}. Giving up.",
                        post.Id);
                    return false;
                }
            }

            return false;
        }

        /// <summary>
        /// Publishes a single post inside a transactional boundary.
        /// </summary>
        private async Task PublishPostAsync(Post post, CancellationToken ct)
        {
            _logger.LogDebug("Publishing post {PostId}", post.Id);

            post.Publish(_clock.UtcNow);

            try
            {
                await _postRepo.UpdateAsync(post, ct);

                // Persist aggregate & events in a single transaction
                await _uow.CommitAsync(ct);

                foreach (var domainEvent in post.CollectEvents())
                {
                    await _dispatcher.DispatchAsync(domainEvent, ct);
                    _logger.LogDebug("Dispatched {EventType} for PostId={PostId}", 
                        domainEvent.GetType().Name, post.Id);
                }

                _logger.LogInformation("Successfully published post {PostId}.", post.Id);
            }
            catch
            {
                // Let the caller decide to retry, but dispose/unit-of-work must roll back
                _logger.LogDebug("Rolling back transaction for post {PostId}.", post.Id);
                throw;
            }
        }
    }

    #endregion
}
```