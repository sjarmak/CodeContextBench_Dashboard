```csharp
// ==============================================================================
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// ----------------------------------------------------------------------------
// File:        src/module_75.txt   (yes, stored as .txt; treated as source)
// Component:   Monetization / Premium Access
// Layer:       Application Service (Ports & Adapters – outgoing)
// Author:      TempoScribe Engineering
// ----------------------------------------------------------------------------
// Description:
//     Provides a hexagon-friendly service that determines whether a user has
//     access to premium content, orchestrating payment, caching, persistence,
//     and logging concerns through well-defined ports.
//
//     • Resilient payment execution via Polly retry policies
//     • Memory / distributed cache shortcut for hot-path reads
//     • Domain-level invariants captured through rich exceptions
//     • Clean separation between core logic and I/O concerns
// ==============================================================================

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Polly;
using Polly.Retry;

namespace TempoScribePro.Application.Monetization
{
    #region Public Interfaces (Ports)
    // ---------------------------------------------------------------------
    // These ports are implemented by adapters in separate infrastructure
    // projects (e.g., StripeAdapter, SqlRepository, RedisCacheProvider).
    // ---------------------------------------------------------------------

    /// <summary>
    /// Abstraction over any payment gateway (Stripe, Braintree, PayPal, …)
    /// </summary>
    public interface IPaymentGateway
    {
        /// <summary>
        /// Attempts to charge the given user for a particular post.
        /// Implementations must be idempotent—calling ChargeAsync twice with
        /// identical arguments should never bill the customer twice.
        /// </summary>
        Task<PaymentResult> ChargeAsync(
            Guid userId,
            Guid postId,
            decimal amount,
            CancellationToken token = default);
    }

    /// <summary>Repository for reading/writing premium access grants.</summary>
    public interface IPremiumAccessRepository
    {
        Task<bool> HasAccessAsync(Guid userId, Guid postId, CancellationToken token = default);
        Task GrantAccessAsync(Guid userId, Guid postId, CancellationToken token = default);
    }

    /// <summary>Repository that describes whether a post is free or premium.</summary>
    public interface IPostRepository
    {
        Task<PostMonetizationInfo> GetMonetizationInfoAsync(
            Guid postId,
            CancellationToken token = default);
    }

    /// <summary>Generic cache provider (in-proc, Redis, etc.).</summary>
    public interface ICacheProvider
    {
        Task<T?> GetAsync<T>(string key, CancellationToken token = default);
        Task SetAsync<T>(string key, T value, TimeSpan ttl, CancellationToken token = default);
        Task InvalidateAsync(string key, CancellationToken token = default);
    }

    /// <summary>Service exposed to controllers / API handlers.</summary>
    public interface IPremiumAccessService
    {
        /// <summary>
        /// Ensures the user has access to the requested post; charges if needed.
        /// Returns true when access is granted, false otherwise.
        /// </summary>
        Task<bool> EnsureAccessAsync(
            Guid postId,
            Guid userId,
            CancellationToken token = default);
    }
    #endregion

    #region Domain DTOs / Value Objects (Trimmed)
    // In the real codebase these live inside the Core Domain project.
    // Here we replicate minimal structure for compilation purposes.
    public record PostMonetizationInfo(Guid PostId, bool IsPremium, decimal Price);
    public record PaymentResult(bool Succeeded, string TransactionId, string? Error);
    #endregion

    #region Exceptions
    /// <summary>Represents unrecoverable domain rule violations.</summary>
    public sealed class DomainException : Exception
    {
        public DomainException(string message) : base(message) { }
    }
    #endregion

    // =========================================================================
    // Implementation
    // =========================================================================
    /// <summary>
    /// Concrete implementation of <see cref="IPremiumAccessService"/>.
    /// Focuses exclusively on workflow orchestration; no framework-specific
    /// code lives here.
    /// </summary>
    public sealed class PremiumAccessService : IPremiumAccessService
    {
        private const string CacheKeyTemplate = "premium_access:{0}:{1}";
        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(15);

        private readonly IPaymentGateway _paymentGateway;
        private readonly IPremiumAccessRepository _accessRepository;
        private readonly IPostRepository _postRepository;
        private readonly ICacheProvider _cache;
        private readonly ILogger<PremiumAccessService> _logger;
        private readonly AsyncRetryPolicy<PaymentResult> _paymentRetryPolicy;

        public PremiumAccessService(
            IPaymentGateway paymentGateway,
            IPremiumAccessRepository accessRepository,
            IPostRepository postRepository,
            ICacheProvider cache,
            ILogger<PremiumAccessService> logger)
        {
            _paymentGateway = paymentGateway ?? throw new ArgumentNullException(nameof(paymentGateway));
            _accessRepository = accessRepository ?? throw new ArgumentNullException(nameof(accessRepository));
            _postRepository = postRepository ?? throw new ArgumentNullException(nameof(postRepository));
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            // Resilient retry: 2 retries with exponential back-off on transient failures
            _paymentRetryPolicy = Policy<PaymentResult>
                .Handle<Exception>() // network, 5xx, timeouts …
                .OrResult(r => !r.Succeeded)
                .WaitAndRetryAsync(
                    retryCount: 2,
                    sleepDurationProvider: attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)),
                    onRetry: (result, span, attempt, ctx) =>
                    {
                        if (result.Exception != null)
                        {
                            _logger.LogWarning(
                                result.Exception,
                                "Payment attempt {Attempt} failed due to exception. Retrying in {Delay}…",
                                attempt,
                                span);
                        }
                        else
                        {
                            _logger.LogWarning(
                                "Payment attempt {Attempt} returned unsuccessful result. Retrying in {Delay}…",
                                attempt,
                                span);
                        }
                    });
        }

        /// <inheritdoc />
        public async Task<bool> EnsureAccessAsync(Guid postId, Guid userId, CancellationToken token = default)
        {
            if (postId == Guid.Empty) throw new ArgumentException("PostId cannot be empty.", nameof(postId));
            if (userId == Guid.Empty) throw new ArgumentException("UserId cannot be empty.", nameof(userId));

            var cacheKey = string.Format(CacheKeyTemplate, postId, userId);

            // 1. Short-circuit via cache
            bool? cached = await _cache.GetAsync<bool?>(cacheKey, token);
            if (cached.HasValue && cached.Value)
            {
                _logger.LogDebug("Cache hit for premium access ({PostId}, {UserId})", postId, userId);
                return true;
            }

            // 2. Consult repository as source of truth
            if (await _accessRepository.HasAccessAsync(userId, postId, token))
            {
                await _cache.SetAsync(cacheKey, true, CacheTtl, token);
                return true;
            }

            // 3. Retrieve post monetization info
            PostMonetizationInfo info =
                await _postRepository.GetMonetizationInfoAsync(postId, token)
                    ?? throw new DomainException($"Post {postId} not found.");

            if (!info.IsPremium)
            {
                // Free content ⇒ Grant & cache
                await _accessRepository.GrantAccessAsync(userId, postId, token);
                await _cache.SetAsync(cacheKey, true, CacheTtl, token);
                return true;
            }

            // 4. Attempt to charge
            _logger.LogInformation("Charging user {UserId} {Price:C} for post {PostId}", userId, info.Price, postId);

            PaymentResult payment = await _paymentRetryPolicy.ExecuteAsync(
                async ct => await _paymentGateway.ChargeAsync(userId, postId, info.Price, ct),
                token);

            if (!payment.Succeeded)
            {
                _logger.LogError(
                    "Payment failed for user {UserId} accessing post {PostId}. Reason: {Error}",
                    userId,
                    postId,
                    payment.Error ?? "Unknown");
                return false;
            }

            // 5. Persist access grant post-payment
            await _accessRepository.GrantAccessAsync(userId, postId, token);
            await _cache.SetAsync(cacheKey, true, CacheTtl, token);

            _logger.LogInformation(
                "Premium access granted. TransactionId={TransactionId}",
                payment.TransactionId);

            return true;
        }
    }
}
```