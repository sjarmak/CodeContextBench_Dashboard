```csharp
// ============================================================================
// TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// File: src/module_36.txt   (C# Source Code)
// Module: Scheduled Publication Notifier – Context-Aware Notification Service
//
// This background service scans for posts that are about to be auto-published
// and delivers timely, idempotent notifications to editors via in-app and/or
// e-mail channels.  The implementation follows the Hexagonal architecture by
// depending exclusively on ports (interfaces) that live in the domain/core
// layer.  Adapters (e.g., EF Core, SendGrid, Redis, etc.) plug in at runtime.
//
// Author: TempoScribe Engineering
// ============================================================================

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace TempoScribePro.Application.Notifications
{
    #region Ports (Hexagonal Interfaces)

    /// <summary>
    /// Read-only repository for obtaining posts from the persistence layer.
    /// This interface belongs in the domain core;  the implementation lives
    /// in an adapter project (e.g., SQL EF Core or MongoDB).
    /// </summary>
    public interface IPostReadRepository
    {
        /// <summary>
        /// Retrieves all posts that have a scheduled publication time between
        /// <paramref name="fromUtc"/> (inclusive) and <paramref name="toUtc"/>
        /// (exclusive).
        /// </summary>
        IAsyncEnumerable<PostProjection> GetScheduledPostsAsync(
            DateTime fromUtc,
            DateTime toUtc,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Abstraction for sending notifications over multiple channels.
    /// </summary>
    public interface INotificationDispatcher
    {
        Task DispatchAsync(NotificationMessage message, CancellationToken ct = default);
    }

    /// <summary>
    /// Renders a notification template into a consumable message body.
    /// </summary>
    public interface INotificationTemplateRenderer
    {
        ValueTask<string> RenderAsync(NotificationTemplate template, PostProjection post, CancellationToken ct = default);
    }

    /// <summary>
    /// Clock abstraction for time-related calculations (useful for tests).
    /// </summary>
    public interface IClock
    {
        DateTime UtcNow { get; }
    }

    #endregion

    #region DTOs & Value Objects (Domain/Core)

    /// <summary>
    /// Lightweight projection of a planned post.  Keeps the background service
    /// decoupled from heavy domain aggregates.
    /// </summary>
    public sealed record PostProjection(
        Guid   Id,
        string Title,
        string AuthorDisplayName,
        DateTime ScheduledPublishUtc);

    /// <summary>
    /// Transport object representing a prepared notification message.
    /// </summary>
    public sealed record NotificationMessage(
        string Subject,
        string Body,
        NotificationChannel Channel,
        string RecipientUserId,
        IDictionary<string, string>? Metadata = null);

    public enum NotificationChannel
    {
        InApp = 1,
        Email = 2,
        Push  = 3
    }

    public enum NotificationTemplate
    {
        ScheduledPublicationReminder = 1
    }

    #endregion

    #region Configuration

    /// <summary>
    /// Configurable settings for the ScheduledPublicationNotifier.
    /// </summary>
    public sealed class ScheduledPublicationNotificationOptions
    {
        /// <summary>
        /// How often the background job wakes up. Default is 5 minutes.
        /// </summary>
        public TimeSpan PollInterval { get; set; } = TimeSpan.FromMinutes(5);

        /// <summary>
        /// How far ahead the job looks when fetching posts. Default is 2 hours.
        /// </summary>
        public TimeSpan LookAheadWindow { get; set; } = TimeSpan.FromHours(2);

        /// <summary>
        /// If true, send e-mail when in-app notification fails.
        /// </summary>
        public bool EnableEmailFallback { get; set; } = true;

        /// <summary>
        /// Distributed cache key prefix, overridable for multi-tenant scenarios.
        /// </summary>
        public string CacheKeyPrefix { get; set; } = "ts:scheduled-notify:";
    }

    #endregion

    #region Background Service (Application Layer)

    /// <summary>
    /// A hosted background service that periodically scans for scheduled posts
    /// and sends reminders to editors so they can do a final review before
    /// the content goes live.
    /// </summary>
    public sealed class ScheduledPublicationNotifier : BackgroundService
    {
        private readonly IPostReadRepository          _postRepository;
        private readonly INotificationDispatcher      _dispatcher;
        private readonly INotificationTemplateRenderer _renderer;
        private readonly IDistributedCache            _cache;
        private readonly IClock                       _clock;
        private readonly ScheduledPublicationNotificationOptions _options;
        private readonly ILogger<ScheduledPublicationNotifier>   _logger;

        public ScheduledPublicationNotifier(
            IPostReadRepository postRepository,
            INotificationDispatcher dispatcher,
            INotificationTemplateRenderer renderer,
            IDistributedCache cache,
            IClock clock,
            IOptions<ScheduledPublicationNotificationOptions> options,
            ILogger<ScheduledPublicationNotifier> logger)
        {
            _postRepository = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _dispatcher     = dispatcher      ?? throw new ArgumentNullException(nameof(dispatcher));
            _renderer       = renderer        ?? throw new ArgumentNullException(nameof(renderer));
            _cache          = cache           ?? throw new ArgumentNullException(nameof(cache));
            _clock          = clock           ?? throw new ArgumentNullException(nameof(clock));
            _logger         = logger          ?? throw new ArgumentNullException(nameof(logger));
            _options        = options?.Value  ?? throw new ArgumentNullException(nameof(options));
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("ScheduledPublicationNotifier started. PollInterval={PollInterval}, LookAhead={LookAhead}",
                _options.PollInterval, _options.LookAheadWindow);

            while (!stoppingToken.IsCancellationRequested)
            {
                var iterationBegan = _clock.UtcNow;
                try
                {
                    await ScanAndNotifyAsync(stoppingToken).ConfigureAwait(false);
                }
                catch (Exception ex) when (!stoppingToken.IsCancellationRequested)
                {
                    // Swallow only non-fatal exceptions so that the service keeps running.
                    _logger.LogError(ex, "Unhandled exception during scheduled-publication scan.");
                }

                var elapsed = _clock.UtcNow - iterationBegan;
                var delay   = _options.PollInterval - elapsed;
                if (delay > TimeSpan.Zero)
                {
                    await Task.Delay(delay, stoppingToken).ConfigureAwait(false);
                }
            }

            _logger.LogInformation("ScheduledPublicationNotifier is shutting down.");
        }

        private async Task ScanAndNotifyAsync(CancellationToken ct)
        {
            var windowStart = _clock.UtcNow;
            var windowEnd   = windowStart + _options.LookAheadWindow;

            await foreach (var post in _postRepository.GetScheduledPostsAsync(windowStart, windowEnd, ct))
            {
                ct.ThrowIfCancellationRequested();

                if (await HasAlreadyBeenNotifiedAsync(post, ct).ConfigureAwait(false))
                {
                    _logger.LogDebug("Skipping post {PostId} – notification already sent.", post.Id);
                    continue;
                }

                try
                {
                    await SendNotificationAsync(post, ct).ConfigureAwait(false);
                    await MarkAsNotifiedAsync(post, ct).ConfigureAwait(false);

                    _logger.LogInformation("Notification sent for post {PostId}.", post.Id);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to send notification for post {PostId}.", post.Id);

                    if (_options.EnableEmailFallback)
                    {
                        await AttemptEmailFallbackAsync(post, ct).ConfigureAwait(false);
                    }
                }
            }
        }

        #region Cache Helpers (Idempotency)

        private string BuildCacheKey(Guid postId)
        {
            // Example: ts:scheduled-notify:0740d42d-6a69-41a6-b827-261c9a8e5cb2
            return $"{_options.CacheKeyPrefix}{postId:D}";
        }

        private async Task<bool> HasAlreadyBeenNotifiedAsync(PostProjection post, CancellationToken ct)
        {
            var cacheKey = BuildCacheKey(post.Id);
            var exists   = await _cache.GetAsync(cacheKey, ct).ConfigureAwait(false);
            return exists is not null;
        }

        private async Task MarkAsNotifiedAsync(PostProjection post, CancellationToken ct)
        {
            // TTL is until the post actually publishes (plus a buffer) so that
            // if the schedule changes, the notification may be re-triggered.
            var timeUntilPublish = post.ScheduledPublishUtc - _clock.UtcNow;
            if (timeUntilPublish < TimeSpan.Zero)
                timeUntilPublish = TimeSpan.Zero;

            var buffer = TimeSpan.FromMinutes(30);
            var ttl    = timeUntilPublish + buffer;

            var cacheEntryOptions = new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = ttl
            };

            await _cache.SetStringAsync(BuildCacheKey(post.Id), "1", cacheEntryOptions, ct).ConfigureAwait(false);
        }

        #endregion

        #region Notification Helpers

        private async Task SendNotificationAsync(PostProjection post, CancellationToken ct)
        {
            var templateBody = await _renderer.RenderAsync(
                NotificationTemplate.ScheduledPublicationReminder, post, ct).ConfigureAwait(false);

            var message = new NotificationMessage(
                Subject: $"⏰ Scheduled Post Reminder: \"{post.Title}\"",
                Body   : templateBody,
                Channel: NotificationChannel.InApp,
                RecipientUserId: post.AuthorDisplayName // Domain uses user ID; simplified for example
            );

            await _dispatcher.DispatchAsync(message, ct).ConfigureAwait(false);
        }

        private async Task AttemptEmailFallbackAsync(PostProjection post, CancellationToken ct)
        {
            try
            {
                var templateBody = await _renderer.RenderAsync(
                    NotificationTemplate.ScheduledPublicationReminder, post, ct).ConfigureAwait(false);

                var emailMessage = new NotificationMessage(
                    Subject: $"⏰ (Fallback) Scheduled Post Reminder: \"{post.Title}\"",
                    Body   : templateBody,
                    Channel: NotificationChannel.Email,
                    RecipientUserId: post.AuthorDisplayName
                );

                await _dispatcher.DispatchAsync(emailMessage, ct).ConfigureAwait(false);

                _logger.LogInformation("E-mail fallback succeeded for post {PostId}.", post.Id);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "E-mail fallback failed for post {PostId}. Will retry on next scan.", post.Id);
            }
        }

        #endregion
    }

    #endregion
}
```