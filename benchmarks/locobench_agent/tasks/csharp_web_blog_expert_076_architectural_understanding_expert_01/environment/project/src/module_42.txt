```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Core.Scheduling
{
    #region Domain Models

    /// <summary>
    /// Immutable value object that represents an amount of money in ISO-4217 currency.
    /// </summary>
    public readonly record struct Money(decimal Amount, string Currency)
    {
        public static readonly Money Zero = new(0, "USD");

        public bool IsPositive() => Amount > 0;
    }

    /// <summary>
    /// Possible states in the lifecycle of a Blog Post.
    /// </summary>
    public enum PostStatus
    {
        Draft       = 0,
        Scheduled   = 1,
        Publishing  = 2,
        Published   = 3,
        Archived    = 4
    }

    /// <summary>
    /// How the post will be monetized once published.
    /// </summary>
    public enum MonetizationRule
    {
        Free            = 0,
        SubscriberOnly  = 1,
        OneOffPurchase  = 2
    }

    /// <summary>
    /// Aggregate root that represents a Blog Post in the domain.
    /// </summary>
    public sealed class Post
    {
        private readonly List<IDomainEvent> _domainEvents = new();

        public Guid             Id                  { get; private set; }
        public Guid             AuthorId            { get; private set; }
        public string           Title               { get; private set; }
        public string           Content             { get; private set; }
        public DateTimeOffset   ScheduledForUtc     { get; private set; }
        public PostStatus       Status              { get; private set; }
        public MonetizationRule MonetizationRule    { get; private set; }
        public Money            Price               { get; private set; } = Money.Zero;

        #region Factory

        private Post() { } // For ORM

        public static Post Schedule(
            Guid postId,
            Guid authorId,
            string title,
            string content,
            DateTimeOffset scheduledForUtc,
            MonetizationRule monetizationRule,
            Money? price = null)
        {
            if (scheduledForUtc <= DateTimeOffset.UtcNow)
                throw new ArgumentException("Scheduled time must be in the future.", nameof(scheduledForUtc));

            if (monetizationRule == MonetizationRule.OneOffPurchase && (price is null || !price.Value.IsPositive()))
                throw new ArgumentException("Price must be positive for one-off purchase posts.", nameof(price));

            return new Post
            {
                Id               = postId,
                AuthorId         = authorId,
                Title            = title,
                Content          = content,
                ScheduledForUtc  = scheduledForUtc,
                Status           = PostStatus.Scheduled,
                MonetizationRule = monetizationRule,
                Price            = price ?? Money.Zero
            };
        }

        #endregion

        #region Behaviour

        public void Publish(DateTimeOffset clockNow)
        {
            if (Status != PostStatus.Scheduled)
                throw new InvalidOperationException($"Post is in an invalid state for publishing: {Status}.");

            if (clockNow < ScheduledForUtc)
                throw new InvalidOperationException("Cannot publish before scheduled time.");

            Status = PostStatus.Published;
            RaiseDomainEvent(new PostPublishedEvent(Id, AuthorId, clockNow));
        }

        private void RaiseDomainEvent(IDomainEvent @event) => _domainEvents.Add(@event);

        public IReadOnlyCollection<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

        public void ClearDomainEvents() => _domainEvents.Clear();

        #endregion
    }

    #endregion

    #region Domain Events

    public interface IDomainEvent { }

    public record PostPublishedEvent(Guid PostId, Guid AuthorId, DateTimeOffset PublishedAtUtc) : IDomainEvent;

    #endregion

    #region Ports (Interfaces)

    /// <summary>
    /// Port that abstracts the persistence of Post aggregates.
    /// </summary>
    public interface IPostRepository
    {
        Task<IReadOnlyCollection<Post>> FindScheduledDueAsync(DateTimeOffset upToUtc, int batchSize,
            CancellationToken ct = default);

        Task SaveAsync(Post post, CancellationToken ct = default);
    }

    /// <summary>
    /// Port that abstracts user billing/subscription verification.
    /// </summary>
    public interface IPaymentGateway
    {
        Task<bool> IsActiveSubscriberAsync(Guid userId, CancellationToken ct = default);
    }

    /// <summary>
    /// Port to provide a reliable clock for time-based calculations. Facilitates testing.
    /// </summary>
    public interface IClock
    {
        DateTimeOffset UtcNow { get; }
    }

    /// <summary>
    /// Port for emitting domain events to external systems (Message bus, EventStore, etc.).
    /// </summary>
    public interface IEventPublisher
    {
        Task PublishAsync(IDomainEvent @event, CancellationToken ct = default);
    }

    /// <summary>
    /// Port that provides a distributed lock to guarantee single-instance execution
    /// across multiple nodes/containers (e.g., Redis, Cosmos DB, SQL Server, etc.).
    /// </summary>
    public interface IDistributedLock : IAsyncDisposable
    {
        Task<bool> TryAcquireAsync(string lockName, TimeSpan ttl, CancellationToken ct = default);
    }

    #endregion

    #region Application Service

    /// <summary>
    /// Application Service responsible for handling scheduled publication flow.
    /// </summary>
    public interface IScheduledPublishingService
    {
        Task<int> PublishDuePostsAsync(int batchSize, CancellationToken ct = default);
    }

    /// <inheritdoc />
    public sealed class ScheduledPublishingService : IScheduledPublishingService
    {
        private const string LockName       = "scheduled-post-publishing-lock";
        private static readonly TimeSpan LockTtl = TimeSpan.FromMinutes(5);

        private readonly IPostRepository   _postRepository;
        private readonly IPaymentGateway   _paymentGateway;
        private readonly IClock            _clock;
        private readonly IEventPublisher   _eventPublisher;
        private readonly IDistributedLock  _distributedLock;
        private readonly ILogger           _logger;

        public ScheduledPublishingService(
            IPostRepository postRepository,
            IPaymentGateway paymentGateway,
            IClock clock,
            IEventPublisher eventPublisher,
            IDistributedLock distributedLock,
            ILogger<ScheduledPublishingService> logger)
        {
            _postRepository  = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _paymentGateway  = paymentGateway  ?? throw new ArgumentNullException(nameof(paymentGateway));
            _clock           = clock           ?? throw new ArgumentNullException(nameof(clock));
            _eventPublisher  = eventPublisher  ?? throw new ArgumentNullException(nameof(eventPublisher));
            _distributedLock = distributedLock ?? throw new ArgumentNullException(nameof(distributedLock));
            _logger          = logger          ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task<int> PublishDuePostsAsync(int batchSize, CancellationToken ct = default)
        {
            if (batchSize <= 0) throw new ArgumentOutOfRangeException(nameof(batchSize));

            // Prevent multiple nodes from publishing the same posts concurrently.
            if (!await _distributedLock.TryAcquireAsync(LockName, LockTtl, ct))
            {
                _logger.LogInformation("Could not acquire distributed lock '{LockName}'. Skipping execution.", LockName);
                return 0;
            }

            // Fetch posts that are scheduled up to now.
            var duePosts = await _postRepository.FindScheduledDueAsync(_clock.UtcNow, batchSize, ct);

            int publishedCount = 0;

            foreach (var post in duePosts)
            {
                try
                {
                    // Validate payment/monetization rules prior to publishing.
                    bool canPublish = await VerifyMonetizationAsync(post, ct);
                    if (!canPublish)
                    {
                        _logger.LogWarning("Post {PostId} by Author {AuthorId} could not be published due " +
                                           "to unsatisfied monetization requirements.", post.Id, post.AuthorId);
                        continue;
                    }

                    post.Publish(_clock.UtcNow);

                    await _postRepository.SaveAsync(post, ct);

                    // Dispatch Domain Events.
                    foreach (var @event in post.DomainEvents)
                    {
                        try
                        {
                            await _eventPublisher.PublishAsync(@event, ct);
                        }
                        catch (Exception e)
                        {
                            _logger.LogError(e,
                                "Failed to publish domain event {EventType} for Post {PostId}.",
                                @event.GetType().Name, post.Id);
                            // Swallow or re-throw based on business requirements.
                        }
                    }

                    post.ClearDomainEvents();
                    publishedCount++;

                    _logger.LogInformation("Successfully published Post {PostId}.", post.Id);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Unexpected error while publishing Post {PostId}.", post.Id);
                    // Continue processing other posts instead of failing the entire batch.
                }
            }

            return publishedCount;
        }

        private async Task<bool> VerifyMonetizationAsync(Post post, CancellationToken ct)
        {
            switch (post.MonetizationRule)
            {
                case MonetizationRule.Free:
                    return true;

                case MonetizationRule.SubscriberOnly:
                    return await _paymentGateway.IsActiveSubscriberAsync(post.AuthorId, ct);

                case MonetizationRule.OneOffPurchase:
                    // For one-off purchases we still publish. Access gating happens at read time.
                    // However, in some businesses you may withhold publishing until a threshold is met.
                    return true;

                default:
                    _logger.LogWarning("Unknown MonetizationRule {Rule} for Post {PostId}.",
                        post.MonetizationRule, post.Id);
                    return false;
            }
        }
    }

    #endregion

    #region In-Memory Adapters (For Demonstration / Tests)

    // NOTE: These are NOT intended for production usage.
    internal sealed class InMemoryPostRepository : IPostRepository
    {
        private readonly List<Post> _posts = new();

        public Task<IReadOnlyCollection<Post>> FindScheduledDueAsync(DateTimeOffset upToUtc, int batchSize, CancellationToken ct = default)
        {
            var due = _posts
                .Where(p => p.Status == PostStatus.Scheduled && p.ScheduledForUtc <= upToUtc)
                .Take(batchSize)
                .ToArray();

            return Task.FromResult<IReadOnlyCollection<Post>>(due);
        }

        public Task SaveAsync(Post post, CancellationToken ct = default)
        {
            var idx = _posts.FindIndex(p => p.Id == post.Id);
            if (idx < 0)
                _posts.Add(post);
            else
                _posts[idx] = post;

            return Task.CompletedTask;
        }

        // Helper method for tests
        public void Seed(Post post) => _posts.Add(post);
    }

    internal sealed class InMemoryPaymentGateway : IPaymentGateway
    {
        private readonly HashSet<Guid> _activeSubscribers = new();

        public void AddSubscriber(Guid userId) => _activeSubscribers.Add(userId);

        public Task<bool> IsActiveSubscriberAsync(Guid userId, CancellationToken ct = default)
            => Task.FromResult(_activeSubscribers.Contains(userId));
    }

    internal sealed class SystemClock : IClock
    {
        public DateTimeOffset UtcNow => DateTimeOffset.UtcNow;
    }

    internal sealed class InMemoryEventPublisher : IEventPublisher
    {
        public readonly List<IDomainEvent> _events = new();

        public Task PublishAsync(IDomainEvent @event, CancellationToken ct = default)
        {
            _events.Add(@event);
            return Task.CompletedTask;
        }
    }

    internal sealed class NoOpDistributedLock : IDistributedLock
    {
        public Task<bool> TryAcquireAsync(string lockName, TimeSpan ttl, CancellationToken ct = default) 
            => Task.FromResult(true);

        public ValueTask DisposeAsync() => ValueTask.CompletedTask;
    }

    #endregion
}
```