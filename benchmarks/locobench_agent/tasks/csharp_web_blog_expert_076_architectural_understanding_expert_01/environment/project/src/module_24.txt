```csharp
// -----------------------------------------------------------------------------
// File:      src/module_24.txt
// Project:   TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// Language:  C# (.NET 7)
// Purpose:   Application-layer service that generates productivity snapshots
//            for creators. The service sits in the “use-case” ring of the
//            Hexagonal Architecture, coordinates domain repositories, applies
//            business rules, leverages distributed cache and logs richly.
// -----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Application.Analytics
{
    #region Interfaces (Ports)

    /// <summary>
    /// Clock abstraction to keep business logic deterministic and testable.
    /// </summary>
    public interface IDateTimeProvider
    {
        DateTime UtcNow { get; }
    }

    /// <summary>
    /// Repository for Post aggregates.
    /// </summary>
    public interface IPostRepository
    {
        Task<IReadOnlyCollection<Post>> GetPublishedByAuthorAsync(
            Guid authorId,
            DateTime fromUtc,
            DateTime toUtc,
            CancellationToken token = default);
    }

    /// <summary>
    /// Repository for WorkSession aggregates (time spent editing, drafting, etc.)
    /// </summary>
    public interface IWorkSessionRepository
    {
        Task<IReadOnlyCollection<WorkSession>> GetByAuthorAsync(
            Guid authorId,
            DateTime fromUtc,
            DateTime toUtc,
            CancellationToken token = default);
    }

    /// <summary>
    /// Use-case service for generating productivity snapshots.
    /// </summary>
    public interface IProductivitySnapshotService
    {
        Task<CreatorPerformanceSnapshot> GenerateSnapshotAsync(
            Guid creatorId,
            DateRange range,
            CancellationToken token = default);
    }

    #endregion

    #region DTOs / Value Objects

    /// <summary>
    /// Simple date range value object (inclusive).
    /// </summary>
    public readonly struct DateRange
    {
        public DateRange(DateTime fromUtc, DateTime toUtc)
        {
            if (fromUtc.Kind != DateTimeKind.Utc || toUtc.Kind != DateTimeKind.Utc)
                throw new ArgumentException("DateRange values must be in UTC.");

            if (fromUtc > toUtc)
                throw new ArgumentException("fromUtc must be earlier than or equal to toUtc.");

            FromUtc = fromUtc;
            ToUtc = toUtc;
        }

        public DateTime FromUtc { get; }
        public DateTime ToUtc { get; }

        public override string ToString()
            => $"{FromUtc:yyyyMMddHHmmss}_{ToUtc:yyyyMMddHHmmss}";
    }

    /// <summary>
    /// Snapshot representing key performance indicators for a creator.
    /// </summary>
    public sealed record CreatorPerformanceSnapshot
    {
        public Guid CreatorId { get; init; }
        public DateRange Range { get; init; }

        public int PostsPublished { get; init; }
        public double WordsPerPostAvg { get; init; }
        public double DraftToPublishTimeHoursAvg { get; init; }
        public TimeSpan TotalEditingTime { get; init; }
        public DateTime GeneratedAtUtc { get; init; }
    }

    #endregion

    #region Domain Stubs (Placeholders)

    // NOTE: The full domain models live in the Domain layer. Only minimal members
    // needed by this module are re-declared here to avoid cross-layer references.
    public sealed record Post
    {
        public Guid Id { get; init; }
        public Guid AuthorId { get; init; }
        public DateTime CreatedAtUtc { get; init; }
        public DateTime PublishedAtUtc { get; init; }
        public int WordCount { get; init; }
    }

    public sealed record WorkSession
    {
        public Guid Id { get; init; }
        public Guid AuthorId { get; init; }
        public DateTime StartedAtUtc { get; init; }
        public DateTime EndedAtUtc { get; init; }

        public TimeSpan Duration => EndedAtUtc - StartedAtUtc;
    }

    #endregion

    #region Implementation

    /// <summary>
    /// Concrete application service that computes creator productivity metrics,
    /// with optional caching and structured logging.
    /// </summary>
    public sealed class ProductivitySnapshotService : IProductivitySnapshotService
    {
        private static readonly JsonSerializerOptions CacheSerializerOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            Converters = { new JsonStringEnumConverter() },
            WriteIndented = false
        };

        private const string CacheKeyTemplate = "analytics:snapshot:{0}:{1}";
        private readonly IPostRepository _postRepository;
        private readonly IWorkSessionRepository _workSessionRepository;
        private readonly IDistributedCache _cache;
        private readonly IDateTimeProvider _clock;
        private readonly ILogger<ProductivitySnapshotService> _logger;

        public ProductivitySnapshotService(
            IPostRepository postRepository,
            IWorkSessionRepository workSessionRepository,
            IDistributedCache cache,
            IDateTimeProvider clock,
            ILogger<ProductivitySnapshotService> logger)
        {
            _postRepository = postRepository ?? throw new ArgumentNullException(nameof(postRepository));
            _workSessionRepository = workSessionRepository ?? throw new ArgumentNullException(nameof(workSessionRepository));
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _clock = clock ?? throw new ArgumentNullException(nameof(clock));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<CreatorPerformanceSnapshot> GenerateSnapshotAsync(
            Guid creatorId,
            DateRange range,
            CancellationToken token = default)
        {
            // Defensive guard
            if (creatorId == Guid.Empty)
                throw new ArgumentException("CreatorId cannot be empty.", nameof(creatorId));

            // Try cache first
            var cacheKey = string.Format(CultureInfo.InvariantCulture, CacheKeyTemplate, creatorId, range);
            var cachedBytes = await _cache.GetAsync(cacheKey, token).ConfigureAwait(false);
            if (cachedBytes is { Length: > 0 })
            {
                try
                {
                    var snapshot = JsonSerializer.Deserialize<CreatorPerformanceSnapshot>(
                        cachedBytes,
                        CacheSerializerOptions);

                    if (snapshot is not null)
                    {
                        _logger.LogInformation("Returning cached productivity snapshot for {CreatorId} ({Range})", creatorId, range);
                        return snapshot;
                    }
                }
                catch (JsonException ex)
                {
                    // Cache corruption should not block execution – log and fall through.
                    _logger.LogWarning(ex, "Failed to deserialize cached snapshot '{CacheKey}'. Regenerating.", cacheKey);
                }
            }

            // Fetch data from repositories
            _logger.LogDebug("Fetching posts for creator {CreatorId} in range {Range}", creatorId, range);

            var postsTask = _postRepository.GetPublishedByAuthorAsync(
                creatorId,
                range.FromUtc,
                range.ToUtc,
                token);

            var sessionsTask = _workSessionRepository.GetByAuthorAsync(
                creatorId,
                range.FromUtc,
                range.ToUtc,
                token);

            await Task.WhenAll(postsTask, sessionsTask).ConfigureAwait(false);

            var posts = postsTask.Result;
            var sessions = sessionsTask.Result;

            _logger.LogDebug(
                "Fetched {PostsCount} posts and {SessionCount} work sessions for creator {CreatorId}",
                posts.Count,
                sessions.Count,
                creatorId);

            // Business rules / calculations
            var postsPublished = posts.Count;
            var wordsPerPostAvg = postsPublished == 0
                ? 0
                : Math.Round(posts.Average(p => p.WordCount), 2);

            var draftToPublishTimeHoursAvg = postsPublished == 0
                ? 0
                : Math.Round(posts.Average(p => (p.PublishedAtUtc - p.CreatedAtUtc).TotalHours), 2);

            var totalEditingTime = sessions.Aggregate(TimeSpan.Zero, (acc, s) => acc + s.Duration);

            var snapshotResult = new CreatorPerformanceSnapshot
            {
                CreatorId = creatorId,
                Range = range,
                PostsPublished = postsPublished,
                WordsPerPostAvg = wordsPerPostAvg,
                DraftToPublishTimeHoursAvg = draftToPublishTimeHoursAvg,
                TotalEditingTime = totalEditingTime,
                GeneratedAtUtc = _clock.UtcNow
            };

            // Store in cache (24h sliding expiration; can be tuned in app settings)
            var cacheOptions = new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(24),
                SlidingExpiration = TimeSpan.FromHours(6)
            };

            var serialized = JsonSerializer.SerializeToUtf8Bytes(snapshotResult, CacheSerializerOptions);
            await _cache.SetAsync(cacheKey, serialized, cacheOptions, token).ConfigureAwait(false);

            _logger.LogInformation(
                "Generated new productivity snapshot for {CreatorId} | Posts: {Posts} | AvgWords: {WordsAvg} | AvgLeadTime(h): {LeadTime} | TotalEdit: {TotalEdit}",
                creatorId,
                postsPublished,
                wordsPerPostAvg,
                draftToPublishTimeHoursAvg,
                totalEditingTime);

            return snapshotResult;
        }
    }

    #endregion
}
```