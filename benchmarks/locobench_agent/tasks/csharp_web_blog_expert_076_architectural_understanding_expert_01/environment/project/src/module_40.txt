```csharp
// src/module_40.txt
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// Module 40: Live-Preview Diff & Cache Service
//
// This source file contains both the application-layer service responsible for
// producing HTML diffs between a Post’s published and in-progress versions, and
// the infrastructure adapter that persists those diffs in a distributed cache.
//
// The code demonstrates the hexagonal pattern:
//
// ┌───────────────────┐   ┌───────────────────────┐
// │   Domain Core     │   │    Application Layer  │
// │  (technology-free)│   │  (orchestrates ports) │
// └───────────────────┘   └───────────────────────┘
//               ▲                       ▲
//               │ Ports / Interfaces    │
//               ▼                       ▼
// ┌───────────────────┐   ┌───────────────────────┐
// │   External Cache  │   │     SQL Repository    │
// │  (Redis adapter)  │   │    (not included)     │
// └───────────────────┘   └───────────────────────┘
//
// NOTE: Other domain objects (Post, PostRevision, etc.) exist elsewhere in the
// solution. Only the types required to compile this module are included here.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Caching.Distributed;
using Newtonsoft.Json;

namespace TempoScribePro.Application.LivePreview
{
    #region DTOs / Value Objects

    /// <summary>
    /// A simple DTO returned to the front-end for live preview rendering.
    /// </summary>
    public sealed record LivePreviewDto(
        Guid PostId,
        string DiffHtml,
        DateTime GeneratedAtUtc,
        bool FromCache);

    #endregion

    #region Ports (Interfaces)

    /// <summary>
    /// Query-side port used by the Application Service to fetch post data.
    /// </summary>
    public interface IPostReadRepository
    {
        /// <summary>
        /// Returns the currently published (public) content for the post, or <c>null</c> if never published.
        /// </summary>
        Task<string?> FetchPublishedMarkdownAsync(Guid postId, CancellationToken ct = default);

        /// <summary>
        /// Returns the most recent draft content, as Markdown, for the post.
        /// Throws if the post does not exist.
        /// </summary>
        Task<(string Markdown, DateTime UpdatedUtc)> FetchLatestDraftMarkdownAsync(Guid postId, CancellationToken ct = default);
    }

    /// <summary>
    /// Domain service responsible for calculating human-friendly HTML diffs.
    /// </summary>
    public interface IDiffGenerator
    {
        Task<string> GenerateDiffHtmlAsync(
            string? oldMarkdown,
            string newMarkdown,
            CancellationToken ct = default);
    }

    /// <summary>
    /// Secondary port for persisting diff results in a distributed cache.
    /// </summary>
    public interface IDiffCache
    {
        Task CacheAsync(Guid postId, DateTime draftUpdatedUtc, string diffHtml, CancellationToken ct = default);
        Task<string?> TryGetAsync(Guid postId, DateTime draftUpdatedUtc, CancellationToken ct = default);
    }

    /// <summary>
    /// Application-layer facade invoked by controllers / GraphQL resolvers.
    /// </summary>
    public interface ILivePreviewService
    {
        Task<LivePreviewDto> GetLivePreviewAsync(Guid postId, CancellationToken ct = default);
    }

    #endregion

    #region Application Service

    /// <summary>
    /// Coordinates repositories, diff generation, and caching to return
    /// an HTML diff that front-end clients can render instantly.
    /// </summary>
    internal sealed class LivePreviewService : ILivePreviewService
    {
        private const int DefaultCacheMinutes = 10;

        private readonly IPostReadRepository _postRepo;
        private readonly IDiffGenerator _diffGenerator;
        private readonly IDiffCache _diffCache;
        private readonly ILogger<LivePreviewService> _logger;

        public LivePreviewService(
            IPostReadRepository postRepo,
            IDiffGenerator diffGenerator,
            IDiffCache diffCache,
            ILogger<LivePreviewService> logger)
        {
            _postRepo      = postRepo  ?? throw new ArgumentNullException(nameof(postRepo));
            _diffGenerator = diffGenerator ?? throw new ArgumentNullException(nameof(diffGenerator));
            _diffCache     = diffCache ?? throw new ArgumentNullException(nameof(diffCache));
            _logger        = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<LivePreviewDto> GetLivePreviewAsync(Guid postId, CancellationToken ct = default)
        {
            // 1. Fetch the latest draft metadata.
            var (draftMarkdown, draftUpdatedUtc) = await _postRepo.FetchLatestDraftMarkdownAsync(postId, ct);

            // 2. Try to find a cached diff keyed by the draft's last update timestamp.
            string? cachedDiff = await _diffCache.TryGetAsync(postId, draftUpdatedUtc, ct);
            if (cachedDiff is not null)
            {
                _logger.LogDebug("Live preview diff served from cache for Post {PostId}", postId);
                return new LivePreviewDto(postId, cachedDiff, DateTime.UtcNow, true);
            }

            // 3. Obtain the published text (may be null if unpublished).
            string? publishedMarkdown = await _postRepo.FetchPublishedMarkdownAsync(postId, ct);

            // 4. Generate a fresh diff.
            string diffHtml;
            try
            {
                diffHtml = await _diffGenerator.GenerateDiffHtmlAsync(publishedMarkdown, draftMarkdown, ct);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Diff generation failed for Post {PostId}", postId);
                throw; // let higher levels decide how to surface to the user
            }

            // 5. Store it in the distributed cache.
            try
            {
                await _diffCache.CacheAsync(postId, draftUpdatedUtc, diffHtml, ct);
            }
            catch (Exception ex)
            {
                // Cache failures must not break user flow.
                _logger.LogWarning(ex, "Unable to cache diff for Post {PostId}", postId);
            }

            return new LivePreviewDto(postId, diffHtml, DateTime.UtcNow, false);
        }
    }

    #endregion

    #region Infrastructure – Diff Cache (Redis / IDistributedCache)

    /// <summary>
    /// Distributes diff payloads via ASP.NET Core's <see cref="IDistributedCache"/>.
    /// Compatible with Redis, SQL Server, NCache, or any custom provider configured in Startup.
    /// </summary>
    public sealed class DistributedDiffCache : IDiffCache
    {
        private readonly IDistributedCache _cache;
        private readonly ILogger<DistributedDiffCache> _logger;
        private readonly DistributedCacheEntryOptions _entryOptions;

        public DistributedDiffCache(
            IDistributedCache cache,
            ILogger<DistributedDiffCache> logger,
            int absoluteExpirationMinutes = 20)
        {
            _cache  = cache  ?? throw new ArgumentNullException(nameof(cache));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            // Configure TTL for diff items. Live previews are short-lived.
            _entryOptions = new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(absoluteExpirationMinutes),
                SlidingExpiration = TimeSpan.FromMinutes(Math.Max(absoluteExpirationMinutes / 2, 5))
            };
        }

        public async Task CacheAsync(Guid postId, DateTime draftUpdatedUtc, string diffHtml, CancellationToken ct = default)
        {
            var key = BuildKey(postId, draftUpdatedUtc);
            var payload = new DiffCachePayload(diffHtml);

            await _cache.SetStringAsync(key, JsonConvert.SerializeObject(payload), _entryOptions, ct);
            _logger.LogTrace("Cached diff for Post {PostId} (key={Key})", postId, key);
        }

        public async Task<string?> TryGetAsync(Guid postId, DateTime draftUpdatedUtc, CancellationToken ct = default)
        {
            var key = BuildKey(postId, draftUpdatedUtc);
            var json = await _cache.GetStringAsync(key, ct);

            if (json == null)
            {
                return null;
            }

            try
            {
                var payload = JsonConvert.DeserializeObject<DiffCachePayload>(json);
                return payload?.DiffHtml;
            }
            catch (JsonException ex)
            {
                _logger.LogWarning(ex, "Corrupted diff cache entry detected (key={Key}) – purging.", key);
                await _cache.RemoveAsync(key, ct);
                return null;
            }
        }

        private static string BuildKey(Guid postId, DateTime updatedUtc)
            => $"livepreview:{postId:N}:{updatedUtc:yyyyMMddHHmmssffff}";

        private sealed record DiffCachePayload(string DiffHtml);
    }

    #endregion

    #region Infrastructure – Simple Html Diff Generator

    /// <summary>
    /// A basic diff generator that operates on Markdown input and highlights line-level changes.
    /// Replace with a more sophisticated semantic diff (e.g. using diff-match-patch) as needed.
    /// </summary>
    public sealed class SimpleHtmlDiffGenerator : IDiffGenerator
    {
        public Task<string> GenerateDiffHtmlAsync(string? oldMarkdown, string newMarkdown, CancellationToken ct = default)
        {
            // For demonstration, compute a naïve line-by-line diff and wrap changes in <ins>/<del>.
            var oldLines = (oldMarkdown ?? string.Empty).Split('\n');
            var newLines = newMarkdown.Split('\n');

            var diffBuilder = new StringBuilder();
            var max = Math.Max(oldLines.Length, newLines.Length);

            for (int i = 0; i < max; i++)
            {
                ct.ThrowIfCancellationRequested();

                var oldLine = i < oldLines.Length ? oldLines[i] : null;
                var newLine = i < newLines.Length ? newLines[i] : null;

                if (oldLine == newLine)
                {
                    diffBuilder.AppendLine(System.Web.HttpUtility.HtmlEncode(newLine ?? string.Empty));
                }
                else
                {
                    if (oldLine is not null)
                    {
                        diffBuilder.Append("<del class=\"ts-diff-del\">")
                                   .Append(System.Web.HttpUtility.HtmlEncode(oldLine))
                                   .AppendLine("</del>");
                    }

                    if (newLine is not null)
                    {
                        diffBuilder.Append("<ins class=\"ts-diff-ins\">")
                                   .Append(System.Web.HttpUtility.HtmlEncode(newLine))
                                   .AppendLine("</ins>");
                    }
                }
            }

            // Wrap in a container so styling can be applied by the front-end.
            var html = $"<div class=\"ts-diff\">{diffBuilder}</div>";
            return Task.FromResult(html);
        }
    }

    #endregion

    #region Dependency Injection Extension

    /// <summary>
    /// Adds LivePreview services and their adapters to the .NET DI container.
    /// </summary>
    public static class LivePreviewServiceCollectionExtensions
    {
        public static IServiceCollection AddLivePreviewModule(this IServiceCollection services)
        {
            // Ports
            services.AddTransient<ILivePreviewService, LivePreviewService>();

            // Domain services
            services.AddSingleton<IDiffGenerator, SimpleHtmlDiffGenerator>();

            // Adapters
            services.AddSingleton<IDiffCache, DistributedDiffCache>();

            // Repositories (IPostReadRepository) should already be registered by the data access layer.

            return services;
        }
    }

    #endregion
}
```