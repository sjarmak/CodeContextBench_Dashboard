```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Core.Analytics
{
    #region Ports (Interfaces)

    /// <summary>
    /// Abstraction for retrieving published blog posts.
    /// </summary>
    public interface IPostRepository
    {
        Task<IReadOnlyCollection<PostDto>> GetPublishedPostsAsync(DateTimeOffset from, DateTimeOffset to, CancellationToken ct);
    }

    /// <summary>
    /// Abstraction for retrieving comments on posts.
    /// </summary>
    public interface ICommentRepository
    {
        Task<IReadOnlyCollection<CommentDto>> GetCommentsForPostsAsync(IEnumerable<Guid> postIds, CancellationToken ct);
    }

    /// <summary>
    /// Abstraction for retrieving analytic events (page views, likes, etc.).
    /// </summary>
    public interface IAnalyticsEventRepository
    {
        Task<IReadOnlyCollection<AnalyticsEventDto>> GetEventsAsync(EventQuery query, CancellationToken ct);
    }

    /// <summary>
    /// Simple abstraction over a distributed cache (Redis, in-proc, memcached).
    /// </summary>
    public interface ICacheProvider
    {
        Task<T?> GetAsync<T>(string key, CancellationToken ct);
        Task SetAsync<T>(string key, T value, TimeSpan ttl, CancellationToken ct);
    }

    /// <summary>
    /// Abstraction for injecting time (testability).
    /// </summary>
    public interface IDateTimeProvider
    {
        DateTimeOffset UtcNow { get; }
    }

    /// <summary>
    /// Application-wide service responsible for building performance snapshots.
    /// </summary>
    public interface IPerformanceSnapshotService
    {
        Task<PerformanceSnapshot> GenerateSnapshotAsync(Guid adminUserId, SnapshotRange range, CancellationToken ct);
    }

    #endregion

    #region DTOs & Value Objects

    public record PostDto(Guid Id, Guid AuthorId, DateTimeOffset PublishedAtUtc);

    public record CommentDto(Guid Id, Guid PostId, Guid AuthorId, DateTimeOffset CreatedAtUtc);

    public record AnalyticsEventDto(Guid Id, Guid PostId, AnalyticsEventKind Kind, DateTimeOffset OccurredAtUtc);

    public enum AnalyticsEventKind
    {
        PageView = 1,
        Reaction  = 2,
        Share     = 3
    }

    /// <summary>
    /// Range helper for snapshot generation (e.g., Last7Days, Last30Days).
    /// </summary>
    public readonly record struct SnapshotRange(DateTimeOffset FromUtc, DateTimeOffset ToUtc)
    {
        public static SnapshotRange Last7Days(IDateTimeProvider clock)
        {
            var now = clock.UtcNow;
            return new SnapshotRange(now.AddDays(-7), now);
        }

        public static SnapshotRange Last30Days(IDateTimeProvider clock)
        {
            var now = clock.UtcNow;
            return new SnapshotRange(now.AddDays(-30), now);
        }
    }

    /// <summary>
    /// Aggregate DTO returned to the admin panel.
    /// </summary>
    public record PerformanceSnapshot
    {
        public SnapshotRange Range { get; init; }
        public int TotalPosts { get; init; }
        public int TotalComments { get; init; }
        public int TotalPageViews { get; init; }
        public int TotalReactions { get; init; }
        public int TotalShares { get; init; }
        public IReadOnlyDictionary<Guid, PostEngagement> EngagementByPost { get; init; } = null!;

        public record PostEngagement
        {
            public Guid PostId           { get; init; }
            public int  Comments         { get; init; }
            public int  PageViews        { get; init; }
            public int  Reactions        { get; init; }
            public int  Shares           { get; init; }
            public double EngagementRate { get; init; } // Custom KPI

            public static PostEngagement From(Guid postId) => new() { PostId = postId };
        }
    }

    /// <summary>
    /// Encapsulates a query for analytic events.
    /// </summary>
    public sealed class EventQuery
    {
        public IReadOnlyCollection<Guid>? PostIds     { get; init; }
        public DateTimeOffset             FromUtc     { get; init; }
        public DateTimeOffset             ToUtc       { get; init; }
        public IReadOnlyCollection<AnalyticsEventKind>? Kinds { get; init; }
    }

    #endregion

    #region Service Implementation

    /// <summary>
    /// Domain service that materializes a <see cref="PerformanceSnapshot"/> and caches it.
    /// The cache key is per-admin + time window to avoid duplicate heavy queries for multiple sessions.
    /// </summary>
    internal sealed class PerformanceSnapshotService : IPerformanceSnapshotService
    {
        private const string CacheKeyTemplate = "snapshot:{0}:{1:yyyyMMddHHmm}-{2:yyyyMMddHHmm}";
        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(15);

        private readonly IPostRepository _postRepo;
        private readonly ICommentRepository _commentRepo;
        private readonly IAnalyticsEventRepository _analyticsRepo;
        private readonly ICacheProvider _cache;
        private readonly IDateTimeProvider _clock;
        private readonly ILogger<PerformanceSnapshotService> _logger;

        public PerformanceSnapshotService(
            IPostRepository postRepo,
            ICommentRepository commentRepo,
            IAnalyticsEventRepository analyticsRepo,
            ICacheProvider cache,
            IDateTimeProvider clock,
            ILogger<PerformanceSnapshotService> logger)
        {
            _postRepo     = postRepo     ?? throw new ArgumentNullException(nameof(postRepo));
            _commentRepo  = commentRepo  ?? throw new ArgumentNullException(nameof(commentRepo));
            _analyticsRepo= analyticsRepo?? throw new ArgumentNullException(nameof(analyticsRepo));
            _cache        = cache        ?? throw new ArgumentNullException(nameof(cache));
            _clock        = clock        ?? throw new ArgumentNullException(nameof(clock));
            _logger       = logger       ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<PerformanceSnapshot> GenerateSnapshotAsync(Guid adminUserId, SnapshotRange range, CancellationToken ct)
        {
            if (range.FromUtc > range.ToUtc)
                throw new ArgumentException("Range.FromUtc must be earlier than Range.ToUtc", nameof(range));

            var cacheKey = string.Format(CacheKeyTemplate, adminUserId, range.FromUtc, range.ToUtc);

            // 1. Try cache first
            var cached = await _cache.GetAsync<PerformanceSnapshot>(cacheKey, ct);
            if (cached is not null)
            {
                _logger.LogDebug("Returning cached snapshot {CacheKey}", cacheKey);
                return cached;
            }

            try
            {
                _logger.LogInformation(
                    "Generating performance snapshot for Admin {AdminUser} between {From} and {To}",
                    adminUserId, range.FromUtc, range.ToUtc);

                // 2. Fetch data from repositories
                var posts = await _postRepo.GetPublishedPostsAsync(range.FromUtc, range.ToUtc, ct);
                var postIds = posts.Select(p => p.Id).ToArray();

                var commentsTask = _commentRepo.GetCommentsForPostsAsync(postIds, ct);
                var eventsTask   = _analyticsRepo.GetEventsAsync(new EventQuery
                {
                    PostIds = postIds,
                    FromUtc = range.FromUtc,
                    ToUtc   = range.ToUtc
                }, ct);

                await Task.WhenAll(commentsTask, eventsTask).ConfigureAwait(false);

                var comments = commentsTask.Result;
                var events   = eventsTask.Result;

                // 3. Aggregate metrics
                var engagementDict = postIds.ToDictionary(
                    id => id,
                    id => PerformanceSnapshot.PostEngagement.From(id));

                foreach (var comment in comments)
                {
                    var e = engagementDict[comment.PostId];
                    e.Comments++;
                }

                foreach (var ev in events)
                {
                    var e = engagementDict[ev.PostId];
                    switch (ev.Kind)
                    {
                        case AnalyticsEventKind.PageView:  e.PageViews++;  break;
                        case AnalyticsEventKind.Reaction:  e.Reactions++;  break;
                        case AnalyticsEventKind.Share:     e.Shares++;     break;
                    }
                }

                // Compute derived KPI per post
                foreach (var kvp in engagementDict)
                {
                    var e = kvp.Value;
                    // Example: simplistic engagement rate formula; tweak to real requirement
                    e.EngagementRate = SafeDivide(e.Reactions + e.Comments + e.Shares, Math.Max(e.PageViews, 1)) * 100.0;
                }

                var snapshot = new PerformanceSnapshot
                {
                    Range = range,
                    TotalPosts     = posts.Count,
                    TotalComments  = comments.Count,
                    TotalPageViews = events.Count(ev => ev.Kind == AnalyticsEventKind.PageView),
                    TotalReactions = events.Count(ev => ev.Kind == AnalyticsEventKind.Reaction),
                    TotalShares    = events.Count(ev => ev.Kind == AnalyticsEventKind.Share),
                    EngagementByPost = engagementDict
                };

                // 4. Cache result
                await _cache.SetAsync(cacheKey, snapshot, CacheTtl, ct).ConfigureAwait(false);

                return snapshot;
            }
            catch (Exception ex) when (!ex.IsFatal())
            {
                _logger.LogError(ex, "Failed to generate performance snapshot for admin {AdminUser}", adminUserId);
                throw; // Bubble up to middleware â€” ensures monitored & observable
            }
        }

        private static double SafeDivide(int numerator, int denominator) =>
            denominator == 0 ? 0 : (double)numerator / denominator;

    }

    #endregion

    #region Helpers

    internal static class ExceptionExtensions
    {
        /// <summary>
        /// Determines if an exception is fatal and should *not* be swallowed/handled.
        /// </summary>
        public static bool IsFatal(this Exception ex) =>
            ex is OutOfMemoryException
            || ex is StackOverflowException
            || ex is ThreadAbortException
            || ex is AccessViolationException;
    }

    #endregion
}
```