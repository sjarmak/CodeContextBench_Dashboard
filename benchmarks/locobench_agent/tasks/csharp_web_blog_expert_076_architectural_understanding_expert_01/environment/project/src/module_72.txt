```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.Logging;
using TempoScribePro.Blog.Core.Domain;
using TempoScribePro.Blog.Core.Domain.Analytics;
using TempoScribePro.Blog.Core.Domain.Repositories;
using TempoScribePro.Blog.Core.Ports.Outgoing;
using TempoScribePro.Blog.SharedKernel;

// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable UnusedMember.Global

namespace TempoScribePro.Blog.Infrastructure.Analytics
{
    /// <summary>
    /// Hexagonal adapter that materializes <see cref="AuthorProductivityReport"/> from persisted aggregates
    /// and caches the result in the configured <see cref="IDistributedCache"/> (Redis, SQL, in-memory, etc.).
    /// </summary>
    /// <remarks>
    /// This is an infrastructure concern and can be swapped out without touching the core domain.
    /// </remarks>
    public sealed class RedisEditorialAnalyticsAdapter : IEditorialAnalyticsPort
    {
        private const string CacheKeyPrefix = "tempo:analytics:author:";
        private static readonly DistributedCacheEntryOptions CacheOptions =
            new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(15),
                SlidingExpiration = TimeSpan.FromMinutes(5)
            };

        private readonly IPostRepository _postRepository;
        private readonly IWorkSessionRepository _workSessionRepository;
        private readonly IDistributedCache _cache;
        private readonly ILogger<RedisEditorialAnalyticsAdapter> _logger;

        public RedisEditorialAnalyticsAdapter(
            IPostRepository postRepository,
            IWorkSessionRepository workSessionRepository,
            IDistributedCache cache,
            ILogger<RedisEditorialAnalyticsAdapter> logger)
        {
            _postRepository = postRepository ?? throw new ArgumentNullException(nameof(postRepository));
            _workSessionRepository = workSessionRepository ?? throw new ArgumentNullException(nameof(workSessionRepository));
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task<AuthorProductivityReport> GetAuthorReportAsync(
            Guid authorId,
            DateRange range,
            CancellationToken cancellationToken = default)
        {
            if (authorId == Guid.Empty) throw new ArgumentException("AuthorId must be a non-empty GUID.", nameof(authorId));

            var cacheKey = BuildCacheKey(authorId, range);

            try
            {
                // Attempt cache lookup first
                var cachedBytes = await _cache.GetAsync(cacheKey, cancellationToken).ConfigureAwait(false);
                if (cachedBytes != null)
                {
                    _logger.LogDebug("Cache hit for {CacheKey}", cacheKey);
                    return JsonSerializer.Deserialize<AuthorProductivityReport>(cachedBytes)!;
                }

                _logger.LogDebug("Cache miss for {CacheKey}. Computing analytics…", cacheKey);

                // Pull aggregates from repositories
                var posts = await _postRepository.GetByAuthorAsync(authorId, range, cancellationToken).ConfigureAwait(false);
                var sessions = await _workSessionRepository.GetByAuthorAsync(authorId, range, cancellationToken)
                    .ConfigureAwait(false);

                var computedReport = ComputeAnalytics(range, posts, sessions);

                // Persist to cache
                var serialized = JsonSerializer.SerializeToUtf8Bytes(computedReport);
                await _cache.SetAsync(cacheKey, serialized, CacheOptions, cancellationToken).ConfigureAwait(false);

                return computedReport;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Failed to generate or cache author report for {AuthorId} within {Range}. Returning fallback.",
                    authorId, range);
                // In case of catastrophic failure, degrade gracefully
                return AuthorProductivityReport.Empty(authorId, range);
            }
        }

        #region Private helpers

        private static string BuildCacheKey(Guid authorId, DateRange range)
            => $"{CacheKeyPrefix}{authorId}:from:{range.Start:O}:to:{range.End:O}";

        private static AuthorProductivityReport ComputeAnalytics(
            DateRange range,
            IReadOnlyCollection<Post> posts,
            IReadOnlyCollection<WorkSession> sessions)
        {
            var publishedPosts = posts.Where(p => p.Status == PostStatus.Published).ToList();

            var totalWords = posts.Sum(p => p.WordCount);
            var totalSessions = sessions.Count;
            var totalMinutes = sessions.Sum(s => s.DurationInMinutes);

            var postsPerSession = totalSessions == 0
                ? 0
                : Math.Round((double)posts.Count / totalSessions, 2);

            var wordsPerMinute = totalMinutes == 0
                ? 0
                : Math.Round((double)totalWords / totalMinutes, 2);

            var averageSessionLength = totalSessions == 0
                ? 0
                : Math.Round((double)totalMinutes / totalSessions, 2);

            return new AuthorProductivityReport(
                authorId: posts.FirstOrDefault()?.AuthorId ?? Guid.Empty,
                range: range,
                totalPosts: posts.Count,
                publishedPosts: publishedPosts.Count,
                totalWords: totalWords,
                totalWorkSessions: totalSessions,
                totalSessionMinutes: totalMinutes,
                averagePostsPerSession: postsPerSession,
                wordsPerMinute: wordsPerMinute,
                averageSessionLengthMinutes: averageSessionLength);
        }

        #endregion
    }
}

/*
─────────────────────────────────────────────────────────────────────────────
Shared Kernel: DateRange and Value Objects
─────────────────────────────────────────────────────────────────────────────
*/

namespace TempoScribePro.Blog.SharedKernel
{
    /// <summary>
    /// Simple value object representing an inclusive date-time range.
    /// </summary>
    public readonly record struct DateRange(DateTimeOffset Start, DateTimeOffset End)
    {
        public static DateRange LastThirtyDays()
        {
            var now = DateTimeOffset.UtcNow;
            return new DateRange(now.AddDays(-30), now);
        }

        public override string ToString() => $"{Start:O} .. {End:O}";
    }
}

/*
─────────────────────────────────────────────────────────────────────────────
Domain Contracts (Ports)
─────────────────────────────────────────────────────────────────────────────
*/

namespace TempoScribePro.Blog.Core.Ports.Outgoing
{
    /// <summary>
    /// Contract for retrieving analytical productivity data. Implemented by infrastructure adapters.
    /// </summary>
    public interface IEditorialAnalyticsPort
    {
        Task<AuthorProductivityReport> GetAuthorReportAsync(
            Guid authorId,
            DateRange range,
            CancellationToken cancellationToken = default);
    }
}

/*
─────────────────────────────────────────────────────────────────────────────
Domain Aggregates & Repositories
─────────────────────────────────────────────────────────────────────────────
*/

namespace TempoScribePro.Blog.Core.Domain
{
    public enum PostStatus
    {
        Draft,
        Scheduled,
        Published,
        Archived
    }

    public sealed class Post
    {
        public Guid Id { get; init; }
        public Guid AuthorId { get; init; }
        public string Title { get; set; } = string.Empty;
        public int WordCount { get; set; }
        public PostStatus Status { get; set; }
        public DateTimeOffset CreatedUtc { get; init; }
        public DateTimeOffset? PublishedUtc { get; set; }
    }

    public sealed class WorkSession
    {
        public Guid Id { get; init; }
        public Guid AuthorId { get; init; }
        public DateTimeOffset StartedUtc { get; init; }
        public DateTimeOffset EndedUtc { get; set; }
        public int DurationInMinutes => (int)(EndedUtc - StartedUtc).TotalMinutes;
    }
}

namespace TempoScribePro.Blog.Core.Domain.Repositories
{
    public interface IPostRepository
    {
        Task<IReadOnlyCollection<Post>> GetByAuthorAsync(
            Guid authorId,
            DateRange range,
            CancellationToken cancellationToken = default);
    }

    public interface IWorkSessionRepository
    {
        Task<IReadOnlyCollection<WorkSession>> GetByAuthorAsync(
            Guid authorId,
            DateRange range,
            CancellationToken cancellationToken = default);
    }
}

/*
─────────────────────────────────────────────────────────────────────────────
Domain DTO
─────────────────────────────────────────────────────────────────────────────
*/

namespace TempoScribePro.Blog.Core.Domain.Analytics
{
    /// <summary>
    /// Immutable snapshot of an author's productivity within a specified <see cref="DateRange"/>.
    /// </summary>
    public sealed record AuthorProductivityReport(
        Guid AuthorId,
        DateRange Range,
        int TotalPosts,
        int PublishedPosts,
        int TotalWords,
        int TotalWorkSessions,
        int TotalSessionMinutes,
        double AveragePostsPerSession,
        double WordsPerMinute,
        double AverageSessionLengthMinutes)
    {
        public static AuthorProductivityReport Empty(Guid authorId, DateRange range) =>
            new(authorId, range, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
```