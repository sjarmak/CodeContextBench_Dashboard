```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Application.Monetization
{
    /// <summary>
    /// Immutable result returned when asking if a user can access premium content.
    /// </summary>
    public sealed record AccessDecision(
        bool HasAccess,
        string? RedirectUrl = null,
        string? FailureReason = null)
    {
        public static AccessDecision Allowed() => new(true);
        public static AccessDecision Denied(string redirectUrl, string reason) => new(false, redirectUrl, reason);
    }

    #region Contract Ports (typically reside in separate assemblies)
    
    /// <summary>
    /// Persists and retrieves Post aggregates.
    /// </summary>
    public interface IPostRepository
    {
        /// <summary>
        /// Fetches lightweight projection of a post, sufficient for access checks.
        /// </summary>
        Task<PostAccessMetadata?> GetAccessMetadataAsync(Guid postId, CancellationToken ct = default);
    }

    /// <summary>
    /// Outbound port for payment gateway (e.g., Stripe) calls.
    /// </summary>
    public interface IPaymentGateway
    {
        /// <summary>
        /// Returns whether the user currently has a valid subscription.
        /// </summary>
        Task<bool> HasActiveSubscriptionAsync(Guid userId, CancellationToken ct = default);

        /// <summary>
        /// Returns whether the user has purchased a one-off license for the given post.
        /// </summary>
        Task<bool> HasSinglePostPurchaseAsync(Guid userId, Guid postId, CancellationToken ct = default);

        /// <summary>
        /// Generates a checkout URL that, once completed, will grant the requested content.
        /// </summary>
        Task<string> CreateCheckoutUrlAsync(CheckoutRequest request, CancellationToken ct = default);
    }

    /// <summary>
    /// Storage-agnostic cache abstraction following the <c>IMemoryCache</c> semantics.
    /// </summary>
    public interface IAccessCache
    {
        bool TryGet(Guid postId, Guid userId, out bool hasAccess);
        void Set(Guid postId, Guid userId, bool hasAccess, TimeSpan ttl);
        void Invalidate(Guid postId, Guid userId);
    }

    #endregion

    /// <summary>
    /// Application service responsible for guarding premium-gated content.
    /// </summary>
    public sealed class PremiumContentAccessService
    {
        private static readonly TimeSpan DefaultCacheTtl = TimeSpan.FromMinutes(10);

        private readonly IPostRepository _posts;
        private readonly IPaymentGateway _payments;
        private readonly IAccessCache _cache;
        private readonly ILogger<PremiumContentAccessService> _logger;

        public PremiumContentAccessService(
            IPostRepository posts,
            IPaymentGateway payments,
            IAccessCache cache,
            ILogger<PremiumContentAccessService> logger)
        {
            _posts   = posts  ?? throw new ArgumentNullException(nameof(posts));
            _payments = payments ?? throw new ArgumentNullException(nameof(payments));
            _cache   = cache  ?? throw new ArgumentNullException(nameof(cache));
            _logger  = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Determines whether the supplied user may view the requested post.  
        /// A checkout URL is returned when the user does not have access.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// Thrown when post lookup fails because the identifier does not exist.
        /// </exception>
        public async Task<AccessDecision> CanAccessAsync(
            Guid postId,
            Guid userId,
            CancellationToken ct = default)
        {
            if (postId == Guid.Empty) throw new ArgumentException("postId cannot be empty", nameof(postId));
            if (userId == Guid.Empty) throw new ArgumentException("userId cannot be empty", nameof(userId));

            // 1. Lightweight in-memory cache for micro-latency
            if (_cache.TryGet(postId, userId, out var hasAccess))
            {
                _logger.LogTrace("Access cache hit for Post:{Post} User:{User} => {Allowed}", postId, userId, hasAccess);
                return hasAccess ? AccessDecision.Allowed() : await BuildDeniedDecisionAsync(postId, userId, ct);
            }

            // 2. Pull required post metadata
            var meta = await _posts.GetAccessMetadataAsync(postId, ct);
            if (meta is null)
            {
                _logger.LogWarning("Post not found when checking access. PostId:{PostId}", postId);
                throw new InvalidOperationException($"Post with id {postId} was not found.");
            }

            // Free content short-circuit
            if (!meta.IsPremium)
            {
                _cache.Set(postId, userId, true, DefaultCacheTtl);
                return AccessDecision.Allowed();
            }

            // 3. Evaluate monetization rules
            hasAccess = await EvaluatePaymentStatusAsync(meta, userId, ct);

            // 4. Cache decision regardless of outcome
            _cache.Set(postId, userId, hasAccess, DefaultCacheTtl);

            if (hasAccess)
            {
                return AccessDecision.Allowed();
            }

            return await BuildDeniedDecisionAsync(postId, userId, ct);
        }

        private async Task<bool> EvaluatePaymentStatusAsync(PostAccessMetadata meta, Guid userId, CancellationToken ct)
        {
            // Paid subscription grants global access
            if (await _payments.HasActiveSubscriptionAsync(userId, ct))
            {
                _logger.LogDebug("User:{User} has global subscription; access granted to Post:{Post}", userId, meta.PostId);
                return true;
            }

            // One-off purchase for this post is considered next
            if (await _payments.HasSinglePostPurchaseAsync(userId, meta.PostId, ct))
            {
                _logger.LogDebug("User:{User} bought individual access; access granted to Post:{Post}", userId, meta.PostId);
                return true;
            }

            // Future rule hooks (coupons, bundles, trials, etc.) could fit here

            _logger.LogInformation("User:{User} lacks monetization rights for Post:{Post}", userId, meta.PostId);
            return false;
        }

        private async Task<AccessDecision> BuildDeniedDecisionAsync(Guid postId, Guid userId, CancellationToken ct)
        {
            // Pre-generate a checkout session for smoother UX
            var checkoutUrl = await _payments.CreateCheckoutUrlAsync(
                new CheckoutRequest(userId, postId, PurchaseKind.SinglePost),
                ct);

            const string reason = "premium-content-locked";
            return AccessDecision.Denied(checkoutUrl, reason);
        }
    }

    #region Supporting DTOs

    /// <summary>
    /// Data required for running an access check. 
    /// Represents a projection rather than the full Post entity.
    /// </summary>
    public sealed class PostAccessMetadata
    {
        public Guid PostId { get; init; }
        public bool IsPremium { get; init; }

        public PostAccessMetadata(Guid postId, bool isPremium)
        {
            PostId   = postId;
            IsPremium = isPremium;
        }
    }

    /// <summary>
    /// Outbound payment request encapsulation; intentionally mutable for serialization convenience.
    /// </summary>
    public sealed class CheckoutRequest
    {
        public Guid UserId { get; }
        public Guid PostId { get; }
        public PurchaseKind Kind { get; }

        public CheckoutRequest(Guid userId, Guid postId, PurchaseKind kind)
        {
            UserId = userId;
            PostId = postId;
            Kind   = kind;
        }
    }

    public enum PurchaseKind
    {
        SinglePost = 1,
        Subscription = 2
    }

    #endregion

    #region Infrastructure Helpers (for reference; real implementations live elsewhere)

    /// <summary>
    /// Simple memory-backed cache implementation used by default adapters.
    /// </summary>
    public sealed class MemoryAccessCache : IAccessCache
    {
        private readonly IMemoryCache _memory;

        public MemoryAccessCache(IMemoryCache memory) => _memory = memory;

        private static string Key(Guid postId, Guid userId) => $"access:{postId:N}:{userId:N}";

        public bool TryGet(Guid postId, Guid userId, out bool hasAccess)
        {
            return _memory.TryGetValue(Key(postId, userId), out hasAccess);
        }

        public void Set(Guid postId, Guid userId, bool hasAccess, TimeSpan ttl)
        {
            _memory.Set(Key(postId, userId), hasAccess, ttl);
        }

        public void Invalidate(Guid postId, Guid userId)
        {
            _memory.Remove(Key(postId, userId));
        }
    }

    #endregion
}
```