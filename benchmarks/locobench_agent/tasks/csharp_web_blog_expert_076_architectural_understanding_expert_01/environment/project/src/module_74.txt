```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Preview
{
    #region Contracts (Ports)

    /// <summary>
    /// Port for generating live preview diffs of blog post content.
    /// </summary>
    public interface ILivePreviewService
    {
        /// <summary>
        /// Generates a diff between <paramref name="originalContent"/> and <paramref name="updatedContent"/>.
        /// Results are cached to prevent redundant computation while an editor is actively working.
        /// </summary>
        /// <param name="postId">The unique identifier of the post being edited.</param>
        /// <param name="originalContent">Content currently persisted in the database.</param>
        /// <param name="updatedContent">Content in the editor textarea.</param>
        /// <param name="cancellationToken">Cancellation token used to abort the task.</param>
        /// <returns>
        /// A <see cref="DiffResult"/> describing changes line-by-line.
        /// </returns>
        Task<DiffResult> GeneratePreviewAsync(
            string postId,
            string originalContent,
            string updatedContent,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Port for a diff generator strategy.  Multiple implementations—character level,
    /// semantic word level, etc.—can be plugged in without touching the core service.
    /// </summary>
    public interface IDiffGenerator
    {
        DiffResult Generate(string original, string updated);
    }

    /// <summary>
    /// Port abstracting the cache adapter used for diff storage.
    /// </summary>
    public interface IPreviewCache
    {
        Task<DiffResult?> TryGetAsync(string cacheKey, CancellationToken token = default);

        Task SetAsync(string cacheKey, DiffResult diff, TimeSpan slidingExpiration, CancellationToken token = default);
    }

    #endregion

    #region Domain Models

    /// <summary>
    /// Represents one segment in a diff result.
    /// </summary>
    public sealed record DiffSegment(DiffOperation Operation, string Text);

    /// <summary>
    /// Aggregates the segments of a diff computation.
    /// </summary>
    public sealed class DiffResult
    {
        public IReadOnlyCollection<DiffSegment> Segments { get; }

        public DiffResult(IEnumerable<DiffSegment> segments)
        {
            Segments = segments.ToArray();
        }
    }

    /// <summary>
    /// Enumerates possible diff operations.
    /// </summary>
    public enum DiffOperation
    {
        Equal,
        Insert,
        Delete
    }

    #endregion

    #region Service Implementation (Use-Case)

    /// <summary>
    /// Application service (Use-Case) orchestrating diff generation
    /// and distributed caching for the live preview feature.
    /// </summary>
    public sealed class LivePreviewService : ILivePreviewService
    {
        private readonly IDiffGenerator _diffGenerator;
        private readonly IPreviewCache _cache;
        private readonly ILogger<LivePreviewService> _logger;

        public LivePreviewService(
            IDiffGenerator diffGenerator,
            IPreviewCache cache,
            ILogger<LivePreviewService> logger)
        {
            _diffGenerator = diffGenerator ?? throw new ArgumentNullException(nameof(diffGenerator));
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<DiffResult> GeneratePreviewAsync(
            string postId,
            string originalContent,
            string updatedContent,
            CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrWhiteSpace(postId))
                throw new ArgumentException("Post Id cannot be null or whitespace.", nameof(postId));

            // Hash is deterministic for the same version of the document pair
            var cacheKey = BuildCacheKey(postId, originalContent, updatedContent);

            try
            {
                _logger.LogDebug("Attempting to retrieve diff from cache. Key={CacheKey}", cacheKey);
                var cachedDiff = await _cache.TryGetAsync(cacheKey, cancellationToken);
                if (cachedDiff is not null)
                {
                    _logger.LogDebug("Cache hit for diff key {CacheKey}.", cacheKey);
                    return cachedDiff;
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed reading diff from cache. Falling back to fresh generation.");
            }

            _logger.LogDebug("Computing diff for post {PostId}.", postId);
            var diff = _diffGenerator.Generate(originalContent, updatedContent);

            try
            {
                _ = _cache.SetAsync(cacheKey, diff, TimeSpan.FromMinutes(5), cancellationToken)
                          .ContinueWith(task =>
                          {
                              if (task.IsFaulted)
                                  _logger.LogWarning(task.Exception, "Unable to store diff in cache.");
                          }, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Unexpected exception when initiating cache save.");
            }

            return diff;
        }

        private static string BuildCacheKey(
            string postId,
            string originalContent,
            string updatedContent)
        {
            // Using SHA256 to avoid unwieldy cache keys and ensure uniqueness
            static string ComputeHash(string input)
            {
                using var sha = SHA256.Create();
                var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input));
                return Convert.ToHexString(bytes);
            }

            var originalHash = ComputeHash(originalContent);
            var updatedHash = ComputeHash(updatedContent);

            return $"preview:{postId}:{originalHash}:{updatedHash}";
        }
    }

    #endregion

    #region Default In-Memory Diff Algorithm (Adapter)

    /// <summary>
    /// A simple, line-level diff implementation using Myers' algorithm
    /// with O((N+M)D) complexity where N and M are line counts.
    /// Good trade-off for real-time previews up to a few thousand lines.
    /// </summary>
    public sealed class MyersLineDiffGenerator : IDiffGenerator
    {
        public DiffResult Generate(string original, string updated)
        {
            var originalLines = SplitLines(original);
            var updatedLines = SplitLines(updated);
            var segments = CalculateDiff(originalLines, updatedLines)
                           .Select(tuple => new DiffSegment(tuple.Operation, tuple.Text));

            return new DiffResult(segments);
        }

        private static string[] SplitLines(string text) =>
            text.Replace("\r\n", "\n").Split('\n');

        private static IEnumerable<(DiffOperation Operation, string Text)> CalculateDiff(
            IReadOnlyList<string> a,
            IReadOnlyList<string> b)
        {
            // Myers diff algorithm (simplified) for arrays of strings.
            int n = a.Count;
            int m = b.Count;
            int max = n + m;
            var v = new Dictionary<int, int> { [1] = 0 };

            var trace = new List<Dictionary<int, int>>();

            for (int d = 0; d <= max; d++)
            {
                var current = new Dictionary<int, int>();
                for (int k = -d; k <= d; k += 2)
                {
                    int x;
                    if (k == -d || (k != d && v[k - 1] < v[k + 1]))
                    {
                        x = v[k + 1]; // down
                    }
                    else
                    {
                        x = v[k - 1] + 1; // right
                    }

                    int y = x - k;
                    while (x < n && y < m && a[x] == b[y])
                    {
                        x++;
                        y++;
                    }

                    current[k] = x;
                    if (x >= n && y >= m)
                    {
                        trace.Add(current);
                        return BuildPath(trace, a, b);
                    }
                }
                trace.Add(current);
                v = current;
            }

            static IEnumerable<(DiffOperation, string)> BuildPath(
                List<Dictionary<int, int>> trace,
                IReadOnlyList<string> aList,
                IReadOnlyList<string> bList)
            {
                var result = new List<(DiffOperation, string)>();

                int x = aList.Count;
                int y = bList.Count;

                for (int d = trace.Count - 1; d >= 0; d--)
                {
                    var v = trace[d];
                    int k = x - y;
                    int prevK;
                    int prevX;

                    if (k == -d || (k != d && v.GetValueOrDefault(k - 1) < v.GetValueOrDefault(k + 1)))
                    {
                        prevK = k + 1;
                        prevX = v[prevK];
                        var prevY = prevX - prevK;
                        // Down (insert)
                        result.Add((DiffOperation.Insert, bList[prevY]));
                    }
                    else
                    {
                        prevK = k - 1;
                        prevX = v[prevK] + 1;
                        var prevY = prevX - prevK;
                        // Right (delete)
                        result.Add((DiffOperation.Delete, aList[prevX - 1]));
                    }

                    x = prevX;
                    y = x - prevK;

                    while (x > 0 && y > 0 && aList[x - 1] == bList[y - 1])
                    {
                        x--;
                        y--;
                        result.Add((DiffOperation.Equal, aList[x]));
                    }
                }

                result.Reverse();
                return result;
            }

            // The algorithm above guarantees completion,
            // but .NET analyzer requires a return here.
            throw new InvalidOperationException("Unreachable code reached in diff algorithm.");
        }
    }

    #endregion

    #region Redis Adapter (Infrastructure)

    /// <summary>
    /// Redis-backed implementation of <see cref="IPreviewCache"/> using <see cref="IDistributedCache"/>.
    /// Registers as a singleton adapter in the IoC container.
    /// </summary>
    public sealed class RedisPreviewCache : IPreviewCache
    {
        private static readonly JsonSerializerOptions SerializerOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = false
        };

        private readonly IDistributedCache _cache;
        private readonly ILogger<RedisPreviewCache> _logger;

        public RedisPreviewCache(
            IDistributedCache cache,
            ILogger<RedisPreviewCache> logger)
        {
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<DiffResult?> TryGetAsync(string cacheKey, CancellationToken token = default)
        {
            var payload = await _cache.GetAsync(cacheKey, token);
            if (payload is null)
                return null;

            try
            {
                var segments = JsonSerializer.Deserialize<IReadOnlyCollection<DiffSegment>>(payload, SerializerOptions);
                return segments is null ? null : new DiffResult(segments);
            }
            catch (JsonException ex)
            {
                _logger.LogWarning(ex, "Failed to deserialize DiffResult for key {CacheKey}. Purging entry.", cacheKey);
                await _cache.RemoveAsync(cacheKey, token);
                return null;
            }
        }

        public async Task SetAsync(
            string cacheKey,
            DiffResult diff,
            TimeSpan slidingExpiration,
            CancellationToken token = default)
        {
            var payload = JsonSerializer.SerializeToUtf8Bytes(diff.Segments, SerializerOptions);
            var options = new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(2),
                SlidingExpiration = slidingExpiration
            };

            await _cache.SetAsync(cacheKey, payload, options, token);
        }
    }

    #endregion
}
```