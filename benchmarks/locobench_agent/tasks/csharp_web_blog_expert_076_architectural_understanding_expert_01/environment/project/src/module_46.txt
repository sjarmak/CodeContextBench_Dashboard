```csharp
// -----------------------------------------------------------------------------
// File:        src/module_46.txt   (original logical name – remains .cs in build)
// Project:     TempoScribe Pro – Hexagonal Productivity Blog Suite
// Purpose:     Implements the core service that automatically publishes all
//              due/scheduled posts.  This lives inside the “core” (domain)
//              project and communicates exclusively through ports.
// -----------------------------------------------------------------------------

#nullable enable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using TempoScribePro.Domain.Caching;
using TempoScribePro.Domain.Events;
using TempoScribePro.Domain.Monetization;
using TempoScribePro.Domain.Posts;
using TempoScribePro.Domain.SharedKernel;
using TempoScribePro.Domain.Time;

namespace TempoScribePro.Domain.Publishing
{
    /// <summary>
    /// Domain-level service responsible for materialising scheduled publications.
    /// 
    ///   • Pulls all <see cref="Post"/> entities that are scheduled and due.
    ///   • Evaluates monetisation rules to determine gating strategy.
    ///   • Transitions valid posts to “Published”.
    ///   • Persists changes, invalidates cache, and emits domain events.
    /// </summary>
    public sealed class PublicationAutomationService : IPublicationAutomationService
    {
        private readonly IPostRepository _postRepository;
        private readonly IMonetizationRuleEvaluator _ruleEvaluator;
        private readonly IContentCache _contentCache;
        private readonly IEventBus _eventBus;
        private readonly IDateTimeProvider _clock;
        private readonly ILogger<PublicationAutomationService> _logger;

        public PublicationAutomationService(
            IPostRepository postRepository,
            IMonetizationRuleEvaluator ruleEvaluator,
            IContentCache contentCache,
            IEventBus eventBus,
            IDateTimeProvider clock,
            ILogger<PublicationAutomationService> logger)
        {
            _postRepository = postRepository ?? throw new ArgumentNullException(nameof(postRepository));
            _ruleEvaluator  = ruleEvaluator  ?? throw new ArgumentNullException(nameof(ruleEvaluator));
            _contentCache   = contentCache   ?? throw new ArgumentNullException(nameof(contentCache));
            _eventBus       = eventBus       ?? throw new ArgumentNullException(nameof(eventBus));
            _clock          = clock          ?? throw new ArgumentNullException(nameof(clock));
            _logger         = logger         ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task<PublicationAutomationResult> ProcessScheduledPublicationsAsync(
            int batchSize                = 50,
            CancellationToken cancellationToken = default)
        {
            var nowUtc       = _clock.UtcNow;
            var publishedIds = new List<Guid>();
            var erroredIds   = new List<Guid>();

            _logger.LogInformation("Starting scheduled publication process at {Time}. Batch size: {BatchSize}", nowUtc, batchSize);

            while (!cancellationToken.IsCancellationRequested)
            {
                // Pull the next chunk of due posts
                IReadOnlyList<Post> duePosts;
                try
                {
                    duePosts = await _postRepository
                        .FetchDueScheduledAsync(nowUtc, batchSize, cancellationToken)
                        .ConfigureAwait(false);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to fetch scheduled posts.");
                    throw; // escalate; something is fundamentally wrong
                }

                if (duePosts.Count == 0)
                {
                    _logger.LogDebug("No further posts due for publication at {Time}.", nowUtc);
                    break;
                }

                foreach (var post in duePosts)
                {
                    if (cancellationToken.IsCancellationRequested)
                    {
                        _logger.LogWarning("Cancellation requested—halting publication loop.");
                        break;
                    }

                    try
                    {
                        PublishPost(post, nowUtc);
                        await _postRepository.SaveAsync(post, cancellationToken).ConfigureAwait(false);

                        // Side-effects are intentionally after persistence
                        await _contentCache.InvalidatePostAsync(post.Id).ConfigureAwait(false);
                        await _eventBus.PublishAsync(new PostPublishedEvent(post.Id, post.PublishedAt!.Value))
                                        .ConfigureAwait(false);

                        publishedIds.Add(post.Id);
                        _logger.LogInformation("Published Post {PostId} – “{Slug}”.", post.Id, post.Slug);
                    }
                    catch (DomainException dex)
                    {
                        // Domain exception = business rule violation
                        erroredIds.Add(post.Id);
                        _logger.LogWarning(dex, "Domain rule failed while publishing Post {PostId}.", post.Id);

                        await MarkPostErroredAsync(post, dex, cancellationToken).ConfigureAwait(false);
                    }
                    catch (Exception uex)
                    {
                        // Unexpected, so propagate after logging
                        _logger.LogError(uex, "Unexpected error while publishing Post {PostId}.", post.Id);
                        throw;
                    }
                }
            }

            var result = new PublicationAutomationResult(
                PublishedIds : publishedIds,
                ErroredIds   : erroredIds);

            _logger.LogInformation("Scheduled publication cycle complete. {Published} published; {Errored} errored.",
                result.PublishedIds.Count, result.ErroredIds.Count);

            return result;
        }

        // -------------------------------------------------
        // Internal helpers
        // -------------------------------------------------

        private void PublishPost(Post post, DateTimeOffset timestampUtc)
        {
            // Evaluate monetisation state before publishing
            MonetizationDecision decision = _ruleEvaluator.Decide(post);

            switch (decision)
            {
                case MonetizationDecision.Free:
                    post.Publish(timestampUtc, isPaywalled: false);
                    break;

                case MonetizationDecision.Paywall:
                    post.Publish(timestampUtc, isPaywalled: true);
                    break;

                case MonetizationDecision.Decline:
                    throw new DomainException($"Post {post.Id} cannot be published due to monetization rules.");
                
                default:
                    throw new ArgumentOutOfRangeException(nameof(decision), decision, null);
            }
        }

        private async Task MarkPostErroredAsync(Post post, DomainException cause, CancellationToken ct)
        {
            post.MarkPublicationError(cause.Message);
            await _postRepository.SaveAsync(post, ct).ConfigureAwait(false);
            await _eventBus.PublishAsync(new PostPublicationFailedEvent(post.Id, cause.Message)).ConfigureAwait(false);
        }
    }

    // -------------------------------------------------------------------------
    // Value objects / DTOs
    // -------------------------------------------------------------------------

    /// <summary>
    /// Return information for a publication cycle.
    /// </summary>
    public sealed record PublicationAutomationResult(
        IReadOnlyList<Guid> PublishedIds,
        IReadOnlyList<Guid> ErroredIds);

    // -------------------------------------------------------------------------
    // Ports (Domain Interfaces) – these are likely defined elsewhere in the
    // solution but provided here as partials to maintain standalone integrity.
    // -------------------------------------------------------------------------

    public interface IPublicationAutomationService
    {
        /// <summary>
        /// Applies all publication rules to scheduled posts that are due and
        /// transitions them to <c>Published</c>.
        /// </summary>
        /// <param name="batchSize">How many posts to process per database read.</param>
        /// <returns>Aggregate result of the publication cycle.</returns>
        Task<PublicationAutomationResult> ProcessScheduledPublicationsAsync(
            int batchSize = 50,
            CancellationToken cancellationToken = default);
    }

    // --------------------------------- Other ports ---------------------------------

    public interface IPostRepository
    {
        Task<IReadOnlyList<Post>> FetchDueScheduledAsync(
            DateTimeOffset currentUtc,
            int            take,
            CancellationToken ct = default);

        Task SaveAsync(Post post, CancellationToken ct = default);
    }

    public interface IMonetizationRuleEvaluator
    {
        MonetizationDecision Decide(Post post);
    }

    public interface IContentCache
    {
        Task InvalidatePostAsync(Guid postId, CancellationToken ct = default);
    }

    public interface IEventBus
    {
        Task PublishAsync<TEvent>(TEvent domainEvent, CancellationToken ct = default)
            where TEvent : IDomainEvent;
    }

    // -------------------------------------------------------------------------
    // Domain Entities & Supporting Types (simplified placeholders)
    // -------------------------------------------------------------------------

    // Post – highly simplified; real implementation lives elsewhere
    public sealed class Post
    {
        public Guid Id { get; init; }
        public string Slug { get; private set; } = string.Empty;
        public PostStatus Status { get; private set; }
        public DateTimeOffset? ScheduledAt { get; init; }
        public DateTimeOffset? PublishedAt { get; private set; }
        public bool IsPaywalled { get; private set; }
        public string? ErrorReason { get; private set; }

        public void Publish(DateTimeOffset timestampUtc, bool isPaywalled)
        {
            if (Status == PostStatus.Published)
                throw new DomainException("Post is already published.");

            Status       = PostStatus.Published;
            PublishedAt  = timestampUtc;
            IsPaywalled  = isPaywalled;
            ErrorReason  = null;
        }

        public void MarkPublicationError(string reason)
        {
            Status      = PostStatus.PublicationError;
            ErrorReason = reason;
        }
    }

    public enum PostStatus
    {
        Draft            = 0,
        Scheduled        = 1,
        Published        = 2,
        PublicationError = 3
    }

    // -------------------------------- Events ----------------------------------

    public interface IDomainEvent { }

    public record PostPublishedEvent(Guid PostId, DateTimeOffset PublishedAt) : IDomainEvent;

    public record PostPublicationFailedEvent(Guid PostId, string Reason) : IDomainEvent;

    // ------------------------------ Monetization ------------------------------

    public enum MonetizationDecision
    {
        Free      = 0,
        Paywall   = 1,
        Decline   = 2
    }

    // --------------------------- Shared Kernel --------------------------------

    public interface IDateTimeProvider
    {
        DateTimeOffset UtcNow { get; }
    }

    public class DomainException : Exception
    {
        public DomainException(string message) : base(message) { }
        public DomainException(string message, Exception inner) : base(message, inner) { }
    }
}
```