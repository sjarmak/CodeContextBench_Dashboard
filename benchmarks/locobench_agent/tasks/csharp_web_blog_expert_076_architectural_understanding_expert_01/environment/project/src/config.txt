```csharp
// src/config.txt
//
// NOTE: Despite the .txt extension, this file intentionally contains
// C# source code.  It ships as a runtime-loaded “configuration adapter”
// that bootstraps strongly-typed options and feature flags for the entire
// TempoScribe Pro blogging suite.
//
// The class exposes a single public API:
//
//     Config.Initialize(IHostEnvironment? hostEnv = null);
//     var flags   = Config.Current.FeatureFlags;
//     var payOpts = Config.Current.PaymentProcessing;
//
// The implementation follows the Microsoft.Extensions.Configuration
// conventions so that *any* adapter (JSON, YAML, Azure App Config, etc.)
// can be injected without touching the domain.  It also performs thorough
// validation and logs helpful diagnostics at startup.

#pragma warning disable CS1591 // (Documentation is provided in XML comments)
#pragma warning disable CA1810 // (Static constructors are used intentionally)

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Infrastructure.Configuration
{
    /// <summary>
    /// Static façade responsible for building and exposing an immutable,
    /// strongly-typed configuration object graph at runtime.
    ///
    /// In production the config hierarchy is, by default:
    ///   1. Embedded defaults             (hard-coded below)
    ///   2. appsettings.json              (repo-root or content-root)
    ///   3. appsettings.{ENV}.json        (optional, overrides #2)
    ///   4. Environment variables         (overrides everything)
    ///   5. Command-line args             (optional, overrides everything)
    ///
    /// Consumers NEVER manipulate <see cref="IConfiguration"/> directly—
    /// they request the individual option objects exposed on
    /// <see cref="Config.Current"/>.
    /// </summary>
    public static class Config
    {
        #region Public API

        /// <summary>
        /// Thread-safe singleton anchor containing all validated options.
        /// Call <see cref="Initialize"/> during program start-up (Program.cs /
        /// Startup.cs) and the property becomes available for the rest of the
        /// process lifetime.
        /// </summary>
        public static Options Current =>
            _instance ?? throw new InvalidOperationException(
                "Config.Initialize must be called once before accessing options.");

        /// <summary>
        /// Bootstraps the configuration system exactly once.  Subsequent calls
        /// are ignored.
        /// </summary>
        /// <param name="hostEnv">
        /// Optional IHostEnvironment so we can discover ContentRootPath and
        /// EnvironmentName when hosted inside ASP.NET Core / Worker Services.
        /// </param>
        /// <param name="args">
        /// Optional command-line arguments, typically forwarded from Program.cs.
        /// </param>
        public static void Initialize(
            IHostEnvironment? hostEnv = null,
            string[]?         args    = null)
        {
            if (_instance is not null) return; // Already initialized (idempotent).

            lock (_syncRoot)
            {
                if (_instance is not null) return;

                // 1. Build IConfiguration.
                var configuration = BuildConfiguration(hostEnv, args);

                // 2. Map to strongly-typed options + validate.
                _instance = BindOptions(configuration);

                // 3. Emit diagnostics (non-fatal).
                LogDiagnostics(_instance);

                // Expose IConfiguration for rare adapter scenarios.
                _configuration = configuration;
            }
        }

        /// <summary>
        /// Returns the raw <see cref="IConfiguration"/> instance behind
        /// <see cref="Config"/> (read-only).  Use sparingly; prefer the typed
        /// option properties where possible.
        /// </summary>
        public static IConfiguration AsIConfiguration()
        {
            return _configuration ??
                   throw new InvalidOperationException(
                       "Call Config.Initialize before requesting IConfiguration.");
        }

        #endregion

        #region Option Objects

        /// <summary>
        /// Immutable aggregate of all top-level option objects.
        /// </summary>
        public sealed record Options(
            FeatureFlagsOptions       FeatureFlags,
            PaymentProcessingOptions  PaymentProcessing,
            CacheOptions              Cache,
            LoggingOptions            Logging,
            AdminPanelOptions         AdminPanel);

        public sealed record FeatureFlagsOptions
        {
            public bool EnablePaymentProcessing { get; init; } = true;
            public bool EnableCaching           { get; init; } = true;
            public bool EnableResponsiveDesign  { get; init; } = true;
            public bool EnableAdminPanel        { get; init; } = true;
            public bool EnableAnalytics         { get; init; } = true;
        }

        public sealed record PaymentProcessingOptions
        {
            [Required] public string  Provider        { get; init; } = "Stripe";
            [Required] public string  ApiKey          { get; init; } = string.Empty;
            [Required] public string  WebHookSecret   { get; init; } = string.Empty;
            public bool               UseSandbox      { get; init; } = false;
            public decimal            DefaultPriceUSD { get; init; } = 4.99m;
        }

        public sealed record CacheOptions
        {
            public bool     Enabled         { get; init; } = true;
            public TimeSpan DefaultTtl      { get; init; } = TimeSpan.FromMinutes(15);
            public string   Provider        { get; init; } = "Redis";
            public string   Connection      { get; init; } = "localhost:6379";
        }

        public sealed record LoggingOptions
        {
            public string MinimumLevel { get; init; } = "Information";
            public string Output       { get; init; } = "Console"; // Or "Seq", "Elastic", etc.
        }

        public sealed record AdminPanelOptions
        {
            public bool  Enabled           { get; init; } = true;
            public int   SessionTimeoutMin { get; init; } = 25;
            public IList<string> SuperAdmins { get; init; } = new List<string>();
        }

        #endregion

        #region Implementation Details

        private static volatile Options?       _instance;
        private static volatile IConfiguration? _configuration;
        private static readonly object          _syncRoot = new();

        private const string FeatureFlagsSection      = "FeatureFlags";
        private const string PaymentProcessingSection = "PaymentProcessing";
        private const string CacheSection             = "Cache";
        private const string LoggingSection           = "Logging";
        private const string AdminPanelSection        = "AdminPanel";

        private static IConfiguration BuildConfiguration(
            IHostEnvironment? hostEnv,
            string[]?         args)
        {
            var envName   = hostEnv?.EnvironmentName ??
                            Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ??
                            "Production";

            var basePath  = hostEnv?.ContentRootPath ??
                            Directory.GetCurrentDirectory();

            var cb = new ConfigurationBuilder()
                     .SetBasePath(basePath)
                     .AddJsonFile("appsettings.json", optional: true,  reloadOnChange: true)
                     .AddJsonFile($"appsettings.{envName}.json",
                                   optional: true, reloadOnChange: true)
                     .AddEnvironmentVariables();

            if (args is { Length: > 0 })
                cb.AddCommandLine(args);

            return cb.Build();
        }

        private static Options BindOptions(IConfiguration config)
        {
            static T BindAndValidate<T>(IConfiguration cfg, string sectionName)
                where T : new()
            {
                var inst = new T();
                cfg.GetSection(sectionName).Bind(inst);

                var ctx = new ValidationContext(inst);
                Validator.ValidateObject(inst, ctx, validateAllProperties: true);
                return inst;
            }

            return new Options(
                FeatureFlags      : BindAndValidate<FeatureFlagsOptions>(config, FeatureFlagsSection),
                PaymentProcessing : BindAndValidate<PaymentProcessingOptions>(config, PaymentProcessingSection),
                Cache             : BindAndValidate<CacheOptions>(config, CacheSection),
                Logging           : BindAndValidate<LoggingOptions>(config, LoggingSection),
                AdminPanel        : BindAndValidate<AdminPanelOptions>(config, AdminPanelSection));
        }

        private static void LogDiagnostics(Options options)
        {
            try
            {
                var loggerFactory = LoggerFactory.Create(builder =>
                {
                    builder.AddSimpleConsole(o =>
                    {
                        o.SingleLine  = true;
                        o.TimestampFormat = "[HH:mm:ss] ";
                    });
                });

                var log = loggerFactory.CreateLogger("Config");

                log.LogInformation("=== TempoScribe Pro Configuration ===");
                log.LogInformation(
                    "Payment Provider = {Provider} (Sandbox = {Sandbox})",
                    options.PaymentProcessing.Provider,
                    options.PaymentProcessing.UseSandbox);

                log.LogInformation("Caching  : {Enabled} (Provider = {Provider}, TTL = {Ttl})",
                    options.Cache.Enabled, options.Cache.Provider, options.Cache.DefaultTtl);

                log.LogInformation("Admin UI : {Enabled}", options.AdminPanel.Enabled);
                log.LogInformation("Feature Flags -> {Flags}",
                    string.Join(", ",
                        typeof(FeatureFlagsOptions)
                            .GetProperties()
                            .Select(p => $"{p.Name}={p.GetValue(options.FeatureFlags)}")));
            }
            catch (Exception ex)
            {
                // Diagnostics should never crash the app; swallow & trace.
                Trace.TraceError("Failed to log configuration diagnostics: {0}", ex);
            }
        }

        #endregion
    }
}
#pragma warning restore CS1591
#pragma warning restore CA1810
```