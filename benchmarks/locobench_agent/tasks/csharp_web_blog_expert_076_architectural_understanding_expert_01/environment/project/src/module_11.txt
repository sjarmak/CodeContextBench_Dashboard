```csharp
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;

namespace TempoScribePro
{
    // ------------------------------------------------------------------------
    //  DOMAIN LAYER (technology-agnostic)
    // ------------------------------------------------------------------------

    /// <summary>
    /// Represents a blog post in the TempoScribe domain model.
    /// </summary>
    public sealed class Post
    {
        public Guid Id { get; private set; }
        public string Slug { get; private set; } = default!;
        public string Title { get; private set; } = default!;
        public string Body { get; private set; } = default!;
        public PostStatus Status { get; private set; } = PostStatus.Draft;
        public DateTimeOffset? ScheduledPublishAt { get; private set; }
        public DateTimeOffset? PublishedAt { get; private set; }
        public int Version { get; private set; }

        public Post(Guid id,
                    string slug,
                    string title,
                    string body,
                    PostStatus status,
                    DateTimeOffset? scheduledPublishAt,
                    DateTimeOffset? publishedAt,
                    int version = 0)
        {
            Guard.AgainstNullOrWhiteSpace(slug);
            Guard.AgainstNullOrWhiteSpace(title);
            Guard.AgainstNullOrWhiteSpace(body);

            Id                 = id;
            Slug               = slug;
            Title              = title;
            Body               = body;
            Status             = status;
            ScheduledPublishAt = scheduledPublishAt;
            PublishedAt        = publishedAt;
            Version            = version;
        }

        /// <summary>
        /// Publishes the post, transitioning it from Draft/Scheduled to Published.
        /// </summary>
        /// <param name="now">The moment the post becomes publicly visible.</param>
        /// <exception cref="InvalidOperationException">
        /// Thrown when attempting to publish a post that is already published.
        /// </exception>
        public void Publish(DateTimeOffset now)
        {
            if (Status == PostStatus.Published)
                throw new InvalidOperationException($"Post [{Id}] is already published.");

            Status       = PostStatus.Published;
            PublishedAt  = now;
            ScheduledPublishAt = null;

            Version++;
        }

        /// <summary>
        /// Marks the post for future automatic publication.
        /// </summary>
        public void ScheduleForPublication(DateTimeOffset scheduleAt)
        {
            if (Status == PostStatus.Published)
                throw new InvalidOperationException("Cannot schedule a published post.");

            ScheduledPublishAt = scheduleAt;
            Status             = PostStatus.Scheduled;
            Version++;
        }
    }

    public enum PostStatus
    {
        Draft      = 0,
        Scheduled  = 1,
        Published  = 2,
        Archived   = 3
    }

    // ------------------------------------------------------------------------
    //  PORTS (hexagonal interface contracts)
    // ------------------------------------------------------------------------

    public interface IPostRepository
    {
        Task<IReadOnlyList<Post>> GetScheduledDraftsAsync(DateTimeOffset upTo, CancellationToken ct);
        void Update(Post post);
    }

    public interface IUnitOfWork
    {
        Task<int> SaveChangesAsync(CancellationToken ct);
    }

    public interface IEventBus
    {
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct);
    }

    public interface IDateTimeProvider
    {
        DateTimeOffset UtcNow { get; }
    }

    // ------------------------------------------------------------------------
    //  APPLICATION SERVICE LAYER
    // ------------------------------------------------------------------------

    /// <summary>
    /// Orchestrates time-based publishing of scheduled posts.
    /// </summary>
    public sealed class ScheduledPublishingOrchestrator
    {
        private readonly IPostRepository          _posts;
        private readonly IUnitOfWork              _uow;
        private readonly IEventBus                _events;
        private readonly IDistributedCache        _cache;
        private readonly IDateTimeProvider        _clock;
        private readonly ILogger<ScheduledPublishingOrchestrator> _logger;

        private const string CachePrefix          = "post:";
        private const string FeedCacheKey         = "feed:latest";

        public ScheduledPublishingOrchestrator(
            IPostRepository posts,
            IUnitOfWork uow,
            IEventBus events,
            IDistributedCache cache,
            IDateTimeProvider clock,
            ILogger<ScheduledPublishingOrchestrator> logger)
        {
            _posts   = posts  ?? throw new ArgumentNullException(nameof(posts));
            _uow     = uow    ?? throw new ArgumentNullException(nameof(uow));
            _events  = events ?? throw new ArgumentNullException(nameof(events));
            _cache   = cache  ?? throw new ArgumentNullException(nameof(cache));
            _clock   = clock  ?? throw new ArgumentNullException(nameof(clock));
            _logger  = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Publishes all posts whose scheduled publish time is in the past.
        /// </summary>
        /// <returns>Total number of posts published.</returns>
        public async Task<int> PublishDuePostsAsync(CancellationToken ct = default)
        {
            var nowUtc = _clock.UtcNow;

            _logger.LogInformation("Running scheduled publishing check at {TimeUtc}", nowUtc);

            IReadOnlyList<Post> duePosts;
            try
            {
                duePosts = await _posts.GetScheduledDraftsAsync(nowUtc, ct);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving scheduled posts.");
                throw;
            }

            if (duePosts.Count == 0)
            {
                _logger.LogDebug("No posts due for publication.");
                return 0;
            }

            var publishedCount = 0;
            foreach (var post in duePosts)
            {
                try
                {
                    post.Publish(nowUtc);
                    _posts.Update(post);
                    publishedCount++;

                    await _events.PublishAsync(new PostPublishedEvent(post.Id, nowUtc), ct)
                                 .ConfigureAwait(false);

                    await InvalidateCacheAsync(post, ct).ConfigureAwait(false);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex,
                        "Failed to publish post {PostId}. Skipping to next.", post.Id);
                    // continue publishing others
                }
            }

            try
            {
                await _uow.SaveChangesAsync(ct).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex,
                    "Failed to commit published posts. Transaction rollback executed.");
                throw;
            }

            _logger.LogInformation("Published {Count} post(s).", publishedCount);
            return publishedCount;
        }

        private async Task InvalidateCacheAsync(Post post, CancellationToken ct)
        {
            try
            {
                await _cache.RemoveAsync($"{CachePrefix}{post.Slug}", ct)
                            .ConfigureAwait(false);
                await _cache.RemoveAsync(FeedCacheKey, ct).ConfigureAwait(false);
                _logger.LogDebug("Invalidated cache entries for post {PostSlug}", post.Slug);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex,
                    "Failed to invalidate cache for post {PostSlug}. Continuing.", post.Slug);
            }
        }
    }

    // ------------------------------------------------------------------------
    //  DOMAIN EVENTS
    // ------------------------------------------------------------------------

    public sealed record PostPublishedEvent(Guid PostId, DateTimeOffset PublishedAt);

    // ------------------------------------------------------------------------
    //  CROSS-CUTTING UTILITIES
    // ------------------------------------------------------------------------

    internal static class Guard
    {
        public static void AgainstNullOrWhiteSpace(string? value,
                                                   string? parameterName = null)
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                if (parameterName is null)
                    throw new ArgumentException("Value cannot be null or whitespace.");
                throw new ArgumentException("Value cannot be null or whitespace.",
                                                parameterName);
            }
        }
    }

    // ------------------------------------------------------------------------
    //  (OPTIONAL) SIMPLE CLOCK IMPLEMENTATION FOR PRODUCTION
    // ------------------------------------------------------------------------

    /// <summary>
    /// Default production implementation of <see cref="IDateTimeProvider"/>.
    /// Swappable for tests or time-travel debugging.
    /// </summary>
    public sealed class SystemClock : IDateTimeProvider
    {
        public DateTimeOffset UtcNow => DateTimeOffset.UtcNow;
    }

    // ------------------------------------------------------------------------
    //  (OPTIONAL) JSON SERIALIZER EXTENSIONS FOR CACHING
    // ------------------------------------------------------------------------

    public static class DistributedCacheExtensions
    {
        private static readonly DistributedCacheEntryOptions DefaultOptions
            = new DistributedCacheEntryOptions
            {
                SlidingExpiration = TimeSpan.FromHours(3)
            };

        public static async Task SetObjectAsync<T>(
            this IDistributedCache cache,
            string key,
            T value,
            DistributedCacheEntryOptions? options = null,
            CancellationToken ct = default)
        {
            var json = JsonConvert.SerializeObject(value);
            await cache.SetStringAsync(key, json, options ?? DefaultOptions, ct)
                       .ConfigureAwait(false);
        }

        public static async Task<T?> GetObjectAsync<T>(
            this IDistributedCache cache,
            string key,
            CancellationToken ct = default)
        {
            var json = await cache.GetStringAsync(key, ct).ConfigureAwait(false);
            return json is null
                ? default
                : JsonConvert.DeserializeObject<T>(json);
        }
    }
}
```