```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using TempoScribePro.Core.Domain.Entities;
using TempoScribePro.Core.Domain.Exceptions;
using TempoScribePro.Core.Domain.Ports;
using TempoScribePro.Core.Domain.ValueObjects;
using TempoScribePro.Core.SharedKernel;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Core.Application.Services
{
    /// <summary>
    ///     Orchestrates the end-to-end workflow for granting a reader access to premium content.
    ///     The service is intentionally free of infrastructure technology concerns.
    ///     • Reads posts and monetization rules from repositories (ports)
    ///     • Charges the reader through an injected payment gateway (adapter)
    ///     • Caches the purchase using an injected cache provider (adapter)
    ///     • Emits domain events for downstream analytics pipelines
    /// </summary>
    public sealed class PaymentProcessingService : IPaymentProcessingService
    {
        private const string CacheKeyFormat = "premium:{0}:post:{1}";
        private readonly IPostRepository _postRepository;
        private readonly IPurchaseRepository _purchaseRepository;
        private readonly IPaymentGateway _paymentGateway;
        private readonly ICacheProvider _cache;
        private readonly IEventBus _eventBus;
        private readonly ILogger<PaymentProcessingService> _logger;

        public PaymentProcessingService(
            IPostRepository postRepository,
            IPurchaseRepository purchaseRepository,
            IPaymentGateway paymentGateway,
            ICacheProvider cache,
            IEventBus eventBus,
            ILogger<PaymentProcessingService> logger)
        {
            _postRepository    = postRepository    ?? throw new ArgumentNullException(nameof(postRepository));
            _purchaseRepository = purchaseRepository ?? throw new ArgumentNullException(nameof(purchaseRepository));
            _paymentGateway    = paymentGateway    ?? throw new ArgumentNullException(nameof(paymentGateway));
            _cache             = cache             ?? throw new ArgumentNullException(nameof(cache));
            _eventBus          = eventBus          ?? throw new ArgumentNullException(nameof(eventBus));
            _logger            = logger            ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task<PostContent> AccessPremiumContentAsync(
            UserId readerId,
            PostId postId,
            PaymentMethodToken paymentMethod,
            CancellationToken cancellationToken = default)
        {
            if (readerId == default)   throw new ArgumentException(nameof(readerId));
            if (postId   == default)   throw new ArgumentException(nameof(postId));
            if (paymentMethod == default) throw new ArgumentException(nameof(paymentMethod));

            var cacheKey = string.Format(CacheKeyFormat, readerId, postId);

            // 1. Fast-path: User already purchased this post
            var cachedContent = await _cache.GetAsync<PostContent>(cacheKey, cancellationToken);
            if (cachedContent is not null)
            {
                _logger.LogDebug("Cache hit for premium content. reader={ReaderId}, post={PostId}", readerId, postId);
                return cachedContent;
            }

            // 2. Retrieve & validate post
            var post = await _postRepository.GetByIdAsync(postId, cancellationToken)
                       ?? throw new NotFoundException($"Post with id '{postId}' was not found.");

            if (!post.IsPremium)
            {
                // Non-premium content: simply return
                _logger.LogDebug("Post {PostId} is public, bypassing payment gateway.", postId);
                return post.Content;
            }

            // 3. Determine price via monetization rules
            var price = post.MonetizationRule.EvaluatePrice(readerId);
            _logger.LogInformation("Calculated price {Price} for reader {ReaderId} on post {PostId}.", price, readerId, postId);

            // 4. Execute payment
            PaymentReceipt receipt;
            try
            {
                receipt = await _paymentGateway.ChargeAsync(
                    readerId: readerId,
                    amount: price,
                    paymentMethod: paymentMethod,
                    metadata: new { PostId = postId.Value },
                    cancellationToken: cancellationToken);
            }
            catch (PaymentDeclinedException ex)
            {
                _logger.LogWarning(ex, "Payment declined for reader {ReaderId}, post {PostId}.", readerId, postId);
                throw;  // Bubble up for controller/UI to surface a friendly message
            }

            // 5. Persist purchase record (for audit & refunds)
            var purchase = Purchase.CreateSuccessful(
                readerId,
                postId,
                receivedAtUtc: receipt.TimestampUtc,
                grossAmount: price,
                paymentGatewayTransactionId: receipt.TransactionId);

            await _purchaseRepository.AddAsync(purchase, cancellationToken);

            // 6. Cache purchased content to avoid re-billing
            await _cache.SetAsync(cacheKey, post.Content,
                                  options: CacheEntryOptions.AbsoluteExpiration(TimeSpan.FromDays(30)),
                                  cancellationToken: cancellationToken);

            // 7. Emit domain event for analytics pipeline
            var domainEvent = new PremiumContentAccessedDomainEvent(
                readerId,
                postId,
                price,
                receipt.TransactionId,
                occurredOnUtc: DateTime.UtcNow);

            await _eventBus.PublishAsync(domainEvent, cancellationToken);

            _logger.LogInformation("Reader {ReaderId} completed purchase for post {PostId}.", readerId, postId);

            return post.Content;
        }
    }

    #region Interfaces & Supporting Types (Ports) — kept minimal for compile-time completeness

    public interface IPaymentProcessingService
    {
        Task<PostContent> AccessPremiumContentAsync(
            UserId readerId,
            PostId postId,
            PaymentMethodToken paymentMethod,
            CancellationToken cancellationToken = default);
    }

    public interface IPostRepository
    {
        Task<Post?> GetByIdAsync(PostId id, CancellationToken cancellationToken = default);
    }

    public interface IPurchaseRepository
    {
        Task AddAsync(Purchase purchase, CancellationToken cancellationToken = default);
    }

    public interface ICacheProvider
    {
        Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default);
        Task SetAsync<T>(string key, T value, CacheEntryOptions options, CancellationToken cancellationToken = default);
    }

    public interface IPaymentGateway
    {
        Task<PaymentReceipt> ChargeAsync(
            UserId readerId,
            Money amount,
            PaymentMethodToken paymentMethod,
            object metadata,
            CancellationToken cancellationToken = default);
    }

    public interface IEventBus
    {
        Task PublishAsync<TDomainEvent>(TDomainEvent @event, CancellationToken cancellationToken = default)
            where TDomainEvent : IDomainEvent;
    }

    #endregion

    #region Domain: Value Objects, Entities, Events (highly simplified)

    public readonly record struct UserId(Guid Value)
    {
        public static implicit operator Guid(UserId id) => id.Value;
        public override string ToString() => Value.ToString();
    }

    public readonly record struct PostId(Guid Value)
    {
        public static implicit operator Guid(PostId id) => id.Value;
        public override string ToString() => Value.ToString();
    }

    public readonly record struct PaymentMethodToken(string Value);

    public sealed record Money(decimal Amount, string Currency = "USD")
    {
        public static Money Zero(string currency = "USD") => new(0, currency);
        public override string ToString() => $"{Currency} {Amount:N2}";
    }

    public sealed class Post
    {
        public PostId Id { get; init; } = default!;
        public bool IsPremium { get; init; }
        public MonetizationRule MonetizationRule { get; init; } = default!;
        public PostContent Content { get; init; } = default!;
    }

    public sealed class PostContent
    {
        public string Html { get; init; } = string.Empty;
        public string Markdown { get; init; } = string.Empty;
    }

    public sealed class Purchase
    {
        private Purchase() { }

        public static Purchase CreateSuccessful(
            UserId readerId,
            PostId postId,
            DateTime receivedAtUtc,
            Money grossAmount,
            string paymentGatewayTransactionId) =>
            new()
            {
                ReaderId = readerId,
                PostId = postId,
                ReceivedAtUtc = receivedAtUtc,
                GrossAmount = grossAmount,
                PaymentGatewayTransactionId = paymentGatewayTransactionId,
                IsRefunded = false
            };

        public Guid   Id { get; private set; } = Guid.NewGuid();
        public UserId ReaderId { get; private set; } = default!;
        public PostId PostId { get; private set; } = default!;
        public DateTime ReceivedAtUtc { get; private set; }
        public Money GrossAmount { get; private set; } = default!;
        public string PaymentGatewayTransactionId { get; private set; } = string.Empty;
        public bool IsRefunded { get; private set; }
    }

    public sealed class PaymentReceipt
    {
        public string TransactionId { get; init; } = string.Empty;
        public DateTime TimestampUtc { get; init; }
    }

    public sealed class MonetizationRule
    {
        private readonly decimal _price;

        public MonetizationRule(decimal price) => _price = price;

        public Money EvaluatePrice(UserId _) => new Money(_price);
    }

    public interface IDomainEvent { }

    public sealed record PremiumContentAccessedDomainEvent(
        UserId ReaderId,
        PostId PostId,
        Money AmountPaid,
        string TransactionId,
        DateTime OccurredOnUtc) : IDomainEvent;

    #endregion

    #region Exceptions

    public class NotFoundException : Exception
    {
        public NotFoundException(string message) : base(message) { }
    }

    public class PaymentDeclinedException : Exception
    {
        public PaymentDeclinedException(string message, Exception? inner = null) : base(message, inner) { }
    }

    #endregion

    #region Cache Options

    public sealed class CacheEntryOptions
    {
        public TimeSpan? AbsoluteExpirationRelativeToNow { get; private set; }

        public static CacheEntryOptions AbsoluteExpiration(TimeSpan ttl) =>
            new() { AbsoluteExpirationRelativeToNow = ttl };
    }

    #endregion
}
```