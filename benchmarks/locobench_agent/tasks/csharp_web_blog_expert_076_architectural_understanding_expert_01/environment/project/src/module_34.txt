```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Core.Application.Services
{
    /// <summary>
    /// Coordinates scheduled publishing, monetization gating, cache invalidation,
    /// and reader/staff notifications.  Acts as an application service that wires
    /// domain abstractions (ports) to infrastructure adapters.
    ///
    /// NOTE:  This file intentionally lives in the core project so that
    /// ports/interfaces remain technology-agnostic.  Adapters provide concrete
    /// implementations at runtime.
    /// </summary>
    public sealed class ScheduledPublisherService : IScheduledPublisherService
    {
        private readonly IPostRepository _postRepository;
        private readonly IClock _clock;
        private readonly IMonetizationRuleEngine _ruleEngine;
        private readonly IPaymentGateway _paymentGateway;
        private readonly ICacheInvalidator _cacheInvalidator;
        private readonly INotificationPort _notificationPort;
        private readonly ILogger<ScheduledPublisherService> _logger;

        public ScheduledPublisherService(
            IPostRepository postRepository,
            IClock clock,
            IMonetizationRuleEngine ruleEngine,
            IPaymentGateway paymentGateway,
            ICacheInvalidator cacheInvalidator,
            INotificationPort notificationPort,
            ILogger<ScheduledPublisherService> logger)
        {
            _postRepository = postRepository ?? throw new ArgumentNullException(nameof(postRepository));
            _clock = clock ?? throw new ArgumentNullException(nameof(clock));
            _ruleEngine = ruleEngine ?? throw new ArgumentNullException(nameof(ruleEngine));
            _paymentGateway = paymentGateway ?? throw new ArgumentNullException(nameof(paymentGateway));
            _cacheInvalidator = cacheInvalidator ?? throw new ArgumentNullException(nameof(cacheInvalidator));
            _notificationPort = notificationPort ?? throw new ArgumentNullException(nameof(notificationPort));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Scans for posts whose ScheduledAt <= now and publishes them in a single
        /// unit of work.  Long-running or faulted operations are logged in detail
        /// but do not prevent other posts from being processed.
        /// </summary>
        public async Task PublishDuePostsAsync(CancellationToken cancellationToken = default)
        {
            var now = _clock.UtcNow;
            IReadOnlyList<Post> duePosts;

            try
            {
                duePosts = await _postRepository.FetchScheduledAsync(now, cancellationToken)
                    .ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to fetch scheduled posts.");
                throw;
            }

            if (!duePosts.Any())
            {
                _logger.LogDebug("No posts to publish at {Now}.", now);
                return;
            }

            _logger.LogInformation("Publishing {Count} scheduled posts.", duePosts.Count);

            foreach (var post in duePosts)
            {
                try
                {
                    await PublishSinglePostAsync(post, cancellationToken).ConfigureAwait(false);
                }
                catch (OperationCanceledException)
                {
                    _logger.LogWarning("Publishing cancelled for PostId={PostId}.", post.Id);
                    throw;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex,
                        "Unhandled error while publishing PostId={PostId}. Continuing with next.",
                        post.Id);
                }
            }
        }

        private async Task PublishSinglePostAsync(Post post, CancellationToken cancellationToken)
        {
            if (post.Status != PostStatus.Scheduled)
            {
                _logger.LogDebug("Skipping PostId={PostId}: status is {Status}.", post.Id, post.Status);
                return;
            }

            // 1. Apply monetization rules (e.g., paywall, dynamic pricing tiers)
            var monetizationResult = _ruleEngine.ApplyRules(post);

            // 2. If up-front payment is required, charge the author's account
            if (monetizationResult.RequiresUpFrontPayment)
            {
                await ChargeAuthorAsync(post, monetizationResult, cancellationToken).ConfigureAwait(false);
            }

            // 3. Change post status & persist
            post.MarkAsPublished(_clock.UtcNow, monetizationResult);

            await _postRepository.SaveAsync(post, cancellationToken).ConfigureAwait(false);

            // 4. Invalidate relevant caches
            await _cacheInvalidator.InvalidatePostAsync(post.Id, cancellationToken).ConfigureAwait(false);

            // 5. Send notifications
            await _notificationPort.NotifyPublishedAsync(post, cancellationToken).ConfigureAwait(false);

            _logger.LogInformation("Post published: PostId={PostId}", post.Id);
        }

        private async Task ChargeAuthorAsync(
            Post post,
            MonetizationResult monetizationResult,
            CancellationToken cancellationToken)
        {
            var chargeRequest = new PaymentChargeRequest(
                CustomerId: post.AuthorId,
                AmountCents: monetizationResult.UpFrontAmountCents,
                Currency: monetizationResult.Currency,
                Metadata: new Dictionary<string, string>
                {
                    ["PostId"] = post.Id.ToString(),
                    ["Title"] = post.Title
                });

            var paymentResult = await _paymentGateway.ChargeAsync(chargeRequest, cancellationToken)
                .ConfigureAwait(false);

            if (!paymentResult.Successful)
            {
                _logger.LogWarning(
                    "Payment failed for PostId={PostId}. Reason={Reason}. Post will not be published.",
                    post.Id,
                    paymentResult.FailureReason);

                throw new PaymentFailedException(post.Id, paymentResult.FailureReason);
            }

            _logger.LogDebug("Payment succeeded for PostId={PostId}. ChargeId={ChargeId}",
                post.Id,
                paymentResult.ChargeId);
        }
    }

    #region Port Interfaces

    // Domain ports (technology-agnostic).
    public interface IScheduledPublisherService
    {
        Task PublishDuePostsAsync(CancellationToken cancellationToken = default);
    }

    public interface IPostRepository
    {
        Task<IReadOnlyList<Post>> FetchScheduledAsync(DateTimeOffset upTo, CancellationToken ct);
        Task SaveAsync(Post post, CancellationToken ct);
    }

    public interface IClock
    {
        DateTimeOffset UtcNow { get; }
    }

    public interface IMonetizationRuleEngine
    {
        MonetizationResult ApplyRules(Post post);
    }

    public interface IPaymentGateway
    {
        Task<PaymentResult> ChargeAsync(PaymentChargeRequest request, CancellationToken ct);
    }

    public interface ICacheInvalidator
    {
        Task InvalidatePostAsync(Guid postId, CancellationToken ct);
    }

    public interface INotificationPort
    {
        Task NotifyPublishedAsync(Post post, CancellationToken ct);
    }

    #endregion

    #region Domain Models

    // Simplified domain entities/value objects used by the service.

    public sealed class Post
    {
        public Guid Id { get; }
        public Guid AuthorId { get; }
        public string Title { get; private set; }
        public PostStatus Status { get; private set; }
        public DateTimeOffset? ScheduledAt { get; private set; }
        public MonetizationResult? MonetizationSnapshot { get; private set; }

        public Post(Guid id, Guid authorId, string title, PostStatus status, DateTimeOffset? scheduledAt)
        {
            Id = id;
            AuthorId = authorId;
            Title = title;
            Status = status;
            ScheduledAt = scheduledAt;
        }

        public void MarkAsPublished(DateTimeOffset publishedAt, MonetizationResult monetization)
        {
            if (Status == PostStatus.Published)
                throw new InvalidOperationException("Post is already published.");

            Status = PostStatus.Published;
            ScheduledAt = null;
            MonetizationSnapshot = monetization;
            DomainEvents.Raise(new PostPublishedDomainEvent(Id, publishedAt));
        }
    }

    public enum PostStatus
    {
        Draft,
        Scheduled,
        Published,
        Archived
    }

    public sealed record MonetizationResult(
        bool RequiresUpFrontPayment,
        int UpFrontAmountCents,
        string Currency);

    public sealed record PaymentChargeRequest(
        Guid CustomerId,
        int AmountCents,
        string Currency,
        IDictionary<string, string> Metadata);

    public sealed record PaymentResult(
        bool Successful,
        string? ChargeId,
        string? FailureReason);

    #endregion

    #region Exceptions & Domain Events

    public sealed class PaymentFailedException : Exception
    {
        public Guid PostId { get; }

        public PaymentFailedException(Guid postId, string reason)
            : base($"Payment failed for post {postId}: {reason}")
        {
            PostId = postId;
        }
    }

    /// <summary>
    /// Domain event raised when a post is successfully published.
    /// Infrastructure subscribers can persist analytics,
    /// trigger webhooks, etc., without polluting the core service.
    /// </summary>
    public sealed record PostPublishedDomainEvent(Guid PostId, DateTimeOffset PublishedAt);

    /// <summary>
    /// Simple domain event dispatcher.  In production, this is wired into
    /// MediatR or a custom event bus via an adapter.  Here we keep a minimal
    /// placeholder to avoid external dependencies in the core layer.
    /// </summary>
    internal static class DomainEvents
    {
        // For brevity, fire-and-forget delegate list.
        private static readonly List<Func<object, Task>> _handlers = new();

        public static void Register(Func<object, Task> handler) => _handlers.Add(handler);

        public static void Raise(object @event)
        {
            foreach (var handler in _handlers)
            {
                // Intentionally not awaitedâ€”handlers run asynchronously.
                _ = handler(@event);
            }
        }
    }

    #endregion
}
```