```csharp
// src/module_60.txt
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// ----------------------------------------------------
// This module provides an application-layer service for capturing
// one-click performance snapshots as well as a reusable, metrics-aware
// caching decorator for post repositories.
//
// The code abides by Ports & Adapters principles – every dependency
// is expressed via an interface so that a different adapter can be
// swapped in without touching the core logic.

#nullable enable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using TempoScribePro.Domain.Models;          // Domain entities (e.g., Post)
using TempoScribePro.Domain.Ports.Repositories;

namespace TempoScribePro.Application.Diagnostics
{
    /// <summary>
    /// Immutable value object containing all metrics captured
    /// during a performance snapshot.
    /// </summary>
    public sealed record PerformanceSnapshot
    {
        public DateTimeOffset CapturedAt { get; init; }
        public double CacheHitRatio { get; init; }
        public long CacheSizeBytes { get; init; }
        public TimeSpan DatabaseRoundTripTime { get; init; }
        public bool PaymentGatewayHealthy { get; init; }
        public IReadOnlyDictionary<string, string> AdditionalMeasurements { get; init; } =
            new Dictionary<string, string>();
    }

    /// <summary>
    /// Service port for taking one-click snapshots that can later be
    /// visualised in the admin panel or exported for auditing.
    /// </summary>
    public interface IPerformanceSnapshotService
    {
        Task<PerformanceSnapshot> CaptureAsync(CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Adapter-independent contract for retrieving cache statistics.
    /// </summary>
    public interface ICacheStatisticsProvider
    {
        Task<(double hitRatio, long sizeBytes)> GetStatisticsAsync(CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Adapter-independent contract for measuring DB latency.
    /// </summary>
    public interface IDatabaseHealthChecker
    {
        Task<TimeSpan> MeasureLatencyAsync(CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Adapter-independent contract for verifying payment gateway status.
    /// </summary>
    public interface IPaymentGatewayHealthChecker
    {
        Task<bool> IsHealthyAsync(CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Orchestrates multiple health check providers and packages the
    /// results into a <see cref="PerformanceSnapshot"/>.
    /// </summary>
    public sealed class PerformanceSnapshotService : IPerformanceSnapshotService
    {
        private readonly ICacheStatisticsProvider         _cacheStats;
        private readonly IDatabaseHealthChecker           _dbHealth;
        private readonly IPaymentGatewayHealthChecker     _paymentHealth;
        private readonly ILogger<PerformanceSnapshotService> _logger;

        public PerformanceSnapshotService(
            ICacheStatisticsProvider         cacheStats,
            IDatabaseHealthChecker           dbHealth,
            IPaymentGatewayHealthChecker     paymentHealth,
            ILogger<PerformanceSnapshotService> logger)
        {
            _cacheStats    = cacheStats    ?? throw new ArgumentNullException(nameof(cacheStats));
            _dbHealth      = dbHealth      ?? throw new ArgumentNullException(nameof(dbHealth));
            _paymentHealth = paymentHealth ?? throw new ArgumentNullException(nameof(paymentHealth));
            _logger        = logger        ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<PerformanceSnapshot> CaptureAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _logger.BeginScope("Capturing performance snapshot");

            try
            {
                _logger.LogInformation("Collecting cache statistics…");
                var (hitRatio, cacheSize) = await _cacheStats.GetStatisticsAsync(cancellationToken)
                                                            .ConfigureAwait(false);

                _logger.LogInformation("Measuring database latency…");
                var dbLatency = await _dbHealth.MeasureLatencyAsync(cancellationToken)
                                               .ConfigureAwait(false);

                _logger.LogInformation("Checking payment gateway health…");
                var paymentHealthy = await _paymentHealth.IsHealthyAsync(cancellationToken)
                                                         .ConfigureAwait(false);

                var snapshot = new PerformanceSnapshot
                {
                    CapturedAt              = DateTimeOffset.UtcNow,
                    CacheHitRatio           = hitRatio,
                    CacheSizeBytes          = cacheSize,
                    DatabaseRoundTripTime   = dbLatency,
                    PaymentGatewayHealthy   = paymentHealthy
                };

                _logger.LogInformation("Performance snapshot captured: {@Snapshot}", snapshot);
                return snapshot;
            }
            catch (Exception ex) when (!ex.IsFatal())
            {
                _logger.LogError(ex, "An error occurred while creating performance snapshot");
                throw;
            }
        }
    }

    /// <summary>
    /// Basic IMemoryCache based implementation used in non-distributed scenarios.
    /// Relies on custom counters maintained by <see cref="CachingPostRepositoryDecorator"/>.
    /// </summary>
    public sealed class MemoryCacheStatisticsProvider : ICacheStatisticsProvider
    {
        private readonly IMemoryCache _cache;

        public MemoryCacheStatisticsProvider(IMemoryCache cache)
            => _cache = cache ?? throw new ArgumentNullException(nameof(cache));

        public Task<(double hitRatio, long sizeBytes)> GetStatisticsAsync(
            CancellationToken cancellationToken = default)
        {
            _cache.TryGetValue(CacheMetricsKeys.HitCounter,   out long hits);
            _cache.TryGetValue(CacheMetricsKeys.MissCounter,  out long misses);
            _cache.TryGetValue(CacheMetricsKeys.SizeBytes,    out long sizeBytes);

            double ratio = hits + misses == 0 ? 1.0 : (double)hits / (hits + misses);
            return Task.FromResult((ratio, sizeBytes));
        }
    }

    /// <summary>
    /// Decorator that adds in-process caching to any <see cref="IPostRepository"/>.
    /// Cache entries are automatically invalidated on save/delete and
    /// global metrics are exposed for analytics.
    /// </summary>
    public sealed class CachingPostRepositoryDecorator : IPostRepository
    {
        private readonly IPostRepository _inner;
        private readonly IMemoryCache    _cache;
        private readonly ILogger<CachingPostRepositoryDecorator> _logger;
        private readonly MemoryCacheEntryOptions _cacheOptions;

        private const string CachePrefix = "post_";

        public CachingPostRepositoryDecorator(
            IPostRepository inner,
            IMemoryCache cache,
            ILogger<CachingPostRepositoryDecorator> logger,
            TimeSpan? absoluteExpirationRelativeToNow = null)
        {
            _inner   = inner   ?? throw new ArgumentNullException(nameof(inner));
            _cache   = cache   ?? throw new ArgumentNullException(nameof(cache));
            _logger  = logger  ?? throw new ArgumentNullException(nameof(logger));

            _cacheOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = absoluteExpirationRelativeToNow ?? TimeSpan.FromMinutes(15),
                SlidingExpiration               = TimeSpan.FromMinutes( 5)
            };
        }

        public async Task<Post?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
        {
            var cacheKey = BuildCacheKey(id);

            if (_cache.TryGetValue(cacheKey, out Post cached))
            {
                IncrementHit();
                _logger.LogDebug("Cache HIT for post {PostId}", id);
                return cached;
            }

            IncrementMiss();
            _logger.LogDebug("Cache MISS for post {PostId}", id);

            var post = await _inner.GetByIdAsync(id, cancellationToken).ConfigureAwait(false);

            if (post is not null)
            {
                _cache.Set(cacheKey, post, _cacheOptions);
                UpdateSizeEstimate(post);
            }

            return post;
        }

        public async Task SaveAsync(Post post, CancellationToken cancellationToken = default)
        {
            await _inner.SaveAsync(post, cancellationToken).ConfigureAwait(false);

            var cacheKey = BuildCacheKey(post.Id);
            _cache.Set(cacheKey, post, _cacheOptions);
            UpdateSizeEstimate(post);
        }

        public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
        {
            await _inner.DeleteAsync(id, cancellationToken).ConfigureAwait(false);
            _cache.Remove(BuildCacheKey(id));
        }

        /* ---------------------------------------------------------- *
         *                    Private helper methods                  *
         * ---------------------------------------------------------- */

        private static string BuildCacheKey(Guid id) => $"{CachePrefix}{id:N}";

        private void UpdateSizeEstimate(Post post)
        {
            // VERY rough size approximation: string length ~= bytes for UTF-16
            var postSizeBytes = (post.Title?.Length  ?? 0) * sizeof(char) +
                                (post.Content?.Length ?? 0) * sizeof(char) + 256;

            var currentSize = _cache.GetOrCreate(CacheMetricsKeys.SizeBytes, _ => 0L);
            _cache.Set(CacheMetricsKeys.SizeBytes, currentSize + postSizeBytes);
        }

        private void IncrementHit()
        {
            var hits = _cache.GetOrCreate(CacheMetricsKeys.HitCounter, _ => 0L);
            _cache.Set(CacheMetricsKeys.HitCounter, hits + 1);
        }

        private void IncrementMiss()
        {
            var misses = _cache.GetOrCreate(CacheMetricsKeys.MissCounter, _ => 0L);
            _cache.Set(CacheMetricsKeys.MissCounter, misses + 1);
        }

        private static class CacheMetricsKeys
        {
            public const string HitCounter  = "__temposcribe_cache_hits";
            public const string MissCounter = "__temposcribe_cache_misses";
            public const string SizeBytes   = "__temposcribe_cache_size_bytes";
        }
    }

    /* -------------------------------------------------------------- *
     *                    Utility/extension helpers                   *
     * -------------------------------------------------------------- */

    internal static class ExceptionExtensions
    {
        /// <summary>
        /// Determines whether the supplied exception is fatal enough that
        /// the process should avoid catching it.
        /// </summary>
        public static bool IsFatal(this Exception exception) =>
            exception is OutOfMemoryException or StackOverflowException;
    }
}
```