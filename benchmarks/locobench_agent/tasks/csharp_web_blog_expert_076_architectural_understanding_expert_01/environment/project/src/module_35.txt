```csharp
// File: src/module_35.txt
// Project: TempoScribe Pro â€“ Hexagonal Productivity Blog Suite (web_blog)
// Language: C#
// Purpose: Publication workflow service + supporting domain types (ports, entities, events, exceptions)

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Abstractions
{
    /// <summary>
    /// Provides the current date/time in a test-friendly way.
    /// </summary>
    public interface IClock
    {
        DateTimeOffset Now { get; }
    }

    /// <summary>
    /// Marker interface for domain events.
    /// </summary>
    public interface IDomainEvent { }

    /// <summary>
    /// Publishes domain events to interested adapters (e.g., outbox, message bus).
    /// </summary>
    public interface IEventPublisher
    {
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct = default)
            where TEvent : IDomainEvent;
    }
}

namespace TempoScribePro.Domain.Exceptions
{
    /// <summary>
    /// Base class for all domain-level exceptions.
    /// </summary>
    public class DomainException : Exception
    {
        public DomainException(string message) : base(message) { }
    }

    public sealed class NotFoundException : DomainException
    {
        public NotFoundException(string message) : base(message) { }
    }

    public sealed class ValidationException : DomainException
    {
        public ValidationException(string message) : base(message) { }
    }
}

namespace TempoScribePro.Domain.Events
{
    using TempoScribePro.Domain.Abstractions;

    public record PublicationScheduledEvent(Guid PostId, DateTimeOffset ScheduledFor) : IDomainEvent;
    public record PublicationCancelledEvent(Guid PostId) : IDomainEvent;
    public record PostPublishedEvent(Guid PostId, DateTimeOffset PublishedAt) : IDomainEvent;
}

namespace TempoScribePro.Domain.Entities
{
    using TempoScribePro.Domain.Abstractions;
    using TempoScribePro.Domain.Events;
    using TempoScribePro.Domain.Exceptions;

    public enum PostStatus
    {
        Draft,
        Scheduled,
        Published
    }

    /// <summary>
    /// Aggregate root representing a blog post inside the domain core.
    /// </summary>
    public sealed class Post
    {
        private readonly List<IDomainEvent> _domainEvents = new();

        public Guid Id { get; }
        public string Title { get; private set; }
        public PostStatus Status { get; private set; }
        public DateTimeOffset? ScheduledAt { get; private set; }
        public DateTimeOffset? PublishedAt { get; private set; }

        public IReadOnlyCollection<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

        public Post(Guid id, string title)
        {
            Id = id;
            Title = title;
            Status = PostStatus.Draft;
        }

        public void SchedulePublication(DateTimeOffset scheduledAt, IClock clock)
        {
            if (scheduledAt <= clock.Now)
                throw new ValidationException("Publication date/time must be in the future.");

            if (Status == PostStatus.Published)
                throw new ValidationException("Cannot schedule a post that has already been published.");

            ScheduledAt = scheduledAt;
            Status = PostStatus.Scheduled;
            _domainEvents.Add(new PublicationScheduledEvent(Id, scheduledAt));
        }

        public void CancelSchedule()
        {
            if (Status != PostStatus.Scheduled)
                throw new ValidationException("Post is not currently scheduled.");

            ScheduledAt = null;
            Status = PostStatus.Draft;
            _domainEvents.Add(new PublicationCancelledEvent(Id));
        }

        public void Publish(IClock clock)
        {
            if (Status != PostStatus.Scheduled)
                throw new ValidationException("Post is not scheduled for publication.");

            if (ScheduledAt.HasValue && ScheduledAt > clock.Now)
                throw new ValidationException("Scheduled time has not yet been reached.");

            Status = PostStatus.Published;
            PublishedAt = clock.Now;
            _domainEvents.Add(new PostPublishedEvent(Id, PublishedAt.Value));
        }

        public void ClearDomainEvents() => _domainEvents.Clear();
    }

    /// <summary>
    /// Simple entity representing a task in the editorial Kanban board.
    /// </summary>
    public sealed class EditorialTask
    {
        public EditorialTask(Guid id, Guid postId, string description)
        {
            Id = id;
            PostId = postId;
            Description = description;
            CreatedAt = DateTimeOffset.UtcNow;
        }

        public Guid Id { get; }
        public Guid PostId { get; }
        public string Description { get; }
        public DateTimeOffset CreatedAt { get; }
    }
}

namespace TempoScribePro.Domain.Repositories
{
    using TempoScribePro.Domain.Entities;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Port for Post persistence.
    /// </summary>
    public interface IPostRepository
    {
        Task<Post?> GetByIdAsync(Guid id, CancellationToken ct = default);
        Task<IReadOnlyList<Post>> GetScheduledDueAsync(DateTimeOffset threshold, CancellationToken ct = default);
        Task UpdateAsync(Post post, CancellationToken ct = default);
    }

    /// <summary>
    /// Port for EditorialTask persistence.
    /// </summary>
    public interface IEditorialTaskRepository
    {
        Task AddAsync(EditorialTask task, CancellationToken ct = default);
    }
}

namespace TempoScribePro.Domain.Services
{
    using TempoScribePro.Domain.Abstractions;
    using TempoScribePro.Domain.Entities;
    using TempoScribePro.Domain.Events;
    using TempoScribePro.Domain.Exceptions;
    using TempoScribePro.Domain.Repositories;

    /// <summary>
    /// Application service orchestrating post publication, scheduling, and related workflow tasks.
    /// </summary>
    public interface IPublicationWorkflowService
    {
        /// <summary>
        /// Schedule a post for future publication.
        /// </summary>
        Task SchedulePublicationAsync(Guid postId, DateTimeOffset scheduledAt, CancellationToken ct = default);

        /// <summary>
        /// Cancel a previously scheduled publication.
        /// </summary>
        Task CancelScheduledPublicationAsync(Guid postId, CancellationToken ct = default);

        /// <summary>
        /// Publish all posts whose scheduled date/time has passed. 
        /// Returns the number of successfully published posts.
        /// </summary>
        Task<int> ExecuteDuePublicationsAsync(CancellationToken ct = default);
    }

    /// <summary>
    /// Concrete implementation of <see cref="IPublicationWorkflowService"/>.
    /// </summary>
    public sealed class PublicationWorkflowService : IPublicationWorkflowService
    {
        private static readonly TimeSpan ReviewWindow = TimeSpan.FromHours(24);

        private readonly IPostRepository _postRepository;
        private readonly IEditorialTaskRepository _taskRepository;
        private readonly IClock _clock;
        private readonly IEventPublisher _eventPublisher;
        private readonly ILogger<PublicationWorkflowService> _logger;

        public PublicationWorkflowService(
            IPostRepository postRepository,
            IEditorialTaskRepository taskRepository,
            IClock clock,
            IEventPublisher eventPublisher,
            ILogger<PublicationWorkflowService> logger)
        {
            _postRepository   = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _taskRepository   = taskRepository  ?? throw new ArgumentNullException(nameof(taskRepository));
            _clock            = clock           ?? throw new ArgumentNullException(nameof(clock));
            _eventPublisher   = eventPublisher  ?? throw new ArgumentNullException(nameof(eventPublisher));
            _logger           = logger          ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task SchedulePublicationAsync(Guid postId, DateTimeOffset scheduledAt, CancellationToken ct = default)
        {
            _logger.LogInformation("Scheduling publication for post {PostId} at {ScheduledAt}.", postId, scheduledAt);

            var post = await _postRepository.GetByIdAsync(postId, ct)
                       ?? throw new NotFoundException($"Post with id {postId} was not found.");

            post.SchedulePublication(scheduledAt, _clock);
            await PersistAndPublishEventsAsync(post, ct);

            // Create an editorial review task if the post is scheduled far in the future.
            if (scheduledAt - _clock.Now > ReviewWindow)
            {
                var task = new EditorialTask(
                    id: Guid.NewGuid(),
                    postId: post.Id,
                    description: $"Review scheduled post \"{post.Title}\" before publication.");

                await _taskRepository.AddAsync(task, ct);
                _logger.LogInformation("Editorial task {TaskId} created for post {PostId}.", task.Id, post.Id);
            }

            _logger.LogInformation("Post {PostId} successfully scheduled.", postId);
        }

        public async Task CancelScheduledPublicationAsync(Guid postId, CancellationToken ct = default)
        {
            _logger.LogInformation("Cancelling scheduled publication for post {PostId}.", postId);

            var post = await _postRepository.GetByIdAsync(postId, ct)
                       ?? throw new NotFoundException($"Post with id {postId} was not found.");

            post.CancelSchedule();
            await PersistAndPublishEventsAsync(post, ct);

            _logger.LogInformation("Schedule cancelled for post {PostId}.", postId);
        }

        public async Task<int> ExecuteDuePublicationsAsync(CancellationToken ct = default)
        {
            IReadOnlyList<Post> duePosts = await _postRepository.GetScheduledDueAsync(_clock.Now, ct);

            if (duePosts.Count == 0)
            {
                _logger.LogDebug("No due publications found at {Now}.", _clock.Now);
                return 0;
            }

            _logger.LogInformation("Found {Count} post(s) due for publication.", duePosts.Count);
            var publishedCount = 0;

            foreach (var post in duePosts)
            {
                try
                {
                    post.Publish(_clock);
                    await PersistAndPublishEventsAsync(post, ct);
                    publishedCount++;
                    _logger.LogInformation("Post {PostId} published successfully.", post.Id);
                }
                catch (DomainException ex)
                {
                    _logger.LogWarning(ex, "Failed to publish post {PostId}.", post.Id);
                    // Intentionally continue processing the next post.
                }
            }

            _logger.LogInformation("{Count} post(s) published in total.", publishedCount);
            return publishedCount;
        }

        #region Private helpers

        private async Task PersistAndPublishEventsAsync(Post post, CancellationToken ct)
        {
            // Persist aggregate state first (transactional boundary).
            await _postRepository.UpdateAsync(post, ct);

            // Publish accumulated domain events.
            foreach (var @event in post.DomainEvents)
            {
                // Hand off to outbox/message bus, depending on adapter.
                await _eventPublisher.PublishAsync(@event, ct);
            }

            post.ClearDomainEvents();
        }

        #endregion
    }
}
```