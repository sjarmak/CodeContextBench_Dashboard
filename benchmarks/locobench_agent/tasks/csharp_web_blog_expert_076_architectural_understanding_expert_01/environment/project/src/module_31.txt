```csharp
// -----------------------------------------------------------------------------
// File: src/module_31.txt   (C# Source − keep .txt to satisfy legacy tooling)
// Project: TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// Description:
//      Background service that orchestrates scheduled publishing of blog posts.
//      Implements the “Ports & Adapters” style—core ports live in this file
//      together with an adapter that plugs into Microsoft’s generic host.
// -----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace TempoScribePro.Application.Scheduling
{
    #region ────────────────────────────── Domain Ports ─────────────────────────
    /// <summary>
    /// Abstraction of a repository that exposes time-boxed queries and
    /// state-mutation methods for blog posts.
    /// </summary>
    public interface IPostRepository
    {
        /// <summary>Gets all posts whose <see cref="IPost.ScheduleAtUtc"/> has
        /// passed and that are still in <see cref="PostStatus.Scheduled"/>.</summary>
        ValueTask<IReadOnlyCollection<IPost>> FetchDueScheduledPostsAsync(
            DateTime utcNow,
            CancellationToken ct = default);

        /// <summary>Persists the post and any aggregated domain events.</summary>
        ValueTask SaveAsync(IPost post, CancellationToken ct = default);
    }

    /// <summary>
    /// Abstraction over the Post aggregate root.
    /// </summary>
    public interface IPost
    {
        Guid            Id             { get; }
        string          Slug           { get; }
        string          Title          { get; }
        DateTime        ScheduleAtUtc  { get; }
        PostStatus      Status         { get; }
        IReadOnlyList<IDomainEvent> DequeueDomainEvents();

        /// <summary>Transitions the post to <see cref="PostStatus.Published"/>,
        /// performing any validation and domain bookkeeping.</summary>
        void Publish(DateTime utcNow);
    }

    /// <summary>
    /// Publishes domain events produced by aggregates.
    /// </summary>
    public interface IDomainEventDispatcher
    {
        Task DispatchAsync(
            IReadOnlyCollection<IDomainEvent> events,
            CancellationToken ct = default);
    }

    /// <summary>
    /// Simple distributed mutex used to guarantee a single publisher is active
    /// cluster-wide at any given time.
    /// </summary>
    public interface IDistributedLock
    {
        Task<IDisposable?> TryAcquireAsync(
            string lockKey,
            TimeSpan timeout,
            CancellationToken ct = default);
    }

    /// <summary>Marker interface.</summary>
    public interface IDomainEvent { }

    public enum PostStatus { Draft, Scheduled, Published }
    #endregion

    #region ─────────────────────────── Options / Settings ──────────────────────
    /// <summary>Configures cadence and locking for the background worker.</summary>
    public sealed class ScheduledPublishingOptions
    {
        /// <summary>
        /// How often the poller wakes up and scans for due posts.
        /// Default: 1 minute.
        /// </summary>
        public TimeSpan PollInterval { get; init; } = TimeSpan.FromMinutes(1);

        /// <summary>
        /// Distributed lock key shared across all app instances.
        /// </summary>
        public string DistributedLockKey { get; init; } = "tempo-scheduled-publisher";

        /// <summary>
        /// Max time a node may hold the distributed lock before renewal.
        /// </summary>
        public TimeSpan LockTimeout { get; init; } = TimeSpan.FromMinutes(5);
    }
    #endregion

    #region ──────────────────────── Background Worker (Adapter) ────────────────
    /// <summary>
    /// Microsoft.Extensions.Hosting adapter that periodically publishes posts
    /// when their schedule matures.  Because TempoScribe ships as a horizontally
    /// scalable web farm, concurrency is coordinated via an <see cref="IDistributedLock"/>.
    /// </summary>
    public sealed class ScheduledPublishBackgroundService : BackgroundService
    {
        private readonly IPostRepository            _posts;
        private readonly IDomainEventDispatcher     _dispatcher;
        private readonly IDistributedLock           _lock;
        private readonly ScheduledPublishingOptions _options;
        private readonly ILogger<ScheduledPublishBackgroundService> _log;

        public ScheduledPublishBackgroundService(
            IPostRepository                        posts,
            IDomainEventDispatcher                 dispatcher,
            IDistributedLock                       @lock,
            IOptions<ScheduledPublishingOptions>   options,
            ILogger<ScheduledPublishBackgroundService> log)
        {
            _posts      = posts       ?? throw new ArgumentNullException(nameof(posts));
            _dispatcher = dispatcher  ?? throw new ArgumentNullException(nameof(dispatcher));
            _lock       = @lock       ?? throw new ArgumentNullException(nameof(@lock));
            _options    = options?.Value ?? throw new ArgumentNullException(nameof(options));
            _log        = log         ?? throw new ArgumentNullException(nameof(log));
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _log.LogInformation("ScheduledPublishBackgroundService started with interval {Interval}.",
                                _options.PollInterval);

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    await TryRunPublishingCycleAsync(stoppingToken).ConfigureAwait(false);
                }
                catch (Exception ex)
                {
                    _log.LogError(ex, "Unhandled exception inside scheduled publishing loop.");
                }

                try
                {
                    await Task.Delay(_options.PollInterval, stoppingToken).ConfigureAwait(false);
                }
                catch (TaskCanceledException) { /* expected on shutdown */ }
            }

            _log.LogInformation("ScheduledPublishBackgroundService stopped.");
        }

        private async Task TryRunPublishingCycleAsync(CancellationToken ct)
        {
            await using var lease = await _lock.TryAcquireAsync(
                _options.DistributedLockKey,
                _options.LockTimeout,
                ct).ConfigureAwait(false);

            if (lease is null)
            {
                _log.LogDebug("Skipped publishing cycle – another node holds the lease.");
                return;
            }

            _log.LogDebug("Lease acquired; scanning for due posts…");

            var duePosts = await _posts.FetchDueScheduledPostsAsync(DateTime.UtcNow, ct)
                                       .ConfigureAwait(false);

            if (duePosts.Count == 0)
            {
                _log.LogDebug("No posts ready for publication.");
                return;
            }

            _log.LogInformation("Found {Count} post(s) ready to publish.", duePosts.Count);

            foreach (var post in duePosts)
            {
                try
                {
                    PublishSinglePost(post, ct);
                    await _posts.SaveAsync(post, ct).ConfigureAwait(false);
                    await _dispatcher.DispatchAsync(post.DequeueDomainEvents(), ct)
                                      .ConfigureAwait(false);

                    _log.LogInformation("Post {PostId} ('{Slug}') published successfully.",
                                        post.Id, post.Slug);
                }
                catch (Exception ex)
                {
                    // Fail fast for the individual post but continue processing others.
                    _log.LogError(ex,
                        "Failed to publish Post {PostId} ('{Slug}'). Will retry on next cycle.",
                        post.Id, post.Slug);
                }
            }
        }

        private static void PublishSinglePost(IPost post, CancellationToken ct)
        {
            // Domain layer FTW: we trust Post.Publish to validate state transitions,
            // fire domain events, invalidate caches, etc.
            if (post.Status != PostStatus.Scheduled)
                throw new InvalidOperationException(
                    $"Post {post.Id} is not in 'Scheduled' status (actual: {post.Status}).");

            post.Publish(DateTime.UtcNow);
            ct.ThrowIfCancellationRequested();
        }
    }
    #endregion
}
```