```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using TempoScribePro.Domain.Analytics;
using TempoScribePro.Domain.Common;
using TempoScribePro.Infrastructure.Logging;

namespace TempoScribePro.Application.Analytics
{
    /// <summary>
    ///     Application-layer service that aggregates editorial analytics events into
    ///     human-readable productivity insights and reports.  This class adheres to the
    ///     Hexagonal architecture by talking only to ports (repositories, cache, clock)
    ///     and remaining agnostic of concrete infrastructure.
    /// </summary>
    public sealed class EditorialAnalyticsService : IEditorialAnalyticsService
    {
        private const string CacheKeyTemplate = "analytics:summary:{0}:{1:yyyyMMdd}-{2:yyyyMMdd}";
        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(15);

        private readonly IAnalyticsEventRepository _eventRepository;
        private readonly ICacheProvider _cache;
        private readonly IDateTimeProvider _clock;
        private readonly ILogger _logger;

        public EditorialAnalyticsService(
            IAnalyticsEventRepository eventRepository,
            ICacheProvider cache,
            IDateTimeProvider clock,
            ILogger logger)
        {
            _eventRepository = eventRepository ?? throw new ArgumentNullException(nameof(eventRepository));
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _clock = clock ?? throw new ArgumentNullException(nameof(clock));
            _logger = logger ?? NullLogger.Instance;
        }

        /// <inheritdoc/>
        public async Task<ProductivitySummaryDto> GetProductivitySummaryAsync(
            Guid userId,
            DateRange range,
            CancellationToken cancellationToken = default)
        {
            if (userId == Guid.Empty) throw new ArgumentException("User id must be provided", nameof(userId));
            if (range.IsEmpty) throw new ArgumentException("Date range may not be empty", nameof(range));

            string cacheKey = BuildCacheKey(userId, range);

            // 1. Happy path: try the cache first
            var cached = await _cache.GetAsync<ProductivitySummaryDto>(cacheKey, cancellationToken);
            if (cached is not null)
            {
                _logger.Debug($"Cache hit for {cacheKey}");
                return cached;
            }

            // 2. Fetch events from the repository
            IReadOnlyList<EditorialAnalyticsEvent> events;
            try
            {
                events = await _eventRepository.GetEventsAsync(userId, range, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Failed to fetch analytics events");
                throw;
            }

            // 3. Compute summary
            var summary = ComputeSummary(events, range);

            // 4. Store in cache (fire-and-forget if the token was cancelled)
            _ = CacheSafeAsync(cacheKey, summary, cancellationToken);

            return summary;
        }

        // --------------------------  private helpers  --------------------------

        private static ProductivitySummaryDto ComputeSummary(
            IReadOnlyList<EditorialAnalyticsEvent> events,
            DateRange range)
        {
            if (events.Count == 0)
            {
                return ProductivitySummaryDto.Empty(range);
            }

            var sessions = events.OfType<WorkSessionAnalyticsEvent>().ToArray();
            var publishEvents = events.OfType<PostPublishedAnalyticsEvent>().ToArray();

            double avgWordsPerSession = sessions.Any()
                ? sessions.Average(s => s.WordsWritten)
                : 0;

            double avgSessionMinutes = sessions.Any()
                ? sessions.Average(s => s.Duration.TotalMinutes)
                : 0;

            int totalWords = sessions.Sum(s => s.WordsWritten);
            int postsPublished = publishEvents.Length;

            TimeSpan? avgDraftToPublish = publishEvents.Any()
                ? TimeSpan.FromMinutes(
                    publishEvents.Average(p => p.TimeFromDraftToPublish.TotalMinutes))
                : null;

            return new ProductivitySummaryDto(
                range,
                avgWordsPerSession,
                avgSessionMinutes,
                totalWords,
                postsPublished,
                avgDraftToPublish);
        }

        private static string BuildCacheKey(Guid userId, DateRange range) =>
            string.Format(CacheKeyTemplate, userId, range.Start, range.End);

        private async Task CacheSafeAsync(
            string key,
            ProductivitySummaryDto value,
            CancellationToken callerToken)
        {
            // Ensure that cancellation of the main operation does not abort caching.
            using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
                callerToken, new CancellationTokenSource().Token);

            try
            {
                await _cache.SetAsync(key, value, CacheTtl, linkedCts.Token);
                _logger.Debug($"Cached productivity summary under {key}");
            }
            catch (OperationCanceledException) when (callerToken.IsCancellationRequested)
            {
                // Respect caller cancellation.
            }
            catch (Exception ex)
            {
                _logger.Warn(ex, $"Unable to populate cache for key {key}");
            }
        }
    }

    // =======================  PORTS & ADAPTER CONTRACTS  =======================

    public interface IEditorialAnalyticsService
    {
        /// <summary>
        ///     Returns a productivity summary for the specified user and date range.
        /// </summary>
        Task<ProductivitySummaryDto> GetProductivitySummaryAsync(
            Guid userId,
            DateRange range,
            CancellationToken cancellationToken = default);
    }

    /// <summary>Repository port for retrieving analytics events.</summary>
    public interface IAnalyticsEventRepository
    {
        Task<IReadOnlyList<EditorialAnalyticsEvent>> GetEventsAsync(
            Guid userId, DateRange range, CancellationToken cancellationToken);
    }

    /// <summary>Simple, high-level cache abstraction.</summary>
    public interface ICacheProvider
    {
        Task<T?> GetAsync<T>(string key, CancellationToken ct);
        Task SetAsync<T>(string key, T value, TimeSpan ttl, CancellationToken ct);
    }

    /// <summary>Clock abstraction to improve testability and determinism.</summary>
    public interface IDateTimeProvider
    {
        DateTime UtcNow { get; }
    }

    // =============================  DOMAIN MODELS  =============================

    namespace TempoScribePro.Domain.Analytics
    {
        /// <summary>Base class for all editorial analytics events.</summary>
        public abstract record EditorialAnalyticsEvent(DateTimeOffset OccurredAt);

        /// <summary>
        ///     Event raised when a user completes a work session (e.g. a Pomodoro).
        /// </summary>
        public sealed record WorkSessionAnalyticsEvent(
            DateTimeOffset OccurredAt,
            int WordsWritten,
            TimeSpan Duration)
            : EditorialAnalyticsEvent(OccurredAt);

        /// <summary>
        ///     Event raised when a post is published.
        /// </summary>
        public sealed record PostPublishedAnalyticsEvent(
            DateTimeOffset OccurredAt,
            Guid PostId,
            TimeSpan TimeFromDraftToPublish)
            : EditorialAnalyticsEvent(OccurredAt);
    }

    namespace TempoScribePro.Domain.Common
    {
        /// <summary>
        ///     Immutable value object representing a closed date range.
        /// </summary>
        public readonly struct DateRange : IEquatable<DateRange>
        {
            public DateTime Start { get; }
            public DateTime End { get; }

            public bool IsEmpty => Start == default && End == default;

            public DateRange(DateTime start, DateTime end)
            {
                if (start > end)
                    throw new ArgumentException($"{nameof(start)} cannot be after {nameof(end)}");

                Start = start.Date;
                End = end.Date;
            }

            public bool Equals(DateRange other) => Start == other.Start && End == other.End;
            public override bool Equals(object? obj) => obj is DateRange other && Equals(other);
            public override int GetHashCode() => HashCode.Combine(Start, End);

            public override string ToString() => $"{Start:yyyy-MM-dd}..{End:yyyy-MM-dd}";
        }

        /// <summary>
        ///     DTO returned to clients consuming analytics endpoints/services.
        /// </summary>
        public sealed record ProductivitySummaryDto(
            DateRange Range,
            double AverageWordsPerSession,
            double AverageSessionDurationMinutes,
            int TotalWordsWritten,
            int PostsPublished,
            TimeSpan? AverageTimeFromDraftToPublish)
        {
            public static ProductivitySummaryDto Empty(DateRange range) =>
                new(range, 0, 0, 0, 0, null);
        }
    }

    namespace TempoScribePro.Infrastructure.Logging
    {
        /// <summary>
        ///     Very light-weight logging abstraction to avoid coupling to a concrete
        ///     logging framework in the core/application layers.
        /// </summary>
        public interface ILogger
        {
            void Debug(string message);
            void Info(string message);
            void Warn(Exception ex, string message);
            void Error(Exception ex, string message,
                       [CallerMemberName] string? member = null,
                       [CallerFilePath] string? file = null,
                       [CallerLineNumber] int line = 0);
        }

        /// <summary>
        ///     No-op fallback logger to guarantee null-safety in environments where
        ///     injection has not been configured (e.g. unit tests).
        /// </summary>
        [SuppressMessage("ReSharper", "TemplateIsNotCompileTimeConstantProblem")]
        public sealed class NullLogger : ILogger
        {
            public static readonly ILogger Instance = new NullLogger();
            private NullLogger() { }

            public void Debug(string message) { /* swallow */ }
            public void Info(string message) { /* swallow */ }
            public void Warn(Exception ex, string message) { /* swallow */ }
            public void Error(Exception ex, string message, string? member = null,
                string? file = null, int line = 0) { /* swallow */ }
        }
    }
}
```