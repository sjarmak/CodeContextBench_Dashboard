```csharp
// =============================================================
// File: src/module_26.txt   (C# Source Module)
// Project: TempoScribe Pro â€“ Hexagonal Productivity Blog Suite
// Description: Live-preview & diff-caching domain service plus
//              in-memory adapter implementations.
// =============================================================

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using DiffPlex;
using DiffPlex.DiffBuilder;
using DiffPlex.DiffBuilder.Model;
using Markdig;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Modules.LivePreview
{
    #region Ports (Hexagonal Interfaces)

    /// <summary>
    /// Abstraction for converting Markdown (or any markup)
    /// to the rendered HTML that the Web UI displays.
    /// </summary>
    public interface IMarkupRendererPort
    {
        /// <summary>
        /// Converts <paramref name="content"/> to HTML.
        /// </summary>
        string RenderToHtml(string content);
    }

    /// <summary>
    /// Abstraction for caching preview artifacts so that
    /// repeated requests for the same markdown are cheap.
    /// </summary>
    public interface IPreviewCachePort
    {
        bool TryGet(string cacheKey, out CachedPreview cached);
        void Set(string cacheKey, CachedPreview cached, TimeSpan ttl);
    }

    #endregion

    #region DTOs

    /// <summary>
    /// The cached object stored by <see cref="IPreviewCachePort"/>.
    /// </summary>
    public record CachedPreview(
        string RawMarkdown,
        string RenderedHtml,
        DateTimeOffset CreatedUtc);

    /// <summary>
    /// Summary of line-level differences between two markdown
    /// versions. Used by the UI to highlight what changed.
    /// </summary>
    public record DiffSummary(
        int AddedLines,
        int DeletedLines,
        int ModifiedLines,
        IReadOnlyCollection<int> ChangedLineNumbers);

    /// <summary>
    /// Result returned by <see cref="LivePreviewService"/>.
    /// </summary>
    public record PreviewResponse(
        string RenderedHtml,
        DiffSummary Diff,
        bool ServedFromCache,
        DateTimeOffset GeneratedUtc);

    #endregion

    #region Domain Service

    /// <summary>
    /// Core service that generates live previews and diff
    /// summaries for the editing experience.
    /// </summary>
    public sealed class LivePreviewService
    {
        private const int MaxMarkdownCharacters = 500_000; // Protect against DoS.
        private static readonly TimeSpan DefaultCacheTtl = TimeSpan.FromMinutes(20);

        private readonly IMarkupRendererPort _renderer;
        private readonly IPreviewCachePort _cache;
        private readonly ILogger<LivePreviewService> _logger;

        // Guards concurrent rendering per cache key.
        private readonly ConcurrentDictionary<string, SemaphoreSlim> _locks = new();

        public LivePreviewService(
            IMarkupRendererPort renderer,
            IPreviewCachePort cache,
            ILogger<LivePreviewService> logger)
        {
            _renderer = renderer ?? throw new ArgumentNullException(nameof(renderer));
            _cache   = cache   ?? throw new ArgumentNullException(nameof(cache));
            _logger  = logger  ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Generates the preview HTML and diff summary for the
        /// supplied <paramref name="markdown"/>.
        /// </summary>
        /// <remarks>
        /// Diff is computed against the most recent cached version
        /// (if any). Subsequent identical requests are served from
        /// cache to avoid redundant rendering work.
        /// </remarks>
        public async Task<PreviewResponse> GeneratePreviewAsync(
            Guid postId,
            string markdown,
            string userId,
            CancellationToken cancellationToken = default)
        {
            if (markdown is null) throw new ArgumentNullException(nameof(markdown));
            if (markdown.Length > MaxMarkdownCharacters)
                throw new ArgumentException($"Markdown exceeds {MaxMarkdownCharacters:N0} characters.", nameof(markdown));

            string cacheKey = BuildCacheKey(postId, userId);
            if (_cache.TryGet(cacheKey, out var cached) && cached.RawMarkdown == markdown)
            {
                _logger.LogDebug("Preview served from cache for Post {PostId} User {UserId}.", postId, userId);
                return new PreviewResponse(
                    cached.RenderedHtml,
                    Diff: new DiffSummary(0, 0, 0, Array.Empty<int>()),
                    ServedFromCache: true,
                    GeneratedUtc: cached.CreatedUtc);
            }

            // Ensure only one renderer at a time per cache key.
            SemaphoreSlim keyLock = _locks.GetOrAdd(cacheKey, _ => new SemaphoreSlim(1, 1));
            await keyLock.WaitAsync(cancellationToken);
            try
            {
                // Double-check cache after acquiring lock.
                if (_cache.TryGet(cacheKey, out cached) && cached.RawMarkdown == markdown)
                {
                    _logger.LogDebug("Preview served from cache (post-lock) for Post {PostId}.", postId);
                    return new PreviewResponse(
                        cached.RenderedHtml,
                        Diff: new DiffSummary(0, 0, 0, Array.Empty<int>()),
                        ServedFromCache: true,
                        GeneratedUtc: cached.CreatedUtc);
                }

                string html = _renderer.RenderToHtml(markdown);
                DiffSummary diff = ComputeDiff(cached?.RawMarkdown, markdown);

                var newCached = new CachedPreview(markdown, html, DateTimeOffset.UtcNow);
                _cache.Set(cacheKey, newCached, DefaultCacheTtl);

                _logger.LogInformation(
                    "Generated new preview for Post {PostId} (Diff +{Added}/-{Deleted}/~{Modified}).",
                    postId, diff.AddedLines, diff.DeletedLines, diff.ModifiedLines);

                return new PreviewResponse(html, diff, ServedFromCache: false, newCached.CreatedUtc);
            }
            finally
            {
                keyLock.Release();
            }
        }

        private static string BuildCacheKey(Guid postId, string userId) => $"{postId:N}:{userId}";

        private static DiffSummary ComputeDiff(string? oldMarkdown, string newMarkdown)
        {
            if (string.IsNullOrEmpty(oldMarkdown))
            {
                int lineCount = newMarkdown.Split('\n').Length;
                return new DiffSummary(lineCount, 0, 0, Enumerable.Range(1, lineCount).ToArray());
            }

            var differ     = new Differ();
            var lineDiff   = differ.CreateLineDiffs(oldMarkdown, newMarkdown, ignoreWhitespace: false);
            var inlineDiff = InlineDiffBuilder.BuildInlineDiffModel(oldMarkdown, newMarkdown);

            int added    = lineDiff.InsertedLines;
            int deleted  = lineDiff.DeletedLines;
            int modified = inlineDiff.Lines.Count(l => l.Type == ChangeType.Modified);

            var changedLines = inlineDiff.Lines
                                         .Select((line, idx) => (line, idx))
                                         .Where(x => x.line.Type != ChangeType.Unchanged)
                                         .Select(x => x.idx + 1)
                                         .ToArray();

            return new DiffSummary(added, deleted, modified, changedLines);
        }
    }

    #endregion

    #region Adapters

    /// <summary>
    /// Production adapter that converts Markdown to HTML using
    /// the popular Markdig pipeline (common extensions enabled).
    /// </summary>
    public sealed class MarkdigRendererAdapter : IMarkupRendererPort
    {
        private readonly MarkdownPipeline _pipeline;

        public MarkdigRendererAdapter()
        {
            _pipeline = new MarkdownPipelineBuilder()
                        .UseAdvancedExtensions()
                        .UseYamlFrontMatter()
                        .Build();
        }

        public string RenderToHtml(string content)
        {
            // Markdig executes quickly, but we still guard against null.
            if (content is null) throw new ArgumentNullException(nameof(content));
            return Markdown.ToHtml(content, _pipeline);
        }
    }

    /// <summary>
    /// In-memory cache backed by <see cref="IMemoryCache"/>.
    /// Can be swapped for Redis or distributed cache through DI.
    /// </summary>
    public sealed class MemoryPreviewCacheAdapter : IPreviewCachePort, IDisposable
    {
        private readonly IMemoryCache _cache;
        private bool _disposed;

        public MemoryPreviewCacheAdapter(IMemoryCache? cache = null)
            => _cache = cache ?? new MemoryCache(new MemoryCacheOptions
            {
                SizeLimit = 1_024 // Rough limit in number of entries.
            });

        public bool TryGet(string cacheKey, out CachedPreview cached)
            => _cache.TryGetValue(cacheKey, out cached!);

        public void Set(string cacheKey, CachedPreview cached, TimeSpan ttl)
        {
            if (_disposed) throw new ObjectDisposedException(nameof(MemoryPreviewCacheAdapter));
            _cache.Set(cacheKey, cached, new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = ttl,
                Size = 1
            });
        }

        public void Dispose()
        {
            if (_disposed) return;
            _cache.Dispose();
            _disposed = true;
        }
    }

    #endregion
}
```