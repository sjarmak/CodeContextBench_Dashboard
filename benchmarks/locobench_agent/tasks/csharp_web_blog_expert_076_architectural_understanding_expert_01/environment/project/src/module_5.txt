```csharp
// File: src/module_5.txt  (TempoScribe Pro – Hexagonal Productivity Blog Suite)
// --------------------------------------------------------------------------------------------------------------------
// PURPOSE
// =======
// Production-grade implementation of the publishing-automation core service responsible for:
//  1. Discovering posts that are scheduled for release.
//  2. Transitioning eligible posts from “Scheduled” to “Published” atomically.
//  3. Emitting domain events that other adapters (e-mail, webhooks, analytics, caches) can react to.
//  4. Providing robust logging, observability, and fault-tolerance hooks.
//
// ARCHITECTURE NOTES
// ==================
// • Pure domain & application layer code ‑ no direct infrastructure references.
// • Talks only to PORTS: IPostRepository, IEventBus, IDateTimeProvider, IUnitOfWork.
// • Adapter implementations (EF Core, Dapper, MongoDB, Redis, RabbitMQ, etc.) plug in elsewhere.
// --------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Application.PublishingAutomation
{
    #region Domain Contracts (Ports)

    /// <summary>
    /// Abstraction over the persistence technology used to store Post aggregates.
    /// </summary>
    public interface IPostRepository
    {
        /// <summary>
        /// Retrieves all posts that should be published on or before <paramref name="asOf"/>.
        /// </summary>
        Task<IReadOnlyCollection<Post>> GetPostsPendingPublicationAsync(
            DateTimeOffset asOf,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Persists updated <see cref="Post"/> aggregates back to storage.
        /// </summary>
        Task SaveAsync(
            IEnumerable<Post> posts,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Provides an abstraction over the system clock, making temporal logic unit-test friendly.
    /// </summary>
    public interface IDateTimeProvider
    {
        DateTimeOffset UtcNow { get; }
    }

    /// <summary>
    /// Abstracts an event bus so the core can emit integration events without knowing the transport.
    /// </summary>
    public interface IEventBus
    {
        Task PublishAsync<TEvent>(
            TEvent @event,
            CancellationToken cancellationToken = default)
            where TEvent : IDomainEvent;
    }

    /// <summary>
    /// Unit-of-Work port to guarantee atomicity across multiple repositories where supported.
    /// </summary>
    public interface IUnitOfWork : IAsyncDisposable
    {
        Task CommitAsync(CancellationToken cancellationToken = default);
    }

    #endregion

    #region Domain Model & Events

    /// <summary>
    /// State diagram:
    /// Draft -> Scheduled -> Published -> Archived
    /// </summary>
    public enum PostStatus
    {
        Draft       = 0,
        Scheduled   = 1,
        Published   = 2,
        Archived    = 3
    }

    /// <summary>
    /// Aggregate root representing a blog post.
    /// </summary>
    public sealed class Post
    {
        private readonly List<IDomainEvent> _domainEvents = new();

        public Guid Id { get; private init; }
        public string Title { get; private set; } = string.Empty;
        public string Slug { get; private set; } = string.Empty;
        public PostStatus Status { get; private set; } = PostStatus.Draft;
        public DateTimeOffset? ScheduledPublishUtc { get; private set; }
        public DateTimeOffset? PublishedUtc { get; private set; }

        // EF-Core, Dapper, or serialization
        private Post() { }

        public Post(Guid id, string title, string slug)
        {
            Id   = id;
            Title = title;
            Slug  = slug;
        }

        public void Schedule(DateTimeOffset publishUtc)
        {
            if (Status != PostStatus.Draft)
                throw new DomainException("Only draft posts can be scheduled.");

            ScheduledPublishUtc = publishUtc;
            Status              = PostStatus.Scheduled;
        }

        public void Publish(IDateTimeProvider clock)
        {
            if (Status != PostStatus.Scheduled)
                throw new DomainException("Only scheduled posts can be published.");

            if (clock.UtcNow < ScheduledPublishUtc)
                throw new DomainException("Cannot publish before scheduled time.");

            PublishedUtc = clock.UtcNow;
            Status       = PostStatus.Published;
            RaiseDomainEvent(new PostPublishedEvent(Id, PublishedUtc.Value));
        }

        public IReadOnlyCollection<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

        public void ClearDomainEvents() => _domainEvents.Clear();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RaiseDomainEvent(IDomainEvent evt) => _domainEvents.Add(evt);
    }

    /// <summary>
    /// Marker interface for Domain Events (DDD).
    /// </summary>
    public interface IDomainEvent { }

    /// <summary>
    /// Fired whenever a post becomes publicly available.
    /// </summary>
    /// <param name="postId">Identifier of the published post.</param>
    /// <param name="publishedAt">Moment the post was published in UTC.</param>
    public record PostPublishedEvent(Guid PostId, DateTimeOffset PublishedAtUtc) : IDomainEvent;

    /// <summary>
    /// Domain-level exception.
    /// </summary>
    public sealed class DomainException : Exception
    {
        public DomainException(string message) : base(message) { }
    }

    #endregion

    #region Application Service

    /// <summary>
    /// Application-layer service orchestrating the scheduled publishing workflow.
    /// </summary>
    public interface IScheduledPublishingService
    {
        /// <summary>
        /// Synchronously processes all posts that are due to be published at this moment.
        /// </summary>
        Task<int> PublishDuePostsAsync(CancellationToken cancellationToken = default);
    }

    /// <inheritdoc />
    public sealed class ScheduledPublishingService : IScheduledPublishingService
    {
        private const int MaxBatchSize = 250; // Fail-fast boundary to protect downstream resources.

        private readonly IPostRepository   _postRepository;
        private readonly IEventBus         _eventBus;
        private readonly IDateTimeProvider _clock;
        private readonly IUnitOfWork       _uow;
        private readonly ILogger<ScheduledPublishingService> _logger;

        public ScheduledPublishingService(
            IPostRepository   postRepository,
            IEventBus         eventBus,
            IDateTimeProvider clock,
            IUnitOfWork       uow,
            ILogger<ScheduledPublishingService> logger)
        {
            _postRepository = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _eventBus       = eventBus        ?? throw new ArgumentNullException(nameof(eventBus));
            _clock          = clock           ?? throw new ArgumentNullException(nameof(clock));
            _uow            = uow             ?? throw new ArgumentNullException(nameof(uow));
            _logger         = logger          ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Publishes all posts whose scheduled timestamp is equal or earlier than the current time.
        /// Uses a defensive batching approach to minimise contention and avoid OOM on massive queues.
        /// </summary>
        public async Task<int> PublishDuePostsAsync(CancellationToken cancellationToken = default)
        {
            var now = _clock.UtcNow;

            _logger.LogInformation(
                "ScheduledPublishingService scanning for publications due at {PublicationTime:u}", now);

            var candidates = await _postRepository.GetPostsPendingPublicationAsync(now, cancellationToken);

            if (!candidates.Any())
            {
                _logger.LogDebug("No posts to publish at {Moment:u}", now);
                return 0;
            }

            // We only take up to MaxBatchSize – additional items will be processed by the next run.
            var batch = candidates
                .OrderBy(p => p.ScheduledPublishUtc ?? DateTimeOffset.MinValue)
                .Take(MaxBatchSize)
                .ToArray();

            _logger.LogInformation("Discovered {Count} post(s) eligible for publication", batch.Length);

            foreach (var post in batch)
            {
                try
                {
                    post.Publish(_clock);
                }
                catch (DomainException dex)
                {
                    _logger.LogWarning(
                        dex,
                        "Domain rules prevented publication of Post[{PostId}] – {@Post}",
                        post.Id,
                        post);
                }
                catch (Exception ex)
                {
                    _logger.LogError(
                        ex,
                        "Unexpected error while publishing Post[{PostId}] – Service will continue processing others",
                        post.Id);
                }
            }

            // Persist all mutated aggregates atomically.
            await _postRepository.SaveAsync(batch, cancellationToken);

            // Commit eventual cross-repository work.
            await _uow.CommitAsync(cancellationToken);

            // Dispatch domain events outside the transactional boundary.
            foreach (var @event in batch.SelectMany(p => p.DomainEvents))
            {
                try
                {
                    await _eventBus.PublishAsync(@event, cancellationToken);
                }
                catch (Exception ex)
                {
                    _logger.LogError(
                        ex,
                        "Failed to publish event {@Event} for Post[{PostId}]",
                        @event,
                        ( @event as PostPublishedEvent )?.PostId);
                }
            }

            // Clear the events to avoid duplicate dispatching if the aggregate is rehydrated later.
            foreach (var post in batch)
                post.ClearDomainEvents();

            _logger.LogInformation("Publishing pipeline completed – {Count} post(s) processed", batch.Length);

            return batch.Length;
        }
    }

    #endregion
}
```