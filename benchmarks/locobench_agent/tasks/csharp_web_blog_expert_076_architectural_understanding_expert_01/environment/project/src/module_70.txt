```csharp
// ==============================================================================
// TempoScribe Pro â€“ Hexagonal Productivity Blog Suite (web_blog)
// File: src/module_70.txt (Analytics Service & Redis Cache Adapter)
// Language: C#
//
// Purpose:
//     Exposes a port/service for recording editorial analytics events and
//     retrieving cached post summaries through a hexagonal architecture.
//     Includes an adapter backed by Redis for low-latency caching.
//
// NOTE:
//     In a full solution each type would live in its own file/folder that
//     respects the Ports & Adapters structure.  Consolidated here for brevity.
// ==============================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using StackExchange.Redis;

namespace TempoScribePro.Analytics
{
    #region Domain Core & Ports
    /// <summary>
    /// Enumeration of all analytics signals the system can track.
    /// </summary>
    public enum AnalyticsEventType
    {
        PostViewed,
        PostLiked,
        CommentAdded,
        DraftSaved,
        WorkSessionStarted,
        WorkSessionEnded
    }

    /// <summary>
    /// Immutable value object representing an editorial analytics event.
    /// </summary>
    /// <param name="EventId">Uniquely identifies the event.</param>
    /// <param name="EventType">Type of event.</param>
    /// <param name="PostId">Id of the related post (if any).</param>
    /// <param name="UserId">Id of the user that triggered the event.</param>
    /// <param name="OccurredAt">When the event happened (UTC).</param>
    /// <param name="MetadataJson">Optional JSON payload for extra context.</param>
    public sealed record AnalyticsEvent(
        Guid EventId,
        AnalyticsEventType EventType,
        Guid? PostId,
        Guid? UserId,
        DateTime OccurredAt,
        string? MetadataJson);

    /// <summary>
    /// Aggregate summary for a post across a time window.
    /// </summary>
    /// <param name="PostId">Post identifier.</param>
    /// <param name="From">Inclusive lower bound.</param>
    /// <param name="To">Exclusive upper bound.</param>
    /// <param name="Views">Number of views.</param>
    /// <param name="Likes">Number of likes.</param>
    /// <param name="Comments">Number of comments.</param>
    public sealed record PostAnalyticsSummary(
        Guid PostId,
        DateTime From,
        DateTime To,
        int Views,
        int Likes,
        int Comments);

    /// <summary>
    /// Port for persisting and querying raw analytics events.
    /// </summary>
    public interface IAnalyticsRepository
    {
        Task SaveAsync(
            AnalyticsEvent analyticEvent,
            CancellationToken ct = default);

        Task<IReadOnlyList<AnalyticsEvent>> GetEventsAsync(
            Guid postId,
            DateTime from,
            DateTime to,
            CancellationToken ct = default);
    }

    /// <summary>
    /// Port for application-level caching.
    /// </summary>
    public interface IAnalyticsCache
    {
        Task<T?> GetOrAddAsync<T>(
            string cacheKey,
            Func<Task<T>> factory,
            TimeSpan ttl,
            CancellationToken ct = default);

        Task InvalidateAsync(
            string cacheKeyPattern,
            CancellationToken ct = default);
    }
    #endregion

    #region Service Layer
    /// <summary>
    /// Service orchestrating editorial analytics logic.
    /// </summary>
    public interface IEditorialAnalyticsService
    {
        Task RecordEventAsync(
            AnalyticsEventType eventType,
            Guid? postId,
            Guid? userId,
            string? metadataJson = null,
            CancellationToken ct = default);

        Task<PostAnalyticsSummary> GetPostSummaryAsync(
            Guid postId,
            DateTime from,
            DateTime to,
            CancellationToken ct = default);
    }

    internal sealed class EditorialAnalyticsService : IEditorialAnalyticsService
    {
        private const string CacheKeyTemplate = "analytics:post:{0}:from:{1:yyyyMMddHHmmss}:to:{2:yyyyMMddHHmmss}";
        private readonly IAnalyticsRepository _repository;
        private readonly IAnalyticsCache _cache;
        private readonly ILogger<EditorialAnalyticsService> _logger;
        private readonly TimeSpan _summaryTtl = TimeSpan.FromMinutes(10);

        public EditorialAnalyticsService(
            IAnalyticsRepository repository,
            IAnalyticsCache cache,
            ILogger<EditorialAnalyticsService> logger)
        {
            _repository = repository ?? throw new ArgumentNullException(nameof(repository));
            _cache      = cache      ?? throw new ArgumentNullException(nameof(cache));
            _logger     = logger     ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task RecordEventAsync(
            AnalyticsEventType eventType,
            Guid? postId,
            Guid? userId,
            string? metadataJson = null,
            CancellationToken ct = default)
        {
            if (ct.IsCancellationRequested) return;

            var evt = new AnalyticsEvent(
                EventId: Guid.NewGuid(),
                EventType: eventType,
                PostId: postId,
                UserId: userId,
                OccurredAt: DateTime.UtcNow,
                MetadataJson: metadataJson);

            try
            {
                await _repository.SaveAsync(evt, ct).ConfigureAwait(false);

                // Bust any summary cache for the post because underlying events changed
                if (postId.HasValue)
                {
                    var pattern = $"analytics:post:{postId.Value}:*";
                    await _cache.InvalidateAsync(pattern, ct).ConfigureAwait(false);
                }

                _logger.LogDebug("Analytics event {EventId} persisted.", evt.EventId);
            }
            catch (Exception ex) when (!ex.IsFatal())
            {
                _logger.LogError(ex, "Failed to record analytics event {EventId}.", evt.EventId);
                throw;
            }
        }

        /// <inheritdoc />
        public Task<PostAnalyticsSummary> GetPostSummaryAsync(
            Guid postId,
            DateTime from,
            DateTime to,
            CancellationToken ct = default)
        {
            if (from >= to) throw new ArgumentException("`from` must be earlier than `to`.");

            var cacheKey = string.Format(CacheKeyTemplate, postId, from, to);

            return _cache.GetOrAddAsync(cacheKey,
                async () =>
                {
                    var events = await _repository
                        .GetEventsAsync(postId, from, to, ct)
                        .ConfigureAwait(false);

                    var summary = new PostAnalyticsSummary(
                        PostId: postId,
                        From: from,
                        To: to,
                        Views: events.Count(e => e.EventType == AnalyticsEventType.PostViewed),
                        Likes: events.Count(e => e.EventType == AnalyticsEventType.PostLiked),
                        Comments: events.Count(e => e.EventType == AnalyticsEventType.CommentAdded));

                    _logger.LogInformation("Computed analytics summary for Post {PostId} ({From}-{To}).",
                        postId, from, to);

                    return summary;
                },
                _summaryTtl,
                ct);
        }
    }
    #endregion

    #region Adapter: Redis Cache
    /// <summary>
    /// Redis-backed implementation of the analytics cache port.
    /// Uses StackExchange.Redis for high-performance networking.
    /// </summary>
    public sealed class RedisAnalyticsCacheAdapter : IAnalyticsCache, IDisposable
    {
        private readonly IDatabase _db;
        private readonly IConnectionMultiplexer _connection;
        private readonly ILogger<RedisAnalyticsCacheAdapter> _logger;
        private bool _disposed;

        public RedisAnalyticsCacheAdapter(
            string connectionString,
            ILogger<RedisAnalyticsCacheAdapter> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            try
            {
                _connection = ConnectionMultiplexer.Connect(connectionString);
                _db = _connection.GetDatabase();
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex, "Unable to connect to Redis at '{ConnectionString}'.", connectionString);
                throw;
            }
        }

        /// <inheritdoc />
        public async Task<T?> GetOrAddAsync<T>(
            string cacheKey,
            Func<Task<T>> factory,
            TimeSpan ttl,
            CancellationToken ct = default)
        {
            if (_disposed) throw new ObjectDisposedException(nameof(RedisAnalyticsCacheAdapter));
            if (string.IsNullOrWhiteSpace(cacheKey)) throw new ArgumentException("Cache key cannot be null or empty.");

            try
            {
                // Try to get from cache
                var cached = await _db.StringGetAsync(cacheKey).ConfigureAwait(false);
                if (cached.HasValue)
                {
                    return JsonSerializer.Deserialize<T>(cached!);
                }

                // Not found, compute via factory
                var result = await factory().ConfigureAwait(false);

                // Store if not canceled
                if (!ct.IsCancellationRequested)
                {
                    var serialized = JsonSerializer.Serialize(result);
                    await _db.StringSetAsync(cacheKey, serialized, ttl).ConfigureAwait(false);
                }

                return result;
            }
            catch (Exception ex) when (!ex.IsFatal())
            {
                _logger.LogError(ex, "Cache lookup failed for key '{CacheKey}'. Falling back to factory.", cacheKey);
                return await factory().ConfigureAwait(false);
            }
        }

        /// <inheritdoc />
        public async Task InvalidateAsync(string cacheKeyPattern, CancellationToken ct = default)
        {
            if (_disposed) throw new ObjectDisposedException(nameof(RedisAnalyticsCacheAdapter));
            if (string.IsNullOrWhiteSpace(cacheKeyPattern)) return;

            // WARNING: KEYS pattern is O(N). Suitable here due to narrow scope but
            // consider server-side Lua script or redis-cluster friendly approach in production.
            try
            {
                var server = GetServer();
                var keys = server.Keys(pattern: cacheKeyPattern);
                foreach (var key in keys)
                {
                    await _db.KeyDeleteAsync(key).ConfigureAwait(false);
                }
            }
            catch (Exception ex) when (!ex.IsFatal())
            {
                _logger.LogWarning(ex, "Cache invalidation failed for pattern '{Pattern}'.", cacheKeyPattern);
            }
        }

        private IServer GetServer()
        {
            // Use first endpoint for simplicity. Production code might do better selection.
            var endpoint = _connection.GetEndPoints().First();
            return _connection.GetServer(endpoint);
        }

        public void Dispose()
        {
            if (_disposed) return;
            _connection.Dispose();
            _disposed = true;
            GC.SuppressFinalize(this);
        }
    }
    #endregion

    #region Helper Extensions
    internal static class ExceptionExtensions
    {
        /// <summary>
        /// Determines if the exception represents a fatal/non-recoverable state.
        /// </summary>
        public static bool IsFatal(this Exception ex) =>
            ex is OutOfMemoryException or
                 StackOverflowException or
                 AccessViolationException;
    }
    #endregion
}
```