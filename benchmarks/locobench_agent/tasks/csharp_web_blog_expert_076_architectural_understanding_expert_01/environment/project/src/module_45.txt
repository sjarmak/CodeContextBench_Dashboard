```csharp
// File: src/module_45.txt
// Project: TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// Language: C# (target framework: .NET 6.0)
//
// Purpose:
//     Provides an adapter‐side implementation for scheduled publishing using Quartz.NET.
//     Exposes the domain port IPublishScheduler and an in‐memory fallback in case
//     Quartz cannot be reached (e.g., in unit tests or disconnected execution).
//
// NuGet dependencies (declared in csproj elsewhere):
//     - Quartz (>= 3.4.0)
//     - Microsoft.Extensions.Logging.Abstractions (>= 6.0.0)

using System;
using System.Collections.Concurrent;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Quartz;
using Quartz.Impl.Matchers;
using Quartz.Spi;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Adapters.Scheduling
{
    #region Domain Contracts (Ports)

    /// <summary>
    /// Value object wrapper for a post identifier.
    /// </summary>
    public readonly record struct PostId(Guid Value)
    {
        public override string ToString() => Value.ToString("N", CultureInfo.InvariantCulture);

        public static PostId New() => new PostId(Guid.NewGuid());
    }

    /// <summary>
    /// Port that the domain layer uses to schedule or cancel future publications.
    /// </summary>
    public interface IPublishScheduler
    {
        /// <summary>
        /// Schedules a post to be published at a specific moment in UTC.
        /// If a schedule already exists it is replaced.
        /// </summary>
        Task SchedulePostAsync(PostId postId, DateTime utcPublishAt, CancellationToken ct = default);

        /// <summary>
        /// Cancels a previously scheduled publication (if any).
        /// </summary>
        Task CancelScheduledPostAsync(PostId postId, CancellationToken ct = default);
    }

    #endregion

    #region Quartz Adapter

    /// <summary>
    /// Quartz‐powered implementation of <see cref="IPublishScheduler"/>.
    /// </summary>
    public sealed class QuartzPublishScheduler : IPublishScheduler
    {
        private readonly IScheduler _scheduler;
        private readonly ILogger<QuartzPublishScheduler> _logger;

        public QuartzPublishScheduler(IScheduler scheduler, ILogger<QuartzPublishScheduler>? logger = null)
        {
            _scheduler = scheduler ?? throw new ArgumentNullException(nameof(scheduler));
            _logger    = logger     ?? Microsoft.Extensions.Logging.Abstractions.NullLogger<QuartzPublishScheduler>.Instance;
        }

        public async Task SchedulePostAsync(PostId postId, DateTime utcPublishAt, CancellationToken ct = default)
        {
            if (utcPublishAt.Kind != DateTimeKind.Utc)
                throw new ArgumentException("utcPublishAt must be expressed in UTC.", nameof(utcPublishAt));

            var job     = CreateJobDetail(postId);
            var trigger = CreateTrigger(postId, utcPublishAt);

            await _scheduler.ScheduleJob(job, new[] { trigger }, true, ct);

            _logger.LogInformation(
                "Scheduled post {PostId} for publication at {PublishAt:o} (UTC).", 
                postId, utcPublishAt);
        }

        public async Task CancelScheduledPostAsync(PostId postId, CancellationToken ct = default)
        {
            var jobKey   = JobKeyFor(postId);
            var jobGroup = JobGroupFor(postId);

            // Only delete job if matching group exists to avoid wiping out unrelated jobs.
            if (await _scheduler.CheckExists(jobKey, ct))
            {
                await _scheduler.DeleteJob(jobKey, ct);
                _logger.LogInformation("Cancelled scheduled publication for post {PostId}.", postId);
            }
            else
            {
                _logger.LogDebug(
                    "No scheduled publication found to cancel for post {PostId}.", postId);
            }

            // Clean up orphaned triggers (defensive).
            var matcher = GroupMatcher<TriggerKey>.GroupEquals(jobGroup);
            foreach (var triggerKey in await _scheduler.GetTriggerKeys(matcher, ct))
            {
                await _scheduler.UnscheduleJob(triggerKey, ct);
            }
        }

        #region Helpers

        private static IJobDetail CreateJobDetail(PostId postId)
        {
            return JobBuilder.Create<PublishJob>()
                             .WithIdentity(JobKeyFor(postId))
                             .UsingJobData(PublishJob.JobDataPostIdKey, postId.ToString())
                             .StoreDurably(false)
                             .RequestRecovery(true)
                             .Build();
        }

        private static ITrigger CreateTrigger(PostId postId, DateTime utcPublishAt)
        {
            return TriggerBuilder.Create()
                                 .WithIdentity(TriggerKeyFor(postId))
                                 .StartAt(utcPublishAt)
                                 .WithSimpleSchedule(x => x.WithMisfireHandlingInstructionFireNow())
                                 .ForJob(JobKeyFor(postId))
                                 .Build();
        }

        private static string JobGroupFor(PostId postId)     => $"post-{postId}";
        private static JobKey JobKeyFor(PostId postId)       => new($"publish-{postId}", JobGroupFor(postId));
        private static TriggerKey TriggerKeyFor(PostId postId) => new($"trigger-{postId}", JobGroupFor(postId));

        #endregion
    }

    /// <summary>
    /// Quartz job responsible for delegating the actual publish operation.
    /// It pushes an integration event onto the internal event bus, or invokes
    /// an application service, depending on the configured delegate.
    /// </summary>
    public sealed class PublishJob : IJob
    {
        public const string JobDataPostIdKey = "PostId";

        private readonly IPublishCommand _publishCommand;
        private readonly ILogger<PublishJob> _logger;

        public PublishJob(IPublishCommand publishCommand, ILogger<PublishJob>? logger = null)
        {
            _publishCommand = publishCommand 
                              ?? throw new ArgumentNullException(nameof(publishCommand));
            _logger         = logger 
                              ?? Microsoft.Extensions.Logging.Abstractions.NullLogger<PublishJob>.Instance;
        }

        public async Task Execute(IJobExecutionContext context)
        {
            var postIdRaw = context.MergedJobDataMap.GetString(JobDataPostIdKey);

            if (!Guid.TryParse(postIdRaw, out var guid))
            {
                _logger.LogError(
                    "PublishJob aborted – invalid PostId in JobData: {PostIdRaw}", postIdRaw);
                return;
            }

            var postId = new PostId(guid);

            _logger.LogInformation(
                "Executing scheduled publication for post {PostId} at {FireTimeUtc:o}.",
                postId, context.FireTimeUtc?.UtcDateTime);

            try
            {
                await _publishCommand.PublishAsync(postId, context.CancellationToken);
            }
            catch (Exception ex)
            {
                // Rethrow to let Quartz trigger retry policies if configured.
                _logger.LogError(ex, "Publishing failed for post {PostId}. Scheduling retry.", postId);
                throw;
            }
        }
    }

    #endregion

    #region Fallback/In-Memory Adapter

    /// <summary>
    /// Minimal in‐memory scheduling implementation intended for unit tests or
    /// single‐process execution environments where Quartz is unavailable.
    /// </summary>
    public sealed class InMemoryPublishScheduler : IPublishScheduler, IDisposable
    {
        private readonly ConcurrentDictionary<PostId, Timer> _timers  = new();
        private readonly IPublishCommand                     _command;
        private readonly ILogger<InMemoryPublishScheduler>    _logger;

        public InMemoryPublishScheduler(
            IPublishCommand command,
            ILogger<InMemoryPublishScheduler>? logger = null)
        {
            _command = command 
                       ?? throw new ArgumentNullException(nameof(command));
            _logger  = logger 
                       ?? Microsoft.Extensions.Logging.Abstractions.NullLogger<InMemoryPublishScheduler>.Instance;
        }

        public Task SchedulePostAsync(PostId postId, DateTime utcPublishAt, CancellationToken ct = default)
        {
            if (utcPublishAt.Kind != DateTimeKind.Utc)
                throw new ArgumentException("utcPublishAt must be expressed in UTC.", nameof(utcPublishAt));

            // Dispose previous timer if we are rescheduling.
            if (_timers.TryRemove(postId, out var existing))
                existing.Dispose();

            var delay = utcPublishAt - DateTime.UtcNow;
            if (delay < TimeSpan.Zero)
                delay = TimeSpan.Zero; // Fire ASAP if in the past.

            var timer = new Timer(async _ => await ExecutePublishAsync(postId),
                                  null,
                                  delay,
                                  Timeout.InfiniteTimeSpan);

            _timers[postId] = timer;
            _logger.LogInformation("In-memory scheduled post {PostId} at {PublishAt:o}.", postId, utcPublishAt);

            return Task.CompletedTask;
        }

        public Task CancelScheduledPostAsync(PostId postId, CancellationToken ct = default)
        {
            if (_timers.TryRemove(postId, out var timer))
            {
                timer.Dispose();
                _logger.LogInformation("Cancelled in-memory scheduled post {PostId}.", postId);
            }

            return Task.CompletedTask;
        }

        private async Task ExecutePublishAsync(PostId postId)
        {
            try
            {
                await _command.PublishAsync(postId);
                _logger.LogInformation("In-memory executed publication for post {PostId}.", postId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "In-memory publication failed for post {PostId}.", postId);
            }
            finally
            {
                // Clean up timer to prevent memory leaks.
                CancelScheduledPostAsync(postId).GetAwaiter().GetResult();
            }
        }

        public void Dispose()
        {
            foreach (var kvp in _timers)
                kvp.Value.Dispose();
            _timers.Clear();
        }
    }

    #endregion

    #region Internal Commands

    /// <summary>
    /// Application service (or domain use‐case) responsible for publishing a post
    /// immediately.  Abstraction allows the scheduler to stay isolated.
    /// </summary>
    public interface IPublishCommand
    {
        /// <summary>
        /// Executes an immediate publish operation, regardless of current status.
        /// </summary>
        Task PublishAsync(PostId postId, CancellationToken ct = default);
    }

    #endregion
}
```