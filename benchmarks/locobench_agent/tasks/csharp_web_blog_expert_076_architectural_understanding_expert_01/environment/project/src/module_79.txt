```csharp
// -----------------------------------------------------------------------------
// File:        src/module_79.cs      (module_79.txt in original manifest)
// Project:     TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// Purpose:     Redis-backed adapter for the Live-Preview Diff Cache
// -----------------------------------------------------------------------------

using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;
using StackExchange.Redis;
using TempoScribePro.Domain.Ports;

namespace TempoScribePro.Infrastructure.Adapters.Caching
{
    /// <summary>
    /// Redis implementation of <see cref="IPreviewCache"/>.  
    /// Treats each post’s diff preview as an independent cache entry with configurable TTL.
    /// Conforms to Hexagonal Architecture by residing in the infrastructure <i>Adapter</i> layer.
    /// </summary>
    public sealed class RedisPreviewCacheAdapter : IPreviewCache, IAsyncDisposable
    {
        private const string KeyPrefix = "preview_diff:";

        private readonly IConnectionMultiplexer _redis;
        private readonly IDatabase _db;
        private readonly ILogger<RedisPreviewCacheAdapter> _logger;
        private readonly JsonSerializerOptions _jsonOptions;
        private bool _disposed;

        public RedisPreviewCacheAdapter(
            IConnectionMultiplexer redis,
            ILogger<RedisPreviewCacheAdapter> logger,
            JsonSerializerOptions? jsonOptions = null)
        {
            _redis = redis ?? throw new ArgumentNullException(nameof(redis));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _jsonOptions = jsonOptions ?? new JsonSerializerOptions(JsonSerializerDefaults.Web);
            _db = _redis.GetDatabase();
        }

        /// <inheritdoc />
        public async Task StoreDiffAsync(
            Guid postId,
            string diffMarkdown,
            TimeSpan ttl,
            CancellationToken cancellationToken = default)
        {
            ThrowIfDisposed();

            if (postId == Guid.Empty)
                throw new ArgumentException("PostId cannot be empty.", nameof(postId));

            var key = BuildKey(postId);

            try
            {
                // Keep Redis I/O async-friendly by using ConfigureAwait(false) in library calls.
                var payload = JsonSerializer.Serialize(diffMarkdown, _jsonOptions);
                var setTask = _db.StringSetAsync(key, payload, ttl);

                using var reg = cancellationToken.Register(
                    () => _logger.LogWarning("StoreDiffAsync for Post {PostId} cancelled.", postId));

                if (!await setTask.ConfigureAwait(false))
                {
                    _logger.LogWarning("Failed to store preview diff for Post {PostId}", postId);
                }
            }
            catch (Exception ex) when (LogAndWrap(ex, nameof(StoreDiffAsync)))
            {
                /* will never get here */
            }
        }

        /// <inheritdoc />
        public async Task<string?> GetDiffAsync(
            Guid postId,
            CancellationToken cancellationToken = default)
        {
            ThrowIfDisposed();

            if (postId == Guid.Empty)
                throw new ArgumentException("PostId cannot be empty.", nameof(postId));

            var key = BuildKey(postId);

            try
            {
                var getTask = _db.StringGetAsync(key);

                using var reg = cancellationToken.Register(
                    () => _logger.LogDebug("GetDiffAsync for Post {PostId} cancelled.", postId));

                var redisValue = await getTask.ConfigureAwait(false);

                if (!redisValue.HasValue)
                    return null;

                return JsonSerializer.Deserialize<string>(redisValue!, _jsonOptions);
            }
            catch (Exception ex) when (LogAndWrap(ex, nameof(GetDiffAsync)))
            {
                return null; // Will never reach here; silence nullable warning.
            }
        }

        /// <inheritdoc />
        public async Task InvalidateDiffAsync(
            Guid postId,
            CancellationToken cancellationToken = default)
        {
            ThrowIfDisposed();

            if (postId == Guid.Empty)
                throw new ArgumentException("PostId cannot be empty.", nameof(postId));

            var key = BuildKey(postId);

            try
            {
                var deleteTask = _db.KeyDeleteAsync(key);

                using var reg = cancellationToken.Register(
                    () => _logger.LogDebug("InvalidateDiffAsync for Post {PostId} cancelled.", postId));

                await deleteTask.ConfigureAwait(false);
            }
            catch (Exception ex) when (LogAndWrap(ex, nameof(InvalidateDiffAsync)))
            {
                /* will never get here */
            }
        }

        // --------------- Private Helpers -------------------------------------

        private static string BuildKey(Guid postId) => $"{KeyPrefix}{postId:D}".ToLowerInvariant();

        private bool LogAndWrap(Exception ex, string methodName)
        {
            // Use filter exception handling to both log and rethrow a sanitized custom exception.
            _logger.LogError(ex, "RedisPreviewCacheAdapter.{Method} failed: {Message}", methodName, ex.Message);
            throw new PreviewCacheException(methodName, ex);
        }

        private void ThrowIfDisposed()
        {
            if (_disposed)
                throw new ObjectDisposedException(nameof(RedisPreviewCacheAdapter));
        }

        // --------------- IAsyncDisposable Implementation ---------------------

        public async ValueTask DisposeAsync()
        {
            if (_disposed) return;

            _disposed = true;

            try
            {
                if (_redis != null)
                    await _redis.CloseAsync(force: false).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Exception while disposing Redis connection.");
            }
        }
    }

    /// <summary>
    /// Custom exception used to wrap low-level Redis errors so that the domain
    /// remains infrastructure-agnostic.
    /// </summary>
    [SuppressMessage("Design", "CA1032:Implement standard exception constructors", Justification = "Simplified for adapter isolation.")]
    public sealed class PreviewCacheException : Exception
    {
        internal PreviewCacheException(string operation, Exception inner)
            : base($"Preview cache operation '{operation}' failed.", inner) { }
    }

    // --------------- Service Collection Extension ---------------------------

    /// <summary>
    /// Dependency-Injection helpers for wiring up RedisPreviewCacheAdapter.
    /// </summary>
    public static class PreviewCacheServiceCollectionExtensions
    {
        /// <summary>
        /// Registers <see cref="IPreviewCache"/> backed by StackExchange.Redis.
        /// </summary>
        public static IServiceCollection AddRedisPreviewCache(
            this IServiceCollection services,
            string configuration,
            Action<JsonSerializerOptions>? configureJson = null)
        {
            if (string.IsNullOrWhiteSpace(configuration))
                throw new ArgumentException("Redis configuration string cannot be null or blank.", nameof(configuration));

            services.AddSingleton<IConnectionMultiplexer>(_ =>
                ConnectionMultiplexer.Connect(configuration));

            services.AddSingleton(provider =>
            {
                var opts = new JsonSerializerOptions(JsonSerializerDefaults.Web);
                configureJson?.Invoke(opts);
                return opts;
            });

            services.AddSingleton<IPreviewCache, RedisPreviewCacheAdapter>();

            return services;
        }
    }
}

// -----------------------------------------------------------------------------
// Domain Port (defined in a separate assembly, included here for clarity only)
// -----------------------------------------------------------------------------
namespace TempoScribePro.Domain.Ports
{
    /// <summary>
    /// Hexagonal <b>Port</b> describing cache operations for post preview diffs.
    /// </summary>
    public interface IPreviewCache
    {
        /// <summary>
        /// Stores a Markdown diff for the specified post, respecting the given TTL.
        /// </summary>
        Task StoreDiffAsync(
            Guid postId,
            string diffMarkdown,
            TimeSpan ttl,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves the cached diff for a post or <c>null</c> if not present/expired.
        /// </summary>
        Task<string?> GetDiffAsync(
            Guid postId,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes the diff entry for the specified post, if it exists.
        /// </summary>
        Task InvalidateDiffAsync(
            Guid postId,
            CancellationToken cancellationToken = default);
    }
}
```