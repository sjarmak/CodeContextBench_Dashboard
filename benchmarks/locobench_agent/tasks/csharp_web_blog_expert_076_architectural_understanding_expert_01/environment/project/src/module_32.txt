```csharp
// File: src/module_32/ScheduledPublishingModule.cs
// Project: TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
//
// Purpose:
//     Core domain service that automates scheduled publishing of blog posts.
//     This module resides in the Domain Core and is technology-agnostic. All I/O
//     (databases, message queues, HTTP endpoints) is deferred to Ports that will
//     be implemented by Adapters elsewhere in the solution.
//
// Architectural role:
//     • Domain Service  (Service Layer / Hexagonal Ports & Adapters)
//     • Relies on Repository and Command Ports
//
// © TempoScribe Pro Contributors. Licensed under MIT.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace TempoScribePro.Core.Scheduling
{
    #region Value Objects & Entities -------------------------------------------------------------

    /// <summary>
    /// Represents a blog post that can be published.
    /// This is a minimal projection used by the scheduler. The full Post aggregate
    /// resides in TempoScribePro.Core.Publishing and is referenced here via the
    /// common IPostProjection interface to avoid cyclic dependencies.
    /// </summary>
    public interface IPostProjection
    {
        Guid      Id                 { get; }
        string    Slug               { get; }
        DateTime  ScheduledUtc       { get; }
        PostState State              { get; }
        bool      IsPremium          { get; }
        string?   AuthorId           { get; }
    }

    /// <summary>
    /// Canonical post states recognized by the scheduler.
    /// </summary>
    public enum PostState
    {
        Draft           = 0,
        Scheduled       = 1,
        Published       = 2,
        Archived        = 3,
        FailedPublish   = 4
    }

    /// <summary>
    /// Lightweight domain event raised whenever a post has been published (success or failure).
    /// </summary>
    public sealed class PostPublishedEvent
    {
        public PostPublishedEvent(Guid postId, PublishResult result, DateTime occurredUtc)
        {
            PostId      = postId;
            Result      = result;
            OccurredUtc = occurredUtc;
        }

        public Guid          PostId      { get; }
        public PublishResult Result      { get; }
        public DateTime      OccurredUtc { get; }
    }

    /// <summary>
    /// Result for a publish attempt.
    /// </summary>
    public enum PublishResult
    {
        Success,
        AlreadyPublished,
        WindowNotReached,
        Failure
    }

    #endregion

    #region Ports (Interfaces) -------------------------------------------------------------------

    /// <summary>
    /// Retrieves posts that are scheduled for publication.
    /// Concrete implementation lives in an adapter backed by the ORM-specific repository.
    /// </summary>
    public interface IScheduledPostRepository
    {
        /// <summary>
        /// Returns posts which are scheduled for publication before or at <paramref name="utcNow"/>.
        /// </summary>
        Task<IReadOnlyList<IPostProjection>> GetDuePostsAsync(DateTime utcNow, CancellationToken ct);
        
        Task SetPostStateAsync(Guid postId, PostState newState, CancellationToken ct);
    }

    /// <summary>
    /// Port used by the domain to publish a post.
    /// Adapter may call an internal API, issue a command on a message bus etc.
    /// </summary>
    public interface IPostPublishingCommandPort
    {
        Task<PublishResult> PublishAsync(Guid postId, CancellationToken ct);
    }

    /// <summary>
    /// Used by the domain to emit events in an infrastructure-agnostic way.
    /// </summary>
    public interface IDomainEventBus
    {
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct);
    }

    /// <summary>
    /// High-resolution time source to facilitate deterministic tests.
    /// </summary>
    public interface IDateTimeProvider
    {
        DateTime UtcNow { get; }
    }

    #endregion

    #region Domain Service -----------------------------------------------------------------------

    /// <summary>
    /// Automates the publication of scheduled posts.
    /// </summary>
    public sealed class ScheduledPublisherService
    {
        private readonly IScheduledPostRepository   _repository;
        private readonly IPostPublishingCommandPort _publisher;
        private readonly IDomainEventBus            _eventBus;
        private readonly IDateTimeProvider          _clock;

        /// <summary>
        /// Recommended batch size for repository queries. Value can be overridden by IoC.
        /// </summary>
        public int BatchSize { get; init; } = 50;

        /// <summary>
        /// Maximum tolerated consecutive failures before the service aborts the current run.
        /// Protects against infinite loops resulting from poisoned messages.
        /// </summary>
        public int FailureThreshold { get; init; } = 10;

        public ScheduledPublisherService(
            IScheduledPostRepository   repository,
            IPostPublishingCommandPort publisher,
            IDomainEventBus            eventBus,
            IDateTimeProvider          clock)
        {
            _repository = repository  ?? throw new ArgumentNullException(nameof(repository));
            _publisher  = publisher   ?? throw new ArgumentNullException(nameof(publisher));
            _eventBus   = eventBus    ?? throw new ArgumentNullException(nameof(eventBus));
            _clock      = clock       ?? throw new ArgumentNullException(nameof(clock));
        }

        /// <summary>
        /// Executes one run of the scheduler. Intended to be invoked by a cron job
        /// or background service every N seconds/minutes.
        /// 
        /// The method is idempotent: running it multiple times for the same time window
        /// will not double-publish a post.
        /// </summary>
        public async Task RunAsync(CancellationToken ct = default)
        {
            DateTime now = _clock.UtcNow;

            int consecutiveFailures = 0;

            while (true)
            {
                ct.ThrowIfCancellationRequested();

                IReadOnlyList<IPostProjection> due =
                    await _repository.GetDuePostsAsync(now, ct).ConfigureAwait(false);

                // Exit if no due posts.
                if (due.Count == 0) break;

                foreach (var post in due.Take(BatchSize))
                {
                    ct.ThrowIfCancellationRequested();

                    try
                    {
                        await HandleDuePostAsync(post, ct).ConfigureAwait(false);
                        consecutiveFailures = 0; // Reset
                    }
                    catch (Exception ex)
                    {
                        // We cannot depend on any specific logging framework inside the domain.
                        // Instead, we propagate the error as a domain event.
                        await _eventBus.PublishAsync(
                            new SchedulerErrorEvent(post.Id, ex, now),
                            ct).ConfigureAwait(false);

                        if (++consecutiveFailures >= FailureThreshold)
                        {
                            // Fail fast to prevent runaway loops.
                            throw new SchedulerAbortedException(
                                $"Scheduler aborted after {FailureThreshold} consecutive failures.",
                                ex);
                        }
                    }
                }

                // Loop again in case there are more due posts than BatchSize.
            }
        }

        private async Task HandleDuePostAsync(IPostProjection post, CancellationToken ct)
        {
            // Guards are intentionally explicit to make domain rules discoverable.
            if (post.State == PostState.Published)
            {
                await _eventBus.PublishAsync(
                    new PostPublishedEvent(post.Id, PublishResult.AlreadyPublished, _clock.UtcNow), ct);
                return;
            }

            if (post.ScheduledUtc > _clock.UtcNow.AddSeconds(-5)) // 5-second grace window
            {
                await _eventBus.PublishAsync(
                    new PostPublishedEvent(post.Id, PublishResult.WindowNotReached, _clock.UtcNow), ct);
                return;
            }

            PublishResult result = await _publisher.PublishAsync(post.Id, ct);

            // Update the state only when the action actually succeeded.
            if (result == PublishResult.Success)
            {
                await _repository.SetPostStateAsync(post.Id, PostState.Published, ct);
            }
            else if (result == PublishResult.Failure)
            {
                await _repository.SetPostStateAsync(post.Id, PostState.FailedPublish, ct);
            }

            await _eventBus.PublishAsync(
                new PostPublishedEvent(post.Id, result, _clock.UtcNow), ct);
        }
    }

    #endregion

    #region Domain Errors & Events ---------------------------------------------------------------

    /// <summary>
    /// Domain-level exception thrown when the scheduler deliberately aborts its run.
    /// Infrastructure should catch and log accordingly.
    /// </summary>
    public sealed class SchedulerAbortedException : Exception
    {
        public SchedulerAbortedException(string message, Exception? inner = null) : base(message, inner) { }
    }

    /// <summary>
    /// Emitted whenever an unexpected error occurs while processing a single post.
    /// Allows the infrastructure to persist the error details without the domain
    /// depending on a specific logging subsystem.
    /// </summary>
    public sealed class SchedulerErrorEvent
    {
        public SchedulerErrorEvent(Guid postId, Exception error, DateTime occurredUtc)
        {
            PostId      = postId;
            Error       = error;
            OccurredUtc = occurredUtc;
        }

        public Guid      PostId      { get; }
        public Exception Error       { get; }
        public DateTime  OccurredUtc { get; }
    }

    #endregion
}
```