```csharp
// src/module_50.txt  (tempo: 2024-05-10)
// NOTE: file extension retained as .txt to satisfy legacy tooling in build pipeline.
// -----------------------------------------------------------------------------
// This file belongs to the TempoScribe Pro – Hexagonal Productivity Blog Suite.
// It implements an analytics application-service that produces editor-centric
// efficiency metrics by projecting domain events. The service is 100 %
// technology-agnostic and communicates exclusively through well-defined ports
// (IEventStream, IAnalyticsRepository, ICacheProvider, ILogger).
// -----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using TempoScribePro.Core.Analytics.Contracts;
using TempoScribePro.Core.Analytics.Models;
using TempoScribePro.Core.Common;
using TempoScribePro.Core.Common.Exceptions;
using TempoScribePro.Core.Logging;

namespace TempoScribePro.Core.Analytics.Services
{
    /// <summary>
    /// Application-service that generates productivity metrics for editors.
    /// It scans an immutable event stream and projects a time-boxed report.
    /// Results are cached to avoid costly recomputations while still honoring
    /// short TTLs (default: 15 minutes) to keep dashboards fresh.
    /// </summary>
    internal sealed class EditorialAnalyticsService : IEditorialAnalyticsService
    {
        private const string CachePrefix = "analytics:editorial-efficiency:";
        private static readonly TimeSpan DefaultCacheTtl = TimeSpan.FromMinutes(15);

        private readonly IEventStream _eventStream;
        private readonly IAnalyticsRepository _repository;
        private readonly ICacheProvider _cache;
        private readonly ILogger _logger;

        public EditorialAnalyticsService(
            IEventStream eventStream,
            IAnalyticsRepository repository,
            ICacheProvider cacheProvider,
            ILogger logger)
        {
            _eventStream = eventStream ?? throw new ArgumentNullException(nameof(eventStream));
            _repository = repository ?? throw new ArgumentNullException(nameof(repository));
            _cache = cacheProvider ?? throw new ArgumentNullException(nameof(cacheProvider));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc/>
        public async Task<EditorialEfficiencyReport> GetEfficiencyReportAsync(
            DateTime fromUtc,
            DateTime toUtc,
            CancellationToken cancellationToken = default)
        {
            if (fromUtc > toUtc)
            {
                throw new ValidationException("'fromUtc' cannot be after 'toUtc'.");
            }

            var cacheKey = BuildCacheKey(fromUtc, toUtc);

            // 1. Try fast-path: return cached report if available.
            if (await _cache.TryGetAsync<EditorialEfficiencyReport>(cacheKey, cancellationToken) is { } cached)
            {
                _logger.Trace($"Cache hit for analytics report [{cacheKey}].");
                return cached;
            }

            // 2. Fallback: compute report by projecting events.
            _logger.Info($"Cache miss for analytics report [{cacheKey}] – recomputing.");

            var events = await _eventStream
                .ReadAsync(fromUtc, toUtc, cancellationToken)
                .ConfigureAwait(false);

            var report = ComputeReport(events, fromUtc, toUtc);

            // 3. Persist summary for historic querying (CQRS read-model).
            await _repository.UpsertAsync(report, cancellationToken);

            // 4. Cache for subsequent reads.
            await _cache.SetAsync(cacheKey, report, DefaultCacheTtl, cancellationToken);

            return report;
        }

        // --------------------------------------------------------------------
        // Helper methods
        // --------------------------------------------------------------------

        private static string BuildCacheKey(DateTime fromUtc, DateTime toUtc) =>
            $"{CachePrefix}{fromUtc:yyyyMMddHHmmss}:{toUtc:yyyyMMddHHmmss}";

        private static EditorialEfficiencyReport ComputeReport(
            IEnumerable<IEditorialEvent> events,
            DateTime fromUtc,
            DateTime toUtc)
        {
            // We rely on LINQ for in-memory projection because event counts per
            // timeframe are modest (<100k). For larger volumes consider
            // incremental snapshots or Map-Reduce.
            var groupedByPost = events
                .GroupBy(e => e.PostId)
                .ToArray();

            int totalPostsPublished = 0;
            double avgDraftIterations = 0;
            double avgTimeToPublishMinutes = 0;
            int totalWordsProduced = 0;

            foreach (var postEvents in groupedByPost)
            {
                var drafts = postEvents
                    .Where(e => e is DraftUpdatedEvent)
                    .Cast<DraftUpdatedEvent>()
                    .OrderBy(e => e.UtcTimestamp)
                    .ToList();

                var published = postEvents
                    .FirstOrDefault(e => e is PostPublishedEvent) as PostPublishedEvent;

                if (published != null)
                {
                    totalPostsPublished++;

                    if (drafts.Count > 0)
                    {
                        avgDraftIterations += drafts.Count;
                        avgTimeToPublishMinutes +=
                            (published.UtcTimestamp - drafts.First().UtcTimestamp).TotalMinutes;
                    }

                    totalWordsProduced += published.WordCount;
                }
            }

            if (totalPostsPublished > 0)
            {
                avgDraftIterations /= totalPostsPublished;
                avgTimeToPublishMinutes /= totalPostsPublished;
            }

            return new EditorialEfficiencyReport
            (
                ReportId: Guid.NewGuid(),
                From: fromUtc,
                To: toUtc,
                TotalPostsPublished: totalPostsPublished,
                AverageDraftIterations: Math.Round(avgDraftIterations, 2),
                AverageMinutesToPublish: Math.Round(avgTimeToPublishMinutes, 2),
                TotalWordsProduced: totalWordsProduced,
                GeneratedAtUtc: DateTime.UtcNow
            );
        }
    }
}

// ============================================================================
// Domain contracts below. These would normally live in separate files but are
// colocated here to keep this single-file sample self-contained.
// ============================================================================

namespace TempoScribePro.Core.Analytics.Contracts
{
    using System;
    using System.Threading;
    using System.Threading.Tasks;
    using TempoScribePro.Core.Analytics.Models;

    /// <summary>
    /// Port for the editorial analytics application-service.
    /// Exposed to the outside world (Adapters: REST, GraphQL, CLI, etc.).
    /// </summary>
    public interface IEditorialAnalyticsService
    {
        /// <summary>
        /// Generates a productivity efficiency report for a given time window.
        /// Intermediate results may be cached and/or persisted to a read-model.
        /// </summary>
        Task<EditorialEfficiencyReport> GetEfficiencyReportAsync(
            DateTime fromUtc,
            DateTime toUtc,
            CancellationToken cancellationToken = default);
    }
}

namespace TempoScribePro.Core.Analytics.Models
{
    using System;

    /// <summary>
    /// Immutable value-object exposing time-boxed efficiency metrics.
    /// </summary>
    public sealed record EditorialEfficiencyReport(
        Guid ReportId,
        DateTime From,
        DateTime To,
        int TotalPostsPublished,
        double AverageDraftIterations,
        double AverageMinutesToPublish,
        int TotalWordsProduced,
        DateTime GeneratedAtUtc);
}

namespace TempoScribePro.Core.Common
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Port that exposes an immutable stream of domain events to consumers.
    /// Adapters can back this with SQL, Kafka, EventStoreDB, etc.
    /// </summary>
    public interface IEventStream
    {
        Task<IReadOnlyList<IEditorialEvent>> ReadAsync(
            DateTime fromUtc,
            DateTime toUtc,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Port for short-lived caching. Adapters may delegate to Redis or MemoryCache.
    /// </summary>
    public interface ICacheProvider
    {
        Task<T?> TryGetAsync<T>(string key, CancellationToken cancellationToken = default)
            where T : class;

        Task SetAsync<T>(
            string key,
            T payload,
            TimeSpan ttl,
            CancellationToken cancellationToken = default);
    }
}

namespace TempoScribePro.Core.Logging
{
    /// <summary>
    /// Slim logger abstraction decoupled from any logging framework.
    /// </summary>
    public interface ILogger
    {
        void Trace(string message);
        void Info(string message);
        void Warn(string message, Exception? ex = null);
        void Error(string message, Exception ex);
    }
}

namespace TempoScribePro.Core.Analytics.Contracts
{
    using System.Threading;
    using System.Threading.Tasks;
    using TempoScribePro.Core.Analytics.Models;

    /// <summary>
    /// Port for persisting computed analytics results (CQRS read-model).
    /// </summary>
    public interface IAnalyticsRepository
    {
        Task UpsertAsync(
            EditorialEfficiencyReport report,
            CancellationToken cancellationToken = default);
    }
}

namespace TempoScribePro.Core.Common.Exceptions
{
    using System;
    using System.Runtime.Serialization;

    [Serializable]
    public sealed class ValidationException : Exception
    {
        public ValidationException(string message) : base(message) { }

        private ValidationException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }
    }
}

namespace TempoScribePro.Core.Common
{
    /// <summary>
    /// Marker interface for editorial domain events.
    /// </summary>
    public interface IEditorialEvent
    {
        Guid EventId { get; }
        Guid PostId { get; }
        DateTime UtcTimestamp { get; }
    }

    // Sample events used by analytics projection.
    public sealed record DraftUpdatedEvent(
        Guid EventId,
        Guid PostId,
        DateTime UtcTimestamp) : IEditorialEvent;

    public sealed record PostPublishedEvent(
        Guid EventId,
        Guid PostId,
        DateTime UtcTimestamp,
        int WordCount) : IEditorialEvent;
}
```