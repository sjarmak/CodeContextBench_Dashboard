```csharp
// -----------------------------------------------------------------------------
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// File:       src/module_1.txt  (Domain Core / Monetization Module)
// Language:   C# 11
// Purpose:    Core monetization engine (technology-agnostic, ports & adapters)
// -----------------------------------------------------------------------------

#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Monetization
{
    /// <summary>
    /// The public‐facing contract that any payment gateway adapter (e.g. Stripe,
    /// Braintree, PayPal) must implement.  This is a Port in the Hexagonal sense.
    /// </summary>
    public interface IPaymentGatewayPort
    {
        Task<PaymentIntent> CreatePaymentIntentAsync(
            Money amount,
            string currency,
            string customerId,
            CancellationToken cancellationToken = default);

        Task<PaymentReceipt> CaptureAsync(
            Guid intentId,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Persistence port for reading/writing monetization rules.  Backed by an
    /// adapter (e.g., EF Core, Dapper, Document DB).
    /// </summary>
    public interface IMonetizationRuleRepositoryPort
    {
        Task<IReadOnlyCollection<MonetizationRule>> GetActiveRulesAsync(
            Guid blogId,
            DateTimeOffset asOf,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Value Object representing a monetary amount.
    /// </summary>
    public sealed record Money(decimal Amount)
    {
        public static readonly Money Zero = new(0m);

        public static Money operator +(Money a, Money b) => new(a.Amount + b.Amount);
        public static Money operator -(Money a, Money b) => new(a.Amount - b.Amount);
        public static Money operator *(Money a, decimal multiplier) => new(a.Amount * multiplier);
    }

    /// <summary>
    /// Well-known rule types in TempoScribe Pro.
    /// </summary>
    public enum RuleKind
    {
        /// <summary>
        /// Viewer must pay a single one-off amount to unlock the post.
        /// </summary>
        PayPerPost = 1,

        /// <summary>
        /// Requires a paid subscription (recurring) – handled upstream.
        /// </summary>
        SubscriptionRequired = 2,

        /// <summary>
        /// No payment required, but still tracked for analytics.
        /// </summary>
        Free = 3
    }

    /// <summary>
    /// Aggregate Root representing a monetization rule.
    /// </summary>
    public sealed class MonetizationRule
    {
        public Guid Id { get; }
        public Guid BlogId { get; }
        public RuleKind Kind { get; }
        public Money Price { get; }
        public DateTimeOffset StartsAt { get; }
        public DateTimeOffset? EndsAt { get; }
        public bool IsActive(DateTimeOffset at) => StartsAt <= at && (EndsAt == null || at <= EndsAt);

        public MonetizationRule(
            Guid id,
            Guid blogId,
            RuleKind kind,
            Money price,
            DateTimeOffset startsAt,
            DateTimeOffset? endsAt)
        {
            Id = id;
            BlogId = blogId;
            Kind = kind;
            Price = price;
            StartsAt = startsAt;
            EndsAt = endsAt;
        }
    }

    /// <summary>
    /// Lightweight DTO containing the results of rule evaluation.
    /// </summary>
    public sealed record PriceQuote(
        RuleKind Kind,
        Money Amount,
        string Currency);

    /// <summary>
    /// Payment intent returned by the gateway; domain core keeps it opaque.
    /// </summary>
    public sealed record PaymentIntent(Guid Id, string ClientSecret);

    /// <summary>
    /// Receipt returned by the gateway after capture.
    /// </summary>
    public sealed record PaymentReceipt(Guid ReceiptId, DateTimeOffset CapturedAtUtc);

    /// <summary>
    /// Domain service that evaluates monetization rules and orchestrates payment.
    /// </summary>
    public sealed class MonetizationService
    {
        private readonly IMonetizationRuleRepositoryPort _ruleRepository;
        private readonly IPaymentGatewayPort _paymentGateway;
        private readonly ILogger<MonetizationService> _logger;

        public MonetizationService(
            IMonetizationRuleRepositoryPort ruleRepository,
            IPaymentGatewayPort paymentGateway,
            ILogger<MonetizationService> logger)
        {
            _ruleRepository = ruleRepository ?? throw new ArgumentNullException(nameof(ruleRepository));
            _paymentGateway = paymentGateway ?? throw new ArgumentNullException(nameof(paymentGateway));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Determines the price a given reader must pay to unlock a post.
        /// </summary>
        /// <remarks>
        /// The method is pure (does not touch the gateway).  Caching adapters
        /// may memoize the result for efficiency.
        /// </remarks>
        public async Task<PriceQuote> QuoteAsync(
            Guid blogId,
            string currency,
            DateTimeOffset at,
            CancellationToken ct = default)
        {
            // 1. Pull active rules
            var rules = await _ruleRepository.GetActiveRulesAsync(blogId, at, ct);

            if (rules.Count == 0)
            {
                _logger.LogWarning("No active monetization rules found for blog {BlogId}", blogId);
                return new PriceQuote(RuleKind.Free, Money.Zero, currency);
            }

            // 2. Business rule: prefer the most specific rule by precedence order.
            //    For MVP: PayPerPost > SubscriptionRequired > Free
            var ordered = rules
                .Where(r => r.IsActive(at))
                .OrderBy(r => r.Kind switch
                {
                    RuleKind.PayPerPost        => 1,
                    RuleKind.SubscriptionRequired => 2,
                    RuleKind.Free              => 3,
                    _                          => 99
                })
                .ToList();

            var selected = ordered.FirstOrDefault();

            if (selected is null)
            {
                _logger.LogInformation("All rules inactive, treating as Free content for blog {BlogId}", blogId);
                return new PriceQuote(RuleKind.Free, Money.Zero, currency);
            }

            _logger.LogDebug(
                "Selected monetization rule {RuleId} (Kind {Kind}) for blog {BlogId}",
                selected.Id, selected.Kind, blogId);

            return new PriceQuote(selected.Kind, selected.Price, currency);
        }

        /// <summary>
        /// Creates a payment intent and returns the opaque client secret.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// Thrown when the quoted price does not match the rule at capture time.
        /// </exception>
        public async Task<PaymentIntent> CreatePaymentIntentAsync(
            Guid blogId,
            string currency,
            string customerId,
            DateTimeOffset at,
            CancellationToken ct = default)
        {
            var quote = await QuoteAsync(blogId, currency, at, ct);
            if (quote.Kind is RuleKind.Free)
            {
                throw new InvalidOperationException("Attempted to create payment intent for a free post.");
            }

            Money amount = quote.Amount;
            if (amount.Amount <= 0)
            {
                _logger.LogError(
                    "Invalid quote amount {Amount} for blog {BlogId}",
                    amount.Amount, blogId);
                throw new InvalidOperationException("Quoted amount must be positive.");
            }

            _logger.LogInformation(
                "Creating payment intent for blog {BlogId} customer {CustomerId} amount {Amount} {Currency}",
                blogId, customerId, amount.Amount, currency);

            try
            {
                var intent = await _paymentGateway.CreatePaymentIntentAsync(
                    amount,
                    currency,
                    customerId,
                    ct);

                _logger.LogInformation(
                    "Payment intent {IntentId} created for blog {BlogId}",
                    intent.Id, blogId);

                return intent;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Failed to create payment intent for blog {BlogId} customer {CustomerId}",
                    blogId, customerId);
                throw; // Bubble up – application service can translate.
            }
        }

        /// <summary>
        /// Captures the previously created payment intent.
        /// </summary>
        public async Task<PaymentReceipt> CaptureAsync(
            Guid intentId,
            CancellationToken ct = default)
        {
            try
            {
                var receipt = await _paymentGateway.CaptureAsync(intentId, ct);
                _logger.LogInformation(
                    "Payment intent {IntentId} captured at {CapturedAt}",
                    intentId, receipt.CapturedAtUtc);
                return receipt;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Failed to capture payment intent {IntentId}",
                    intentId);
                throw;
            }
        }
    }
}
```