```csharp
// -----------------------------------------------------------------------------
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// File:     src/module_3.txt  (logical name: PublishingAutomationService.cs)
// Language: C# 10
//
// Description:
//   Core domain‐level service that is responsible for automatically publishing
//   scheduled posts and triggering the corresponding domain events.
//   Lives in the domain/core layer and depends only on ports (interfaces).
//
//   NOTE:  This file intentionally ships as *.txt so that the adapter layer can
//          decide at build time whether the implementation is compiled into a
//          serverless function, a hang-fire worker, or a console daemon.
//
// -----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using TempoScribePro.Core.Domain;
using TempoScribePro.Core.Exceptions;
using TempoScribePro.Core.Ports;
using TempoScribePro.SharedKernel;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Core.Services
{
    /// <summary>
    ///     Service responsible for orchestrating the automatic publishing of
    ///     scheduled posts.  Executes periodically via an adapter (e.g. cron,
    ///     Hangfire, Azure Function) and uses ports to remain infrastructure-
    ///     agnostic.
    /// </summary>
    public sealed class PublishingAutomationService : IPublishingAutomationService
    {
        private readonly IPostRepository          _postRepository;
        private readonly IEventPublisher          _eventPublisher;
        private readonly IDateTimeProvider        _dateTimeProvider;
        private readonly ILogger<PublishingAutomationService> _logger;

        public PublishingAutomationService(
            IPostRepository   postRepository,
            IEventPublisher   eventPublisher,
            IDateTimeProvider dateTimeProvider,
            ILogger<PublishingAutomationService> logger)
        {
            _postRepository   = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _eventPublisher   = eventPublisher  ?? throw new ArgumentNullException(nameof(eventPublisher));
            _dateTimeProvider = dateTimeProvider ?? throw new ArgumentNullException(nameof(dateTimeProvider));
            _logger           = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task<int> ProcessScheduledPublishingAsync(CancellationToken cancellationToken = default)
        {
            // STEP 1: Fetch posts that are READY to be published.
            IReadOnlyCollection<Post> duePosts;
            var asOf = _dateTimeProvider.UtcNow;

            try
            {
                duePosts = await _postRepository
                    .GetScheduledPostsDueAsync(asOf, cancellationToken)
                    .ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Failed to query scheduled posts due as of {AsOf:u}", asOf);
                throw new PublishingAutomationException(
                    "Failed to query scheduled posts due.", ex);
            }

            if (duePosts.Count == 0)
            {
                _logger.LogDebug("No scheduled posts were due as of {AsOf:u}", asOf);
                return 0;
            }

            _logger.LogInformation("Found {Count} scheduled post(s) due for publishing.", duePosts.Count);

            // STEP 2: Iterate and publish each post atomically.
            var publishedCount = 0;

            foreach (var post in duePosts)
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (!post.CanBePublished())
                {
                    _logger.LogWarning("Post {PostId} was returned as scheduled but cannot be published due to state {State}.",
                        post.Id, post.Status);
                    continue;
                }

                try
                {
                    PublishPostDomainLogic(post, asOf);

                    await _postRepository
                        .UpdateAsync(post, cancellationToken)
                        .ConfigureAwait(false);

                    await _eventPublisher
                        .PublishAsync(new ScheduledPostPublishedEvent(post.Id, post.Slug, post.PublishedUtc!.Value))
                        .ConfigureAwait(false);

                    publishedCount++;
                    _logger.LogInformation("Successfully published Post {PostId}.", post.Id);
                }
                catch (ConcurrencyException ex)
                {
                    // Another worker beat us to it—log at debug and move on.
                    _logger.LogDebug(ex,
                        "Concurrency conflict encountered while publishing Post {PostId}. " +
                        "It was likely published by another process.", post.Id);
                }
                catch (Exception ex)
                {
                    // We keep looping instead of failing the entire batch, but bubble-up at the end.
                    _logger.LogError(ex,
                        "Unexpected error occurred while publishing Post {PostId}.", post.Id);
                    throw new PublishingAutomationException(
                        $"Failed to publish Post {post.Id}.", ex);
                }
            }

            _logger.LogInformation("Publishing automation completed. {PublishedCount} post(s) published.", publishedCount);
            return publishedCount;
        }

        #region Private Helpers

        private static void PublishPostDomainLogic(Post post, DateTimeOffset asOfUtc)
        {
            // Move state machine from 'Scheduled' to 'Published'.
            post.PublishedUtc = asOfUtc;
            post.Status       = PostStatus.Published;

            // Add audit trail entry for editors.
            post.AddAuditLogEntry(
                $"Automated publish at {asOfUtc:u} by PublishingAutomationService.");
        }

        #endregion
    }

    // -------------------------------------------------------------------------
    // PORT INTERFACES — Part of the domain layer, implemented by adapters.
    // -------------------------------------------------------------------------

    public interface IPublishingAutomationService
    {
        /// <summary>
        ///     Publishes all posts whose <see cref="Post.PublishAtUtc" /> is
        ///     less than or equal to <see cref="IDateTimeProvider.UtcNow" />.
        /// </summary>
        /// <returns>The number of posts published.</returns>
        Task<int> ProcessScheduledPublishingAsync(CancellationToken cancellationToken = default);
    }

    public interface IPostRepository
    {
        /// <summary>
        ///     Returns posts that are scheduled and due for publishing.
        /// </summary>
        Task<IReadOnlyCollection<Post>> GetScheduledPostsDueAsync(
            DateTimeOffset asOfUtc,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     Persists the updated post state; throws <see cref="ConcurrencyException" />
        ///     if the optimistic concurrency token is stale.
        /// </summary>
        Task UpdateAsync(Post post, CancellationToken cancellationToken = default);
    }

    public interface IEventPublisher
    {
        /// <summary>
        ///     Publishes a domain event to the bus of choice (e.g. MediatR,
        ///     NServiceBus, MassTransit).  The implementation lives in an
        ///     adapter.
        /// </summary>
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken cancellationToken = default)
            where TEvent : IDomainEvent;
    }

    public interface IDateTimeProvider
    {
        /// <summary>The current UTC date/time.</summary>
        DateTimeOffset UtcNow { get; }
    }

    // -------------------------------------------------------------------------
    // DOMAIN ENTITIES & EVENTS
    // -------------------------------------------------------------------------

    /// <summary>Represents a blog post within the TempoScribe Pro domain.</summary>
    public sealed class Post : Entity<Guid>
    {
        private readonly List<AuditLogEntry> _auditLog = new();

        public string             Slug           { get; init; } = default!;
        public string             Title          { get; set; } = default!;
        public PostStatus         Status         { get; set; }
        public DateTimeOffset?    PublishAtUtc   { get; init; }
        public DateTimeOffset?    PublishedUtc   { get; set; }
        public uint               Version        { get; set; } // Optimistic concurrency

        // Domain Behaviors ----------------------------------------------------

        public bool CanBePublished()
            => Status == PostStatus.Scheduled && PublishAtUtc <= DateTimeOffset.UtcNow;

        internal void AddAuditLogEntry(string description)
            => _auditLog.Add(new AuditLogEntry(DateTimeOffset.UtcNow, description));
    }

    /// <summary>High-level status for posts seen by the domain.</summary>
    public enum PostStatus
    {
        Draft      = 0,
        Scheduled  = 1,
        Published  = 2,
        Archived   = 3,
        Deleted    = 4
    }

    /// <summary>Represents an audit log entry for a <see cref="Post" />.</summary>
    public readonly record struct AuditLogEntry(DateTimeOffset AtUtc, string Description);

    /// <summary>
    ///     Base contract for all domain events emitted by the core.
    /// </summary>
    public interface IDomainEvent { }

    /// <summary>
    ///     Domain event emitted when a scheduled post is automatically
    ///     published by the <see cref="PublishingAutomationService" />.
    /// </summary>
    public sealed record ScheduledPostPublishedEvent(
        Guid PostId,
        string Slug,
        DateTimeOffset PublishedUtc) : IDomainEvent;

    // -------------------------------------------------------------------------
    //  SHARED KERNEL & EXCEPTIONS
    // -------------------------------------------------------------------------

    /// <summary>
    ///     Simple base entity with an ID and equality helper.
    /// </summary>
    public abstract class Entity<TId> : IEquatable<Entity<TId>>
    {
        public TId Id { get; init; } = default!;

        public bool Equals(Entity<TId>? other)
            => ReferenceEquals(this, other) || (other is not null && EqualityComparer<TId>.Default.Equals(Id, other.Id));

        public override bool Equals(object? obj) => obj is Entity<TId> other && Equals(other);

        public override int GetHashCode() => EqualityComparer<TId>.Default.GetHashCode(Id);
    }

    /// <summary>
    ///     Thrown when an optimistic concurrency conflict occurs (e.g., stale
    ///     version token).
    /// </summary>
    public sealed class ConcurrencyException : Exception
    {
        public ConcurrencyException(string? message, Exception? inner = null)
            : base(message, inner) { }
    }

    /// <summary>
    ///     Wraps lower-level exceptions thrown during scheduled publishing so
    ///     that callers can catch a single domain-specific exception.
    /// </summary>
    public sealed class PublishingAutomationException : Exception
    {
        public PublishingAutomationException(string? message, Exception? inner = null)
            : base(message, inner) { }
    }
}
```