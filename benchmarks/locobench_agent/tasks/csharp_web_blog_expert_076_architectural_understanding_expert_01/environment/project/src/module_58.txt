```csharp
// -----------------------------------------------------------------------------
// File path: src/module_58.txt   (TempoScribe Pro – Hexagonal Productivity Blog Suite)
// -----------------------------------------------------------------------------
// Module: ScheduledPublishingCoordinator
// Layer : Application (Service Layer / Use-Case Handler)
//
// Responsibility:
//     • Periodically scan for posts that are scheduled for automatic publication
//       and whose scheduled timestamp is now due.
//     • Transition eligible posts to “Published” state, persist changes,
//       dispatch domain events, and produce a summary report.
//     • Remain agnostic of infrastructure concerns by depending strictly on
//       ports (repositories, clock providers, event buses, etc.).
//
// -----------------------------------------------------------------------------
// © TempoScribe Pro – All rights reserved.
// -----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using TempoScribePro.Domain.Blog;
using TempoScribePro.Domain.Common;
using TempoScribePro.Domain.Ports;

namespace TempoScribePro.Application.Publishing
{
    /// <summary>
    /// Coordinates the scheduled-publishing workflow.  The coordinator is intended
    /// to be triggered by an adapter (e.g. Hangfire, Quartz.NET, AWS EventBridge,
    /// or a simple Cron job) on a configurable interval.  It is implementation-
    /// agnostic and safe to execute concurrently because post-state transitions
    /// are guarded by pessimistic or optimistic locking in lower tiers.
    /// </summary>
    public sealed class ScheduledPublishingCoordinator
    {
        private const int DefaultBatchSize = 50;

        private readonly IPostRepository      _postRepository;
        private readonly IDomainEventDispatcher _eventDispatcher;
        private readonly IUnitOfWork          _unitOfWork;
        private readonly IDateTimeProvider    _clock;
        private readonly ILogger<ScheduledPublishingCoordinator> _logger;

        public ScheduledPublishingCoordinator(
            IPostRepository                   postRepository,
            IDomainEventDispatcher            eventDispatcher,
            IUnitOfWork                       unitOfWork,
            IDateTimeProvider                 clock,
            ILogger<ScheduledPublishingCoordinator> logger)
        {
            _postRepository  = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _eventDispatcher = eventDispatcher ?? throw new ArgumentNullException(nameof(eventDispatcher));
            _unitOfWork      = unitOfWork      ?? throw new ArgumentNullException(nameof(unitOfWork));
            _clock           = clock           ?? throw new ArgumentNullException(nameof(clock));
            _logger          = logger          ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Scans, publishes, and summarizes all posts that are ready for automatic
        /// publication.  The operation is idempotent and safe to run concurrently.
        /// </summary>
        /// <param name="cancellationToken">Propagates caller cancellation.</param>
        /// <param name="batchSize">
        /// Optional override for batch size when scanning large queues.
        /// </param>
        /// <returns>
        /// A <see cref="ScheduledPublishingSummary"/> describing the processing
        /// outcome (successes, failures, elapsed time).
        /// </returns>
        /// <exception cref="ScheduledPublishingException">
        /// Thrown when irrecoverable persistence errors occur.
        /// </exception>
        public async Task<ScheduledPublishingSummary> ProcessPendingScheduledPostsAsync(
            CancellationToken cancellationToken = default,
            int batchSize = DefaultBatchSize)
        {
            var stopwatch = ValueStopwatch.StartNew();
            int succeeded = 0;
            int failed    = 0;
            int inspected = 0;

            try
            {
                _logger.LogInformation("Scheduled-publishing routine started at {Now}.", _clock.UtcNow);

                List<Post> duePosts;
                do
                {
                    duePosts = (await _postRepository
                                    .GetScheduledPostsDueAsync(_clock.UtcNow, batchSize, cancellationToken))
                                .ToList();

                    inspected += duePosts.Count;

                    foreach (var post in duePosts)
                    {
                        try
                        {
                            // Domain logic is encapsulated by the entity itself.
                            post.Publish(_clock.UtcNow);

                            // Persist immediately to release any database-level locks early.
                            await _postRepository.UpdateAsync(post, cancellationToken);
                            await _eventDispatcher.DispatchAndClearEventsAsync(post, cancellationToken);

                            succeeded++;
                            _logger.LogInformation(
                                "Post {PostId} ('{Title}') published successfully.", post.Id, post.Title);
                        }
                        catch (PostDomainException ex)
                        {
                            failed++;
                            _logger.LogWarning(ex,
                                "Domain-level validation failed while publishing post {PostId}.", post.Id);
                        }
                        catch (Exception ex)
                        {
                            failed++;
                            _logger.LogError(ex,
                                "Unexpected error while publishing post {PostId}.", post.Id);
                        }
                    }

                    // Commit after each batch to keep transactions lean and release locks quickly.
                    if (duePosts.Any())
                    {
                        await _unitOfWork.CommitAsync(cancellationToken);
                    }

                } while (duePosts.Count == batchSize && !cancellationToken.IsCancellationRequested);

                var summary = new ScheduledPublishingSummary(
                    inspectedPosts: inspected,
                    publishedPosts: succeeded,
                    failedPosts: failed,
                    elapsed: stopwatch.Elapsed);

                _logger.LogInformation(
                    "Scheduled-publishing routine completed in {ElapsedSeconds:n1}s. " +
                    "{Published}/{Total} posts published; {Failed} failed.",
                    summary.Elapsed.TotalSeconds,
                    summary.PublishedPosts,
                    summary.InspectedPosts,
                    summary.FailedPosts);

                return summary;
            }
            catch (Exception ex) when (!(ex is ScheduledPublishingException))
            {
                _logger.LogCritical(ex,
                    "Fatal error occurred in scheduled-publishing coordinator. " +
                    "Execution aborted; manual intervention may be required.");

                throw new ScheduledPublishingException(
                    "An unexpected error occurred while processing scheduled posts.", ex);
            }
        }
    }

    /// <summary>
    /// Immutable DTO summarizing scheduled-publishing results.
    /// </summary>
    public sealed record ScheduledPublishingSummary(
        int InspectedPosts,
        int PublishedPosts,
        int FailedPosts,
        TimeSpan Elapsed)
    {
        public int PendingPosts => InspectedPosts - (PublishedPosts + FailedPosts);
    }

    /// <summary>
    /// Exception wrapper for unrecoverable scheduled-publishing errors.
    /// </summary>
    public sealed class ScheduledPublishingException : Exception
    {
        public ScheduledPublishingException(string message, Exception? inner = null)
            : base(message, inner) { }
    }
}

// -----------------------------------------------------------------------------
// Domain Ports referenced by this module.
// (In Hexagonal architecture, these interfaces live in the Domain or
// Application contracts project.  They are reproduced here only for compiler
// completeness of this standalone code sample.)
// -----------------------------------------------------------------------------
namespace TempoScribePro.Domain.Ports
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;
    using TempoScribePro.Domain.Blog;

    /// <summary>
    /// Repository port for the <see cref="Post"/> aggregate root.
    /// </summary>
    public interface IPostRepository
    {
        /// <summary>
        /// Retrieves posts that are in “Scheduled” state and whose scheduled
        /// publication date is earlier than or equal to the provided timestamp.
        /// </summary>
        Task<IEnumerable<Post>> GetScheduledPostsDueAsync(
            DateTimeOffset utcNow,
            int batchSize,
            CancellationToken cancellationToken);

        /// <summary>
        /// Persists changes to a <see cref="Post"/> aggregate.
        /// </summary>
        Task UpdateAsync(Post post, CancellationToken cancellationToken);
    }

    /// <summary>
    /// Provides a consistent, mockable source of current time.
    /// </summary>
    public interface IDateTimeProvider
    {
        DateTimeOffset UtcNow { get; }
    }

    /// <summary>
    /// Dispatches domain events raised by aggregates to their respective
    /// handlers (e.g., via MediatR).
    /// </summary>
    public interface IDomainEventDispatcher
    {
        Task DispatchAndClearEventsAsync(
            IEntity entity,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Explicit unit-of-work boundary (useful when multiple aggregates are
    /// modified in a single use-case).
    /// </summary>
    public interface IUnitOfWork
    {
        Task CommitAsync(CancellationToken cancellationToken = default);
    }
}

// -----------------------------------------------------------------------------
// Domain entities and shared abstractions referenced in this module.
// (Simplified stubs necessary for compilation.  Real implementations live
// elsewhere in the solution.)
// -----------------------------------------------------------------------------
namespace TempoScribePro.Domain.Common
{
    using System;
    using System.Diagnostics;

    public interface IEntity
    {
        Guid Id { get; }
        IReadOnlyCollection<IDomainEvent> DomainEvents { get; }
        void ClearDomainEvents();
    }

    public interface IDomainEvent { }

    /// <summary>
    /// High-precision stopwatch value object that avoids heap allocations.
    /// </summary>
    internal readonly struct ValueStopwatch
    {
        private static readonly double _timestampToTicks = TimeSpan.TicksPerSecond / (double)Stopwatch.Frequency;
        private readonly long _startTimestamp;

        private ValueStopwatch(long startTimestamp) => _startTimestamp = startTimestamp;

        public static ValueStopwatch StartNew() => new ValueStopwatch(Stopwatch.GetTimestamp());

        public TimeSpan Elapsed
        {
            get
            {
                long end = Stopwatch.GetTimestamp();
                long delta = end - _startTimestamp;
                long ticks = (long)(_timestampToTicks * delta);
                return new TimeSpan(ticks);
            }
        }
    }
}

namespace TempoScribePro.Domain.Blog
{
    using System;
    using System.Collections.Generic;
    using TempoScribePro.Domain.Common;

    /// <summary>
    /// Aggregate root representing a blog post.
    /// NOTE: Simplified for brevity; real implementation includes many more
    ///       properties (content, tags, monetization rules, etc.).
    /// </summary>
    public sealed class Post : IEntity
    {
        private readonly List<IDomainEvent> _domainEvents = new();

        public Guid            Id                { get; init; }
        public string          Title             { get; private set; } = string.Empty;
        public PostStatus      Status            { get; private set; } = PostStatus.Draft;
        public DateTimeOffset? ScheduledAtUtc    { get; private set; }
        public DateTimeOffset? PublishedAtUtc    { get; private set; }

        public IReadOnlyCollection<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

        /// <summary>
        /// Publishes the post immediately.  Throws <see cref="PostDomainException"/>
        /// if the post is not eligible for publishing.
        /// </summary>
        public void Publish(DateTimeOffset utcNow)
        {
            if (Status != PostStatus.Scheduled)
                throw new PostDomainException($"Post {Id} is not in 'Scheduled' state.");

            if (ScheduledAtUtc is null || utcNow < ScheduledAtUtc.Value)
                throw new PostDomainException($"Post {Id} cannot be published before its schedule ({ScheduledAtUtc}).");

            Status         = PostStatus.Published;
            PublishedAtUtc = utcNow;
            _domainEvents.Add(new PostPublishedDomainEvent(this));
        }

        public void ClearDomainEvents() => _domainEvents.Clear();
    }

    public enum PostStatus
    {
        Draft     = 0,
        Scheduled = 1,
        Published = 2,
        Archived  = 3
    }

    public sealed record PostPublishedDomainEvent(Post Post) : IDomainEvent;

    public sealed class PostDomainException : Exception
    {
        public PostDomainException(string message) : base(message) { }
    }
}
```