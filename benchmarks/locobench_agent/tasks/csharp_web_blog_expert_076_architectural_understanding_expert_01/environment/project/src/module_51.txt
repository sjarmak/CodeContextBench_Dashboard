```csharp
// -------------------------------------------------------------------------------------------------
// File:     module_51.txt          (treated as .cs within build pipeline)
// Project:  TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// Module:   Publishing Automation – Scheduled Publishing Service
// Author:   GPT Codegen – Hexagonal Advocates
// -------------------------------------------------------------------------------------------------
// Description
// -----------
// Responsible for automatically transitioning posts from “Scheduled” to “Published” once their
// PublishAt timestamp elapses.  The service is pure domain logic and therefore depends only on
// Ports (IPostRepository, IClockProvider, IEventBus, IDistributedLock) that can be fulfilled by
// any Adapter (SQL, MongoDB, Redis, Azure Service Bus, etc.).
//
// This file purposely bundles the small cluster of types (service + supporting ports / entities)
// to keep prompt scope self-contained. In the real project they live in their respective folders.
//
// -------------------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace TempoScribePro.Domain.Publishing
{
    #region Domain Models & Events ---------------------------------------------------------------

    /// <summary>
    /// Aggregate root representing a blog post in the TempoScribe domain.
    /// IMPORTANT: Only minimal properties are shown; the real model lives in Domain/Post.cs
    /// </summary>
    public sealed class Post
    {
        public Guid            Id               { get; }
        public string          Title            { get; private set; } = string.Empty;
        public string          Slug             { get; private set; } = string.Empty;
        public PostStatus      Status           { get; private set; } = PostStatus.Draft;
        public DateTimeOffset? PublishAt        { get; private set; }
        public DateTimeOffset? PublishedOn      { get; private set; }

        private readonly List<IDomainEvent> _domainEvents = new();

        public Post(Guid id, string title, string slug)
        {
            Id    = id;
            Title = title;
            Slug  = slug;
        }

        /// <summary>
        /// Marks the post as published if the guard conditions are met.
        /// </summary>
        /// <exception cref="InvalidOperationException"/>
        public void Publish(DateTimeOffset utcNow)
        {
            if (Status == PostStatus.Published)
                throw new InvalidOperationException("Post already published.");

            if (Status != PostStatus.Scheduled)
                throw new InvalidOperationException("Only scheduled posts can be published.");

            if (PublishAt is null || PublishAt > utcNow)
                throw new InvalidOperationException("PublishAt not reached yet.");

            Status      = PostStatus.Published;
            PublishedOn = utcNow;

            _domainEvents.Add(new PostPublishedEvent(Id, utcNow));
        }

        /// <summary>Returns and clears the domain events list (unit-of-work pattern).</summary>
        public IReadOnlyCollection<IDomainEvent> FlushEvents()
        {
            var copy = _domainEvents.AsReadOnly();
            _domainEvents.Clear();
            return copy;
        }
    }

    public enum PostStatus
    {
        Draft      = 0,
        Scheduled  = 1,
        Published  = 2,
        Archived   = 3
    }

    /// <summary>Marker interface for domain events.</summary>
    public interface IDomainEvent { }

    /// <summary>Raised when a post transitions to the Published state.</summary>
    public sealed record PostPublishedEvent(Guid PostId, DateTimeOffset PublishedOnUtc) : IDomainEvent;

    #endregion

    #region Port Definitions ---------------------------------------------------------------------

    /// <summary>
    /// Abstraction for data persistence operations on <see cref="Post"/> aggregates.
    /// </summary>
    public interface IPostRepository
    {
        Task<IReadOnlyList<Post>> GetBatchScheduledBeforeAsync(DateTimeOffset utcNow, int maxItems,
            CancellationToken ct);

        Task SaveAsync(Post post, CancellationToken ct);
    }

    /// <summary>Allows the domain to obtain the current UTC timestamp (mockable in tests).</summary>
    public interface IClockProvider
    {
        DateTimeOffset UtcNow { get; }
    }

    /// <summary>
    /// Simple domain event dispatcher. Adapters can implement with any bus (MediatR, Kafka, etc.).
    /// </summary>
    public interface IEventBus
    {
        Task PublishAsync(IEnumerable<IDomainEvent> events, CancellationToken ct);
    }

    /// <summary>
    /// Cross-service distributed lock abstraction (e.g., backed by Redis or SQL sp_getapplock).
    /// Ensures only one publishing worker executes the critical section at any given time.
    /// </summary>
    public interface IDistributedLock
    {
        Task<bool> TryAcquireAsync(string resource, TimeSpan ttl, CancellationToken ct);
        Task ReleaseAsync(string resource);
    }

    /// <summary>
    /// Structured logging abstraction.  Typically fulfilled by an adapter to Serilog / NLog.
    /// </summary>
    public interface ILogger
    {
        void Debug(string message, params object[] args);
        void Info(string  message, params object[] args);
        void Warn(string  message, params object[] args);
        void Error(Exception ex, string message, params object[] args);
    }

    #endregion

    #region Service Implementation ---------------------------------------------------------------

    /// <summary>
    /// Domain service that sweeps for due scheduled posts and publishes them atomically.
    /// Aggregates are saved and their emitted domain events are pushed to the <see cref="IEventBus"/>.
    /// </summary>
    public sealed class ScheduledPublishingService
    {
        private const string LockResource = "TempoScribe:ScheduledPublishing";
        private static readonly TimeSpan LockTtl = TimeSpan.FromSeconds(55);

        private readonly IPostRepository  _posts;
        private readonly IClockProvider   _clock;
        private readonly IEventBus        _bus;
        private readonly IDistributedLock _lock;
        private readonly ILogger          _logger;

        public ScheduledPublishingService(
            IPostRepository posts,
            IClockProvider  clock,
            IEventBus       bus,
            IDistributedLock @lock,
            ILogger         logger)
        {
            _posts  = posts  ?? throw new ArgumentNullException(nameof(posts));
            _clock  = clock  ?? throw new ArgumentNullException(nameof(clock));
            _bus    = bus    ?? throw new ArgumentNullException(nameof(bus));
            _lock   = @lock  ?? throw new ArgumentNullException(nameof(@lock));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Executes one sweep cycle. Designed to be triggered by a hosted service / cron job
        /// every minute.  Method is idempotent and concurrency-safe.
        /// </summary>
        public async Task<int> PublishDuePostsAsync(CancellationToken ct = default)
        {
            var utcNow = _clock.UtcNow;

            if (!await _lock.TryAcquireAsync(LockResource, LockTtl, ct).ConfigureAwait(false))
            {
                _logger.Debug("ScheduledPublishingService → lock already taken, skipping cycle.");
                return 0;
            }

            try
            {
                // Fetch a limited batch to avoid long running transactions.
                const int MaxBatch = 50;
                var duePosts = await _posts
                    .GetBatchScheduledBeforeAsync(utcNow, MaxBatch, ct)
                    .ConfigureAwait(false);

                if (duePosts.Count == 0)
                {
                    _logger.Debug("ScheduledPublishingService → no due posts.");
                    return 0;
                }

                _logger.Info("ScheduledPublishingService → found {0} due posts.", duePosts.Count);

                int publishedCount = 0;

                foreach (var post in duePosts)
                {
                    try
                    {
                        post.Publish(utcNow);

                        // Persist changes
                        await _posts.SaveAsync(post, ct).ConfigureAwait(false);

                        // Emit domain events
                        var events = post.FlushEvents();
                        if (events.Count > 0)
                            await _bus.PublishAsync(events, ct).ConfigureAwait(false);

                        publishedCount++;
                    }
                    catch (Exception ex)
                    {
                        // Swallow per-item errors so remaining posts still process.
                        _logger.Error(ex,
                            "ScheduledPublishingService → failed to publish PostId={0}", post.Id);
                    }
                }

                _logger.Info("ScheduledPublishingService → successfully published {0} posts.",
                    publishedCount);

                return publishedCount;
            }
            finally
            {
                await _lock.ReleaseAsync(LockResource).ConfigureAwait(false);
            }
        }
    }

    #endregion
}
```