using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.LivePreview
{
    /// <summary>
    /// Value object representing a version of a post.
    /// Immutable to guarantee referential transparency.
    /// </summary>
    public sealed record PostVersion(
        Guid PostId,
        int VersionNumber,
        string Content,
        DateTimeOffset CreatedAt);

    /// <summary>
    /// Port that defines how the core domain accesses persisted post versions.
    /// Implementations live in the infrastructure (e.g. SQL, Mongo, or in-memory).
    /// </summary>
    public interface IPostVersionRepository
    {
        Task<PostVersion?> GetLatestPublishedVersionAsync(
            Guid postId,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Generic cache abstraction (e.g. Redis, in-proc memory).
    /// Keeps the core free from infrastructure details.
    /// </summary>
    public interface ICacheProvider
    {
        Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default);
        Task  SetAsync<T>(string key, T value, TimeSpan ttl, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Result of a diff operation. 
    /// Arrays are guaranteed non-null but may be empty.
    /// </summary>
    public sealed record DiffResult(
        string[] AddedLines,
        string[] RemovedLines,
        string[] UnchangedLines);

    /// <summary>
    /// Generates a diff between two pieces of text.
    /// </summary>
    public interface IDiffGenerator
    {
        DiffResult Generate(string oldContent, string newContent);
    }

    /// <summary>
    /// A simple line-by-line diff generator that categorises each line as
    /// Added, Removed, or Unchanged using the Longest Common Subsequence algorithm.  
    ///
    /// NOTE: Good enough for preview UX; swap with a more sophisticated
    /// algorithm (e.g. Myers) by implementing <see cref="IDiffGenerator"/>.
    /// </summary>
    public sealed class SimpleLineDiffGenerator : IDiffGenerator
    {
        public DiffResult Generate(string oldContent, string newContent)
        {
            var oldLines = (oldContent ?? string.Empty)
                .Split(Environment.NewLine, StringSplitOptions.None);
            var newLines = (newContent ?? string.Empty)
                .Split(Environment.NewLine, StringSplitOptions.None);

            var lcs = CalculateLcsMatrix(oldLines, newLines);
            var diff = BacktrackLcs(oldLines, newLines, lcs);

            return new DiffResult(
                diff.Added.ToArray(),
                diff.Removed.ToArray(),
                diff.Unchanged.ToArray());
        }

        private static int[,] CalculateLcsMatrix(IReadOnlyList<string> a, IReadOnlyList<string> b)
        {
            var m = a.Count;
            var n = b.Count;
            var lcs = new int[m + 1, n + 1];

            for (var i = 1; i <= m; i++)
            for (var j = 1; j <= n; j++)
                if (a[i - 1] == b[j - 1])
                    lcs[i, j] = lcs[i - 1, j - 1] + 1;
                else
                    lcs[i, j] = Math.Max(lcs[i - 1, j], lcs[i, j - 1]);

            return lcs;
        }

        private static (List<string> Added, List<string> Removed, List<string> Unchanged)
            BacktrackLcs(
                IReadOnlyList<string> a,
                IReadOnlyList<string> b,
                int[,] lcs)
        {
            var i = a.Count;
            var j = b.Count;

            var added = new List<string>();
            var removed = new List<string>();
            var unchanged = new List<string>();

            while (i > 0 && j > 0)
            {
                if (a[i - 1] == b[j - 1])
                {
                    unchanged.Insert(0, a[i - 1]);
                    i--;
                    j--;
                }
                else if (lcs[i - 1, j] >= lcs[i, j - 1])
                {
                    removed.Insert(0, a[i - 1]);
                    i--;
                }
                else
                {
                    added.Insert(0, b[j - 1]);
                    j--;
                }
            }

            while (i > 0)
            {
                removed.Insert(0, a[i - 1]);
                i--;
            }

            while (j > 0)
            {
                added.Insert(0, b[j - 1]);
                j--;
            }

            return (added, removed, unchanged);
        }
    }

    /// <summary>
    /// Public port that the Web/UI adapter calls to generate
    /// real-time preview diffs while the user edits a draft.
    /// </summary>
    public interface ILivePreviewPort
    {
        Task<DiffResult> GetDiffAsync(
            Guid postId,
            string draftContent,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Domain service responsible for returning a diff between the
    /// previously published version and the current in-progress draft.
    /// Results are cached to reduce unnecessary recomputation while
    /// the user types, which happens very frequently.
    /// </summary>
    public sealed class LivePreviewService : ILivePreviewPort
    {
        private readonly IPostVersionRepository _postVersionRepository;
        private readonly IDiffGenerator _diffGenerator;
        private readonly ICacheProvider _cache;
        private readonly ILogger<LivePreviewService> _logger;

        private static readonly TimeSpan CacheTtl = TimeSpan.FromSeconds(30);

        public LivePreviewService(
            IPostVersionRepository postVersionRepository,
            IDiffGenerator diffGenerator,
            ICacheProvider cache,
            ILogger<LivePreviewService> logger)
        {
            _postVersionRepository = postVersionRepository ??
                                     throw new ArgumentNullException(nameof(postVersionRepository));
            _diffGenerator         = diffGenerator         ??
                                     throw new ArgumentNullException(nameof(diffGenerator));
            _cache                 = cache                 ??
                                     throw new ArgumentNullException(nameof(cache));
            _logger                = logger                ??
                                     throw new ArgumentNullException(nameof(logger));
        }

        public async Task<DiffResult> GetDiffAsync(
            Guid postId,
            string draftContent,
            CancellationToken cancellationToken = default)
        {
            if (postId == Guid.Empty)
                throw new ArgumentException("Post ID must be a non-empty GUID.", nameof(postId));

            draftContent ??= string.Empty;

            var cached = await TryGetFromCacheAsync(postId, draftContent, cancellationToken);
            if (cached is not null)
            {
                _logger.LogDebug("Live preview diff served from cache for post {PostId}.", postId);
                return cached;
            }

            var lastPublished = await _postVersionRepository
               .GetLatestPublishedVersionAsync(postId, cancellationToken)
               .ConfigureAwait(false);

            var oldContent = lastPublished?.Content ?? string.Empty;

            // Compute diff
            DiffResult diff;
            try
            {
                diff = _diffGenerator.Generate(oldContent, draftContent);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Failed to generate diff for post {PostId}. " +
                    "Falling back to simple content replacement.",
                    postId);

                // Fallback: mark everything as added.
                diff = new DiffResult(
                    AddedLines: draftContent.Split(Environment.NewLine),
                    RemovedLines: Array.Empty<string>(),
                    UnchangedLines: Array.Empty<string>());
            }

            await SaveToCacheAsync(postId, draftContent, diff, cancellationToken)
                .ConfigureAwait(false);

            return diff;
        }

        #region Cache Helpers

        private Task SaveToCacheAsync(
            Guid postId,
            string draftContent,
            DiffResult diff,
            CancellationToken cancellationToken)
        {
            var key = BuildCacheKey(postId, draftContent);
            return _cache.SetAsync(key, diff, CacheTtl, cancellationToken);
        }

        private async Task<DiffResult?> TryGetFromCacheAsync(
            Guid postId,
            string draftContent,
            CancellationToken cancellationToken)
        {
            var key   = BuildCacheKey(postId, draftContent);
            var diff  = await _cache.GetAsync<DiffResult>(key, cancellationToken)
                                    .ConfigureAwait(false);
            return diff;
        }

        private static string BuildCacheKey(Guid postId, string draftContent)
        {
            const string prefix = "livepreview:diff:";
            var hash = HashHelper.ComputeHash(draftContent);
            return $"{prefix}{postId}:{hash}";
        }

        #endregion
    }

    /// <summary>
    /// Helper class to compute a stable hash of a string using SHA-256.
    /// </summary>
    internal static class HashHelper
    {
        public static string ComputeHash(string value)
        {
            if (value is null)
                return string.Empty;

            using var sha = SHA256.Create();
            var bytes = Encoding.UTF8.GetBytes(value);
            var hashBytes = sha.ComputeHash(bytes);
            var sb = new StringBuilder(hashBytes.Length * 2);

            foreach (var b in hashBytes)
                sb.Append(b.ToString("x2"));

            return sb.ToString();
        }
    }
}