```csharp
// ─────────────────────────────────────────────────────────────────────────────
// File: src/module_69.txt  (treated as *.cs by build pipeline)
// Project: TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// 
// Module #69 – Live Preview Diff & Caching Core Service
// -----------------------------------------------------------------------------
// This file contains the domain-level service responsible for generating live
// preview diffs between the latest editable draft and the last published
// version of a blog post.  The service is implemented following Hexagonal
// principles: all infrastructure concerns (data store, cache, diffing engine,
// and logging) are abstracted behind ports so that adapters can be swapped
// without impacting the domain.
// ─────────────────────────────────────────────────────────────────────────────

using System;
using System.Threading;
using System.Threading.Tasks;

namespace TempoScribePro.Core.LivePreview
{
    #region Domain Model

    /// <summary>
    /// Current state of a blog post.
    /// </summary>
    public enum PostStatus
    {
        Draft   = 0,
        Queued  = 1,
        Review  = 2,
        Published = 3,
        Archived  = 4
    }

    /// <summary>
    /// Aggregate root representing a blog post.
    /// NOTE: Simplified for brevity – full implementation is located in
    ///       TempoScribePro.Core.Posts namespace.
    /// </summary>
    public sealed class Post
    {
        public Guid      Id            { get; init; }
        public string    Title         { get; private set; }   = string.Empty;
        public string    Content       { get; private set; }   = string.Empty;
        public int       Version       { get; private set; }
        public PostStatus Status       { get; private set; }
        public DateTime  UpdatedUtc    { get; private set; }

        public Post WithContent(string newContent, int newVersion, DateTime updatedUtc)
            => new Post
            {
                Id         = Id,
                Title      = Title,
                Content    = newContent,
                Version    = newVersion,
                Status     = Status,
                UpdatedUtc = updatedUtc
            };
    }

    #endregion

    #region Ports (Driven + Driving)

    /// <summary>
    /// Repository abstraction used to load post aggregates.
    /// Infrastructure adapters may point to SQL, NoSQL, or in-memory stores.
    /// </summary>
    public interface IPostRepository
    {
        Task<Post?> GetAsync(Guid postId, CancellationToken ct = default);
    }

    /// <summary>
    /// Stateless component that produces a text diff given "before" and "after"
    /// versions of a document. Implementation could wrap SharpDiff, Google's
    /// diff-match-patch, or a custom algorithm.
    /// </summary>
    public interface IDiffEngine
    {
        /// <summary>
        /// Returns an HTML-annotated diff that can be injected directly into the
        /// preview panel of the TempoScribe editor.
        /// </summary>
        ValueTask<string> GenerateHtmlDiffAsync(
            string original,
            string revised,
            CancellationToken ct = default);
    }

    /// <summary>
    /// Minimal cache abstraction.  Typical adapter uses Redis, though memory-
    /// cache is substituted during unit tests.
    /// </summary>
    public interface ICacheProvider
    {
        /// <summary>Tries to retrieve a cached value.</summary>
        ValueTask<(bool Hit, T? Value)> TryGetAsync<T>(string key, CancellationToken ct = default);

        /// <summary>Caches a value for a specified time-to-live.</summary>
        ValueTask SetAsync<T>(string key, T value, TimeSpan ttl, CancellationToken ct = default);
    }

    /// <summary>
    /// Logger abstraction.  In production an adapter forwards logs to Serilog or
    /// OpenTelemetry; tests inject a NullLogger.
    /// </summary>
    public interface IAppLogger<T>
    {
        void Trace(string message);
        void Info (string message);
        void Warn (string message, Exception? ex = null);
        void Error(string message, Exception ex);
    }

    #endregion

    #region Exceptions

    /// <summary>
    /// Thrown when the system fails to generate a diff due to missing data.
    /// </summary>
    public sealed class LivePreviewException : Exception
    {
        public LivePreviewException(string message) : base(message) { }
        public LivePreviewException(string message, Exception inner) : base(message, inner) { }
    }

    #endregion

    #region Service

    /// <summary>
    /// Domain service orchestrating diff generation with cache awareness.
    /// </summary>
    public sealed class LivePreviewDiffService
    {
        private readonly IPostRepository _postRepo;
        private readonly IDiffEngine     _diffEngine;
        private readonly ICacheProvider  _cache;
        private readonly IAppLogger<LivePreviewDiffService> _logger;

        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(5);

        public LivePreviewDiffService(
            IPostRepository postRepo,
            IDiffEngine diffEngine,
            ICacheProvider cache,
            IAppLogger<LivePreviewDiffService> logger)
        {
            _postRepo   = postRepo  ?? throw new ArgumentNullException(nameof(postRepo));
            _diffEngine = diffEngine?? throw new ArgumentNullException(nameof(diffEngine));
            _cache      = cache     ?? throw new ArgumentNullException(nameof(cache));
            _logger     = logger    ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Retrieves an HTML diff for the post identified by <paramref name="postId"/>.
        /// If the draft has not changed since the last invocation, the previously
        /// cached diff is returned to minimize processing time.
        /// </summary>
        /// <param name="postId">Aggregate identifier of the blog post.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <exception cref="LivePreviewException">
        /// Thrown when the draft or published version cannot be found.
        /// </exception>
        public async ValueTask<string> GetLivePreviewDiffAsync(
            Guid postId,
            CancellationToken ct = default)
        {
            string cacheKey = BuildCacheKey(postId);

            // 1. Try to serve from cache.
            var (hit, cachedValue) = await _cache.TryGetAsync<string>(cacheKey, ct);
            if (hit && cachedValue is not null)
            {
                _logger.Trace($"[LivePreview] Cache hit for post {postId}");
                return cachedValue;
            }

            _logger.Trace($"[LivePreview] Cache miss for post {postId}. Generating diff...");

            // 2. Load current Draft & Published versions.
            var post = await _postRepo.GetAsync(postId, ct);
            if (post is null)
            {
                _logger.Warn($"[LivePreview] Post {postId} not found");
                throw new LivePreviewException($"Post ({postId}) not found.");
            }

            if (post.Status == PostStatus.Draft)
            {
                // The last published version is required for diffing; attempt to load.
                var published = await _postRepo.GetAsync(postId, ct); // Implementation
                                                                      // of repository determines last published retrieval.
                if (published is null || published.Status != PostStatus.Published)
                {
                    _logger.Info($"[LivePreview] Post {postId} has no published baseline");
                    throw new LivePreviewException("No published version to diff against.");
                }

                return await GenerateAndCacheDiffAsync(
                    postId,
                    original: published.Content,
                    revised:  post.Content,
                    cacheKey,
                    ct);
            }

            // If the current status is not Draft, diff generation is not applicable.
            _logger.Warn($"[LivePreview] Post {postId} is not in Draft status; current status = {post.Status}");
            throw new LivePreviewException("Live preview available only for draft posts.");
        }

        #endregion

        #region Helpers

        private static string BuildCacheKey(Guid postId)
            => $"live_preview_diff:{postId:N}";

        private async ValueTask<string> GenerateAndCacheDiffAsync(
            Guid postId,
            string original,
            string revised,
            string cacheKey,
            CancellationToken ct)
        {
            try
            {
                string diffHtml = await _diffEngine.GenerateHtmlDiffAsync(original, revised, ct);

                // Cache for future calls. We intentionally don't block on the SetAsync
                // call (fire-and-forget) because diffHtml is already computed.
                _ = _cache.SetAsync(cacheKey, diffHtml, CacheTtl, ct);

                _logger.Info($"[LivePreview] Generated diff for post {postId} (ttl={CacheTtl.TotalMinutes} min)");
                return diffHtml;
            }
            catch (Exception ex) when (ex is not LivePreviewException)
            {
                _logger.Error($"[LivePreview] Failed generating diff for {postId}", ex);
                throw new LivePreviewException("Unable to generate preview diff.", ex);
            }
        }

        #endregion
    }
}
```