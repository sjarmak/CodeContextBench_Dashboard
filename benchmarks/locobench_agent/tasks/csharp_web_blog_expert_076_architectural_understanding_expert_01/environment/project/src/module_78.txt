```csharp
// -----------------------------------------------------------------------------
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// File:        src/module_78.txt  (Domain Service – Scheduled Publishing)
// Language:    C# 10
// Description: Core service that automatically promotes scheduled posts whose
//              publish‐time has elapsed.  100 % technology-agnostic and wired
//              through ports (repositories, unit-of-work, clock, logger, etc.).
// -----------------------------------------------------------------------------

#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using TempoScribePro.Domain.Abstractions;
using TempoScribePro.Domain.Events;
using TempoScribePro.Domain.Models;
using TempoScribePro.Domain.Monetization;
using TempoScribePro.Domain.Shared;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Scheduling;

/// <summary>
/// Exposes functionality for promoting scheduled posts to a published state when the
/// configured <see cref="IPost.ScheduledAt"/> timestamp is in the past.
/// </summary>
public interface IScheduledPublishingService
{
    /// <summary>
    /// Processes every post that is currently <see cref="PostStatus.Scheduled"/> and
    /// whose <see cref="IPost.ScheduledAt"/> has elapsed.
    /// </summary>
    /// <param name="cancellationToken">Token that cancels the ongoing operation.</param>
    /// <returns>A report that summarizes the promotion run.</returns>
    Task<PublishingReport> PromoteDueScheduledPostsAsync(CancellationToken cancellationToken = default);
}

/// <summary>
/// Represents the outcome of <see cref="IScheduledPublishingService"/> execution.
/// </summary>
public sealed record PublishingReport(
    int TotalExamined,
    int SuccessfullyPublished,
    int SkippedByRule,
    int Failed,
    IReadOnlyCollection<PublishingFailure> Failures)
{
    public static PublishingReport Empty =>
        new(0, 0, 0, 0, Array.Empty<PublishingFailure>());
}

/// <summary>
/// Contains information about a specific post that failed to publish.
/// </summary>
public sealed record PublishingFailure(PostId PostId, string Reason, Exception? Exception);

/// <inheritdoc />
internal sealed class ScheduledPublishingService : IScheduledPublishingService
{
    private readonly IPostRepository _postRepository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly IClock _clock;
    private readonly IMonetizationRuleEvaluator _monetizationRuleEvaluator;
    private readonly IDomainEventDispatcher _eventDispatcher;
    private readonly ILogger<ScheduledPublishingService> _logger;

    public ScheduledPublishingService(
        IPostRepository postRepository,
        IUnitOfWork unitOfWork,
        IClock clock,
        IMonetizationRuleEvaluator monetizationRuleEvaluator,
        IDomainEventDispatcher eventDispatcher,
        ILogger<ScheduledPublishingService> logger)
    {
        _postRepository           = postRepository ?? throw new ArgumentNullException(nameof(postRepository));
        _unitOfWork               = unitOfWork    ?? throw new ArgumentNullException(nameof(unitOfWork));
        _clock                    = clock         ?? throw new ArgumentNullException(nameof(clock));
        _monetizationRuleEvaluator= monetizationRuleEvaluator ?? throw new ArgumentNullException(nameof(monetizationRuleEvaluator));
        _eventDispatcher          = eventDispatcher ?? throw new ArgumentNullException(nameof(eventDispatcher));
        _logger                   = logger        ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public async Task<PublishingReport> PromoteDueScheduledPostsAsync(CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Scheduled publishing run started at {Instant}.", _clock.UtcNow);

        IReadOnlyList<IPost> duePosts =
            await _postRepository
                .FindScheduledDueAsync(_clock.UtcNow, cancellationToken)
                .ConfigureAwait(false);

        if (duePosts.Count == 0)
        {
            _logger.LogInformation("No due scheduled posts found.");
            return PublishingReport.Empty;
        }

        _logger.LogInformation("{Count} post(s) due for publishing.", duePosts.Count);

        var failures = new List<PublishingFailure>();
        int published = 0, skipped = 0;

        foreach (var post in duePosts)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                _logger.LogWarning("Publishing run aborted by cancellation request.");
                break;
            }

            try
            {
                // Evaluate monetization rules before publishing. E.g., premium gating, tier checks, etc.
                MonetizationDecision decision =
                    await _monetizationRuleEvaluator
                        .EvaluateAsync(post, cancellationToken)
                        .ConfigureAwait(false);

                if (decision == MonetizationDecision.DenyPublish)
                {
                    skipped++;
                    _logger.LogInformation(
                        "Post {PostId} skipped by monetization rule: {Reason}.",
                        post.Id, decision.Reason);
                    continue;
                }

                post.Publish(_clock.UtcNow);

                // Persist state change through repository + UoW.
                await _unitOfWork.SaveChangesAsync(cancellationToken).ConfigureAwait(false);

                // Propagate domain events so adapters (email, webhooks, cache invalidation, etc.) can react.
                await _eventDispatcher.DispatchAsync(post.PendingEvents, cancellationToken).ConfigureAwait(false);
                post.ClearPendingEvents();

                published++;
                _logger.LogInformation("Post {PostId} successfully published.", post.Id);
            }
            catch (Exception ex)
            {
                failures.Add(new PublishingFailure(post.Id, ex.Message, ex));
                _logger.LogError(ex, "Failed to publish post {PostId}.", post.Id);
            }
        }

        var report = new PublishingReport(
            TotalExamined       : duePosts.Count,
            SuccessfullyPublished : published,
            SkippedByRule       : skipped,
            Failed              : failures.Count,
            Failures            : failures);

        _logger.LogInformation(
            "Scheduled publishing run finished. Examined={Examined} Published={Published} Skipped={Skipped} Failed={Failed}",
            report.TotalExamined, report.SuccessfullyPublished, report.SkippedByRule, report.Failed);

        return report;
    }
}

// -----------------------------------------------------------------------------
// Port Definitions (simplified).  In a larger solution these reside in their
// dedicated namespaces/files but are colocated here for single-file delivery.
// -----------------------------------------------------------------------------

namespace TempoScribePro.Domain.Abstractions
{
    using System.Threading;
    using System.Threading.Tasks;
    using System.Collections.Generic;

    public interface IPostRepository
    {
        /// <summary>
        /// Returns every post that is <see cref="PostStatus.Scheduled"/> and whose
        /// <see cref="IPost.ScheduledAt"/> is earlier or equal to <paramref name="utcNow"/>.
        /// </summary>
        Task<IReadOnlyList<IPost>> FindScheduledDueAsync(DateTimeOffset utcNow, CancellationToken token);

        // Other repository members omitted for brevity.
    }

    public interface IUnitOfWork
    {
        Task SaveChangesAsync(CancellationToken token = default);
    }

    public interface IClock
    {
        DateTimeOffset UtcNow { get; }
    }

    /// <summary>
    /// Publishes raised domain events to their interested handlers.  Implementation
    /// could be based on in-process dispatcher (e.g., MediatR), message bus, etc.
    /// </summary>
    public interface IDomainEventDispatcher
    {
        Task DispatchAsync(IEnumerable<IDomainEvent> events, CancellationToken token = default);
    }

    public interface IDomainEvent { }
}

namespace TempoScribePro.Domain.Models
{
    using TempoScribePro.Domain.Abstractions;
    using System;
    using System.Collections.Generic;

    public enum PostStatus
    {
        Draft,
        Scheduled,
        Published,
        Archived,
        SoftDeleted
    }

    public readonly record struct PostId(Guid Value)
    {
        public static PostId New() => new(Guid.NewGuid());
        public override string ToString() => Value.ToString();
        public static implicit operator Guid(PostId id) => id.Value;
    }

    public interface IPost
    {
        PostId Id { get; }
        string Title { get; }
        DateTimeOffset CreatedAt { get; }
        DateTimeOffset? ScheduledAt { get; }
        PostStatus Status { get; }
        IReadOnlyCollection<IDomainEvent> PendingEvents { get; }

        void Publish(DateTimeOffset publishedAt);
        void ClearPendingEvents();
    }

    public sealed class Post : IPost
    {
        private readonly List<IDomainEvent> _events = new();

        public PostId Id { get; private init; } = PostId.New();
        public string Title { get; private init; } = string.Empty;
        public DateTimeOffset CreatedAt { get; private init; }
        public DateTimeOffset? ScheduledAt { get; private init; }
        public DateTimeOffset? PublishedAt { get; private set; }
        public PostStatus Status { get; private set; } = PostStatus.Draft;

        public IReadOnlyCollection<IDomainEvent> PendingEvents => _events.AsReadOnly();

        public void Publish(DateTimeOffset publishedAt)
        {
            if (Status == PostStatus.Published)
                throw new InvalidOperationException("Post is already published.");

            Status      = PostStatus.Published;
            PublishedAt = publishedAt;
            _events.Add(new PostPublishedEvent(Id, publishedAt));
        }

        public void ClearPendingEvents() => _events.Clear();
    }
}

namespace TempoScribePro.Domain.Events
{
    using TempoScribePro.Domain.Abstractions;
    using TempoScribePro.Domain.Models;
    using System;

    /// <summary>Raised when a post transitions into <see cref="PostStatus.Published"/>.</summary>
    public sealed record PostPublishedEvent(PostId PostId, DateTimeOffset PublishedAt) : IDomainEvent;
}

namespace TempoScribePro.Domain.Monetization
{
    using System.Threading;
    using System.Threading.Tasks;
    using TempoScribePro.Domain.Models;

    public enum MonetizationDecision
    {
        AllowPublish,
        DenyPublish
    }

    public readonly struct MonetizationDecisionInfo
    {
        public MonetizationDecision Decision { get; init; }
        public string? Reason { get; init; }
        public static implicit operator MonetizationDecision(MonetizationDecisionInfo info) => info.Decision;
    }

    public interface IMonetizationRuleEvaluator
    {
        Task<MonetizationDecisionInfo> EvaluateAsync(IPost post, CancellationToken token = default);
    }
}

namespace TempoScribePro.Domain.Shared
{
    // Shared / common utilities would live here. Included for namespace completeness.
}
```
