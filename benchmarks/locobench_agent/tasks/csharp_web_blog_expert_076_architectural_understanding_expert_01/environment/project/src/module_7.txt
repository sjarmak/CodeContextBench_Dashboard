```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Services
{
    /// <summary>
    /// Domain-level service responsible for automatically publishing posts that are due
    /// and broadcasting notifications to interested parties (subscribers, editors, etc.).
    /// </summary>
    public sealed class ScheduledPublishingService : IScheduledPublishingService
    {
        private readonly IPostRepository           _postRepository;
        private readonly INotificationPort         _notificationPort;
        private readonly IPostCache                _postCache;
        private readonly ISystemClock              _clock;
        private readonly ILogger<ScheduledPublishingService> _logger;

        public ScheduledPublishingService(
            IPostRepository   postRepository,
            INotificationPort notificationPort,
            IPostCache        postCache,
            ISystemClock      clock,
            ILogger<ScheduledPublishingService> logger)
        {
            _postRepository   = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _notificationPort = notificationPort?? throw new ArgumentNullException(nameof(notificationPort));
            _postCache        = postCache       ?? throw new ArgumentNullException(nameof(postCache));
            _clock            = clock           ?? throw new ArgumentNullException(nameof(clock));
            _logger           = logger          ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task<int> PublishDuePostsAsync(CancellationToken ct = default)
        {
            var nowUtc = _clock.UtcNow;
            _logger.LogDebug("Scanning for scheduled posts due before {NowUtc}", nowUtc);

            IReadOnlyCollection<Post> duePosts;
            try
            {
                duePosts = (await _postRepository
                        .GetScheduledPostsAsync(nowUtc, ct)
                        .ConfigureAwait(false))
                        .ToArray();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to load scheduled posts");
                throw;
            }

            if (duePosts.Count == 0)
            {
                _logger.LogDebug("No scheduled posts found");
                return 0;
            }

            _logger.LogInformation("Found {Count} post(s) due for publishing", duePosts.Count);

            var publishedPosts = new List<Post>(duePosts.Count);

            foreach (var post in duePosts)
            {
                try
                {
                    PublishPost(post, nowUtc);
                    await _postRepository.UpdateAsync(post, ct).ConfigureAwait(false);
                    await _postCache.InvalidateAsync(post.Id, ct).ConfigureAwait(false);
                    publishedPosts.Add(post);

                    _logger.LogInformation("Published post {PostId} ({Title})", post.Id, post.Title);
                }
                catch (Exception ex)
                {
                    // A single failed post should not block others.
                    _logger.LogError(ex,
                        "Failed to publish scheduled post {PostId} – continuing with next post",
                        post.Id);
                }
            }

            await BroadcastNotificationsAsync(publishedPosts, ct).ConfigureAwait(false);
            return publishedPosts.Count;
        }

        private static void PublishPost(Post post, DateTimeOffset publishedAtUtc)
        {
            if (post is null) throw new ArgumentNullException(nameof(post));

            if (post.Status == PostStatus.Published)
            {
                throw new InvalidOperationException($"Post {post.Id} is already published.");
            }

            post.Status       = PostStatus.Published;
            post.PublishedAt  = publishedAtUtc;
            post.ScheduledFor = null; // Clear schedule
        }

        private async Task BroadcastNotificationsAsync(
            IReadOnlyCollection<Post> publishedPosts,
            CancellationToken ct)
        {
            if (publishedPosts.Count == 0) return;

            foreach (var post in publishedPosts)
            {
                var recipients = await _postRepository
                    .GetSubscribersAsync(post.Id, ct)
                    .ConfigureAwait(false);

                if (!recipients.Any()) continue;

                var message = NotificationMessage.CreateForNewPost(post);
                try
                {
                    await _notificationPort
                        .SendAsync(message, recipients, ct)
                        .ConfigureAwait(false);
                    _logger.LogDebug(
                        "Notified {RecipientCount} recipient(s) for post {PostId}",
                        recipients.Count(), post.Id);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex,
                        "Failed to send notifications for post {PostId}",
                        post.Id);
                }
            }
        }
    }

    #region Interfaces & Supporting Models

    /// <summary>
    /// Hexagonal port: abstraction for clock to keep time deterministic/testable.
    /// </summary>
    public interface ISystemClock
    {
        DateTimeOffset UtcNow { get; }
    }

    /// <summary>
    /// Hexagonal port: repository abstraction for accessing post aggregates.
    /// </summary>
    public interface IPostRepository
    {
        Task<IReadOnlyCollection<Post>> GetScheduledPostsAsync(
            DateTimeOffset upToUtc,
            CancellationToken ct);

        Task UpdateAsync(Post post, CancellationToken ct);

        /// <summary>
        /// Returns the set of users that should be notified for a given post.
        /// </summary>
        Task<IReadOnlyCollection<User>> GetSubscribersAsync(
            Guid postId,
            CancellationToken ct);
    }

    /// <summary>
    /// Hexagonal port: outbound adaptor for pushing notifications to external systems
    /// (e-mail, push, websocket, etc.).
    /// </summary>
    public interface INotificationPort
    {
        Task SendAsync(
            NotificationMessage message,
            IEnumerable<User> recipients,
            CancellationToken ct);
    }

    /// <summary>
    /// Hexagonal port: caching adapter for invalidating or seeding post-level caches.
    /// </summary>
    public interface IPostCache
    {
        Task InvalidateAsync(Guid postId, CancellationToken ct);
    }

    /// <summary>
    /// Service layer contract—facilitates IoC, mocking, and orchestration.
    /// </summary>
    public interface IScheduledPublishingService
    {
        /// <summary>
        /// Publishes all posts scheduled up to the current (UTC) time and
        /// notifies subscribers. Returns the number of posts successfully published.
        /// </summary>
        Task<int> PublishDuePostsAsync(CancellationToken ct = default);
    }

    /// <summary>
    /// Slim view of a user for notification purposes.
    /// </summary>
    public sealed record User(Guid Id, string Email);

    /// <summary>
    /// Lightweight DTO for outbound notification pipelines.
    /// </summary>
    public sealed record NotificationMessage(
        string Subject,
        string Body,
        Uri    TargetUrl)
    {
        public static NotificationMessage CreateForNewPost(Post post)
        {
            var subject = $"New post published: {post.Title}";
            var body    = $"{post.AuthorName} just published \"{post.Title}\".\n\nRead now: {post.PublicUrl}";
            return new NotificationMessage(subject, body, post.PublicUrl);
        }
    }

    /// <summary>
    /// Enumerates the various states of a blog post.
    /// </summary>
    public enum PostStatus
    {
        Draft        = 0,
        Scheduled    = 1,
        Published    = 2,
        Archived     = 3
    }

    /// <summary>
    /// Core domain model for a blog post. Only the fields relevant to scheduling
    /// are included here; other properties/methods live elsewhere in the domain.
    /// </summary>
    public sealed class Post
    {
        public Guid            Id            { get; init; }
        public string          Title         { get; private set; } = null!;
        public string          AuthorName    { get; private set; } = null!;
        public Uri             PublicUrl     { get; private set; } = null!;
        public PostStatus      Status        { get; set; } = PostStatus.Draft;
        public DateTimeOffset? ScheduledFor  { get; set; }
        public DateTimeOffset? PublishedAt   { get; set; }
    }

    #endregion
}
```