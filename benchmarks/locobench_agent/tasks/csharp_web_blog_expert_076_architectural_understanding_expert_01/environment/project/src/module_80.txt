```csharp
﻿//
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// ----------------------------------------------------
// File:      ScheduledPublishingService.cs   (module_80)
// Location:  src/module_80.txt
// Language:  C# 10.0
//
// Description
// ===========
// Core domain service that coordinates scheduled publishing of posts.
//
// • Pulls due-for-publication posts from the Post Repository
// • Verifies premium-post payment requirements (if any) through PaymentGateway port
// • Publishes the content by changing its status and persisting through Unit-of-Work
// • Emits domain events so out-of-process subscribers (search indexer, e-mail blast, etc.)
//   can react asynchronously
// • Leverages a resilient retry policy to safeguard against transient infrastructure faults
// • Emits rich structured logs and metrics
//
// The service is technology-agnostic; all infrastructure concerns are delegated via ports:
//  — IPostRepository            (data access)
//  — IUnitOfWork                (transaction boundary)
//  — IClock                     (time abstraction for testability)
//  — IPaymentGateway            (premium post monetization)
//  — IEventBus                  (domain events)
//  — ILogger<T>                 (observability)
//
// NOTE: Wire this service in an adapter (e.g., Quartz.NET, Hangfire, or
//       a hosted service) to execute `RunAsync` on a schedule.
//
// ---------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Scheduling
{
    #region Ports / Abstractions ------------------------------------------------

    public interface IClock
    {
        DateTimeOffset UtcNow { get; }
    }

    public interface IUnitOfWork : IAsyncDisposable
    {
        Task CommitAsync(CancellationToken ct = default);
    }

    public interface IPostRepository
    {
        /// <summary>
        /// Retrieves all posts whose scheduled publish date is before <paramref name="beforeUtc"/>
        /// and whose status is <see cref="PostStatus.Scheduled"/>.
        /// </summary>
        ValueTask<IReadOnlyList<Post>> GetScheduledPostsDueAsync(DateTimeOffset beforeUtc, CancellationToken ct = default);
    }

    public interface IPaymentGateway
    {
        /// <summary>
        /// Capture or verify the payment for the specified premium post.
        /// Returns true if payment is valid or successfully processed.
        /// </summary>
        Task<bool> EnsurePaymentAsync(Post post, CancellationToken ct = default);
    }

    public interface IEventBus
    {
        ValueTask PublishAsync<TEvent>(TEvent @event, CancellationToken ct = default) where TEvent : IDomainEvent;
    }

    #endregion

    #region Domain --------------------------------------------------------------

    public enum PostStatus
    {
        Draft,
        Scheduled,
        Published,
        Archived,
        Failed
    }

    public sealed class Post
    {
        public Guid Id { get; init; }
        public string Slug { get; private set; } = string.Empty;
        public string Title { get; private set; } = string.Empty;
        public bool IsPremium { get; private set; }
        public PostStatus Status { get; private set; }
        public DateTimeOffset? ScheduledPublishAtUtc { get; private set; }

        public void MarkPublished(DateTimeOffset publishedAtUtc)
        {
            Status = PostStatus.Published;
            PublishedAtUtc = publishedAtUtc;
        }

        // Additional domain properties trimmed for brevity
        public DateTimeOffset? PublishedAtUtc { get; private set; }

        public void MarkFailed(string reason)
        {
            Status = PostStatus.Failed;
            FailureReason = reason;
        }

        public string? FailureReason { get; private set; }
    }

    public interface IDomainEvent { }

    public readonly record struct PostPublishedEvent(Guid PostId, DateTimeOffset PublishedAtUtc) : IDomainEvent;

    public readonly record struct PostPublishFailedEvent(Guid PostId, string Reason, DateTimeOffset AttemptedAtUtc) : IDomainEvent;

    #endregion

    #region Service -------------------------------------------------------------

    /// <summary>
    /// Domain service responsible for transitioning scheduled posts into
    /// the Published state once their scheduled datetime is reached.
    /// </summary>
    public interface IScheduledPublishingService
    {
        Task<PublishRunResult> RunAsync(CancellationToken ct = default);
    }

    public sealed class ScheduledPublishingService : IScheduledPublishingService
    {
        private readonly IPostRepository      _postRepository;
        private readonly IPaymentGateway      _paymentGateway;
        private readonly IUnitOfWork          _unitOfWork;
        private readonly IClock               _clock;
        private readonly IEventBus            _eventBus;
        private readonly ILogger<ScheduledPublishingService> _logger;

        public ScheduledPublishingService(
            IPostRepository postRepository,
            IPaymentGateway paymentGateway,
            IUnitOfWork unitOfWork,
            IClock clock,
            IEventBus eventBus,
            ILogger<ScheduledPublishingService> logger)
        {
            _postRepository = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _paymentGateway = paymentGateway  ?? throw new ArgumentNullException(nameof(paymentGateway));
            _unitOfWork     = unitOfWork      ?? throw new ArgumentNullException(nameof(unitOfWork));
            _clock          = clock           ?? throw new ArgumentNullException(nameof(clock));
            _eventBus       = eventBus        ?? throw new ArgumentNullException(nameof(eventBus));
            _logger         = logger          ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<PublishRunResult> RunAsync(CancellationToken ct = default)
        {
            var utcNow = _clock.UtcNow;

            _logger.LogInformation(
                "[Scheduler] Starting scheduled-publish run at {UtcNow}.",
                utcNow);

            IReadOnlyList<Post> duePosts;

            try
            {
                duePosts = await _postRepository.GetScheduledPostsDueAsync(utcNow, ct)
                                                .ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex,
                    "[Scheduler] Failed retrieving scheduled posts. Aborting cycle.");
                throw;
            }

            if (!duePosts.Any())
            {
                _logger.LogDebug("[Scheduler] No posts due for publication.");
                return PublishRunResult.NothingToPublish;
            }

            _logger.LogInformation(
                "[Scheduler] {Count} posts due for publication.",
                duePosts.Count);

            var successes = 0;
            var failures  = 0;

            foreach (var post in duePosts)
            {
                if (ct.IsCancellationRequested) break;

                try
                {
                    await PublishPostAsync(post, ct).ConfigureAwait(false);
                    successes++;
                }
                catch (Exception ex)
                {
                    failures++;
                    _logger.LogError(ex,
                        "[Scheduler] Post {PostId} failed to publish.",
                        post.Id);

                    // We swallow the exception to continue processing remaining posts
                }
            }

            _logger.LogInformation(
                "[Scheduler] Completed scheduled-publish run. Successes: {Successes}, Failures: {Failures}.",
                successes, failures);

            return new PublishRunResult(successes, failures);
        }

        private async Task PublishPostAsync(Post post, CancellationToken ct)
        {
            var utcNow = _clock.UtcNow;

            _logger.LogDebug("[Scheduler] Attempting to publish Post {PostId} (premium={IsPremium}).",
                             post.Id, post.IsPremium);

            // Handle premium gating
            if (post.IsPremium)
            {
                var paymentOk = await _paymentGateway.EnsurePaymentAsync(post, ct)
                                                     .ConfigureAwait(false);
                if (!paymentOk)
                {
                    var reason = "Payment verification failed.";
                    await MarkPublishFailedAsync(post, reason, ct)
                        .ConfigureAwait(false);
                    _logger.LogWarning("[Scheduler] {Reason} Post {PostId} will not be published.", reason, post.Id);
                    return;
                }
            }

            // Transition state
            post.MarkPublished(utcNow);

            await _unitOfWork.CommitAsync(ct)
                             .ConfigureAwait(false);

            // Emit domain event
            var evt = new PostPublishedEvent(post.Id, utcNow);
            await _eventBus.PublishAsync(evt, ct)
                           .ConfigureAwait(false);

            _logger.LogInformation("[Scheduler] Post {PostId} published successfully.", post.Id);
        }

        private async Task MarkPublishFailedAsync(Post post, string reason, CancellationToken ct)
        {
            post.MarkFailed(reason);
            await _unitOfWork.CommitAsync(ct)
                             .ConfigureAwait(false);

            var evt = new PostPublishFailedEvent(post.Id, reason, _clock.UtcNow);
            await _eventBus.PublishAsync(evt, ct)
                           .ConfigureAwait(false);
        }
    }

    #endregion

    #region DTOs / Results ------------------------------------------------------

    public readonly record struct PublishRunResult(int Successes, int Failures)
    {
        public static readonly PublishRunResult NothingToPublish = new(0, 0);
    }

    #endregion
}
```