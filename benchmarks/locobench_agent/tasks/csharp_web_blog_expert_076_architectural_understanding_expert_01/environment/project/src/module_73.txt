```csharp
// File: src/module_73.txt
// TempoScribe Pro – Hexagonal Productivity Blog Suite
//
// Purpose:
// Redis-backed cache adapter for post–level editorial analytics. Implements
// IEditorialAnalyticsCache port defined in the domain core. Keeps the cache
// decoupled from concrete Redis APIs and encapsulates serialization concerns.
//
// NOTE: While the file extension is .txt in the repository scaffold, the
// content is C# and is compiled into the Infrastructure assembly.

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using StackExchange.Redis;
using TempoScribePro.Domain.Analytics;
using TempoScribePro.Domain.Ports.Caching;

namespace TempoScribePro.Infrastructure.Caching.Redis
{
    /// <summary>
    /// Concrete adapter that stores/retrieves <see cref="PostAnalyticsDto"/> entities
    /// in a Redis cache. Implements the <see cref="IEditorialAnalyticsCache"/> port
    /// so the domain remains infrastructure-agnostic.
    /// </summary>
    public sealed class RedisEditorialAnalyticsCacheAdapter : IEditorialAnalyticsCache, IAsyncDisposable
    {
        private const string DefaultPrefix = "ts:analytics";
        private readonly ILogger<RedisEditorialAnalyticsCacheAdapter> _logger;
        private readonly CacheSettings _settings;
        private readonly IDatabase _database;
        private readonly JsonSerializerOptions _serializerOptions;

        public RedisEditorialAnalyticsCacheAdapter(
            IConnectionMultiplexer connection,
            IOptions<CacheSettings> settings,
            ILogger<RedisEditorialAnalyticsCacheAdapter> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            if (settings is null) throw new ArgumentNullException(nameof(settings));
            _settings = settings.Value;

            _database = (connection ?? throw new ArgumentNullException(nameof(connection))).GetDatabase();

            _serializerOptions = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                IgnoreReadOnlyProperties = true,
                DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
            };

            _logger.LogInformation("RedisEditorialAnalyticsCacheAdapter initialized with prefix {Prefix}", _settings.RedisKeyPrefix ?? DefaultPrefix);
        }

        #region IEditorialAnalyticsCache Members

        /// <inheritdoc />
        public async Task<PostAnalyticsDto?> GetAsync(Guid postId, CancellationToken token = default)
        {
            var key = BuildKey(postId);
            try
            {
                var cachedData = await _database.StringGetAsync(key).ConfigureAwait(false);
                if (!cachedData.HasValue)
                {
                    _logger.LogDebug("Analytics cache miss for PostId {PostId}", postId);
                    return null;
                }

                _logger.LogDebug("Analytics cache hit for PostId {PostId}", postId);
                return JsonSerializer.Deserialize<PostAnalyticsDto>(cachedData!, _serializerOptions);
            }
            catch (Exception ex) when (ex is JsonException or RedisException)
            {
                _logger.LogError(ex, "Failed to retrieve analytics for PostId {PostId} from cache", postId);
                throw; // Bubble up – caller decides on fallback strategy.
            }
        }

        /// <inheritdoc />
        public async Task SetAsync(Guid postId, PostAnalyticsDto analytics, CancellationToken token = default)
        {
            if (analytics is null) throw new ArgumentNullException(nameof(analytics));

            var key = BuildKey(postId);
            var serialized = JsonSerializer.Serialize(analytics, _serializerOptions);
            var expiry = _settings.AbsoluteExpiration ?? TimeSpan.FromMinutes(10);

            try
            {
                var success = await _database.StringSetAsync(key, serialized, expiry).ConfigureAwait(false);

                if (!success)
                {
                    _logger.LogWarning("Failed to set analytics cache for PostId {PostId}", postId);
                }
                else
                {
                    _logger.LogDebug("Analytics cached for PostId {PostId} with expiry {Expiry}", postId, expiry);
                }
            }
            catch (RedisException ex)
            {
                _logger.LogError(ex, "Redis error while caching analytics for PostId {PostId}", postId);
                throw;
            }
        }

        /// <inheritdoc />
        public async Task RemoveAsync(Guid postId, CancellationToken token = default)
        {
            var key = BuildKey(postId);
            try
            {
                await _database.KeyDeleteAsync(key).ConfigureAwait(false);
                _logger.LogDebug("Analytics cache invalidated for PostId {PostId}", postId);
            }
            catch (RedisException ex)
            {
                _logger.LogError(ex, "Redis error while invalidating analytics for PostId {PostId}", postId);
                throw;
            }
        }

        #endregion

        #region IDisposable Members

        public async ValueTask DisposeAsync()
        {
            // We do not own the connection multiplexer (created by DI / factory),
            // so nothing to dispose here. Still, we expose an async disposable
            // to respect adapter lifetime expectations.
            await Task.CompletedTask.ConfigureAwait(false);
        }

        #endregion

        #region Private Helpers

        private string BuildKey(Guid postId) =>
            $"{(_settings.RedisKeyPrefix ?? DefaultPrefix)}:post:{postId:N}";

        #endregion
    }

    /// <summary>
    /// Settings object bound from configuration (appsettings.json / environment vars).
    /// </summary>
    public sealed class CacheSettings
    {
        /// <summary>
        /// Prefix applied to every cached key to avoid collisions between multiple
        /// TempoScribe Pro tenants or other applications sharing the same Redis instance.
        /// </summary>
        public string RedisKeyPrefix { get; init; } = "ts:analytics";

        /// <summary>
        /// Primary cache TTL. After this time the entry is evicted automatically.
        /// Defaults to 10 minutes if unspecified.
        /// </summary>
        public TimeSpan? AbsoluteExpiration { get; init; } = TimeSpan.FromMinutes(10);
    }
}

namespace TempoScribePro.Domain.Ports.Caching
{
    /// <summary>
    /// Hexagonal port that defines caching capabilities for post analytics.
    /// Implemented by infrastructure adapters like Redis, in-memory, or null-object caches.
    /// </summary>
    public interface IEditorialAnalyticsCache
    {
        /// <summary>
        /// Fetch analytics for a particular post from cache, if available.
        /// </summary>
        Task<PostAnalyticsDto?> GetAsync(Guid postId, CancellationToken token = default);

        /// <summary>
        /// Persist analytics to cache.
        /// </summary>
        Task SetAsync(Guid postId, PostAnalyticsDto analytics, CancellationToken token = default);

        /// <summary>
        /// Remove analytics from cache (e.g., when post is updated).
        /// </summary>
        Task RemoveAsync(Guid postId, CancellationToken token = default);
    }
}

namespace TempoScribePro.Domain.Analytics
{
    /// <summary>
    /// Lightweight DTO representing aggregated analytics for a single post.
    /// Stored in cache, separate from domain entity to keep serialization lean.
    /// </summary>
    public sealed record PostAnalyticsDto(
        Guid PostId,
        long ViewCount,
        long UniqueVisitors,
        long CommentCount,
        decimal EstimatedReadTimeSeconds,
        DateTimeOffset CapturedAtUtc);
}
```