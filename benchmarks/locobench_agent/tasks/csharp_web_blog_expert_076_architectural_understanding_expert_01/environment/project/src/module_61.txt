```csharp
// File: src/module_61.txt
// Project: TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// Language: C#
// Description: Domain-level publishing scheduler that automatically publishes
//              posts whose ScheduledPublishAt date has elapsed.  Uses a pure
//              hexagonal design: all infrastructure concerns are accessed via
//              ports (interfaces) that can be swapped out by adapters at run-time.
// ----------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace TempoScribePro.Domain.Scheduling
{
    #region Ports (Interfaces)

    /// <summary>
    /// Abstraction over time retrieval to keep code deterministic & testable.
    /// </summary>
    public interface IClock
    {
        DateTime UtcNow { get; }
    }

    /// <summary>
    /// Generic event bus that publishes domain events to interested handlers.
    /// </summary>
    public interface IEventBus
    {
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct = default);
    }

    /// <summary>
    /// Repository for querying & persisting Post aggregates.
    /// </summary>
    public interface IPostRepository
    {
        Task<IReadOnlyCollection<Post>> GetScheduledPostsAsync(DateTime asOfUtc, CancellationToken ct = default);
        Task SaveAsync(Post post, CancellationToken ct = default);
    }

    /// <summary>
    /// Application-wide logging abstraction.
    /// </summary>
    public interface ILogger
    {
        void Trace(string message);
        void Info(string message);
        void Warn(string message, Exception? ex = null);
        void Error(string message, Exception ex);
    }

    #endregion

    #region Domain Model

    /// <summary>
    /// Aggregate root representing a blog post.
    /// </summary>
    public sealed class Post
    {
        public Guid Id { get; }
        public string Title { get; private set; }
        public PostStatus Status { get; private set; }
        public DateTime? ScheduledPublishAtUtc { get; private set; }
        public DateTime? PublishedAtUtc { get; private set; }
        public string ContentMarkdown { get; private set; }
        public string? RowVersion { get; private set; } // Concurrency token (e.g., SQL timestamp/base64)

        public Post(
            Guid id,
            string title,
            string contentMarkdown,
            PostStatus status = PostStatus.Draft,
            DateTime? scheduledPublishAtUtc = null,
            string? rowVersion = null)
        {
            Id = id;
            Title = title;
            ContentMarkdown = contentMarkdown;
            Status = status;
            ScheduledPublishAtUtc = scheduledPublishAtUtc;
            RowVersion = rowVersion;
        }

        /// <summary>
        /// Marks the post as published and returns a domain event.
        /// </summary>
        public PostPublishedEvent Publish(IClock clock)
        {
            if (Status == PostStatus.Published)
            {
                throw new InvalidOperationException(
                    $"Cannot publish post '{Id}' because it is already published.");
            }

            Status = PostStatus.Published;
            PublishedAtUtc = clock.UtcNow;
            ScheduledPublishAtUtc = null; // Clear scheduling

            return new PostPublishedEvent(Id, PublishedAtUtc.Value);
        }
    }

    public enum PostStatus
    {
        Draft = 0,
        Scheduled = 1,
        Published = 2,
    }

    #endregion

    #region Domain Events

    /// <summary>
    /// Event raised when a post transitions to Published.
    /// </summary>
    public sealed record PostPublishedEvent(Guid PostId, DateTime PublishedAtUtc);

    #endregion

    #region Service

    /// <summary>
    /// Application service that scans for scheduled posts whose
    /// schedule has elapsed and publishes them automatically.
    ///
    /// IMPORTANT: Intentionally stateless.  Infrastructure (e.g. EF Core)
    ///            handles cross-service crypto concurrency via RowVersion.
    /// </summary>
    public sealed class PublishingSchedulerService
    {
        private readonly IClock _clock;
        private readonly IPostRepository _posts;
        private readonly IEventBus _events;
        private readonly ILogger _log;

        public PublishingSchedulerService(
            IClock clock,
            IPostRepository posts,
            IEventBus events,
            ILogger log)
        {
            _clock = clock;
            _posts = posts;
            _events = events;
            _log = log;
        }

        /// <summary>
        /// Runs a single publishing scan cycle.
        /// </summary>
        /// <param name="ct">Cancel to abort early.</param>
        public async Task ScanAsync(CancellationToken ct = default)
        {
            var now = _clock.UtcNow;

            _log.Trace($"Starting scheduled-publishing scan at {now:O}.");

            IReadOnlyCollection<Post> duePosts;
            try
            {
                duePosts = await _posts.GetScheduledPostsAsync(now, ct).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _log.Error("Failed to query scheduled posts.", ex);
                return;
            }

            if (!duePosts.Any())
            {
                _log.Trace("No scheduled posts ready for publishing.");
                return;
            }

            _log.Info($"Found {duePosts.Count} post(s) ready for publishing.");

            foreach (var post in duePosts)
            {
                if (ct.IsCancellationRequested)
                    break;

                try
                {
                    var publishEvent = post.Publish(_clock);

                    // Persist state change
                    await _posts.SaveAsync(post, ct).ConfigureAwait(false);

                    // Broadcast event
                    await _events.PublishAsync(publishEvent, ct).ConfigureAwait(false);

                    _log.Info($"Successfully auto-published post {post.Id} — '{post.Title}'.");
                }
                catch (InvalidOperationException oe)
                {
                    _log.Warn($"Skipping post {post.Id}. Reason: {oe.Message}", oe);
                }
                catch (Exception ex)
                {
                    // We do NOT throw to avoid halting other posts. Instead log & continue.
                    _log.Error($"Failed to auto-publish post {post.Id}.", ex);
                }
            }

            _log.Trace("Scheduled-publishing scan finished.");
        }
    }

    #endregion
}
```