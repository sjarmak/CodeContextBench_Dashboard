```csharp
// src/module_10.txt
// TempoScribe Pro â€“ Hexagonal Productivity Blog Suite (web_blog)
// Module: Publishing Automation
//
// This file defines the domain port IPostPublicationScheduler and a Quartz-based
// adapter QuartzPublicationSchedulerAdapter that schedules and cancels
// post-publication jobs.  The code is production-ready, follows our hexagonal
// design rules, and is safe to swap out (i.e. replace Quartz with Hangfire)
// without touching the core domain.
//
// References (NuGet):
//   - Quartz           (scheduler)
//   - Microsoft.Extensions.Logging.Abstractions
//   - TempoScribePro.Core (domain models & contracts)
//
// Author: TempoScribe Pro Team

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Quartz;

namespace TempoScribePro.Core.PublishingAutomation
{
    /// <summary>
    /// Port that defines how the core domain schedules a post
    /// for future publication.  Implementations are infrastructure
    /// concerns (e.g. Quartz, Hangfire, native DB scheduling).
    /// </summary>
    public interface IPostPublicationScheduler
    {
        /// <summary>
        /// Schedule a post to be published at the specified time.
        /// </summary>
        /// <param name="post">The publication payload containing post metadata.</param>
        /// <param name="ct">Cancellation token for cooperative cancellation.</param>
        Task ScheduleAsync(ScheduledPost post, CancellationToken ct = default);

        /// <summary>
        /// Cancel a previously scheduled publication job.
        /// </summary>
        /// <param name="postId">The unique identifier of the post.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>True if a job existed and was removed; otherwise, false.</returns>
        Task<bool> CancelAsync(Guid postId, CancellationToken ct = default);
    }

    /// <summary>
    /// Value object representing a scheduled post with lightweight validation.
    /// Uses a factory to avoid anemic constructors.
    /// </summary>
    public sealed class ScheduledPost
    {
        private ScheduledPost(Guid id,
                              Guid authorId,
                              string title,
                              DateTimeOffset publishAtUtc)
        {
            Id           = id;
            AuthorId     = authorId;
            Title        = title;
            PublishAtUtc = publishAtUtc;
        }

        /// <summary>Primary key of the post aggregate.</summary>
        public Guid Id { get; }

        /// <summary>Author who owns the post.</summary>
        public Guid AuthorId { get; }

        /// <summary>Title used strictly for logging/observability.</summary>
        public string Title { get; }

        /// <summary>UTC time at which the post should be published.</summary>
        public DateTimeOffset PublishAtUtc { get; }

        /// <summary>
        /// Factory method with basic domain validation.
        /// </summary>
        /// <exception cref="ArgumentException">
        /// Thrown when invalid data is supplied.
        /// </exception>
        public static ScheduledPost Create(Guid id,
                                           Guid authorId,
                                           string title,
                                           DateTimeOffset publishAtUtc)
        {
            if (id == Guid.Empty)          throw new ArgumentException("Post id cannot be empty.", nameof(id));
            if (authorId == Guid.Empty)    throw new ArgumentException("Author id cannot be empty.", nameof(authorId));
            if (string.IsNullOrWhiteSpace(title))
                throw new ArgumentException("Title is required.", nameof(title));
            if (publishAtUtc <= DateTimeOffset.UtcNow)
                throw new ArgumentException("PublishAtUtc must be in the future.", nameof(publishAtUtc));

            return new ScheduledPost(id, authorId, title.Trim(), publishAtUtc);
        }
    }
}

namespace TempoScribePro.Adapters.Quartz.PublishingAutomation
{
    using TempoScribePro.Core.PublishingAutomation;

    /// <summary>
    /// Quartz implementation of the publication scheduler.
    /// Respects the IPostPublicationScheduler port, enabling painless swapping.
    /// </summary>
    public sealed class QuartzPublicationSchedulerAdapter : IPostPublicationScheduler, IAsyncDisposable
    {
        private const string JobGroup   = "TempoScribePro.PostPublishing";
        private const string TriggerGrp = "TempoScribePro.PublishTriggers";

        private readonly IScheduler               _scheduler;
        private readonly ILogger<QuartzPublicationSchedulerAdapter> _logger;

        public QuartzPublicationSchedulerAdapter(IScheduler scheduler,
                                                 ILogger<QuartzPublicationSchedulerAdapter> logger)
        {
            _scheduler = scheduler ?? throw new ArgumentNullException(nameof(scheduler));
            _logger    = logger    ?? throw new ArgumentNullException(nameof(logger));
        }

        #region IPostPublicationScheduler

        public async Task ScheduleAsync(ScheduledPost post, CancellationToken ct = default)
        {
            if (post == null) throw new ArgumentNullException(nameof(post));

            ct.ThrowIfCancellationRequested();

            var jobKey = CreateJobKey(post.Id);
            if (await _scheduler.CheckExists(jobKey, ct))
            {
                // Replace existing schedule (idempotent behaviour)
                await CancelAsync(post.Id, ct);
            }

            var job = JobBuilder
                .Create<PublishPostJob>()
                .WithIdentity(jobKey)
                .UsingJobData(nameof(ScheduledPost.Id),        post.Id.ToString())
                .UsingJobData(nameof(ScheduledPost.AuthorId),  post.AuthorId.ToString())
                .UsingJobData(nameof(ScheduledPost.Title),     post.Title)
                .Build();

            var trigger = TriggerBuilder
                .Create()
                .WithIdentity(CreateTriggerKey(post.Id))
                .StartAt(post.PublishAtUtc.UtcDateTime)
                .WithSimpleSchedule(x => x.WithMisfireHandlingInstructionFireNow())
                .ForJob(job)
                .Build();

            await _scheduler.ScheduleJob(job, trigger, ct);

            _logger.LogInformation("Scheduled post '{Title}' (Id: {Id}) for {PublishAt}.",
                                   post.Title, post.Id, post.PublishAtUtc);
        }

        public async Task<bool> CancelAsync(Guid postId, CancellationToken ct = default)
        {
            if (postId == Guid.Empty) throw new ArgumentException("Post id cannot be empty.", nameof(postId));

            ct.ThrowIfCancellationRequested();

            var jobKey = CreateJobKey(postId);
            var deleted = await _scheduler.DeleteJob(jobKey, ct);

            if (deleted)
                _logger.LogInformation("Cancelled scheduled publication for PostId {PostId}.", postId);
            else
                _logger.LogWarning("Attempted to cancel non-existent schedule for PostId {PostId}.", postId);

            return deleted;
        }

        #endregion

        #region Quartz bookkeeping helpers

        private static JobKey CreateJobKey(Guid postId) =>
            new JobKey($"PublishPost#{postId}", JobGroup);

        private static TriggerKey CreateTriggerKey(Guid postId) =>
            new TriggerKey($"PublishTrigger#{postId}", TriggerGrp);

        #endregion

        #region Async disposal

        public async ValueTask DisposeAsync()
        {
            if (!_scheduler.IsShutdown)
            {
                await _scheduler.Shutdown(waitForJobsToComplete: false);
            }
        }

        #endregion
    }

    /// <summary>
    /// Quartz job that raises a domain event to publish a post.
    /// In the real system the event would be dispatched to an application layer
    /// handler which completes the publication workflow.
    /// </summary>
    public sealed class PublishPostJob : IJob
    {
        private readonly ILogger<PublishPostJob> _logger;
        // In a full implementation this would be an IEventBus or ApplicationService
        // injected via DI to perform the actual publish operation.

        public PublishPostJob(ILogger<PublishPostJob> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public Task Execute(IJobExecutionContext context)
        {
            var data = context.MergedJobDataMap;

            var postId  = Guid.Parse(data.GetString(nameof(ScheduledPost.Id)));
            var title   = data.GetString(nameof(ScheduledPost.Title));

            _logger.LogInformation("Executing scheduled publish for Post '{Title}' (Id: {Id})", title, postId);

            // TODO: Raise domain event or call application service.
            // PublishPostCommand command = new(postId);
            // await _mediator.Send(command);

            return Task.CompletedTask;
        }
    }
}
```