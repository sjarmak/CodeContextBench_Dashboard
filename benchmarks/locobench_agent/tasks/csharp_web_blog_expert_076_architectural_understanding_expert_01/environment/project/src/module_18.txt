```csharp
// File: src/module_18.txt
// Project: TempoScribe Pro – Hexagonal Productivity Blog Suite
// Description:
//   Core domain service responsible for promoting “scheduled” blog posts
//   to “published” status once they become due.  This module lives inside
//   the domain (hexagon) and communicates only through well-defined ports
//   (repositories, clocks, and event buses).  Infrastructure details such
//   as SQL/NoSQL storage, message brokers, etc. live in their own adapter
//   projects and are therefore invisible here.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Scheduling
{
    #region Domain Contracts (Ports)

    /// <summary>
    /// Repository abstraction for reading and mutating <see cref="Post"/>s.
    /// Infrastructure adapters (EF Core, Dapper, Mongo, etc.) implement this.
    /// </summary>
    public interface IPostRepository
    {
        /// <summary>
        /// Returns every post with <see cref="PostStatus.Scheduled"/> where
        /// <see cref="Post.ScheduledAtUtc"/> is less than or equal to <paramref name="beforeUtc"/>.
        /// </summary>
        Task<IReadOnlyList<Post>> GetPostsScheduledBeforeAsync(
            DateTimeOffset beforeUtc,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Persists a post after a state transition.
        /// Must apply optimistic concurrency rules (e.g., row-version/ETag).
        /// </summary>
        Task UpdateAsync(Post post, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Clock abstraction used to make all time-based logic deterministic and testable.
    /// </summary>
    public interface IDateTimeProvider
    {
        DateTimeOffset UtcNow { get; }
    }

    /// <summary>
    /// Simple event bus abstraction.  Domain raises events through this port
    /// and adapters route them to the outside world (Kafka, RabbitMQ, MediatR, etc.).
    /// </summary>
    public interface IEventBus
    {
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken cancellationToken = default);
    }

    #endregion

    #region Domain Model

    /// <summary>
    /// Possible lifecycle states for a <see cref="Post"/>.
    /// </summary>
    public enum PostStatus
    {
        Draft,
        Scheduled,
        Published,
        Archived
    }

    /// <summary>
    /// Aggregate root representing a blog post inside the TempoScribe domain.
    /// </summary>
    public sealed class Post
    {
        // Aggregate identity
        public Guid Id { get; private set; }

        // Business data
        public string Title { get; private set; } = default!;
        public string Slug { get; private set; } = default!;
        public PostStatus Status { get; private set; } = PostStatus.Draft;

        // Scheduling metadata
        public DateTimeOffset? ScheduledAtUtc { get; private set; }
        public DateTimeOffset? PublishedAtUtc { get; private set; }

        // Optimistic concurrency token
        public int Version { get; private set; }

        // Required by ORMs/Serialisers
        private Post() { }

        public Post(Guid id, string title, string slug)
        {
            Id    = id;
            Title = title ?? throw new ArgumentNullException(nameof(title));
            Slug  = slug  ?? throw new ArgumentNullException(nameof(slug));
        }

        /// <summary>
        /// Schedules the post for publishing at a future (or immediate) point in time.
        /// </summary>
        public void Schedule(DateTimeOffset whenUtc)
        {
            if (Status == PostStatus.Published)
                throw new InvalidOperationException("Already published; cannot schedule again.");

            Status        = PostStatus.Scheduled;
            ScheduledAtUtc = whenUtc;
            Version++;
        }

        /// <summary>
        /// Transitions the post to <see cref="PostStatus.Published"/>.
        /// </summary>
        public void Publish(IDateTimeProvider clock)
        {
            if (Status == PostStatus.Published)
                return; // idempotency

            if (Status != PostStatus.Scheduled)
                throw new InvalidOperationException("Only scheduled posts can be published automatically.");

            Status        = PostStatus.Published;
            PublishedAtUtc = clock.UtcNow;
            Version++;
        }
    }

    /// <summary>
    /// Event raised when a post transitions into the <see cref="PostStatus.Published"/> state.
    /// </summary>
    public sealed record PostPublishedEvent(Guid PostId, DateTimeOffset PublishedAtUtc);

    /// <summary>
    /// Exception thrown by <see cref="IPostRepository"/> implementations when an
    /// optimistic concurrency violation is detected.
    /// </summary>
    public sealed class ConcurrencyException : Exception
    {
        public ConcurrencyException(string? message, Exception? inner = null) : base(message, inner) { }
    }

    #endregion

    #region Service (Application Layer)

    /// <summary>
    /// Application-level service (use-case) responsible for promoting all due-now
    /// scheduled posts to published status.
    /// </summary>
    public interface IScheduledPublishingService
    {
        /// <summary>
        /// Executes a full publishing cycle and returns the number of posts published.
        /// </summary>
        Task<int> ProcessDueScheduledPostsAsync(CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Default implementation of <see cref="IScheduledPublishingService"/>.
    /// </summary>
    internal sealed class ScheduledPublishingService : IScheduledPublishingService
    {
        private readonly IPostRepository _posts;
        private readonly IEventBus       _events;
        private readonly IDateTimeProvider _clock;
        private readonly ILogger<ScheduledPublishingService> _logger;

        public ScheduledPublishingService(
            IPostRepository posts,
            IEventBus events,
            IDateTimeProvider clock,
            ILogger<ScheduledPublishingService> logger)
        {
            _posts  = posts  ?? throw new ArgumentNullException(nameof(posts));
            _events = events ?? throw new ArgumentNullException(nameof(events));
            _clock  = clock  ?? throw new ArgumentNullException(nameof(clock));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task<int> ProcessDueScheduledPostsAsync(CancellationToken cancellationToken = default)
        {
            var now = _clock.UtcNow;
            _logger.LogDebug("Starting scheduled-publishing cycle at {UtcNow}", now);

            IReadOnlyList<Post> duePosts;
            try
            {
                duePosts = await _posts.GetPostsScheduledBeforeAsync(now, cancellationToken)
                                       .ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to query for scheduled posts.");
                throw;
            }

            if (duePosts.Count == 0)
            {
                _logger.LogDebug("No scheduled posts are due.");
                return 0;
            }

            int publishedCount = 0;
            foreach (var post in duePosts)
            {
                cancellationToken.ThrowIfCancellationRequested();

                try
                {
                    _logger.LogInformation(
                        "Publishing scheduled post {PostId} – \"{Title}\"",
                        post.Id, post.Title);

                    post.Publish(_clock);

                    await _posts.UpdateAsync(post, cancellationToken).ConfigureAwait(false);
                    await _events.PublishAsync(new PostPublishedEvent(post.Id, post.PublishedAtUtc!.Value), cancellationToken)
                                 .ConfigureAwait(false);

                    publishedCount++;
                    _logger.LogInformation("Post {PostId} successfully published.", post.Id);
                }
                catch (ConcurrencyException cx)
                {
                    // Another actor beat us to it; safe to ignore but log for insight.
                    _logger.LogWarning(cx, "Concurrency conflict while publishing post {PostId}.", post.Id);
                }
                catch (Exception ex)
                {
                    // Log & continue – other posts still need processing.
                    _logger.LogError(ex, "Unexpected error while publishing post {PostId}.", post.Id);
                }
            }

            _logger.LogInformation(
                "Scheduled-publishing cycle completed. {PublishedCount} posts published.",
                publishedCount);

            return publishedCount;
        }
    }

    #endregion
}
```