```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Core.Services.Publishing
{
    /// <summary>
    /// Represents the domain model for a blog post.  
    /// NOTE: A trimmed-down version that lives only to serve this service.
    /// In the real solution, Post is defined inside TempoScribePro.Core.Domain.
    /// </summary>
    public sealed record Post
    {
        public Guid           Id            { get; init; } = Guid.NewGuid();
        public string         Title         { get; private set; } = string.Empty;
        public string         Slug          { get; private set; } = string.Empty;
        public string         Content       { get; private set; } = string.Empty;
        public PostStatus     Status        { get; private set; } = PostStatus.Draft;
        public DateTimeOffset? PublishAtUtc { get; private set; }
        public bool           IsPremium     { get; private set; }

        #region Factory & Mutators
        public static Post Draft(string title, string slug, string content, bool isPremium) =>
            new()
            {
                Title     = title,
                Slug      = slug,
                Content   = content,
                IsPremium = isPremium,
                Status    = PostStatus.Draft
            };

        public void Schedule(DateTimeOffset publishAtUtc)
        {
            if (Status is PostStatus.Published or PostStatus.Archived)
                throw new InvalidOperationException($"Cannot schedule a post in state '{Status}'.");

            Status        = PostStatus.Scheduled;
            PublishAtUtc  = publishAtUtc;
        }

        public void PublishNow(DateTimeOffset nowUtc)
        {
            Status       = PostStatus.Published;
            PublishAtUtc = nowUtc;
        }
        #endregion
    }

    public enum PostStatus
    {
        Draft,
        Scheduled,
        Published,
        Archived
    }

    #region Ports (Hexagonal Interfaces)

    /// <summary>
    /// Abstraction for a repository responsible for persisting <see cref="Post"/> aggregates.
    /// </summary>
    public interface IPostRepository
    {
        Task<Post?>                  GetByIdAsync(Guid id, CancellationToken ct = default);
        Task                         AddAsync(Post post, CancellationToken ct = default);
        Task                         UpdateAsync(Post post, CancellationToken ct = default);
        Task<IReadOnlyList<Post>>    GetPostsDueForPublishingAsync(DateTimeOffset beforeUtc, CancellationToken ct = default);
        Task                         SaveChangesAsync(CancellationToken ct = default);
    }

    /// <summary>
    /// Abstraction for a distributed cache / in-memory cache invalidator. 
    /// We keep it deliberately small – just what we need here.
    /// </summary>
    public interface ICacheInvalidator
    {
        Task InvalidatePostAsync(Guid postId, CancellationToken ct = default);
    }

    /// <summary>
    /// Used to raise domain events outward so that adapters (e.g., SignalR hubs,
    /// message brokers, or e-mail dispatchers) can react.
    /// </summary>
    public interface IEventBus
    {
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct = default);
    }

    /// <summary>
    /// System-wide date/time provider. Helps with testability.
    /// </summary>
    public interface IDateTimeProvider
    {
        DateTimeOffset UtcNow { get; }
    }

    #endregion

    #region Domain Events

    public sealed record PostScheduledEvent(Guid PostId, DateTimeOffset PublishAtUtc);
    public sealed record PostPublishedEvent(Guid PostId, DateTimeOffset PublishedAtUtc);

    #endregion

    /// <summary>
    /// Application service responsible for scheduling and publishing posts automatically.
    /// It is domain-centric and technology-agnostic – all infrastructure concerns
    /// are pushed to the injected ports.
    /// </summary>
    public sealed class ScheduledPublishingService : IScheduledPublishingService
    {
        private readonly IPostRepository   _posts;
        private readonly ICacheInvalidator _cache;
        private readonly IEventBus         _bus;
        private readonly IDateTimeProvider _clock;
        private readonly ILogger           _log;

        public ScheduledPublishingService(
            IPostRepository   posts,
            ICacheInvalidator cache,
            IEventBus         bus,
            IDateTimeProvider clock,
            ILogger<ScheduledPublishingService> log)
        {
            _posts  = posts  ?? throw new ArgumentNullException(nameof(posts));
            _cache  = cache  ?? throw new ArgumentNullException(nameof(cache));
            _bus    = bus    ?? throw new ArgumentNullException(nameof(bus));
            _clock  = clock  ?? throw new ArgumentNullException(nameof(clock));
            _log    = log    ?? throw new ArgumentNullException(nameof(log));
        }

        /// <inheritdoc />
        public async Task SchedulePostAsync(Post post, DateTimeOffset publishAtUtc, CancellationToken ct = default)
        {
            ArgumentNullException.ThrowIfNull(post);

            _log.LogDebug("Scheduling post {PostId} to publish at {PublishAt}.", post.Id, publishAtUtc);

            post.Schedule(publishAtUtc);

            await _posts.UpdateAsync(post, ct).ConfigureAwait(false);
            await _posts.SaveChangesAsync(ct).ConfigureAwait(false);

            await _bus.PublishAsync(new PostScheduledEvent(post.Id, publishAtUtc), ct).ConfigureAwait(false);

            _log.LogInformation("Post {PostId} successfully scheduled for {PublishAt}.", post.Id, publishAtUtc);
        }

        /// <inheritdoc />
        public async Task<int> PublishDuePostsAsync(CancellationToken ct = default)
        {
            var nowUtc = _clock.UtcNow;
            _log.LogDebug("Fetching due posts for publishing (<= {Now}).", nowUtc);

            IReadOnlyList<Post> duePosts = await _posts
                .GetPostsDueForPublishingAsync(nowUtc, ct)
                .ConfigureAwait(false);

            if (duePosts.Count == 0)
            {
                _log.LogDebug("No posts ready for publishing.");
                return 0;
            }

            int publishCount = 0;

            foreach (Post post in duePosts)
            {
                try
                {
                    post.PublishNow(nowUtc);
                    await _posts.UpdateAsync(post, ct).ConfigureAwait(false);
                    await _cache.InvalidatePostAsync(post.Id, ct).ConfigureAwait(false);
                    await _bus.PublishAsync(new PostPublishedEvent(post.Id, nowUtc), ct).ConfigureAwait(false);

                    publishCount++;
                    _log.LogInformation("Post {PostId} published at {PublishedAt}.", post.Id, nowUtc);
                }
                catch (Exception ex)
                {
                    // We intentionally swallow the exception here to continue processing
                    // other posts. The error is logged and bubbled up via telemetry/logs.
                    _log.LogError(ex, "Failed to publish post {PostId}. Continuing with next.", post.Id);
                }
            }

            await _posts.SaveChangesAsync(ct).ConfigureAwait(false);

            return publishCount;
        }
    }

    /// <summary>
    /// Contract to expose the publishing capabilities to the outer application layer.
    /// </summary>
    public interface IScheduledPublishingService
    {
        /// <summary>
        /// Schedules a single <see cref="Post"/> to be automatically published at the specified time.
        /// </summary>
        Task SchedulePostAsync(Post post, DateTimeOffset publishAtUtc, CancellationToken ct = default);

        /// <summary>
        /// Publishes all posts whose scheduled publish time is in the past.
        /// Returns the number of posts successfully published.
        /// </summary>
        Task<int> PublishDuePostsAsync(CancellationToken ct = default);
    }
}
```