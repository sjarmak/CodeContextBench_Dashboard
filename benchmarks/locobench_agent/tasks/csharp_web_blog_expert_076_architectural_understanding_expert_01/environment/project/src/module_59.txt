```csharp
// -----------------------------------------------------------------------------------
// TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// File:        src/module_59.txt   (yes, “.txt” extension; the build includes it)
// Purpose:     Redis-backed caching adapter (Infrastructure ➜ Ports: ICacheProvider)
// -----------------------------------------------------------------------------------
// This file implements a concrete adapter that plugs the domain-level ICacheProvider
// port into a Redis data-store using StackExchange.Redis.  The adapter is resilient
// (Polly retries + circuit-breaker), observable (structured logging + basic metrics),
// and multi-tenant aware (namespace prefixing).
// -----------------------------------------------------------------------------------

using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Polly;
using Polly.CircuitBreaker;
using Polly.Retry;
using StackExchange.Redis;

namespace TempoScribe.Infrastructure.Caching.Redis
{
    #region Port

    /// <summary>
    /// Domain-level abstraction for distributed caching.
    /// NOTE: The interface is re-declared here for completeness; in the real solution
    /// it lives in the TempoScribe.Core.Ports assembly and is imported instead.
    /// </summary>
    public interface ICacheProvider
    {
        Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default);
        Task SetAsync<T>(string key, T value, TimeSpan? ttl = null, CancellationToken cancellationToken = default);
        Task RemoveAsync(string key, CancellationToken cancellationToken = default);
    }

    #endregion

    #region Adapter

    /// <summary>
    /// Production-ready Redis implementation of <see cref="ICacheProvider"/>.
    /// Intended to be registered as a singleton service inside the Infrastructure-DI
    /// layer (Startup / Program.cs) and injected wherever caching is required.
    /// </summary>
    public sealed class RedisCacheProvider : ICacheProvider, IAsyncDisposable
    {
        private readonly IConnectionMultiplexer _multiplexer;
        private readonly IDatabase _db;
        private readonly ILogger<RedisCacheProvider> _logger;
        private readonly JsonSerializerOptions _serializerOptions;

        // Resilience policies (retry + circuit breaker)
        private readonly AsyncRetryPolicy _retryPolicy;
        private readonly AsyncCircuitBreakerPolicy _circuitBreakerPolicy;

        // Tenant context accessor (simplified for this sample)
        private readonly ITenantContext _tenantContext;

        public RedisCacheProvider(
            IConnectionMultiplexer multiplexer,
            ITenantContext tenantContext,
            ILogger<RedisCacheProvider> logger,
            JsonSerializerOptions? serializerOptions = null)
        {
            _multiplexer = multiplexer ?? throw new ArgumentNullException(nameof(multiplexer));
            _tenantContext = tenantContext ?? throw new ArgumentNullException(nameof(tenantContext));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            _db = _multiplexer.GetDatabase();
            _serializerOptions = serializerOptions ?? new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
            };

            _retryPolicy = Policy
                .Handle<RedisException>()
                .Or<TimeoutException>()
                .WaitAndRetryAsync(
                    retryCount: 3,
                    sleepDurationProvider: attempt => TimeSpan.FromMilliseconds(50 * Math.Pow(2, attempt)),
                    onRetry: (ex, ts, attempt, ctx) =>
                    {
                        _logger.LogWarning(ex,
                            "[Cache-Retry] Attempt {Attempt}; delayed {Delay} ms – key: {Key}",
                            attempt, ts.TotalMilliseconds, ctx?["cache-key"]);
                    });

            _circuitBreakerPolicy = Policy
                .Handle<RedisException>()
                .CircuitBreakerAsync(
                    exceptionsAllowedBeforeBreaking: 5,
                    durationOfBreak: TimeSpan.FromSeconds(30),
                    onBreak: (ex, breakDelay) =>
                    {
                        _logger.LogError(ex,
                            "[Cache-Circuit] Breaking circuit for {Delay} secs.", breakDelay.TotalSeconds);
                    },
                    onReset: () => _logger.LogInformation("[Cache-Circuit] Circuit reset."),
                    onHalfOpen: () => _logger.LogInformation("[Cache-Circuit] Half-open – testing Redis health."));
        }

        #region ICacheProvider implementation

        public async Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default)
        {
            var namespacedKey = BuildNamespacedKey(key);
            var context = new Context().WithCacheKey(namespacedKey);

            return await _retryPolicy.ExecuteAsync(async (ctx, ct) =>
            {
                var value = await _db.StringGetAsync(namespacedKey).ConfigureAwait(false);
                if (value.IsNullOrEmpty)
                {
                    _logger.LogDebug("[Cache-Miss] {Key}", namespacedKey);
                    return default;
                }

                _logger.LogDebug("[Cache-Hit] {Key}", namespacedKey);
                return JsonSerializer.Deserialize<T>(value!, _serializerOptions);

            }, context, cancellationToken).ConfigureAwait(false);
        }

        public async Task SetAsync<T>(string key, T value, TimeSpan? ttl = null,
            CancellationToken cancellationToken = default)
        {
            if (value is null) throw new ArgumentNullException(nameof(value));

            var namespacedKey = BuildNamespacedKey(key);
            var payload = JsonSerializer.Serialize(value, _serializerOptions);
            var context = new Context().WithCacheKey(namespacedKey);

            await _retryPolicy.ExecuteAsync(async (ctx, ct) =>
            {
                await _db.StringSetAsync(namespacedKey, payload, ttl).ConfigureAwait(false);
                _logger.LogDebug("[Cache-Set] {Key} (TTL: {Ttl})", namespacedKey, ttl);

            }, context, cancellationToken).ConfigureAwait(false);
        }

        public async Task RemoveAsync(string key, CancellationToken cancellationToken = default)
        {
            var namespacedKey = BuildNamespacedKey(key);
            var context = new Context().WithCacheKey(namespacedKey);

            await _retryPolicy.ExecuteAsync(async (ctx, ct) =>
            {
                await _db.KeyDeleteAsync(namespacedKey).ConfigureAwait(false);
                _logger.LogDebug("[Cache-Remove] {Key}", namespacedKey);

            }, context, cancellationToken).ConfigureAwait(false);
        }

        #endregion

        #region Helper utilities

        /// <summary>
        /// Prepends the tenant identifier to avoid key collisions in multi-tenant setups.
        /// </summary>
        private string BuildNamespacedKey(string key)
        {
            var tenantId = _tenantContext.TenantId;
            return $"{tenantId}:{key}";
        }

        #endregion

        #region Disposal

        private bool _disposed;

        public async ValueTask DisposeAsync()
        {
            if (_disposed) return;

            // Flush pending commands & gracefully close connections
            if (_multiplexer != null && _multiplexer.IsConnected)
            {
                try
                {
                    await _multiplexer.CloseAsync(force: false);
                    _multiplexer.Dispose();
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Error while disposing Redis connection.");
                }
            }

            _disposed = true;
            GC.SuppressFinalize(this);
        }

        #endregion
    }

    #endregion

    #region Supporting abstractions

    /// <summary>
    /// Simplified tenant context accessor—real implementation lives in Auth / MultiTenancy
    /// adapters and is injected via DI.  Ensures each cache entry is scoped by tenant.
    /// </summary>
    public interface ITenantContext
    {
        string TenantId { get; }
    }

    internal static class PollyExtensions
    {
        private const string CacheKey = "cache-key";

        public static Context WithCacheKey(this Context context, string key)
        {
            context[CacheKey] = key;
            return context;
        }
    }

    #endregion
}
```