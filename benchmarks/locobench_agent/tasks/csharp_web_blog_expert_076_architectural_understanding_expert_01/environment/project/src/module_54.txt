```csharp
// File: src/module_54.txt
// Project: TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// Description: Core service responsible for executing scheduled‐post publishing.
//              This service illustrates the Hexagonal “ports & adapters” style by
//              depending only on abstractions that will be fulfilled by adapters
//              (SQL/NoSQL repository, Redis cache, message bus, distributed lock, etc.).

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Core.Scheduling
{
    #region Domain Models

    /// <summary>
    /// Simplified representation of a blog post within the scheduling context.
    /// The canonical Post aggregate lives elsewhere in the domain; we reuse only
    /// what is strictly necessary to remain independent of any infrastructure.
    /// </summary>
    public sealed class Post
    {
        public Guid       Id             { get; }
        public string     Slug           { get; }
        public DateTimeOffset PublishAt  { get; }
        public bool       IsPublished    { get; private set; }

        public Post(Guid id, string slug, DateTimeOffset publishAt, bool isPublished)
        {
            Id          = id;
            Slug        = slug;
            PublishAt   = publishAt;
            IsPublished = isPublished;
        }

        public void MarkAsPublished() => IsPublished = true;
    }

    /// <summary>
    /// Domain event raised when a post transitions from scheduled → published.
    /// </summary>
    public sealed record PostPublishedEvent(Guid PostId, string Slug, DateTimeOffset PublishedAt);

    #endregion

    #region Ports (Hexagonal Interfaces)

    /// <summary>
    /// Abstraction for retrieving and mutating posts in persistent storage.
    /// </summary>
    public interface IPostRepository
    {
        Task<IReadOnlyCollection<Post>> GetPostsScheduledBeforeAsync(
            DateTimeOffset due, CancellationToken ct = default);

        Task MarkAsPublishedAsync(Guid postId, CancellationToken ct = default);
    }

    /// <summary>
    /// Abstraction for emitting domain events to downstream subscribers/read models.
    /// </summary>
    public interface IEventBus
    {
        Task PublishAsync<TEvent>(TEvent domainEvent, CancellationToken ct = default);
    }

    /// <summary>
    /// Simple cache provider abstraction (Redis, MemoryCache, etc.).
    /// </summary>
    public interface ICacheProvider
    {
        Task InvalidateAsync(string key, CancellationToken ct = default);
    }

    /// <summary>
    /// Distributed lock abstraction preventing concurrent scheduler executions.
    /// </summary>
    public interface IDistributedLock
    {
        /// <summary>
        /// Attempts to acquire the named lock for the specified TTL.
        /// Returns <c>null</c> if the lock could not be obtained.
        /// </summary>
        Task<IDisposable?> TryAcquireAsync(
            string name, TimeSpan ttl, CancellationToken ct = default);
    }

    #endregion

    #region Service

    /// <summary>
    /// Executes scheduled publishing in a safe, idempotent manner.
    /// </summary>
    public interface IPublishingAutomationService
    {
        /// <summary>
        /// Publishes all posts whose <see cref="Post.PublishAt"/> is in the past
        /// and have not been published yet.
        /// </summary>
        Task RunAsync(CancellationToken ct = default);
    }

    /// <inheritdoc />
    public sealed class PublishingAutomationService : IPublishingAutomationService
    {
        private const string SchedulerLockName  = "tempo-scribe-publisher-lock";
        private static readonly TimeSpan LockTtl = TimeSpan.FromMinutes(5);

        private readonly IPostRepository _posts;
        private readonly IEventBus       _events;
        private readonly ICacheProvider  _cache;
        private readonly IDistributedLock _lock;
        private readonly ILogger<PublishingAutomationService> _logger;

        public PublishingAutomationService(
            IPostRepository posts,
            IEventBus events,
            ICacheProvider cache,
            IDistributedLock @lock,
            ILogger<PublishingAutomationService> logger)
        {
            _posts  = posts  ?? throw new ArgumentNullException(nameof(posts));
            _events = events ?? throw new ArgumentNullException(nameof(events));
            _cache  = cache  ?? throw new ArgumentNullException(nameof(cache));
            _lock   = @lock  ?? throw new ArgumentNullException(nameof(@lock));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc/>
        public async Task RunAsync(CancellationToken ct = default)
        {
            // 1. Try to acquire a distributed lock to avoid concurrent executions.
            await using var lockHandle = await _lock.TryAcquireAsync(SchedulerLockName, LockTtl, ct);

            if (lockHandle is null)
            {
                _logger.LogWarning("Publishing automation skipped — lock '{LockName}' is already held.", SchedulerLockName);
                return;
            }

            try
            {
                // 2. Fetch due posts at this exact moment.
                var now       = DateTimeOffset.UtcNow;
                var duePosts  = await _posts.GetPostsScheduledBeforeAsync(now, ct);

                if (duePosts.Count == 0)
                {
                    _logger.LogDebug("No scheduled posts were due for publication at {Now}.", now);
                    return;
                }

                _logger.LogInformation("Publishing {Count} scheduled post(s) at {Now}.", duePosts.Count, now);

                // 3. Process each post individually for atomic failure handling.
                foreach (var post in duePosts.OrderBy(p => p.PublishAt))
                {
                    ct.ThrowIfCancellationRequested();
                    await PublishAsync(post, ct);
                }
            }
            catch (Exception ex) when (!ex.IsFatal())
            {
                // Non-fatal — log and swallow so that the job runner survives.
                _logger.LogError(ex, "Unhandled error while executing publishing automation.");
            }
        }

        private async Task PublishAsync(Post post, CancellationToken ct)
        {
            var postId = post.Id;

            // If this method is called, business invariants guarantee not published.
            post.MarkAsPublished();

            try
            {
                await _posts.MarkAsPublishedAsync(postId, ct);
                _logger.LogInformation("Post {PostId} marked as published.", postId);

                // Invalidate caches that might include this post.
                await _cache.InvalidateAsync(CacheKeys.PostBySlug(post.Slug), ct);
                await _cache.InvalidateAsync(CacheKeys.HomeFeed, ct);

                // Raise domain event.
                var evt = new PostPublishedEvent(post.Id, post.Slug, DateTimeOffset.UtcNow);
                await _events.PublishAsync(evt, ct);
            }
            catch (Exception ex) when (!ex.IsFatal())
            {
                // Rollback in-memory state if necessary; the next run will retry.
                _logger.LogError(ex, "Error while publishing post {PostId}. Retrying on next cycle.", postId);
            }
        }
    }

    #endregion

    #region Helper Extensions / Static Types

    internal static class CacheKeys
    {
        private const string PostPrefix = "post:";
        public const string  HomeFeed   = "feed:home";

        public static string PostBySlug(string slug) => $"{PostPrefix}{slug}";
    }

    internal static class ExceptionExtensions
    {
        /// <summary>
        /// Determines whether the exception should be re-thrown immediately.  
        /// </summary>
        public static bool IsFatal(this Exception ex) =>
            ex is OutOfMemoryException or
                 StackOverflowException or
                 ThreadAbortException;
    }

    #endregion
}
```