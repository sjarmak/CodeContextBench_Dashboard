```csharp
// ============================================================================
//  TempoScribe Pro ‒ Hexagonal Productivity Blog Suite
//  File:        src/module_65.txt      (yes, *.txt; hosting environment renames)
//  Module:      Payments – Premium Content Gating
//  Language:    C# 10.0
//  Purpose:     Core Application Service + Ports & Default Adapter for
//               processing one-off premium-post purchases via Stripe.
//
//  This file is intentionally self-contained so that it can be dropped into
//  unit tests or demo environments without additional code generation. In the
//  full solution, each interface is implemented by its own adapter project.
//
//  © 2024 TempoScribe Pro Contributors. All rights reserved.
// ============================================================================

#nullable enable

using System;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Caching.Memory;

namespace TempoScribePro.Application.Payments
{
    // ------------------------------------------------------------------------
    //  1. Domain Value Objects & DTOs
    // ------------------------------------------------------------------------

    /// <summary>
    /// Immutable request object handed to the Application Service
    /// when a user attempts to purchase access to a premium post.
    /// </summary>
    public sealed record PremiumPurchaseRequest(
        Guid UserId,
        Guid PostId,
        string? CouponCode,
        string IdempotencyKey);

    /// <summary>
    /// Response surface returned to MVC/REST edges. Intentionally slim to keep
    /// the domain free from web-specific abstractions.
    /// </summary>
    public sealed record PremiumPurchaseResult(
        bool Success,
        string Message,
        string? ReceiptUrl,
        bool AlreadyOwned);

    /// <summary>
    /// Captures success/failure from the payment provider port.
    /// </summary>
    public sealed record PaymentProviderChargeResult(
        bool Succeeded,
        string? ProviderTransactionId,
        string? FailureReason,
        string? ReceiptUrl);

    // ------------------------------------------------------------------------
    //  2. Domain Exceptions
    // ------------------------------------------------------------------------

    public sealed class PaymentFailedException : Exception
    {
        public PaymentFailedException(string reason)
            : base($"Payment failed: {reason}") { }
    }

    public sealed class PostNotFoundException : Exception
    {
        public PostNotFoundException(Guid postId)
            : base($"Post '{postId}' was not found or is not premium.") { }
    }

    // ------------------------------------------------------------------------
    //  3. Hexagonal Ports (Interfaces)
    // ------------------------------------------------------------------------

    /// <summary>
    /// Outbound port for payment providers (Stripe, PayPal, etc.).
    /// </summary>
    public interface IPaymentProviderPort
    {
        /// <summary>Sends a charge request to the external payment provider.</summary>
        Task<PaymentProviderChargeResult> ChargeAsync(
            Guid userId,
            decimal amount,
            string currency,
            string description,
            string idempotencyKey,
            CancellationToken ct);
    }

    /// <summary>Outbound port for CRUD over PremiumPurchase aggregates.</summary>
    public interface IPremiumPurchaseRepository
    {
        Task<bool> ExistsAsync(Guid userId, Guid postId, CancellationToken ct);
        Task AddAsync(PremiumPurchase purchase, CancellationToken ct);
    }

    /// <summary>Outbound port for Post look-ups.</summary>
    public interface IPostRepository
    {
        Task<PostSnapshot?> FindByIdAsync(Guid postId, CancellationToken ct);
    }

    /// <summary>Infrastructure cross-cut: Unit-of-Work for atomic persistence.</summary>
    public interface IUnitOfWork : IAsyncDisposable
    {
        Task CommitAsync(CancellationToken ct);
    }

    /// <summary>Abstraction over time to simplify deterministic testing.</summary>
    public interface IDateTimeProvider
    {
        DateTime UtcNow { get; }
    }

    /// <summary>Inbound port, exposed to Adapters such as MVC, GraphQL, etc.</summary>
    public interface IPremiumContentAccessService
    {
        Task<PremiumPurchaseResult> PurchasePremiumPostAsync(
            PremiumPurchaseRequest request,
            CancellationToken ct = default);
    }

    // ------------------------------------------------------------------------
    //  4. Domain Entities (snapshots to keep file small; real models richer)
    // ------------------------------------------------------------------------

    public sealed class PostSnapshot
    {
        public Guid PostId { get; init; }
        public bool IsPremium { get; init; }
        public decimal Price { get; init; }
        public string Currency { get; init; } = "USD";
        public string Title { get; init; } = string.Empty;
    }

    public sealed class PremiumPurchase
    {
        public Guid PurchaseId { get; init; } = Guid.NewGuid();
        public Guid UserId { get; init; }
        public Guid PostId { get; init; }
        public decimal Amount { get; init; }
        public string Currency { get; init; } = "USD";
        public DateTime PurchasedAtUtc { get; init; }
        public string ProviderTransactionId { get; init; } = string.Empty;
        public string? ReceiptUrl { get; init; }
    }

    // ------------------------------------------------------------------------
    //  5. Application Service (Use-Case)
    // ------------------------------------------------------------------------

    /// <summary>
    /// Core use-case performing idempotent, transactional premium purchases.
    /// Conforms to Clean Architecture/Hexagonal calling patterns:
    ///  - Validates and loads required entities
    ///  - Delegates external calls via ports
    ///  - Persists changes inside a Unit-of-Work
    ///  - Caches access tokens for micro-optimisations
    /// </summary>
    public sealed class PremiumContentAccessService : IPremiumContentAccessService
    {
        private static readonly TimeSpan CacheSlidingExpiration = TimeSpan.FromMinutes(30);

        private readonly IPaymentProviderPort _paymentProvider;
        private readonly IPremiumPurchaseRepository _purchaseRepo;
        private readonly IPostRepository _postRepo;
        private readonly IUnitOfWork _unitOfWork;
        private readonly IDateTimeProvider _clock;
        private readonly IMemoryCache _cache;
        private readonly ILogger<PremiumContentAccessService> _logger;

        public PremiumContentAccessService(
            IPaymentProviderPort paymentProvider,
            IPremiumPurchaseRepository purchaseRepo,
            IPostRepository postRepo,
            IUnitOfWork unitOfWork,
            IDateTimeProvider clock,
            IMemoryCache cache,
            ILogger<PremiumContentAccessService> logger)
        {
            _paymentProvider = paymentProvider;
            _purchaseRepo    = purchaseRepo;
            _postRepo        = postRepo;
            _unitOfWork      = unitOfWork;
            _clock           = clock;
            _cache           = cache;
            _logger          = logger;
        }

        /// <inheritdoc/>
        public async Task<PremiumPurchaseResult> PurchasePremiumPostAsync(
            PremiumPurchaseRequest request,
            CancellationToken ct = default)
        {
            ArgumentNullException.ThrowIfNull(request);
            _logger.LogInformation("Initiating premium-post purchase {@Request}", request);

            var cacheKey = GetCacheKey(request.UserId, request.PostId);

            // Fast-path: user already owns it, cached.
            if (_cache.TryGetValue(cacheKey, out bool alreadyOwned) && alreadyOwned)
            {
                _logger.LogDebug("User {UserId} already owns Post {PostId} (cache hit).",
                                 request.UserId, request.PostId);
                return new PremiumPurchaseResult(
                    Success: true,
                    Message: "Already purchased.",
                    ReceiptUrl: null,
                    AlreadyOwned: true);
            }

            // Load post details.
            var post = await _postRepo.FindByIdAsync(request.PostId, ct)
                        ?? throw new PostNotFoundException(request.PostId);

            if (!post.IsPremium)
            {
                // Non-premium post, no charge needed; mark as owned.
                _cache.Set(cacheKey, true, CacheSlidingExpiration);
                return new PremiumPurchaseResult(
                    Success: true,
                    Message: "Post is free to access.",
                    ReceiptUrl: null,
                    AlreadyOwned: true);
            }

            // Check persistent store for previous purchase (idempotency beyond cache).
            if (await _purchaseRepo.ExistsAsync(request.UserId, request.PostId, ct))
            {
                _cache.Set(cacheKey, true, CacheSlidingExpiration);
                return new PremiumPurchaseResult(
                    Success: true,
                    Message: "Already purchased.",
                    ReceiptUrl: null,
                    AlreadyOwned: true);
            }

            // Perform external payment call.
            PaymentProviderChargeResult providerResult;
            try
            {
                providerResult = await _paymentProvider.ChargeAsync(
                    request.UserId,
                    post.Price,
                    post.Currency,
                    $"Premium post: {post.Title}",
                    request.IdempotencyKey,
                    ct);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Payment provider threw while charging user {UserId}", request.UserId);
                throw;
            }

            if (!providerResult.Succeeded)
            {
                _logger.LogWarning("Payment failed for User {UserId}: {Reason}", request.UserId,
                                   providerResult.FailureReason);
                throw new PaymentFailedException(providerResult.FailureReason ?? "Unknown failure");
            }

            // Record purchase.
            var purchase = new PremiumPurchase
            {
                UserId = request.UserId,
                PostId = request.PostId,
                Amount = post.Price,
                Currency = post.Currency,
                PurchasedAtUtc = _clock.UtcNow,
                ProviderTransactionId = providerResult.ProviderTransactionId ?? string.Empty,
                ReceiptUrl = providerResult.ReceiptUrl
            };

            await _purchaseRepo.AddAsync(purchase, ct);
            await _unitOfWork.CommitAsync(ct);

            // Cache ownership for future checks.
            _cache.Set(cacheKey, true, CacheSlidingExpiration);

            _logger.LogInformation("Successfully processed premium purchase {@Purchase}", purchase);
            return new PremiumPurchaseResult(
                Success: true,
                Message: "Purchase successful.",
                ReceiptUrl: providerResult.ReceiptUrl,
                AlreadyOwned: false);
        }

        private static string GetCacheKey(Guid userId, Guid postId)
            => $"premium_access:{userId:N}:{postId:N}";
    }

    // ------------------------------------------------------------------------
    //  6. Default Stripe Adapter (Outbound) — demo implementation
    // ------------------------------------------------------------------------

    /// <summary>
    /// Minimal, demo-level Stripe adapter. In production this would live
    /// in its own assembly and encapsulate all Stripe SDK concerns.
    /// </summary>
    public sealed class StripePaymentProviderAdapter : IPaymentProviderPort
    {
        private readonly ILogger<StripePaymentProviderAdapter> _logger;

        // Placeholder for Stripe SDK client ‑ not included to keep dependencies light.
        private const string FakeStripeEndpoint = "https://api.stripe.example/charge";

        public StripePaymentProviderAdapter(ILogger<StripePaymentProviderAdapter> logger)
        {
            _logger = logger;
        }

        public async Task<PaymentProviderChargeResult> ChargeAsync(
            Guid userId,
            decimal amount,
            string currency,
            string description,
            string idempotencyKey,
            CancellationToken ct)
        {
            _logger.LogDebug("Charging User {UserId} {Amount} {Currency} for '{Description}'",
                             userId, amount, currency, description);

            // In a real implementation, this would call Stripe's SDK:
            // var options = new ChargeCreateOptions { ... };
            // var service = new ChargeService();
            // Charge charge = await service.CreateAsync(options, ...);

            await Task.Delay(250, ct); // Simulate network latency.

            // For the sake of example, randomly simulate failures.
            if (Random.Shared.Next(0, 20) == 0) // 5% failure rate
            {
                return new PaymentProviderChargeResult(
                    Succeeded: false,
                    ProviderTransactionId: null,
                    FailureReason: "Card declined",
                    ReceiptUrl: null);
            }

            var fakeTxId = Guid.NewGuid().ToString("N");
            var fakeReceiptUrl = $"{FakeStripeEndpoint}/receipt/{fakeTxId}";

            _logger.LogDebug("Stripe charge successful. TxId={TxId}", fakeTxId);

            return new PaymentProviderChargeResult(
                Succeeded: true,
                ProviderTransactionId: fakeTxId,
                FailureReason: null,
                ReceiptUrl: fakeReceiptUrl);
        }
    }

    // ------------------------------------------------------------------------
    //  7. Simple In-Memory Repository (for tests/demo)
    // ------------------------------------------------------------------------

    internal sealed class InMemoryPremiumPurchaseRepository : IPremiumPurchaseRepository
    {
        private readonly HashSet<(Guid UserId, Guid PostId)> _purchases = new();

        public Task<bool> ExistsAsync(Guid userId, Guid postId, CancellationToken ct)
            => Task.FromResult(_purchases.Contains((userId, postId)));

        public Task AddAsync(PremiumPurchase purchase, CancellationToken ct)
        {
            _purchases.Add((purchase.UserId, purchase.PostId));
            return Task.CompletedTask;
        }
    }

    internal sealed class InMemoryPostRepository : IPostRepository
    {
        private readonly Dictionary<Guid, PostSnapshot> _posts = new();

        public InMemoryPostRepository()
        {
            // Seed with a demo premium post.
            var demoId = Guid.Parse("aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa");
            _posts[demoId] = new PostSnapshot
            {
                PostId  = demoId,
                IsPremium = true,
                Title   = "How I Write 10× Faster Using Hexagonal Architecture",
                Price   = 12.49m,
                Currency = "USD"
            };
        }

        public Task<PostSnapshot?> FindByIdAsync(Guid postId, CancellationToken ct)
            => Task.FromResult(_posts.TryGetValue(postId, out var post) ? post : null);
    }

    // ------------------------------------------------------------------------
    //  8. Infrastructure helpers
    // ------------------------------------------------------------------------

    internal sealed class SystemDateTimeProvider : IDateTimeProvider
    {
        public DateTime UtcNow => DateTime.UtcNow;
    }

    internal sealed class NoOpUnitOfWork : IUnitOfWork
    {
        public Task CommitAsync(CancellationToken ct) => Task.CompletedTask;
        public ValueTask DisposeAsync() => ValueTask.CompletedTask;
        async ValueTask IAsyncDisposable.DisposeAsync()
        {
            await DisposeAsync();
        }
    }
}
```