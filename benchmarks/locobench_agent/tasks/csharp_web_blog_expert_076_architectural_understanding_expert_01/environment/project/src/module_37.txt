```csharp
// -----------------------------------------------------------------------------
// TempoScribe Pro – Hexagonal Productivity Blog Suite
// Module 37: Publishing Automation  (Port + Application Service)
// -----------------------------------------------------------------------------
// File:     src/module_37.txt
// Language: C# 10.0
// Purpose:  Provides the application-side orchestration for scheduling posts
//           for future publication.  Relies on:
//             • IRepository<Post> (domain persistence)
//             • ISchedulerPort     (time-based trigger adapter, e.g. Quartz.NET)
//             • IDomainEventBus    (decoupled event dispatcher)
// -----------------------------------------------------------------------------
// NOTE: File extension *.txt is intentional (keeps domain model independent of
//       compilation unit boundaries in certain build pipelines).  The build
//       system treats *.txt containing valid C# as generated source files.
// -----------------------------------------------------------------------------

#nullable enable
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.PublishingAutomation
{
    // -------------------------------------------------------------------------
    // DOMAIN CONCEPTS
    // -------------------------------------------------------------------------

    /// <summary>
    /// Strong-typed aggregate identifier for a blog post.
    /// </summary>
    public readonly record struct PostId(Guid Value)
    {
        public static PostId New() => new(Guid.NewGuid());
        public override string ToString() => Value.ToString();
    }

    /// <summary>
    /// Aggregate root representing a blog post. Only the properties required for
    /// scheduling are included; the full Post aggregate lives elsewhere.
    /// </summary>
    public sealed class Post
    {
        private readonly object _stateLock = new();

        public PostId Id { get; }
        public string Title { get; private set; }
        public DateTimeOffset? ScheduledPublishUtc { get; private set; }
        public bool IsPublished { get; private set; }

        public Post(PostId id, string title)
        {
            Id    = id;
            Title = title;
        }

        /// <summary>
        /// Schedules the post for publication at the specified date/time.
        /// Will throw if the post is already published or the schedule is invalid.
        /// </summary>
        public void SchedulePublish(DateTimeOffset scheduleUtc)
        {
            lock (_stateLock)
            {
                if (IsPublished)
                    throw new InvalidOperationException("Post is already published.");

                if (scheduleUtc <= DateTimeOffset.UtcNow.AddMinutes(1))
                    throw new InvalidScheduleException("Scheduled time must be at least one minute in the future.");

                ScheduledPublishUtc = scheduleUtc;
            }
        }

        public void MarkPublished()
        {
            lock (_stateLock)
            {
                ScheduledPublishUtc = null;
                IsPublished         = true;
            }
        }

        public sealed class InvalidScheduleException : Exception
        {
            public InvalidScheduleException(string message) : base(message) { }
        }
    }

    /// <summary>
    /// Domain event raised when a post has been scheduled for future publication.
    /// </summary>
    public sealed record PostScheduledDomainEvent(PostId PostId, DateTimeOffset PublishAtUtc);

    // -------------------------------------------------------------------------
    // PORTS (Interfaces)
    // -------------------------------------------------------------------------

    /// <summary>
    /// Port that abstracts the persistence of the Post aggregate.
    /// Exists in the Application Layer; implemented by an Adapter
    /// (e.g. EF Core, Dapper, Cassandra, etc.).
    /// </summary>
    public interface IPostRepository
    {
        Task<Post?> FindAsync(PostId id, CancellationToken ct = default);
        Task SaveAsync(Post post, CancellationToken ct = default);
    }

    /// <summary>
    /// Port for scheduling jobs with an external time-based trigger system.
    /// Implementations might use Quartz.NET, Hangfire, AWS EventBridge, etc.
    /// </summary>
    public interface ISchedulerPort
    {
        /// <summary>
        /// Requests the execution of a job at the specified moment.
        /// The <paramref name="jobId" /> must be idempotent. Implementation
        /// decides the actual storage and execution details.
        /// </summary>
        Task ScheduleOneTimeJobAsync(
            string            jobId,
            DateTimeOffset    executeAtUtc,
            Func<CancellationToken, Task> job,
            CancellationToken ct = default);
    }

    /// <summary>
    /// Simple domain-event bus (in-process, message queue, or outbox mediator).
    /// </summary>
    public interface IDomainEventBus
    {
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct = default)
            where TEvent : class;
    }

    // -------------------------------------------------------------------------
    // APPLICATION SERVICE
    // -------------------------------------------------------------------------

    /// <summary>
    /// Handles business logic around scheduling posts for publication.
    /// </summary>
    public sealed class PublishingAutomationService
    {
        private readonly IPostRepository _posts;
        private readonly ISchedulerPort  _scheduler;
        private readonly IDomainEventBus _events;
        private readonly ILogger<PublishingAutomationService> _log;

        public PublishingAutomationService(
            IPostRepository posts,
            ISchedulerPort  scheduler,
            IDomainEventBus events,
            ILogger<PublishingAutomationService> log)
        {
            _posts     = posts  ?? throw new ArgumentNullException(nameof(posts));
            _scheduler = scheduler ?? throw new ArgumentNullException(nameof(scheduler));
            _events    = events ?? throw new ArgumentNullException(nameof(events));
            _log       = log    ?? throw new ArgumentNullException(nameof(log));
        }

        /// <summary>
        /// Schedules a post for future publication.  This method:
        ///  1. Loads and validates the Post aggregate
        ///  2. Applies domain logic (Post.SchedulePublish)
        ///  3. Persists changes through repository
        ///  4. Delegates trigger setup to <see cref="ISchedulerPort"/>
        ///  5. Publishes PostScheduledDomainEvent
        /// </summary>
        /// <exception cref="ArgumentException">If post not found.</exception>
        public async Task SchedulePostAsync(
            PostId          postId,
            DateTimeOffset  publishAtUtc,
            CancellationToken ct = default)
        {
            _log.LogTrace("Scheduling post {PostId} at {PublishAt} UTC", postId, publishAtUtc);

            var post = await _posts.FindAsync(postId, ct)
                        ?? throw new ArgumentException($"Post {postId} not found.", nameof(postId));

            try
            {
                post.SchedulePublish(publishAtUtc);
            }
            catch (Post.InvalidScheduleException ex)
            {
                _log.LogWarning(ex,
                    "Failed to schedule post {PostId} – schedule invalid: {Message}",
                    postId, ex.Message);
                throw;
            }

            await _posts.SaveAsync(post, ct);

            // Generate an idempotent job id (Post-scoped).
            var jobId = $"PublishPost-{postId}";

            // Schedule the adapter job
            await _scheduler.ScheduleOneTimeJobAsync(
                jobId,
                publishAtUtc,
                async jobCt => await PublishPostJobAsync(post.Id, jobCt),
                ct);

            // Broadcast domain event
            await _events.PublishAsync(
                new PostScheduledDomainEvent(postId, publishAtUtc),
                ct);

            _log.LogInformation("Post {PostId} scheduled successfully for {Date}", postId, publishAtUtc);
        }

        // ---------------------------------------------------------------------
        // JOB METHOD (invoked by Scheduler Port adapter)
        // ---------------------------------------------------------------------

        /// <summary>
        /// Job executed by the scheduler.  Marks the post as published and persists.
        /// Intended to be idempotent (safe to run once only).
        /// </summary>
        private async Task PublishPostJobAsync(PostId postId, CancellationToken ct)
        {
            _log.LogDebug("Scheduler triggered PublishPostJob for {PostId}", postId);

            var post = await _posts.FindAsync(postId, ct);
            if (post is null)
            {
                _log.LogError("PublishJob failed – post {PostId} not found.", postId);
                return;
            }

            if (post.IsPublished)
            {
                _log.LogInformation("Post {PostId} already published. Skipping.", postId);
                return;
            }

            post.MarkPublished();
            await _posts.SaveAsync(post, ct);

            _log.LogInformation("Post {PostId} published at {Date}", postId, DateTimeOffset.UtcNow);
            // Future: emit PostPublishedDomainEvent, flush caches, etc.
        }
    }

    // -------------------------------------------------------------------------
    // MOCK / STUB ADAPTERS (for unit testing)
    // -------------------------------------------------------------------------

    // NOTE: Simple in-memory test doubles are defined below to allow the module
    // to compile in isolation and facilitate unit-level validation. Production
    // adapters live in separate infrastructure projects.

    public sealed class InMemoryPostRepository : IPostRepository
    {
        private readonly System.Collections.Concurrent.ConcurrentDictionary<PostId, Post> _db = new();

        public Task<Post?> FindAsync(PostId id, CancellationToken ct = default)
        {
            _db.TryGetValue(id, out var post);
            return Task.FromResult(post);
        }

        public Task SaveAsync(Post post, CancellationToken ct = default)
        {
            _db[post.Id] = post;
            return Task.CompletedTask;
        }
    }

    public sealed class InMemorySchedulerPort : ISchedulerPort
    {
        public Task ScheduleOneTimeJobAsync(
            string jobId,
            DateTimeOffset executeAtUtc,
            Func<CancellationToken, Task> job,
            CancellationToken ct = default)
        {
            // Fire-and-forget timer for example purposes only.
            _ = Task.Run(async () =>
            {
                var delay = executeAtUtc - DateTimeOffset.UtcNow;
                if (delay > TimeSpan.Zero)
                    await Task.Delay(delay, ct);

                await job(ct);

            }, ct);

            return Task.CompletedTask;
        }
    }

    public sealed class SynchronousEventBus : IDomainEventBus
    {
        private readonly ILogger<SynchronousEventBus> _log;
        public SynchronousEventBus(ILogger<SynchronousEventBus> log) => _log = log;

        public Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct = default)
            where TEvent : class
        {
            _log.LogDebug("Event dispatched: {EventType}", @event.GetType().Name);
            // No subscribers in stub.
            return Task.CompletedTask;
        }
    }
}
```