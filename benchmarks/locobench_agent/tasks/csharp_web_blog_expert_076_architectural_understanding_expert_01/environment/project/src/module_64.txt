```csharp
// File: src/module_64.txt
//
// TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
// Module 64 – Scheduled Publishing Orchestrator (Domain/Application layer)
// Language: C#
//
// This file lives in the domain/application layer and therefore has no direct
// knowledge about EF Core, Redis, GraphQL, etc.  Instead it communicates
// exclusively through ports (interfaces).  Adapters live in a different
// assembly and can be swapped or mocked for testing.
//
// ----------------------------------------------------------------------------
// NOTE: The project uses <Nullable>enable</Nullable>.  Keep null-checks tight.
// ----------------------------------------------------------------------------

#nullable enable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Publishing
{
    /// <summary>
    /// Public facade for the Scheduled Publishing Orchestrator.
    /// Consumers (e.g., a background worker, Hangfire job, or Azure Function)
    /// call <see cref="ExecuteAsync"/> on a recurring basis—typically once per
    /// minute—to publish every post whose <c>PublishAt</c> value is less than
    /// or equal to the current time, as provided by an injected
    /// <see cref="ISystemClock"/> implementation.
    /// 
    /// The orchestrator is fully unit-testable because all IO concerns are
    /// abstracted behind ports.
    /// </summary>
    public sealed class PostPublishingScheduler
    {
        private readonly IPostRepository _postRepository;
        private readonly IPostPublisher _postPublisher;
        private readonly ISystemClock _clock;
        private readonly IDomainEventDispatcher _domainEventDispatcher;
        private readonly ILogger<PostPublishingScheduler> _logger;

        public PostPublishingScheduler(
            IPostRepository postRepository,
            IPostPublisher postPublisher,
            ISystemClock clock,
            IDomainEventDispatcher domainEventDispatcher,
            ILogger<PostPublishingScheduler> logger)
        {
            _postRepository        = postRepository  ?? throw new ArgumentNullException(nameof(postRepository));
            _postPublisher         = postPublisher   ?? throw new ArgumentNullException(nameof(postPublisher));
            _clock                 = clock           ?? throw new ArgumentNullException(nameof(clock));
            _domainEventDispatcher = domainEventDispatcher ?? throw new ArgumentNullException(nameof(domainEventDispatcher));
            _logger                = logger          ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Publishes all posts whose scheduled publish time has arrived.
        /// 
        /// Returns the number of posts successfully published.  Individual post
        /// failures are logged *and swallowed* so that one bad apple does not
        /// poison the entire batch.
        /// </summary>
        /// <param name="cancellationToken">Cancellation for long-running jobs.</param>
        public async Task<int> ExecuteAsync(CancellationToken cancellationToken = default)
        {
            var now = _clock.UtcNow;
            _logger.LogDebug("ScheduledPublishing job started at {UtcNow}", now);

            IReadOnlyList<Post> duePosts;
            try
            {
                duePosts = await _postRepository
                    .GetPostsScheduledForPublishingAsync(now, cancellationToken)
                    .ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unable to query repository for scheduled posts.");
                throw; // Fail-fast—this indicates infrastructure outage.
            }

            if (duePosts.Count == 0)
            {
                _logger.LogDebug("No posts due for publishing at {UtcNow}.", now);
                return 0;
            }

            _logger.LogInformation("Found {PostCount} post(s) scheduled for publishing.", duePosts.Count);

            var publishCount = 0;
            foreach (var post in duePosts)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    _logger.LogWarning("Cancellation requested, aborting remaining publishes.");
                    break;
                }

                try
                {
                    await PublishPostAsync(post, cancellationToken).ConfigureAwait(false);
                    publishCount++;
                }
                catch (Exception ex)
                {
                    // Swallow exception for individual posts; surfaces via logging/observability.
                    _logger.LogError(ex,
                        "Failed to publish PostId={PostId}, slug '{Slug}'. Continuing with next item.",
                        post.PostId,
                        post.Slug);
                }
            }

            _logger.LogInformation("ScheduledPublishing job completed. {Published} / {Total} posts published.",
                publishCount, duePosts.Count);

            return publishCount;
        }

        // ---------------------------------------------------------------------
        // Internal helpers
        // ---------------------------------------------------------------------

        private async Task PublishPostAsync(Post post, CancellationToken ct)
        {
            // Double-check to protect against race conditions: another worker
            // might have already published this post in the meantime.
            if (post.Status == PostStatus.Published)
            {
                _logger.LogDebug("PostId={PostId} already published by another instance.", post.PostId);
                return;
            }

            // Domain rule: A post cannot be published if it is awaiting approval
            // by an editor.  Handle gracefully.
            if (post.RequiresApproval && !post.IsApproved)
            {
                _logger.LogWarning("PostId={PostId} requires approval and will not be auto-published.", post.PostId);
                return;
            }

            _logger.LogDebug("Publishing PostId={PostId} (slug '{Slug}').", post.PostId, post.Slug);

            // 1) Delegate to the publishing adapter (e.g., markdown → HTML).
            await _postPublisher.PublishAsync(post, ct).ConfigureAwait(false);

            // 2) Update repository state.
            post.MarkAsPublished(_clock.UtcNow);
            await _postRepository.UpdateAsync(post, ct).ConfigureAwait(false);

            // 3) Raise domain events (analytics, notifications, etc.).
            var evt = new PostPublishedEvent(post.PostId, post.PublishedAt!.Value);
            await _domainEventDispatcher.DispatchAsync(evt, ct).ConfigureAwait(false);

            _logger.LogInformation("Successfully published PostId={PostId}.", post.PostId);
        }
    }

    // ========================================================================
    // Domain entities & value objects (minimal representation)
    // ========================================================================

    public enum PostStatus
    {
        Draft        = 0,
        Scheduled    = 1,
        Published    = 2,
        Archived     = 3
    }

    public sealed class Post
    {
        private readonly List<object> _domainEvents = new();

        public Guid            PostId        { get; }
        public string          Slug          { get; }
        public PostStatus      Status        { get; private set; }
        public DateTimeOffset? PublishAt     { get; }
        public DateTimeOffset? PublishedAt   { get; private set; }

        // Simplified approval flags
        public bool            RequiresApproval { get; }
        public bool            IsApproved       { get; private set; }

        public IReadOnlyCollection<object> DomainEvents => _domainEvents.AsReadOnly();

        public Post(Guid postId,
                    string slug,
                    PostStatus status,
                    DateTimeOffset? publishAt,
                    bool requiresApproval,
                    bool isApproved)
        {
            PostId           = postId;
            Slug             = slug;
            Status           = status;
            PublishAt        = publishAt;
            RequiresApproval = requiresApproval;
            IsApproved       = isApproved;
        }

        public void Approve()
        {
            if (!RequiresApproval)
                throw new InvalidOperationException("Approval not required.");

            if (IsApproved)
                return;

            IsApproved = true;
            AddDomainEvent(new PostApprovedEvent(PostId, DateTimeOffset.UtcNow));
        }

        public void MarkAsPublished(DateTimeOffset publishedAt)
        {
            if (Status == PostStatus.Published)
                return;

            Status      = PostStatus.Published;
            PublishedAt = publishedAt;
            AddDomainEvent(new PostStatusChangedEvent(PostId, Status, publishedAt));
        }

        private void AddDomainEvent(object @event) => _domainEvents.Add(@event);
    }

    // ========================================================================
    // Domain Events
    // ========================================================================

    public sealed record PostPublishedEvent(Guid PostId, DateTimeOffset PublishedAt);
    public sealed record PostApprovedEvent(Guid PostId, DateTimeOffset ApprovedAt);
    public sealed record PostStatusChangedEvent(Guid PostId, PostStatus Status, DateTimeOffset ChangedAt);

    // ========================================================================
    // Ports (Interfaces) ‑ to be implemented by Adapters
    // ========================================================================

    /// <summary>
    /// Time abstraction to decouple from DateTime.UtcNow.
    /// Allows deterministic tests & time-travel simulations.
    /// </summary>
    public interface ISystemClock
    {
        DateTimeOffset UtcNow { get; }
    }

    public interface IPostRepository
    {
        /// <summary>
        /// Returns every post whose <c>PublishAt</c> ≤ <paramref name="asOf"/> and
        /// whose status is <see cref="PostStatus.Scheduled"/>.
        /// </summary>
        Task<IReadOnlyList<Post>> GetPostsScheduledForPublishingAsync(
            DateTimeOffset asOf,
            CancellationToken cancellationToken);

        Task UpdateAsync(Post post, CancellationToken cancellationToken);
    }

    /// <summary>
    /// Responsible for turning a <see cref="Post"/> into published content.
    /// Implementation examples: ‑ Generate full HTML & push to CDN
    ///                           ‑ Enqueue a static-site rebuild
    ///                           ‑ Call headless CMS API
    /// </summary>
    public interface IPostPublisher
    {
        Task PublishAsync(Post post, CancellationToken cancellationToken);
    }

    /// <summary>
    /// Dispatches domain events (Sync or Async).
    /// Typical implementation: wraps MediatR, NATS, Kafka, etc.
    /// </summary>
    public interface IDomainEventDispatcher
    {
        Task DispatchAsync(object domainEvent, CancellationToken cancellationToken);
    }
}
```