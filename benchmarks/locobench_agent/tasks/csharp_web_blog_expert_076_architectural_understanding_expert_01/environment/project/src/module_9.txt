```csharp
// File: src/module_9.txt  (treated as C# source code)
//
// Module: Post Live-Preview – Diff Caching
// Responsibility: Calculates the textual diff between the latest published
//                 version of a post and the current working draft, stores
//                 and retrieves that diff from a fast cache (Redis).
//
// Architectural position:
// ‑ IPostDiffCache            : Hexagonal Port
// ‑ PostDiffService           : Application / Service-Layer Core
// ‑ RedisPostDiffCacheAdapter : Redis-based Adapter (external concern)

using System;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Security.Cryptography;
using System.Collections.Generic;
using Microsoft.Extensions.Logging;
using StackExchange.Redis;

namespace TempoScribePro.Core.Preview
{
    #region Domain Models & Value Objects ------------------------------------------------------

    /// <summary>
    /// Immutable value object representing a post identifier.
    /// </summary>
    public readonly struct PostId : IEquatable<PostId>
    {
        public Guid Value { get; }

        public PostId(Guid value) => Value = value == Guid.Empty
            ? throw new ArgumentException("Post ID cannot be empty.", nameof(value))
            : value;

        public bool Equals(PostId other) => Value.Equals(other.Value);
        public override bool Equals(object? obj) => obj is PostId other && Equals(other);
        public override int GetHashCode() => Value.GetHashCode();
        public override string ToString() => Value.ToString();
        public static implicit operator Guid(PostId id) => id.Value;
        public static PostId New() => new PostId(Guid.NewGuid());
    }

    /// <summary>
    /// Simple DTO carrying diff results for UI consumption.
    /// </summary>
    public sealed record PostDiff(
        PostId PostId,
        string DraftChecksum,
        string PublishedChecksum,
        IReadOnlyList<LineDiff> LineDiffs,
        DateTimeOffset CalculatedAtUtc);

    /// <summary>
    /// Represents a line-by-line diff entry.
    /// </summary>
    public sealed record LineDiff(int LineNumber, string? Original, string? Modified);

    #endregion

    #region Ports ------------------------------------------------------------------------------

    /// <summary>
    /// Port exposing diff caching contract to the application core.
    /// </summary>
    public interface IPostDiffCache
    {
        Task<PostDiff?> TryGetAsync(PostId postId, string draftChecksum, CancellationToken ct = default);
        Task SetAsync(PostDiff diff, TimeSpan ttl, CancellationToken ct = default);
        Task InvalidateAsync(PostId postId, CancellationToken ct = default);
    }

    /// <summary>
    /// Port representing the repository to fetch post content. Provided elsewhere in the solution.
    /// Only signature is needed here to remain technology agnostic.
    /// </summary>
    public interface IPostRepository
    {
        Task<string?> GetLatestPublishedMarkdownAsync(PostId postId, CancellationToken ct = default);
    }

    #endregion

    #region Service Layer ----------------------------------------------------------------------

    /// <summary>
    /// Application-service responsible for producing and caching post diff results.
    /// </summary>
    public sealed class PostDiffService
    {
        private readonly IPostRepository _postRepository;
        private readonly IPostDiffCache  _cache;
        private readonly ILogger<PostDiffService> _logger;
        private static readonly TimeSpan DefaultTtl = TimeSpan.FromMinutes(15);

        public PostDiffService(
            IPostRepository postRepository,
            IPostDiffCache cache,
            ILogger<PostDiffService> logger)
        {
            _postRepository = postRepository ?? throw new ArgumentNullException(nameof(postRepository));
            _cache = cache   ?? throw new ArgumentNullException(nameof(cache));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Returns a diff between the draft and last published version.
        /// Utilises cache when possible, otherwise calculates and stores result.
        /// </summary>
        public async Task<PostDiff> GetDiffAsync(
            PostId postId,
            string draftMarkdown,
            CancellationToken ct = default)
        {
            if (draftMarkdown is null) throw new ArgumentNullException(nameof(draftMarkdown));

            var draftChecksum = ComputeSha256(draftMarkdown);

            // 1. Try cached value
            var cached = await _cache.TryGetAsync(postId, draftChecksum, ct).ConfigureAwait(false);
            if (cached is not null)
            {
                _logger.LogDebug("Cache hit for post {PostId}", postId);
                return cached;
            }

            _logger.LogDebug("Cache miss for post {PostId}", postId);

            // 2. Fetch latest published content
            var publishedMarkdown = await _postRepository
                .GetLatestPublishedMarkdownAsync(postId, ct)
                .ConfigureAwait(false) ?? string.Empty;

            var publishedChecksum = ComputeSha256(publishedMarkdown);

            // 3. Calculate diff
            var diffs = DiffUtil.ComputeLineDiffs(publishedMarkdown, draftMarkdown);

            var diffResult = new PostDiff(
                PostId: postId,
                DraftChecksum: draftChecksum,
                PublishedChecksum: publishedChecksum,
                LineDiffs: diffs,
                CalculatedAtUtc: DateTimeOffset.UtcNow);

            // 4. Cache result
            await _cache.SetAsync(diffResult, DefaultTtl, ct).ConfigureAwait(false);

            return diffResult;
        }

        /// <summary>
        /// Invalidates any cached diff for a given post. Typically called after publishing.
        /// </summary>
        public Task InvalidateAsync(PostId postId, CancellationToken ct = default) =>
            _cache.InvalidateAsync(postId, ct);

        private static string ComputeSha256(string input)
        {
            using var sha = SHA256.Create();
            var bytes = Encoding.UTF8.GetBytes(input);
            var hash  = sha.ComputeHash(bytes);
            return Convert.ToHexString(hash);
        }
    }

    #endregion

    #region Diff Utility (Domain Logic) --------------------------------------------------------

    internal static class DiffUtil
    {
        /// <summary>
        /// Naïve but effective line-by-line diff. This is sufficient for preview UI
        /// which highlights added/removed/changed lines. 
        /// For sophisticated diffing consider Myers or Patience algorithms.
        /// </summary>
        public static IReadOnlyList<LineDiff> ComputeLineDiffs(string older, string newer)
        {
            var oldLines = older.Split('\n');
            var newLines = newer.Split('\n');
            var max      = Math.Max(oldLines.Length, newLines.Length);
            var diffs    = new List<LineDiff>(capacity: max);

            for (int i = 0; i < max; i++)
            {
                var original = i < oldLines.Length ? oldLines[i] : null;
                var modified = i < newLines.Length ? newLines[i] : null;

                if (!string.Equals(original, modified, StringComparison.Ordinal))
                    diffs.Add(new LineDiff(i + 1, original, modified));
            }

            return diffs;
        }
    }

    #endregion

    #region Redis Adapter ----------------------------------------------------------------------

    /// <summary>
    /// Redis-based adapter fulfilling the IPostDiffCache contract.
    /// Uses JSON for value serialisation to remain language-agnostic.
    /// </summary>
    public sealed class RedisPostDiffCacheAdapter : IPostDiffCache, IDisposable
    {
        private readonly IConnectionMultiplexer _multiplexer;
        private readonly IDatabase _db;
        private readonly ILogger<RedisPostDiffCacheAdapter> _logger;

        private static readonly JsonSerializerOptions _jsonOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = false
        };

        public RedisPostDiffCacheAdapter(
            IConnectionMultiplexer multiplexer,
            ILogger<RedisPostDiffCacheAdapter> logger)
        {
            _multiplexer = multiplexer ?? throw new ArgumentNullException(nameof(multiplexer));
            _db = _multiplexer.GetDatabase();
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<PostDiff?> TryGetAsync(PostId postId, string draftChecksum, CancellationToken ct = default)
        {
            var key = BuildKey(postId);
            try
            {
                var value = await _db.StringGetAsync(key).ConfigureAwait(false);
                if (!value.HasValue) return null;

                var diff = Deserialize(value!);
                return diff.DraftChecksum == draftChecksum ? diff : null;
            }
            catch (RedisConnectionException ex)
            {
                _logger.LogWarning(ex, "Unable to retrieve diff cache for post {PostId}", postId);
                return null;
            }
        }

        public async Task SetAsync(PostDiff diff, TimeSpan ttl, CancellationToken ct = default)
        {
            var key   = BuildKey(diff.PostId);
            var value = Serialize(diff);

            try
            {
                await _db.StringSetAsync(key, value, ttl).ConfigureAwait(false);
            }
            catch (RedisConnectionException ex)
            {
                _logger.LogError(ex, "Unable to write diff cache for post {PostId}", diff.PostId);
            }
        }

        public async Task InvalidateAsync(PostId postId, CancellationToken ct = default)
        {
            try
            {
                await _db.KeyDeleteAsync(BuildKey(postId)).ConfigureAwait(false);
            }
            catch (RedisConnectionException ex)
            {
                _logger.LogWarning(ex, "Unable to invalidate diff cache for post {PostId}", postId);
            }
        }

        private static string BuildKey(PostId id) => $"tspro:diff:{id}";

        #region JSON Serialization helpers

        private static string Serialize(PostDiff diff) =>
            System.Text.Json.JsonSerializer.Serialize(diff, _jsonOptions);

        private static PostDiff Deserialize(string json) =>
            System.Text.Json.JsonSerializer.Deserialize<PostDiff>(json, _jsonOptions)
            ?? throw new InvalidOperationException("Deserialised diff is null.");

        #endregion

        #region IDisposable Support

        private bool _disposed;

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;
            // Multiplexer is normally a singleton and disposed by DI container,
            // so we don't dispose it here to avoid accidental shutdown.
        }

        #endregion
    }

    #endregion
}
```