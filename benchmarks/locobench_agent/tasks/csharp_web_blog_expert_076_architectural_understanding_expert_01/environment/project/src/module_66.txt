```csharp
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Services.Scheduling
{
    /// <summary>
    /// Abstraction for retrieving the current time. 
    /// Provides seam for deterministic testing and time-zone insulation.
    /// </summary>
    public interface IClock
    {
        DateTime UtcNow { get; }
    }

    /// <summary>
    /// Contract for persistence and state-transition access to <see cref="Post"/> aggregates.
    /// </summary>
    public interface IPostRepository
    {
        /// <summary>
        /// Returns Posts that are scheduled for publishing at or before <paramref name="utcNow"/>
        /// and have not yet been published.
        /// </summary>
        Task<IReadOnlyCollection<Post>> FetchScheduledDueAsync(DateTime utcNow, CancellationToken ct);

        /// <summary>
        /// Persists state changes for the supplied Post.
        /// </summary>
        Task UpdateAsync(Post post, CancellationToken ct);
    }

    /// <summary>
    /// Represents a unit-of-work boundary for committing multiple aggregate changes atomically.
    /// </summary>
    public interface IUnitOfWork
    {
        Task CommitAsync(CancellationToken ct);
    }

    /// <summary>
    /// Port that ultimately publishes a post outside the domain.
    /// The implementation may post to REST API, trigger web hooks, etc.
    /// </summary>
    public interface IPublishingGateway
    {
        Task PublishAsync(Post post, CancellationToken ct);
    }

    /// <summary>
    /// Domain event bus abstraction. 
    /// </summary>
    public interface IEventBus
    {
        Task DispatchAsync(IDomainEvent @event, CancellationToken ct);
    }

    public interface IDomainEvent { }

    #region Domain Model (simplified)

    /// <summary>
    /// Simplified representation of a blog post aggregate in the TempoScribe domain.
    /// Actual implementation is richer and stored elsewhere in the solution.
    /// </summary>
    public class Post
    {
        public Guid Id { get; init; }
        public string Slug { get; private set; } = string.Empty;
        public PostStatus Status { get; private set; } = PostStatus.Draft;
        public DateTime? ScheduledAtUtc { get; private set; }
        public DateTime? PublishedAtUtc { get; private set; }

        public void MarkPublished(DateTime utcNow)
        {
            Status = PostStatus.Published;
            PublishedAtUtc = utcNow;
        }

        public void MarkPublishingFailed(string reason, DateTime utcNow)
        {
            Status        = PostStatus.PublishingFailed;
            PublishedAtUtc = utcNow; // record the attempt time even though it failed
            _failReason    = reason;
        }

        public string? GetLastFailureReason() => _failReason;

        private string? _failReason;
    }

    public enum PostStatus
    {
        Draft,
        Scheduled,
        Published,
        PublishingFailed
    }

    #endregion

    #region Scheduled Publishing Service

    /// <summary>
    /// Public surface for orchestrating scheduled publishing.
    /// </summary>
    public interface IScheduledPublishingService
    {
        Task<PublishSummary> PublishDuePostsAsync(CancellationToken ct = default);
    }

    /// <summary>
    /// Aggregate statistics for a publishing batch.
    /// </summary>
    public sealed record PublishSummary(
        int Attempted,
        int Succeeded,
        int Failed,
        IReadOnlyCollection<PublishResult> Results);

    /// <summary>
    /// Captures the result of attempting to publish a single post.
    /// </summary>
    public sealed record PublishResult(Guid PostId, bool Success, string? Error);

    /// <summary>
    /// Coordinates the domain work of publishing scheduled posts.
    /// Adheres to hexagonal principles by relying only on ports.
    /// </summary>
    public sealed class ScheduledPublishingService : IScheduledPublishingService
    {
        private readonly IClock                 _clock;
        private readonly IPostRepository        _repository;
        private readonly IUnitOfWork            _uow;
        private readonly IPublishingGateway     _gateway;
        private readonly IEventBus              _eventBus;
        private readonly ILogger<ScheduledPublishingService> _logger;

        public ScheduledPublishingService(
            IClock clock,
            IPostRepository repository,
            IUnitOfWork uow,
            IPublishingGateway gateway,
            IEventBus eventBus,
            ILogger<ScheduledPublishingService> logger)
        {
            _clock     = clock     ?? throw new ArgumentNullException(nameof(clock));
            _repository = repository ?? throw new ArgumentNullException(nameof(repository));
            _uow        = uow        ?? throw new ArgumentNullException(nameof(uow));
            _gateway    = gateway    ?? throw new ArgumentNullException(nameof(gateway));
            _eventBus   = eventBus   ?? throw new ArgumentNullException(nameof(eventBus));
            _logger     = logger     ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <inheritdoc />
        public async Task<PublishSummary> PublishDuePostsAsync(CancellationToken ct = default)
        {
            var duePosts = await _repository.FetchScheduledDueAsync(_clock.UtcNow, ct)
                                            .ConfigureAwait(false);

            var results      = new List<PublishResult>(duePosts.Count);
            var succeeded    = 0;
            var failed       = 0;

            _logger.LogInformation("Found {Count} post(s) ready for scheduled publishing.", duePosts.Count);

            foreach (var post in duePosts)
            {
                if (ct.IsCancellationRequested)
                {
                    _logger.LogWarning("Publishing batch was cancelled.");
                    break;
                }

                try
                {
                    await _gateway.PublishAsync(post, ct).ConfigureAwait(false);
                    post.MarkPublished(_clock.UtcNow);

                    results.Add(new PublishResult(post.Id, true, null));
                    succeeded++;

                    await _eventBus.DispatchAsync(
                        new PostPublishedEvent(post.Id, post.Slug, post.PublishedAtUtc!.Value),
                        ct).ConfigureAwait(false);

                    _logger.LogInformation("Successfully published scheduled post {PostId}", post.Id);
                }
                catch (Exception ex)
                {
                    // swallow exception to allow other posts to continue
                    failed++;
                    _logger.LogError(ex, "Failed to publish scheduled post {PostId}", post.Id);

                    post.MarkPublishingFailed(ex.Message, _clock.UtcNow);
                    results.Add(new PublishResult(post.Id, false, ex.Message));
                }

                await _repository.UpdateAsync(post, ct).ConfigureAwait(false);
            }

            // Commit all changes in a single transaction
            await _uow.CommitAsync(ct).ConfigureAwait(false);

            return new PublishSummary(
                Attempted : results.Count,
                Succeeded : succeeded,
                Failed    : failed,
                Results   : results.AsReadOnly());
        }
    }

    #endregion

    #region Domain Events

    /// <summary>
    /// Raised once a post has been published (either scheduled or manual).
    /// </summary>
    public sealed class PostPublishedEvent : IDomainEvent
    {
        public Guid      PostId       { get; }
        public string    Slug         { get; }
        public DateTime  PublishedUtc { get; }

        public PostPublishedEvent(Guid postId, string slug, DateTime publishedUtc)
        {
            PostId       = postId;
            Slug         = slug;
            PublishedUtc = publishedUtc;
        }
    }

    #endregion
}
```