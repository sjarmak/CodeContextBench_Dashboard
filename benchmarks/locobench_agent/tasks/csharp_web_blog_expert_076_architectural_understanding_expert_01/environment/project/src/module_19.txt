```csharp
// File: src/module_19.txt
// Project: TempoScribe Pro – Hexagonal Productivity Blog Suite (web_blog)
//
// NOTE: Although this file lives under a *.txt extension inside the repository,
//       it intentionally contains compilable C# source code. The build-pipeline
//       picks it up and adds it to the compilation unit via a wildcard include.
//
// Purpose:
//   Encapsulates domain logic for scheduled post-publishing.  The service is
//   part of the core domain and therefore exposes only technology-agnostic
//   ports.  Adapters (SQL, MongoDB, Azure Service Bus, REST, etc.) plug in via
//   dependency injection at composition-root level.
//
//   Hexagonal ports defined here:
//     • IPublicationScheduleRepository – persistence abstraction
//     • IPostPublicationPort           – executes the actual “publish” use-case
//     • ISystemClock                   – provides an injectable clock for testing
//     • IEventBus                      – domain events dispatcher
//
//   Domain service:
//     • PublishingSchedulerService – orchestrates time-based publishing,
//       implements pessimistic transaction handling, robust error logging,
//       and graceful cancellation semantics.
//
//   This module is intentionally free of framework entanglements; the only
//   external dependency is Microsoft.Extensions.Logging for structured logs.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace TempoScribePro.Domain.Scheduling
{
    #region Value Objects & Aggregates -------------------------------------------------------------

    /// <summary>
    /// Strongly-typed identifier for a <see cref="PublicationSchedule"/>.
    /// </summary>
    public sealed record PublicationScheduleId(Guid Value)
    {
        public static PublicationScheduleId New() => new(Guid.NewGuid());

        public override string ToString() => Value.ToString();
    }

    /// <summary>
    /// Aggregate root representing a scheduling request for automatic publication
    /// of a blog post at <see cref="PublishAt"/>.  Domain invariants guarantee a
    /// schedule is published only once.
    /// </summary>
    public sealed class PublicationSchedule
    {
        public PublicationScheduleId Id { get; }
        public Guid                   PostId     { get; }
        public DateTimeOffset         PublishAt  { get; private set; }
        public bool                   Published  { get; private set; }

        public PublicationSchedule(
            PublicationScheduleId id,
            Guid postId,
            DateTimeOffset publishAt)
        {
            Id        = id     ?? throw new ArgumentNullException(nameof(id));
            PostId    = postId == Guid.Empty
                      ? throw new ArgumentException("PostId cannot be empty.", nameof(postId))
                      : postId;
            PublishAt = publishAt;
            Published = false;
        }

        /// <summary>
        /// Marks the schedule as completed.  Only valid once.
        /// </summary>
        /// <exception cref="InvalidOperationException">If already marked published.</exception>
        public void MarkPublished()
        {
            if (Published)
                throw new InvalidOperationException(
                    $"Schedule {Id} is already marked as published.");

            Published = true;
        }

        /// <summary>
        /// Allows an editor to move the planned date/time into the future.  Cannot
        /// reschedule if the post has already been published.
        /// </summary>
        public void Reschedule(DateTimeOffset newPublishAt)
        {
            if (Published)
                throw new InvalidOperationException("Cannot reschedule a published post.");

            if (newPublishAt <= DateTimeOffset.UtcNow)
                throw new ArgumentException("New publish date must be in the future.",
                                            nameof(newPublishAt));

            PublishAt = newPublishAt;
        }
    }

    #endregion

    #region Hexagonal Ports ------------------------------------------------------------------------

    /// <summary>
    /// Repository abstraction for <see cref="PublicationSchedule"/> aggregates.
    /// Persistence adapters (e.g., Dapper, EF Core, MongoDB) implement this port.
    /// </summary>
    public interface IPublicationScheduleRepository
    {
        Task<IReadOnlyList<PublicationSchedule>> GetDueSchedulesAsync(
            DateTimeOffset asOf,
            CancellationToken cancellationToken = default);

        Task SaveAsync(
            PublicationSchedule schedule,
            CancellationToken cancellationToken = default);

        // Transaction support is optional for adapters that cannot guarantee
        // atomicity at a lower level (e.g., Mongo).  No-op implementations are
        // acceptable in such cases.
        Task BeginTransactionAsync(CancellationToken cancellationToken = default);
        Task CommitTransactionAsync(CancellationToken cancellationToken = default);
        Task RollbackTransactionAsync(CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Executes the concrete “publish post” use-case.  A blog engine adapter
    /// translates this into database writes, cache invalidations, and public
    /// reader notifications.
    /// </summary>
    public interface IPostPublicationPort
    {
        Task PublishPostAsync(
            Guid postId,
            CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Injectable clock for deterministic testing & time-zone abstractions.
    /// </summary>
    public interface ISystemClock
    {
        DateTimeOffset UtcNow { get; }
    }

    /// <summary>
    /// Thin mediator for pushing domain events to interested adapters
    /// (e.g., real-time websockets, message queues, email jobs).
    /// </summary>
    public interface IEventBus
    {
        Task PublishAsync<TEvent>(
            TEvent domainEvent,
            CancellationToken cancellationToken = default)
            where TEvent : class;
    }

    #endregion

    #region Domain Events --------------------------------------------------------------------------

    public record PostScheduledForPublication(
        Guid             PostId,
        DateTimeOffset   PublishAt,
        PublicationScheduleId ScheduleId);

    public record PostPublished(
        Guid             PostId,
        DateTimeOffset   PublishedAt,
        PublicationScheduleId ScheduleId);

    #endregion

    #region Domain Service -------------------------------------------------------------------------

    /// <summary>
    /// Core domain service responsible for:
    ///   • Accepting new scheduling requests.
    ///   • Periodically scanning for due schedules and triggering publication.
    ///   • Emitting relevant domain events.
    ///   • Ensuring idempotency and transactional consistency.
    ///
    /// This type lives in the domain layer and is agnostic of any concrete
    /// infrastructure: databases, message brokers, background workers, etc.
    /// </summary>
    public sealed class PublishingSchedulerService
    {
        private readonly IPublicationScheduleRepository _repository;
        private readonly IPostPublicationPort           _postPublicationPort;
        private readonly ISystemClock                   _clock;
        private readonly IEventBus                      _eventBus;
        private readonly ILogger<PublishingSchedulerService> _logger;

        public PublishingSchedulerService(
            IPublicationScheduleRepository repository,
            IPostPublicationPort            postPublicationPort,
            ISystemClock                    clock,
            IEventBus                       eventBus,
            ILogger<PublishingSchedulerService> logger)
        {
            _repository         = repository         ?? throw new ArgumentNullException(nameof(repository));
            _postPublicationPort= postPublicationPort?? throw new ArgumentNullException(nameof(postPublicationPort));
            _clock              = clock              ?? throw new ArgumentNullException(nameof(clock));
            _eventBus           = eventBus           ?? throw new ArgumentNullException(nameof(eventBus));
            _logger             = logger             ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Schedules a post for future publication.
        /// </summary>
        /// <exception cref="ArgumentException">If <paramref name="publishAt"/> is not in future.</exception>
        public async Task<PublicationScheduleId> SchedulePublicationAsync(
            Guid             postId,
            DateTimeOffset   publishAt,
            CancellationToken cancellationToken = default)
        {
            if (publishAt <= _clock.UtcNow)
                throw new ArgumentException("Publish date must be in the future.", nameof(publishAt));

            var schedule = new PublicationSchedule(
                PublicationScheduleId.New(),
                postId,
                publishAt);

            await _repository.SaveAsync(schedule, cancellationToken)
                             .ConfigureAwait(false);

            await _eventBus.PublishAsync(
                    new PostScheduledForPublication(postId, publishAt, schedule.Id),
                    cancellationToken)
                    .ConfigureAwait(false);

            _logger.LogInformation(
                "Post {PostId} scheduled for publication at {PublishAt}. ScheduleId={ScheduleId}",
                postId, publishAt, schedule.Id);

            return schedule.Id;
        }

        /// <summary>
        /// Checks for schedules that are due (i.e., <see cref="ISystemClock.UtcNow"/>
        /// is on/after <see cref="PublicationSchedule.PublishAt"/>) and publishes
        /// them sequentially.  This method is concurrency-safe and can be invoked
        /// by multiple worker instances thanks to repository-level pessimistic or
        /// optimistic locking (implementation-specific).
        /// </summary>
        public async Task ProcessDueSchedulesAsync(
            CancellationToken cancellationToken = default)
        {
            var now = _clock.UtcNow;
            _logger.LogDebug("Scanning for due publication schedules at {Now}.", now);

            IReadOnlyList<PublicationSchedule> dueSchedules;
            try
            {
                dueSchedules = await _repository.GetDueSchedulesAsync(now, cancellationToken)
                                                .ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to retrieve due publication schedules.");
                throw; // Bubble up – upstream orchestrator decides retry policy
            }

            if (dueSchedules.Count == 0)
            {
                _logger.LogDebug("No due schedules found.");
                return;
            }

            // Process in chronological order for deterministic behavior
            foreach (var schedule in dueSchedules.OrderBy(s => s.PublishAt))
            {
                cancellationToken.ThrowIfCancellationRequested();

                _logger.LogDebug("Attempting to publish Post {PostId} (ScheduleId={ScheduleId}) …",
                                 schedule.PostId, schedule.Id);

                try
                {
                    await _repository.BeginTransactionAsync(cancellationToken)
                                     .ConfigureAwait(false);

                    await _postPublicationPort.PublishPostAsync(schedule.PostId, cancellationToken)
                                              .ConfigureAwait(false);

                    schedule.MarkPublished();

                    await _repository.SaveAsync(schedule, cancellationToken)
                                     .ConfigureAwait(false);

                    await _eventBus.PublishAsync(
                            new PostPublished(schedule.PostId, now, schedule.Id),
                            cancellationToken)
                            .ConfigureAwait(false);

                    await _repository.CommitTransactionAsync(cancellationToken)
                                     .ConfigureAwait(false);

                    _logger.LogInformation(
                        "Successfully published Post {PostId} at {Timestamp}. ScheduleId={ScheduleId}",
                        schedule.PostId, now, schedule.Id);
                }
                catch (OperationCanceledException)
                {
                    // Explicit cancellation – do NOT treat as error, simply rethrow
                    _logger.LogWarning(
                        "Publishing loop cancelled while processing Post {PostId}.",
                        schedule.PostId);
                    await _repository.RollbackTransactionAsync(CancellationToken.None);
                    throw;
                }
                catch (Exception ex)
                {
                    await SafeRollbackAsync(schedule, ex, cancellationToken);
                }
            }
        }

        #region Private helpers --------------------------------------------------------------------

        private async Task SafeRollbackAsync(
            PublicationSchedule schedule,
            Exception           ex,
            CancellationToken   cancellationToken)
        {
            try
            {
                _logger.LogError(
                    ex,
                    "Error while publishing Post {PostId} (ScheduleId={ScheduleId}). Initiating rollback …",
                    schedule.PostId,
                    schedule.Id);

                await _repository.RollbackTransactionAsync(cancellationToken)
                                 .ConfigureAwait(false);
            }
            catch (Exception rollbackEx)
            {
                _logger.LogCritical(
                    rollbackEx,
                    "Rollback failed for Post {PostId} (ScheduleId={ScheduleId}). Manual intervention required!",
                    schedule.PostId,
                    schedule.Id);

                // In a real implementation, this branch should raise an alert
                // (PagerDuty, Slack, etc.) via a resiliency adapter.
            }
        }

        #endregion
    }

    #endregion
}
```