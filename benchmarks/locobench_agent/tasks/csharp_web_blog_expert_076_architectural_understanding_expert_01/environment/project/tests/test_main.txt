```csharp
// File: tests/Test_ScheduledPublishingService.cs
//
// NOTE:  This file lives under /tests in the solution root so that
//        it can be compiled independently of concrete adapters.
//        The tests exercise the application-service layer that sits
//        on top of the pure domain and below adapter implementations.
//
//        NuGet packages required (added via the solution’s build script):
//        – xunit
//        – xunit.runner.visualstudio
//        – Moq
//        – FluentAssertions
//
// ---------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using FluentAssertions;
using Moq;
using TempoScribePro.Core.Domain.Blogging;
using TempoScribePro.Core.Domain.Blogging.Events;
using TempoScribePro.Core.Ports.Repositories;
using TempoScribePro.Core.Ports.Services;
using TempoScribePro.Core.Services;
using Xunit;

namespace TempoScribePro.Tests.ApplicationServices
{
    /// <summary>
    ///     Tests focused on <see cref="ScheduledPublishingService"/> logic.
    ///     The service is part of the application/service layer and wires
    ///     the domain model (<see cref="Post"/> aggregate) to the outside
    ///     world through ports.
    ///
    ///     All external dependencies (repositories, notification dispatcher,
    ///     publisher port) are mocked so that these tests remain fast and
    ///     deterministic.
    /// </summary>
    public sealed class ScheduledPublishingServiceTests
    {
        private readonly Mock<IPostRepository>            _postRepositoryMock;
        private readonly Mock<IPublisherPort>             _publisherPortMock;
        private readonly Mock<IUnitOfWork>                _uowMock;
        private readonly Mock<INotificationDispatcher>    _notificationMock;
        private readonly ScheduledPublishingService       _service;

        public ScheduledPublishingServiceTests()
        {
            _postRepositoryMock = new Mock<IPostRepository>(MockBehavior.Strict);
            _publisherPortMock  = new Mock<IPublisherPort>(MockBehavior.Strict);
            _uowMock            = new Mock<IUnitOfWork>(MockBehavior.Strict);
            _notificationMock   = new Mock<INotificationDispatcher>(MockBehavior.Strict);

            _service = new ScheduledPublishingService(
                _postRepositoryMock.Object,
                _publisherPortMock.Object,
                _uowMock.Object,
                _notificationMock.Object);
        }

        [Fact(DisplayName = "RunAsync publishes due posts and commits exactly once")]
        public async Task RunAsync_PublishesDuePostsAndCommits()
        {
            // Arrange
            var utcNow = new DateTime(2030, 01, 01, 12, 00, 00, DateTimeKind.Utc);

            var draftPost1 = Post.CreateDraft("UniqueId-1", "First Draft", authorId: "user-123");
            var draftPost2 = Post.CreateDraft("UniqueId-2", "Second Draft", authorId: "user-123");

            draftPost1.SchedulePublication(utcNow.AddMinutes(-15)); // Due
            draftPost2.SchedulePublication(utcNow.AddMinutes(-5));  // Due

            IReadOnlyList<Post> duePosts = new[] { draftPost1, draftPost2 };

            _postRepositoryMock
                .Setup(r => r.FindScheduledToPublishAsync(utcNow, It.IsAny<CancellationToken>()))
                .ReturnsAsync(duePosts);

            _publisherPortMock
                .Setup(p => p.PublishAsync(It.IsAny<Post>(), It.IsAny<CancellationToken>()))
                .Returns(Task.CompletedTask);

            _uowMock.Setup(u => u.CommitAsync(It.IsAny<CancellationToken>()))
                    .Returns(Task.CompletedTask);

            _notificationMock
                .Setup(n => n.DispatchAsync(It.IsAny<PublicationSucceeded>(), It.IsAny<CancellationToken>()))
                .Returns(Task.CompletedTask);

            // Act
            await _service.RunAsync(utcNow, CancellationToken.None);

            // Assert
            _publisherPortMock.Verify(p => p.PublishAsync(draftPost1, It.IsAny<CancellationToken>()), Times.Once);
            _publisherPortMock.Verify(p => p.PublishAsync(draftPost2, It.IsAny<CancellationToken>()), Times.Once);

            _uowMock.Verify(u => u.CommitAsync(It.IsAny<CancellationToken>()), Times.Once);

            draftPost1.Status.Should().Be(PostStatus.Published);
            draftPost2.Status.Should().Be(PostStatus.Published);
        }

        [Fact(DisplayName = "RunAsync is a NO-OP when no posts are due to publish")]
        public async Task RunAsync_NoDuePosts_NoCommit()
        {
            // Arrange
            var utcNow = DateTime.UtcNow;

            _postRepositoryMock
                .Setup(r => r.FindScheduledToPublishAsync(utcNow, It.IsAny<CancellationToken>()))
                .ReturnsAsync(Array.Empty<Post>());

            // No calls should be made to publisher/notification/UoW:
            _publisherPortMock.SetupNoOtherCalls();
            _notificationMock.SetupNoOtherCalls();
            _uowMock.SetupNoOtherCalls();

            // Act
            await _service.RunAsync(utcNow, CancellationToken.None);

            // Assert
            _publisherPortMock.Verify(p => p.PublishAsync(It.IsAny<Post>(), It.IsAny<CancellationToken>()), Times.Never);
            _uowMock.Verify(u => u.CommitAsync(It.IsAny<CancellationToken>()), Times.Never);
            _notificationMock.Verify(n => n.DispatchAsync(It.IsAny<IDomainEvent>(), It.IsAny<CancellationToken>()), Times.Never);
        }

        [Fact(DisplayName = "RunAsync rolls back when publisher fails and re-throws")]
        public async Task RunAsync_PublisherFails_RollsBackAndThrows()
        {
            // Arrange
            var utcNow = DateTime.UtcNow;

            var draftPost = Post.CreateDraft("UniqueId-1", "Failing Draft", authorId: "user-456");
            draftPost.SchedulePublication(utcNow.AddMinutes(-30)); // Due

            _postRepositoryMock
                .Setup(r => r.FindScheduledToPublishAsync(utcNow, It.IsAny<CancellationToken>()))
                .ReturnsAsync(new[] { draftPost });

            _publisherPortMock
                .Setup(p => p.PublishAsync(draftPost, It.IsAny<CancellationToken>()))
                .ThrowsAsync(new InvalidOperationException("Unit Test – Simulated failure"));

            _uowMock.Setup(u => u.RollbackAsync(It.IsAny<CancellationToken>()))
                    .Returns(Task.CompletedTask);

            // Act
            Func<Task> act = () => _service.RunAsync(utcNow, CancellationToken.None);

            // Assert
            await act.Should()
                     .ThrowAsync<InvalidOperationException>()
                     .WithMessage("*Simulated failure*");

            _uowMock.Verify(u => u.RollbackAsync(It.IsAny<CancellationToken>()), Times.Once);
        }
    }
}

/* ------------------------------------------------------------------------
 * Minimal domain & service classes needed for compilation ***ONLY***.
 * In the production codebase these live in their own projects. They are
 * duplicated here to keep the test file self-contained for illustrative
 * purposes. In real projects, reference the actual domain assemblies.
 * --------------------------------------------------------------------- */

namespace TempoScribePro.Core.Domain.Blogging
{
    public enum PostStatus { Draft, Scheduled, Published }

    public sealed class Post
    {
        private Post(string id, string title, string authorId)
        {
            Id        = id;
            Title     = title;
            AuthorId  = authorId;
            Status    = PostStatus.Draft;
        }

        public string     Id         { get; }
        public string     Title      { get; private set; }
        public string     AuthorId   { get; }
        public PostStatus Status     { get; private set; }
        public DateTime?  PublishAt  { get; private set; }

        public static Post CreateDraft(string id, string title, string authorId)
            => new Post(id, title, authorId);

        public void SchedulePublication(DateTime utcWhen)
        {
            if (Status != PostStatus.Draft)
                throw new InvalidOperationException("Only draft posts can be scheduled");

            PublishAt = utcWhen;
            Status    = PostStatus.Scheduled;
        }

        public void MarkPublished(DateTime utcNow)
        {
            Status    = PostStatus.Published;
            PublishAt = utcNow;
        }
    }
}

namespace TempoScribePro.Core.Domain.Blogging.Events
{
    public interface IDomainEvent { }

    public sealed class PublicationSucceeded : IDomainEvent
    {
        public PublicationSucceeded(string postId, DateTime publishedUtc)
        {
            PostId       = postId;
            PublishedUtc = publishedUtc;
        }

        public string   PostId       { get; }
        public DateTime PublishedUtc { get; }
    }
}

namespace TempoScribePro.Core.Ports.Repositories
{
    using TempoScribePro.Core.Domain.Blogging;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;

    public interface IPostRepository
    {
        Task<IReadOnlyList<Post>> FindScheduledToPublishAsync(
            DateTime utcNow,
            CancellationToken ct);
    }

    public interface IUnitOfWork
    {
        Task CommitAsync(CancellationToken ct);
        Task RollbackAsync(CancellationToken ct);
    }
}

namespace TempoScribePro.Core.Ports.Services
{
    using TempoScribePro.Core.Domain.Blogging;
    using TempoScribePro.Core.Domain.Blogging.Events;
    using System.Threading;
    using System.Threading.Tasks;

    public interface IPublisherPort
    {
        Task PublishAsync(Post post, CancellationToken ct);
    }

    public interface INotificationDispatcher
    {
        Task DispatchAsync(IDomainEvent @event, CancellationToken ct);
    }
}

namespace TempoScribePro.Core.Services
{
    using TempoScribePro.Core.Domain.Blogging;
    using TempoScribePro.Core.Domain.Blogging.Events;
    using TempoScribePro.Core.Ports.Repositories;
    using TempoScribePro.Core.Ports.Services;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    ///     Application-service responsible for scanning scheduled posts
    ///     and sending them to the publishing adapter when they become due.
    /// </summary>
    public sealed class ScheduledPublishingService
    {
        private readonly IPostRepository         _repository;
        private readonly IPublisherPort          _publisher;
        private readonly IUnitOfWork             _uow;
        private readonly INotificationDispatcher _notifications;

        public ScheduledPublishingService(
            IPostRepository         repository,
            IPublisherPort          publisher,
            IUnitOfWork             uow,
            INotificationDispatcher notifications)
        {
            _repository    = repository;
            _publisher     = publisher;
            _uow           = uow;
            _notifications = notifications;
        }

        public async Task RunAsync(DateTime utcNow, CancellationToken ct)
        {
            // Query phase
            var duePosts = await _repository.FindScheduledToPublishAsync(utcNow, ct);

            if (!duePosts.Any())
                return; // Nothing to do – bail out early for performance.

            try
            {
                // Command phase
                foreach (var post in duePosts)
                {
                    await _publisher.PublishAsync(post, ct);
                    post.MarkPublished(utcNow);

                    await _notifications.DispatchAsync(
                        new PublicationSucceeded(post.Id, utcNow), ct);
                }

                // Commit phase
                await _uow.CommitAsync(ct);
            }
            catch
            {
                await _uow.RollbackAsync(ct);
                throw; // Let the caller's retry / circuit-breaker handle it.
            }
        }
    }
}
```