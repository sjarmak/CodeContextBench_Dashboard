```csharp
// File: tests/test_utils.txt
// Project: TempoScribe Pro – Hexagonal Productivity Blog Suite
// Purpose: Common helpers that make writing unit & integration tests concise and deterministic.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Moq;

namespace TempoScribe.Tests.Common
{
    /// <summary>
    ///     Central factory methods & helpers used across the test suite.
    ///     Each utility is deliberately opinionated for the TempoScribe domain
    ///     but remains free of production-only dependencies.
    /// </summary>
    public static class TestUtils
    {
        /// <summary>
        ///     Creates a new <see cref="PostBuilder"/> pre-populated with sane defaults.
        /// </summary>
        public static PostBuilder Post() => new PostBuilder();

        /// <summary>
        ///     Creates a new <see cref="EditorialTaskBuilder"/> pre-populated with sane defaults.
        /// </summary>
        public static EditorialTaskBuilder EditorialTask() => new EditorialTaskBuilder();

        /// <summary>
        ///     Returns an <see cref="ILogger{T}"/> instance that discards all log messages.
        ///     Useful when the test doesn’t assert on logged output.
        /// </summary>
        public static ILogger<T> NullLogger<T>() => NullLogger<T>.Instance;

        /// <summary>
        ///     Creates a deterministic clock for time-sensitive tests.
        /// </summary>
        public static FakeClock Clock(DateTime? utcSeed = null) => new FakeClock(utcSeed);

        /// <summary>
        ///     Creates a <see cref="CancellationToken"/> that auto-cancels after <paramref name="seconds"/>.
        ///     Extremely handy to prevent tests from hanging indefinitely (e.g. while awaiting tasks).
        /// </summary>
        public static CancellationToken TokenWithTimeout(int seconds = 10)
            => new CancellationTokenSource(TimeSpan.FromSeconds(seconds)).Token;

        /// <summary>
        ///     Polls <paramref name="condition"/> until it returns <c>true</c> or
        ///     <paramref name="timeout"/> elapses. Throws <see cref="TimeoutException"/> in the latter case.
        ///     Intended for async eventually-consistent operations (e.g. waiting for background consumers).
        /// </summary>
        public static async Task WaitUntilAsync(
            Func<bool> condition,
            TimeSpan timeout,
            TimeSpan? pollInterval = null)
        {
            pollInterval ??= TimeSpan.FromMilliseconds(100);
            using var cts = new CancellationTokenSource(timeout);
            while (!condition())
            {
                await Task.Delay(pollInterval.Value, cts.Token).ConfigureAwait(false);
            }
        }

        /// <summary>
        ///     Creates a ready-to-use <see cref="Mock{T}"/> for <see cref="ILogger{T}"/> in a single call.
        /// </summary>
        public static Mock<ILogger<T>> MockLogger<T>() => new Mock<ILogger<T>>();
    }

    #region Fake Clock

    /// <summary>
    ///     Deterministic implementation of TempoScribe’s <c>IDateTimeProvider</c> port.
    ///     Allows tests to advance or freeze time without relying on <see cref="DateTime.UtcNow"/>.
    /// </summary>
    public sealed class FakeClock : IDateTimeProvider
    {
        private DateTime _utcNow;

        public FakeClock(DateTime? utcSeed = null) => _utcNow = utcSeed ?? DateTime.UtcNow;

        public DateTime UtcNow => _utcNow;
        public DateTime Now => _utcNow.ToLocalTime();

        /// <summary>Jumps forward by the specified <paramref name="duration"/>.</summary>
        public void Advance(TimeSpan duration) => _utcNow = _utcNow.Add(duration);

        /// <summary>Sets the clock to an explicit UTC instant.</summary>
        public void Set(DateTime utc) => _utcNow = utc;
    }

    /// <summary>
    ///     Contract used by core domain services that need wall-clock time.
    ///     Placed here to avoid leaking testing infrastructure into production code.
    /// </summary>
    public interface IDateTimeProvider
    {
        DateTime UtcNow { get; }
        DateTime Now { get; }
    }

    #endregion

    #region Entity Builders

    /// <summary>
    ///     Test-friendly builder for <c>Post</c> aggregates.
    ///     Produces immutable snapshots of the entity’s state that can be used for assertions
    ///     (instead of manipulating the real production class, which might contain heavy logic).
    /// </summary>
    public sealed class PostBuilder
    {
        private Guid _id           = Guid.NewGuid();
        private string _title      = "Untitled Post";
        private string _content    = "Lorem ipsum dolor sit amet, consectetur adipiscing elit.";
        private DateTime _created  = DateTime.UtcNow;
        private DateTime? _publish = null;
        private readonly List<string> _tags = new();
        private bool _premium      = false;

        public PostBuilder WithId(Guid id)                          { _id      = id;      return this; }
        public PostBuilder WithTitle(string title)                  { _title   = title;   return this; }
        public PostBuilder WithContent(string content)              { _content = content; return this; }
        public PostBuilder CreatedOn(DateTime utc)                  { _created = utc;     return this; }
        public PostBuilder ScheduledFor(DateTime utc)               { _publish = utc;     return this; }
        public PostBuilder WithTags(params string[] tags)           { _tags.Clear(); _tags.AddRange(tags); return this; }
        public PostBuilder Premium()                                { _premium = true;    return this; }

        /// <summary>
        ///     Builds an immutable snapshot that represents how the post would look in persistence.
        ///     Using a record avoids tight coupling with the domain model.
        /// </summary>
        public PostSnapshot Build()
            => new PostSnapshot(_id, _title, _content, _created, _publish, _tags.ToArray(), _premium);
    }

    /// <summary>Lightweight projection of a Post, used only for assertions in tests.</summary>
    public sealed record PostSnapshot(
        Guid                Id,
        string              Title,
        string              Content,
        DateTime            CreatedOn,
        DateTime?           PublishOn,
        IReadOnlyCollection<string> Tags,
        bool                IsPremium);

    /// <summary>
    ///     Builder for <c>EditorialTask</c> value objects used inside the editorial workflow.
    /// </summary>
    public sealed class EditorialTaskBuilder
    {
        private Guid _id            = Guid.NewGuid();
        private string _description = "Proof-read copy";
        private TaskStatus _status  = TaskStatus.WaitingToRun;
        private DateTime _deadline  = DateTime.UtcNow.AddDays(1);

        public EditorialTaskBuilder WithId(Guid id)               { _id = id;             return this; }
        public EditorialTaskBuilder Describe(string description)  { _description = description; return this; }
        public EditorialTaskBuilder Status(TaskStatus status)     { _status = status;     return this; }
        public EditorialTaskBuilder Deadline(DateTime utc)        { _deadline = utc;      return this; }

        public EditorialTaskSnapshot Build()
            => new EditorialTaskSnapshot(_id, _description, _status, _deadline);
    }

    /// <summary>Projection of an Editorial Task for testing purposes.</summary>
    public sealed record EditorialTaskSnapshot(
        Guid       Id,
        string     Description,
        TaskStatus Status,
        DateTime   Deadline);

    #endregion
}
```