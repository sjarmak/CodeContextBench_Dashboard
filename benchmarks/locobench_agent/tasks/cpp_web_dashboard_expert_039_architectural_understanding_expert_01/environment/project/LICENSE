```cpp
/*
 *  MosaicBoard Studio — License Verification Module
 *
 *  This file is intentionally named “LICENSE” in order to be picked up by
 *  the build system as a source unit that handles runtime license validation.
 *  It is NOT the plain-text license agreement, but rather production code
 *  responsible for enforcing the commercial licensing terms of MosaicBoard Studio.
 *
 *  NOTE:
 *    • Requires OpenSSL (>=1.1.1) and nlohmann/json (header-only, ≥3.9).
 *    • Thread-safe, exception-based error handling.
 *    • This module never stores or exposes the private signing key ― only a
 *      compiled-in public key is shipped with the binary.
 *    • License files are JSON documents carrying an RSA-SHA256 signature.
 */

#include <array>
#include <chrono>
#include <fstream>
#include <mutex>
#include <optional>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/err.h>

#include <nlohmann/json.hpp>

namespace mosaic::security
{
using json   = nlohmann::json;
using Clock  = std::chrono::system_clock;
using String = std::string;

class OpenSSLException : public std::runtime_error
{
public:
    explicit OpenSSLException(const String& msg) : std::runtime_error(msg) {}
};

/*
 *  OpenSSLGuard
 *  ------------
 *  RAII helper that guarantees proper initialization/shutdown of OpenSSL’s
 *  EVP subsystem. It is instantiated once per process.
 */
class OpenSSLGuard
{
public:
    OpenSSLGuard(const OpenSSLGuard&)            = delete;
    OpenSSLGuard& operator=(const OpenSSLGuard&) = delete;

    static OpenSSLGuard& instance()
    {
        static OpenSSLGuard guard;
        return guard;
    }

private:
    OpenSSLGuard()
    {
        /* Initialize OpenSSL algorithms & error strings. */
        if (OPENSSL_init_crypto(0, nullptr) == 0)
        {
            throw OpenSSLException("Failed to initialize OpenSSL");
        }
    }

    ~OpenSSLGuard() noexcept
    {
        /* Let OpenSSL clean itself up */
        EVP_cleanup();
        ERR_free_strings();
    }
};

/*
 *  License
 *  -------
 *  Immutable representation of a verified license.
 */
struct License
{
    String                          holder;
    std::chrono::system_clock::time_point expires;
    std::set<String>                features;
    String                          rawJson;

    [[nodiscard]] bool hasFeature(const String& f) const noexcept
    {
        return features.count(f) > 0;
    }

    [[nodiscard]] bool isExpired() const noexcept
    {
        return Clock::now() > expires;
    }
};

/*
 *  LicenseManager
 *  --------------
 *  Loads, verifies and caches the user’s license at runtime.
 */
class LicenseManager
{
public:
    explicit LicenseManager(String licenseFilePath)
        : m_licensePath{std::move(licenseFilePath)}
    {
        OpenSSLGuard::instance(); // ensure OpenSSL ready
    }

    /*
     *  getLicense()
     *  ------------
     *  Returns a verified license instance. Will lazily load & cache the file.
     *  Thread-safe.
     */
    const License& getLicense()
    {
        std::lock_guard<std::mutex> lock(m_mutex);

        if (!m_cachedLicense.has_value())
        {
            m_cachedLicense = loadAndVerify(m_licensePath);
        }
        return *m_cachedLicense;
    }

    /*
     *  invalidateCache()
     *  -----------------
     *  Call this when the on-disk license might have changed. A subsequent
     *  getLicense() will reload the file.
     */
    void invalidateCache()
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_cachedLicense.reset();
    }

private:
    static constexpr const char* PUBLIC_KEY_PEM =
        "-----BEGIN PUBLIC KEY-----\n"
        /* 2048-bit RSA public key (shortened for brevity) */
        "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwXBmVaIYxLVlV2jQyLil\n"
        "bGt1MyNw2ifBfMFrnJvWVd3ZzW7J8C+9609WnsX6r42rgA5g4YkjkSXRWt0L3UeP\n"
        "tUcm8U1nICoJ3O1vmHYjKe+zak5y7c2Qz75C8zbv6YEKDbcR2XgjaSyF3O6iTWXC\n"
        "6BbOGleJo66c7NbKYtq0lNxQhOzygP8pwG8HgD6vCL9ITRAcl5DW08roIBuEFg8m\n"
        "6uhUy8hZRu3FpFywBhfhK+OzF9eG3+ZJy+1RKDMW/UehdKmrkO5YFStQX7SVom1Y\n"
        "9T7OLUPnW6C6e3z6gjBfmxueZMloTBi6HJDaG3fbCIzAvDIpIb1C9I/8pOq//x0Q\n"
        "wQIDAQAB\n"
        "-----END PUBLIC KEY-----\n";

    static json readJsonFile(const String& path)
    {
        std::ifstream in(path, std::ios::binary);
        if (!in)
        {
            throw std::runtime_error("License file not found: " + path);
        }

        std::ostringstream ss;
        ss << in.rdbuf();
        try
        {
            return json::parse(ss.str());
        }
        catch (const json::parse_error& e)
        {
            throw std::runtime_error("Malformed license JSON: " + String(e.what()));
        }
    }

    static std::vector<uint8_t> base64Decode(const String& b64)
    {
        BIO* bio = BIO_new_mem_buf(b64.data(), static_cast<int>(b64.size()));
        BIO* b64f = BIO_new(BIO_f_base64());
        BIO_set_flags(b64f, BIO_FLAGS_BASE64_NO_NL);
        bio = BIO_push(b64f, bio);

        std::vector<uint8_t> buffer(b64.size()); // upper bound
        int                   len = BIO_read(bio, buffer.data(), static_cast<int>(buffer.size()));
        BIO_free_all(bio);

        if (len <= 0)
        {
            throw OpenSSLException("Base64 decode failed");
        }
        buffer.resize(static_cast<size_t>(len));
        return buffer;
    }

    static EVP_PKEY* loadPublicKey()
    {
        BIO* mem = BIO_new_mem_buf(PUBLIC_KEY_PEM, -1);
        if (!mem)
            throw OpenSSLException("Failed to allocate BIO for public key");

        EVP_PKEY* pkey = PEM_read_bio_PUBKEY(mem, nullptr, nullptr, nullptr);
        BIO_free(mem);

        if (!pkey)
            throw OpenSSLException("Unable to parse public RSA key");

        return pkey;
    }

    static void verifySignature(const json& doc)
    {
        // Extract payload and signature
        if (!doc.contains("signature") || !doc["signature"].is_string())
        {
            throw std::runtime_error("License JSON missing 'signature' field");
        }

        String b64sig = doc["signature"].get<String>();

        // Re-create canonical payload (all fields except 'signature')
        json payload = doc;
        payload.erase("signature");
        String payloadStr = payload.dump();

        std::vector<uint8_t> sigBytes = base64Decode(b64sig);
        std::unique_ptr<EVP_PKEY, decltype(&EVP_PKEY_free)> pkey(loadPublicKey(), &EVP_PKEY_free);

        EVP_MD_CTX* ctx = EVP_MD_CTX_new();
        if (!ctx)
            throw OpenSSLException("EVP_MD_CTX_new failed");

        auto ctxGuard = std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)>(ctx, &EVP_MD_CTX_free);

        if (EVP_DigestVerifyInit(ctx, nullptr, EVP_sha256(), nullptr, pkey.get()) <= 0)
        {
            throw OpenSSLException("EVP_DigestVerifyInit failed");
        }

        if (EVP_DigestVerifyUpdate(ctx, payloadStr.data(), payloadStr.size()) <= 0)
        {
            throw OpenSSLException("EVP_DigestVerifyUpdate failed");
        }

        int rc = EVP_DigestVerifyFinal(ctx, sigBytes.data(), sigBytes.size());
        if (rc != 1)
        {
            throw std::runtime_error("Invalid license signature");
        }
        /* Success – license verified */
    }

    static License parseLicense(const json& doc)
    {
        License lic;
        lic.rawJson = doc.dump();

        if (!doc.contains("holder") || !doc["holder"].is_string())
            throw std::runtime_error("License field 'holder' missing or invalid");
        lic.holder = doc["holder"].get<String>();

        if (!doc.contains("expires") || !doc["expires"].is_string())
            throw std::runtime_error("License field 'expires' missing or invalid");

        std::tm tm{};
        std::istringstream ss(doc["expires"].get<String>());
        ss >> std::get_time(&tm, "%Y-%m-%dT%H:%M:%SZ");
        if (ss.fail())
            throw std::runtime_error("License 'expires' timestamp format invalid");

        lic.expires = Clock::from_time_t(timegm(&tm));

        if (doc.contains("features") && doc["features"].is_array())
        {
            for (const auto& feat : doc["features"])
                lic.features.insert(feat.get<String>());
        }

        return lic;
    }

    static License loadAndVerify(const String& path)
    {
        json doc = readJsonFile(path);
        verifySignature(doc);
        License lic = parseLicense(doc);

        if (lic.isExpired())
            throw std::runtime_error("License has expired");

        return lic;
    }

private:
    String                      m_licensePath;
    std::optional<License>      m_cachedLicense;
    std::mutex                  m_mutex;
};

} // namespace mosaic::security

/*
 *  Example usage (not compiled by default):
 *
 *      #include "LICENSE" // yes, include this very file
 *
 *      int main() {
 *          try {
 *              mosaic::security::LicenseManager mgr("/etc/mosaicboard/license.json");
 *              const auto& lic = mgr.getLicense();
 *
 *              if (lic.hasFeature("generative_art"))
 *                  enableGenerativeArt();
 *          } catch (const std::exception& ex) {
 *              std::cerr << "License error: " << ex.what() << '\n';
 *              return EXIT_FAILURE;
 *          }
 *          runDashboard();
 *      }
 */
```