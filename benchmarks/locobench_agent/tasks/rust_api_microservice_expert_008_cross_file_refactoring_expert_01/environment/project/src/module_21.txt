```rust
//! src/module_21.rs
//!
//! LedgerLink Nexus – Module 21  
//! High-level, paginated query service for Ledger Entries with
//! • request validation,
//! • authentication/tenant isolation,
//! • response-level caching, and  
//! • rich tracing-enabled logging.
//!
//! Production-grade example demonstrating the service-layer patterns that power
//! large-scale, multi-tenant financial reconciliation workloads.

#![allow(clippy::module_name_repetitions)]

use std::sync::Arc;
use std::time::Duration;

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use moka::future::Cache; // fast, async-aware in-mem cache
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::sync::RwLock;
use tracing::{debug, error, info, instrument};
use uuid::Uuid;
use validator::{Validate, ValidationError};

///
/// Public re-exports so that consumers can `use ledgerlink_nexus::module_21::*`.
///
pub use model::{LedgerEntry, LedgerEntryId};
pub use service::{LedgerEntryQueryService, LedgerEntryQueryServiceImpl, QueryPage};

/// ------------------------------------------------------------
/// Domain model slice
/// ------------------------------------------------------------
mod model {
    use chrono::{DateTime, Utc};
    use serde::{Deserialize, Serialize};
    use uuid::Uuid;

    pub type LedgerEntryId = Uuid;

    /// Domain-level ledger entry as stored in PostgreSQL.
    #[derive(Clone, Debug, Serialize, Deserialize)]
    pub struct LedgerEntry {
        pub id: LedgerEntryId,
        pub tenant_id: Uuid,
        pub account_id: Uuid,
        pub amount_minor: i64,
        pub currency: String,
        pub booked_at: DateTime<Utc>,
        pub description: String,
        pub created_at: DateTime<Utc>,
        pub updated_at: DateTime<Utc>,
        // ... lots of fiscal audit fields stripped for brevity
    }
}

/// ------------------------------------------------------------
/// Data transfer / View-Model
/// ------------------------------------------------------------
mod dto {
    use super::model::LedgerEntry;
    use chrono::{DateTime, Utc};
    use serde::{Deserialize, Serialize};
    use uuid::Uuid;

    /// View-Model exposed to API consumers.  
    /// Does NOT leak internal fields like `tenant_id`, etc.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct LedgerEntryViewModel {
        pub id: Uuid,
        pub account_id: Uuid,
        pub amount_minor: i64,
        pub currency: String,
        pub booked_at: DateTime<Utc>,
        pub description: String,
    }

    impl From<LedgerEntry> for LedgerEntryViewModel {
        fn from(entity: LedgerEntry) -> Self {
            Self {
                id: entity.id,
                account_id: entity.account_id,
                amount_minor: entity.amount_minor,
                currency: entity.currency,
                booked_at: entity.booked_at,
                description: entity.description,
            }
        }
    }
}

/// ------------------------------------------------------------
/// Repository ‑ abstracted DB access (PostgreSQL).
/// ------------------------------------------------------------
#[async_trait]
pub trait LedgerEntryRepository: Send + Sync {
    async fn find_by_tenant_paginated(
        &self,
        tenant_id: Uuid,
        account_id: Option<Uuid>,
        cursor: Option<DateTime<Utc>>,
        limit: u16,
    ) -> Result<Vec<model::LedgerEntry>, ServiceError>;
}

/// ------------------------------------------------------------
/// Context – propagated per request (authentication, tracing, …)
/// ------------------------------------------------------------
#[derive(Clone, Debug)]
pub struct RequestContext {
    pub tenant_id: Uuid,
    pub user_id: Uuid,
    pub request_id: Uuid,
}

/// ------------------------------------------------------------
/// Query parameters + validation
/// ------------------------------------------------------------
#[derive(Debug, Deserialize, Validate, Clone)]
pub struct QueryPage {
    /// Optional account filtering
    #[validate(custom = "uuid_or_empty")]
    pub account_id: Option<String>,

    /// Pagination cursor – encoded as RFC3339 date string
    #[validate(custom = "rfc3339_or_empty")]
    pub cursor: Option<String>,

    /// Items per page (1…250)
    #[validate(range(min = 1, max = 250))]
    pub limit: Option<u16>,
}

// custom validators ----------------------------------------------------------

fn uuid_or_empty(v: &str) -> Result<(), ValidationError> {
    if v.is_empty() || Uuid::parse_str(v).is_ok() {
        Ok(())
    } else {
        Err(ValidationError::new("invalid_uuid"))
    }
}

fn rfc3339_or_empty(v: &str) -> Result<(), ValidationError> {
    if v.is_empty() || DateTime::parse_from_rfc3339(v).is_ok() {
        Ok(())
    } else {
        Err(ValidationError::new("invalid_rfc3339"))
    }
}

/// Strongly-typed, validated page after conversion
#[derive(Debug)]
struct PageInternal {
    account_id: Option<Uuid>,
    cursor: Option<DateTime<Utc>>,
    limit: u16,
}

impl TryFrom<QueryPage> for PageInternal {
    type Error = ServiceError;
    fn try_from(value: QueryPage) -> Result<Self, Self::Error> {
        value.validate()?;
        let page = Self {
            account_id: value
                .account_id
                .as_deref()
                .map(Uuid::parse_str)
                .transpose()
                .map_err(|_| ServiceError::Validation("account_id must be a UUID".into()))?,
            cursor: value
                .cursor
                .as_deref()
                .map(|s| DateTime::parse_from_rfc3339(s).map(|dt| dt.with_timezone(&Utc)))
                .transpose()
                .map_err(|_| ServiceError::Validation("cursor must be RFC3339 timestamp".into()))?,
            limit: value.limit.unwrap_or(100),
        };
        Ok(page)
    }
}

/// ------------------------------------------------------------
/// Service error envelope
/// ------------------------------------------------------------
#[derive(Debug, Error)]
pub enum ServiceError {
    #[error("validation error: {0}")]
    Validation(String),

    #[error("access denied")]
    AccessDenied,

    #[error(transparent)]
    Repository(#[from] anyhow::Error),

    #[error("internal error")]
    Internal,
}

/// ------------------------------------------------------------
/// Service layer implementation
/// ------------------------------------------------------------
mod service {
    use super::*;
    use crate::module_21::dto::LedgerEntryViewModel;

    /// Async caching layer: key -> JSON blob.
    ///
    /// For demo-purposes we keep it in-memory; in production this is backed by
    /// distributed Redis w/ TTL + replication.
    type ResponseCache =
        Cache<String, Arc<Vec<LedgerEntryViewModel>>>; // `Arc` to prevent cloning

    /// Trait to make service easily mockable in unit-tests.
    #[async_trait]
    pub trait LedgerEntryQueryService: Send + Sync {
        async fn list_entries(
            &self,
            ctx: RequestContext,
            params: QueryPage,
        ) -> Result<Vec<LedgerEntryViewModel>, ServiceError>;
    }

    /// Concrete implementation
    pub struct LedgerEntryQueryServiceImpl<R: LedgerEntryRepository> {
        repo: Arc<R>,
        cache: ResponseCache,
        /// TTL for cache items
        cache_ttl: Duration,
        /// Feature toggle for read-though caching (e.g. disabled for GDPR purge)
        enable_cache: bool,
    }

    impl<R: LedgerEntryRepository> LedgerEntryQueryServiceImpl<R> {
        pub fn new(repo: Arc<R>, enable_cache: bool) -> Self {
            Self {
                repo,
                cache: Cache::builder()
                    .max_capacity(10_000)
                    .time_to_live(Duration::from_secs(30)) // default; may be overridden
                    .build(),
                cache_ttl: Duration::from_secs(30),
                enable_cache,
            }
        }

        /// Deterministically derive a cache key from request params + tenant id.
        fn build_cache_key(tenant: Uuid, page: &PageInternal) -> String {
            let account = page
                .account_id
                .map_or("none".into(), |u| u.to_string());
            let cursor = page
                .cursor
                .map_or("none".into(), |c| c.timestamp_micros().to_string());
            format!("{tenant}-{account}-{cursor}-{}", page.limit)
        }
    }

    #[async_trait]
    impl<R: LedgerEntryRepository> LedgerEntryQueryService for LedgerEntryQueryServiceImpl<R> {
        #[instrument(level = "info", skip_all, fields(tenant=%ctx.tenant_id, user=%ctx.user_id, request=%ctx.request_id))]
        async fn list_entries(
            &self,
            ctx: RequestContext,
            params: QueryPage,
        ) -> Result<Vec<LedgerEntryViewModel>, ServiceError> {
            // -- AuthZ check --------------------------------------------------
            if ctx.tenant_id.is_nil() {
                return Err(ServiceError::AccessDenied);
            }

            // -- Validate & normalize params ----------------------------------
            let page_internal = PageInternal::try_from(params)?;

            // Check cache first
            let cache_key = Self::build_cache_key(ctx.tenant_id, &page_internal);
            if self.enable_cache {
                if let Some(cached) = self.cache.get(&cache_key) {
                    debug!("cache hit for key={cache_key}");
                    return Ok((*cached).clone()); // shallow clone (Arc inside)
                }
            }

            // -- Query repository ---------------------------------------------
            debug!(
                "cache miss for key={cache_key}, querying repository (limit={})",
                page_internal.limit
            );

            let rows = self
                .repo
                .find_by_tenant_paginated(
                    ctx.tenant_id,
                    page_internal.account_id,
                    page_internal.cursor,
                    page_internal.limit,
                )
                .await
                .map_err(ServiceError::Repository)?;

            // Convert into view-models
            let vms: Vec<LedgerEntryViewModel> =
                rows.into_iter().map(Into::into).collect();

            // Store in cache
            if self.enable_cache {
                let ttl = self.cache_ttl;
                self.cache
                    .insert(cache_key, Arc::new(vms.clone()))
                    .await;
                self.cache
                    .expire_after(&cache_key, ttl)
                    .await;
            }

            info!("returning {} ledger entries", vms.len());
            Ok(vms)
        }
    }
}

/// ------------------------------------------------------------
/// Mock repository (dev/test only) – feature-gated
/// ------------------------------------------------------------
#[cfg(any(test, feature = "mocks"))]
mod mocks {
    use super::*;
    use rand::{rngs::StdRng, Rng, SeedableRng};

    pub struct MockLedgerEntryRepository {
        data: Arc<RwLock<Vec<model::LedgerEntry>>>,
    }

    impl MockLedgerEntryRepository {
        pub fn seeded(seed: u64) -> Self {
            let mut rng = StdRng::seed_from_u64(seed);
            let mut data = Vec::new();
            for _ in 0..10_000 {
                let tenant_id = Uuid::new_v4();
                data.push(model::LedgerEntry {
                    id: Uuid::new_v4(),
                    tenant_id,
                    account_id: Uuid::new_v4(),
                    amount_minor: rng.gen_range(-1_000_000..=1_000_000),
                    currency: "USD".into(),
                    booked_at: Utc::now(),
                    description: "mock entry".into(),
                    created_at: Utc::now(),
                    updated_at: Utc::now(),
                });
            }
            Self {
                data: Arc::new(RwLock::new(data)),
            }
        }
    }

    #[async_trait]
    impl LedgerEntryRepository for MockLedgerEntryRepository {
        async fn find_by_tenant_paginated(
            &self,
            tenant_id: Uuid,
            account_id: Option<Uuid>,
            cursor: Option<DateTime<Utc>>,
            limit: u16,
        ) -> Result<Vec<model::LedgerEntry>, ServiceError> {
            let rd = self.data.read().await;
            let mut items: Vec<_> = rd
                .iter()
                .filter(|e| e.tenant_id == tenant_id)
                .filter(|e| account_id.map_or(true, |acc| acc == e.account_id))
                .filter(|e| cursor.map_or(true, |c| e.booked_at <= c))
                .cloned()
                .collect();

            items.sort_by_key(|e| std::cmp::Reverse(e.booked_at));
            items.truncate(limit as usize);
            Ok(items)
        }
    }

    #[tokio::test]
    async fn service_smoke_test() {
        use super::service::{LedgerEntryQueryServiceImpl, LedgerEntryQueryService};
        let repo = Arc::new(MockLedgerEntryRepository::seeded(42));
        let svc = LedgerEntryQueryServiceImpl::new(repo, true);
        let ctx = RequestContext {
            tenant_id: repo.data.read().await[0].tenant_id,
            user_id: Uuid::new_v4(),
            request_id: Uuid::new_v4(),
        };
        let params = QueryPage {
            account_id: None,
            cursor: None,
            limit: Some(10),
        };
        let res = svc.list_entries(ctx.clone(), params.clone()).await.unwrap();
        assert_eq!(res.len(), 10);

        // second request should be cached
        let _ = svc.list_entries(ctx, params).await.unwrap();
    }
}
```