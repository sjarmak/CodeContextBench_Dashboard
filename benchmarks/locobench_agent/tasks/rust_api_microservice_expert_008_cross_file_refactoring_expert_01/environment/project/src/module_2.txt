```rust
// src/module_2.rs
//
// LedgerLink Nexus – Ledger Entry Query Module
//
// This module exposes a thin, MVVM-style Query Service for retrieving
// ledger entries with first-class pagination, validation and response-
// caching hints.  The service is intentionally decoupled from transport
// (REST / GraphQL) concerns and can be wired into either.
//
// Dependencies expected in `Cargo.toml`:
//
// tracing          = "0.1"
// async-trait      = "0.1"
// serde            = { version = "1.0", features = ["derive"] }
// serde_json       = "1.0"
// validator        = { version = "0.16", features = ["derive"] }
// thiserror        = "1.0"
// chrono           = { version = "0.4", features = ["serde"] }
// tokio            = { version = "1", features = ["rt-multi-thread", "macros"] }

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, sync::Arc, time::Duration};
use thiserror::Error;
use tracing::{debug, instrument};
use validator::Validate;

/// A domain entity representing a ledger entry in the accounting system.
#[derive(Clone, Debug, Serialize)]
pub struct LedgerEntry {
    pub id: String,
    pub account_id: String,
    pub amount: f64,
    pub currency: String,
    pub booked_at: DateTime<Utc>,
    pub status: LedgerStatus,
}

#[derive(Clone, Debug, Serialize)]
pub enum LedgerStatus {
    Pending,
    Cleared,
    Voided,
}

/// Filter parameters accepted by the list query.
///
/// Every field is optional and validated before hitting persistence.
#[derive(Debug, Deserialize, Validate)]
pub struct LedgerEntryFilter {
    /// Only return entries for this account id.
    #[validate(length(min = 1, max = 64))]
    #[serde(default)]
    pub account_id: Option<String>,

    /// Only return entries with this status.
    #[serde(default)]
    pub status: Option<LedgerStatus>,

    /// Entries booked after this date/time.
    #[serde(default)]
    pub from: Option<DateTime<Utc>>,

    /// Entries booked before this date/time.
    #[serde(default)]
    pub until: Option<DateTime<Utc>>,
}

/// Standard pagination envelope for incoming requests.
#[derive(Debug, Deserialize, Validate)]
pub struct Pagination {
    #[validate(range(min = 1, max = 10_000))]
    pub per_page: u64,

    #[validate(range(min = 1))]
    pub page: u64,
}

/// Hint to the API layer about how long the response could be cached.
///
/// The gateway (or GraphQL engine) can decide to override or respect this hint.
#[derive(Clone, Debug, Serialize)]
pub struct CacheHint {
    pub ttl: Duration,
    pub scope: CacheScope,
}

#[derive(Clone, Debug, Serialize)]
pub enum CacheScope {
    Private,
    Public,
}

/// Wrapper returned to the transport layer: domain data + metadata.
#[derive(Debug, Serialize)]
pub struct PaginatedLedgerEntryView {
    pub entries: Vec<LedgerEntryView>,
    pub page: u64,
    pub per_page: u64,
    pub total: u64,
    pub cache_hint: CacheHint,
}

/// Transport-safe representation of a ledger entry.
///
/// Keeping this separate from `LedgerEntry` allows forward compatibility
/// and internal refactors without breaking the public contract.
#[derive(Debug, Serialize)]
pub struct LedgerEntryView {
    pub id: String,
    pub account_id: String,
    pub amount: String,   // Formatted string e.g., "123.45 USD"
    pub booked_at: DateTime<Utc>,
    pub status: LedgerStatus,
}

impl From<LedgerEntry> for LedgerEntryView {
    fn from(le: LedgerEntry) -> Self {
        Self {
            id: le.id,
            account_id: le.account_id,
            amount: format!("{:.2} {}", le.amount, le.currency),
            booked_at: le.booked_at,
            status: le.status,
        }
    }
}

/// Repository errors bubbled up from the persistence layer.
#[derive(Error, Debug)]
pub enum RepositoryError {
    #[error("database connection unavailable")]
    ConnectionUnavailable,
    #[error("query failed: {0}")]
    QueryFailed(String),
    #[error("internal error: {0}")]
    Internal(String),
}

/// Contract for data retrieval.
///
/// A concrete implementation sits in another crate / module
/// (e.g. Postgres, Redis, etc.).  This trait is mocked in memory for
/// unit testing below.
#[async_trait]
pub trait LedgerEntryRepository: Send + Sync {
    async fn fetch_entries(
        &self,
        filter: LedgerEntryFilter,
        offset: u64,
        limit: u64,
    ) -> Result<(Vec<LedgerEntry>, u64), RepositoryError>;
}

/// Domain-agnostic error envelope returned by service methods.
#[derive(Error, Debug)]
pub enum ServiceError {
    #[error("validation failed: {0}")]
    Validation(String),
    #[error("repository error: {0}")]
    Repository(#[from] RepositoryError),
}

/// Query service used by controllers / resolvers.
#[derive(Clone)]
pub struct LedgerEntryQueryService<R: LedgerEntryRepository> {
    repo: Arc<R>,
    default_ttl: Duration,
}

impl<R> LedgerEntryQueryService<R>
where
    R: LedgerEntryRepository + 'static,
{
    pub fn new(repo: Arc<R>, default_ttl: Duration) -> Self {
        Self { repo, default_ttl }
    }

    /// List ledger entries with pagination and cache hint generation.
    #[instrument(skip(self))]
    pub async fn list(
        &self,
        filter: LedgerEntryFilter,
        pagination: Pagination,
    ) -> Result<PaginatedLedgerEntryView, ServiceError> {
        // Validate inputs before proceeding.
        filter
            .validate()
            .map_err(|e| ServiceError::Validation(e.to_string()))?;
        pagination
            .validate()
            .map_err(|e| ServiceError::Validation(e.to_string()))?;

        let offset = (pagination.page - 1) * pagination.per_page;
        let limit = pagination.per_page;

        debug!(
            ?filter,
            page = pagination.page,
            per_page = pagination.per_page,
            "Fetching paginated ledger entries"
        );

        let (entries, total) = self
            .repo
            .fetch_entries(filter, offset, limit)
            .await
            .map_err(ServiceError::from)?;

        let view_entries: Vec<LedgerEntryView> =
            entries.into_iter().map(LedgerEntryView::from).collect();

        Ok(PaginatedLedgerEntryView {
            entries: view_entries,
            page: pagination.page,
            per_page: pagination.per_page,
            total,
            cache_hint: CacheHint {
                ttl: self.default_ttl,
                scope: CacheScope::Private,
            },
        })
    }
}

/* --------------------------------------------------------------------------
   In-memory repository implementation for local testing / examples.
   -------------------------------------------------------------------------- */

/// Simple, non-persistent repository using a Vec and HashMap.
///
/// NOTE: This is *NOT* suitable for production.
pub struct InMemoryLedgerEntryRepo {
    by_account: HashMap<String, Vec<LedgerEntry>>,
}

impl InMemoryLedgerEntryRepo {
    pub fn new(seed: Vec<LedgerEntry>) -> Self {
        let mut by_account: HashMap<String, Vec<LedgerEntry>> = HashMap::new();
        for entry in seed {
            by_account
                .entry(entry.account_id.clone())
                .or_default()
                .push(entry);
        }
        Self { by_account }
    }
}

#[async_trait]
impl LedgerEntryRepository for InMemoryLedgerEntryRepo {
    async fn fetch_entries(
        &self,
        filter: LedgerEntryFilter,
        offset: u64,
        limit: u64,
    ) -> Result<(Vec<LedgerEntry>, u64), RepositoryError> {
        let mut collected: Vec<LedgerEntry> = Vec::new();

        // Naïve scan – good enough for a mock.
        for entries in self.by_account.values() {
            collected.extend(entries.iter().cloned());
        }

        // Apply filter predicates.
        let filtered: Vec<LedgerEntry> = collected
            .into_iter()
            .filter(|e| {
                filter
                    .account_id
                    .as_ref()
                    .map_or(true, |acc| &e.account_id == acc)
            })
            .filter(|e| filter.status.as_ref().map_or(true, |s| &e.status == s))
            .filter(|e| filter.from.map_or(true, |from| e.booked_at >= from))
            .filter(|e| filter.until.map_or(true, |until| e.booked_at <= until))
            .collect();

        let total = filtered.len() as u64;
        let page_slice = filtered
            .into_iter()
            .skip(offset as usize)
            .take(limit as usize)
            .collect();

        Ok((page_slice, total))
    }
}

/* --------------------------------------------------------------------------
   Unit-tests exercising the query service contract.
   -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::TimeZone;
    use tokio::runtime::Runtime;

    fn seed_entries() -> Vec<LedgerEntry> {
        vec![
            LedgerEntry {
                id: "1".into(),
                account_id: "A-123".into(),
                amount: 100.0,
                currency: "USD".into(),
                booked_at: Utc.timestamp_opt(1_680_000_000, 0).unwrap(),
                status: LedgerStatus::Pending,
            },
            LedgerEntry {
                id: "2".into(),
                account_id: "A-123".into(),
                amount: 200.0,
                currency: "USD".into(),
                booked_at: Utc.timestamp_opt(1_680_100_000, 0).unwrap(),
                status: LedgerStatus::Cleared,
            },
            LedgerEntry {
                id: "3".into(),
                account_id: "B-456".into(),
                amount: 300.0,
                currency: "EUR".into(),
                booked_at: Utc.timestamp_opt(1_680_200_000, 0).unwrap(),
                status: LedgerStatus::Cleared,
            },
        ]
    }

    #[test]
    fn test_pagination() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let repo = Arc::new(InMemoryLedgerEntryRepo::new(seed_entries()));
            let service = LedgerEntryQueryService::new(repo, Duration::from_secs(60));

            let filter = LedgerEntryFilter {
                account_id: Some("A-123".into()),
                status: None,
                from: None,
                until: None,
            };
            let pagination = Pagination { page: 1, per_page: 1 };

            let result = service.list(filter, pagination).await.unwrap();

            assert_eq!(result.entries.len(), 1);
            assert_eq!(result.total, 2);
            assert_eq!(result.page, 1);
            assert_eq!(result.per_page, 1);
        });
    }
}
```