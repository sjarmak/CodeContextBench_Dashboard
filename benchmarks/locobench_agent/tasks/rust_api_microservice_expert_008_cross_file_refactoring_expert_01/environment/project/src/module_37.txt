```rust
//! src/module_37.rs
//! -----------------------------------------------------------------------------
//! LedgerLink Nexus – Pagination + Repository module
//! -----------------------------------------------------------------------------
//!
//! This file contains the following building blocks:
//! 1. A generic, fully-featured pagination helper including:
//!    - Input validation
//!    - Offset/limit translation
//!    - Next/prev cursor calculation
//! 2. A cache-hint envelope that surfaces freshness & ETag metadata to callers.
//! 3. A small LedgerEntry repository implementation showcasing how the service
//!    layer consumes the pagination helper when querying PostgreSQL via `sqlx`.
//!
//! The code purposefully focuses on realistic production needs: proper error
//! handling, typed DTOs, tracing instrumentation, and idiomatic async Rust.
//!
//! -----------------------------------------------------------------------------
//! Public API surface
//! -----------------------------------------------------------------------------
//!   use module_37::pagination::{Pagination, Paginated};
//!   use module_37::repository::{LedgerEntryRepository, PgLedgerEntryRepository};
//!
//! -----------------------------------------------------------------------------
//! Crate‐level dependencies (add to Cargo.toml)
//! -----------------------------------------------------------------------------
//! [dependencies]
//! serde         = { version = "1", features = ["derive"] }
//! serde_json    = "1"
//! validator     = { version = "0.16", features = ["derive"] }
//! chrono        = { version = "0.4", default-features = false, features = ["std"] }
//! uuid          = { version = "1", features = ["serde", "v4"] }
//! sqlx          = { version = "0.7", default-features = false, features = ["runtime-tokio", "postgres", "chrono", "uuid"] }
//! thiserror     = "1"
//! tracing       = "0.1"
//! sha2          = "0.10"
//!
//! -- dev-dependencies
//! tokio         = { version = "1", features = ["macros", "rt-multi-thread", "time"] }
//!
//! -----------------------------------------------------------------------------
#![allow(clippy::module_name_repetitions)]

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::fmt;
use thiserror::Error;
use uuid::Uuid;

// -------------- Pagination Module --------------------------------------------------------------
pub mod pagination {
    use super::*;

    // -------- Errors ---------------------------------------------------------------------------
    #[derive(Debug, Error)]
    pub enum PaginationError {
        #[error("page index must start at 1")]
        PageIndexOutOfRange,
        #[error("per_page must be in the range 1..={0}")]
        PerPageOutOfRange(u32),
    }

    // -------- Pagination Parameters ------------------------------------------------------------
    #[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
    #[serde(rename_all = "camelCase")]
    pub struct Pagination {
        /// 1-based index of the page to retrieve.
        pub page: u32,

        /// Number of items per page.
        pub per_page: u32,
    }

    impl Pagination {
        pub const MAX_PER_PAGE: u32 = 500;
        pub const DEFAULT_PER_PAGE: u32 = 50;

        /// Creates a new Pagination, validating bounds and applying defaults.
        pub fn new(page: Option<u32>, per_page: Option<u32>) -> Result<Self, PaginationError> {
            let page = page.unwrap_or(1);
            if page == 0 {
                return Err(PaginationError::PageIndexOutOfRange);
            }

            let per_page = per_page.unwrap_or(Self::DEFAULT_PER_PAGE);
            if !(1..=Self::MAX_PER_PAGE).contains(&per_page) {
                return Err(PaginationError::PerPageOutOfRange(Self::MAX_PER_PAGE));
            }

            Ok(Self { page, per_page })
        }

        /// Calculate SQL offset from current pagination parameters.
        #[inline]
        pub const fn offset(self) -> u64 {
            (self.page.saturating_sub(1) * self.per_page) as u64
        }

        /// SQL LIMIT counterpart.
        #[inline]
        pub const fn limit(self) -> u64 {
            self.per_page as u64
        }
    }

    // -------- Response Metadata ---------------------------------------------------------------
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    #[serde(rename_all = "camelCase")]
    pub struct PaginationMetadata {
        pub page: u32,
        pub per_page: u32,
        pub total_pages: u32,
        pub total_items: u64,
        pub next_page: Option<u32>,
        pub prev_page: Option<u32>,
    }

    impl PaginationMetadata {
        #[must_use]
        pub fn new(paging: Pagination, total_items: u64) -> Self {
            let total_pages = ((total_items + paging.per_page as u64 - 1) / paging.per_page as u64)
                .max(1) as u32;

            let next_page = if paging.page < total_pages {
                Some(paging.page + 1)
            } else {
                None
            };

            let prev_page = if paging.page > 1 {
                Some(paging.page - 1)
            } else {
                None
            };

            Self {
                page: paging.page,
                per_page: paging.per_page,
                total_pages,
                total_items,
                next_page,
                prev_page,
            }
        }
    }

    // -------- Cache Hint Envelope --------------------------------------------------------------
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CacheHint {
        /// An RFC 7232 strong validator for the resource.
        pub etag: String,

        /// Timestamp when the payload was generated.
        pub generated_at: DateTime<Utc>,

        /// Suggested client-side TTL in seconds.
        pub suggested_ttl: u32,
    }

    impl CacheHint {
        pub fn new(payload: &str, suggested_ttl: u32) -> Self {
            // NOTE: For performance we hash the JSON string. In a real system
            // you may prefer a more elaborate strategy (e.g., version + hash).
            let mut hasher = Sha256::new();
            hasher.update(payload);
            let etag = format!("{:x}", hasher.finalize());

            Self {
                etag,
                generated_at: Utc::now(),
                suggested_ttl,
            }
        }
    }

    // -------- Paginated Wrapper ---------------------------------------------------------------
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Paginated<T> {
        pub data: Vec<T>,
        pub pagination: PaginationMetadata,
        pub cache: CacheHint,
    }

    impl<T: Serialize> Paginated<T> {
        /// Creates a paginated response, calculating an ETag from the serialized payload.
        ///
        /// # Errors
        ///
        /// Returns `serde_json::Error` if serialization of `data` fails (should
        /// not happen for well-formed DTOs).
        pub fn build(
            data: Vec<T>,
            paging: Pagination,
            total_items: u64,
            suggested_ttl: u32,
        ) -> Result<Self, serde_json::Error> {
            // Build metadata first (cheap & infallible)
            let meta = PaginationMetadata::new(paging, total_items);

            // Pre-serialize payload to create a stable ETag.
            let payload_json = serde_json::to_string(&data)?;

            let cache = CacheHint::new(&payload_json, suggested_ttl);

            Ok(Self {
                data,
                pagination: meta,
                cache,
            })
        }
    }
}

// -------------- Repository Module --------------------------------------------------------------
pub mod repository {
    use super::pagination::{Paginated, Pagination};
    use super::*;

    use chrono::{DateTime, Utc};
    use sqlx::{postgres::PgRow, PgPool, Row};
    use tracing::{instrument, Instrument};

    // -------- Domain Model ---------------------------------------------------------------------
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LedgerEntry {
        pub id: Uuid,
        pub account_id: Uuid,
        pub posted_at: DateTime<Utc>,
        pub amount_minor: i64,
        pub currency: String,
        pub reference: String,
        pub description: String,
    }

    impl<'r> TryFrom<PgRow<'r>> for LedgerEntry {
        type Error = sqlx::Error;

        fn try_from(row: PgRow<'r>) -> Result<Self, Self::Error> {
            Ok(Self {
                id: row.try_get("id")?,
                account_id: row.try_get("account_id")?,
                posted_at: row.try_get("posted_at")?,
                amount_minor: row.try_get("amount_minor")?,
                currency: row.try_get("currency")?,
                reference: row.try_get("reference")?,
                description: row.try_get("description")?,
            })
        }
    }

    // -------- ViewModel DTO -------------------------------------------------------------------
    //
    // ViewModel decouples the database row from what we actually expose over
    // REST/GraphQL. Money is represented as decimal + currency for clients.
    //
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LedgerEntryVm {
        pub id: Uuid,
        pub posted_at: DateTime<Utc>,
        pub amount: f64, // formatted in major units for views
        pub currency: String,
        pub reference: String,
        pub description: String,
    }

    impl From<LedgerEntry> for LedgerEntryVm {
        fn from(src: LedgerEntry) -> Self {
            Self {
                id: src.id,
                posted_at: src.posted_at,
                amount: src.amount_minor as f64 / 100.0,
                currency: src.currency,
                reference: src.reference,
                description: src.description,
            }
        }
    }

    // -------- Repository Interface -------------------------------------------------------------
    #[async_trait::async_trait]
    pub trait LedgerEntryRepository {
        /// Fetches ledger entries for an account with pagination.
        async fn fetch_for_account(
            &self,
            account_id: Uuid,
            paging: Pagination,
        ) -> Result<Paginated<LedgerEntryVm>, RepoError>;
    }

    // -------- Repository Error -----------------------------------------------------------------
    #[derive(Debug, Error)]
    pub enum RepoError {
        #[error("database error: {0}")]
        Db(#[from] sqlx::Error),

        #[error("serialization error: {0}")]
        Serde(#[from] serde_json::Error),
    }

    // -------- Pg Implementation ----------------------------------------------------------------
    pub struct PgLedgerEntryRepository {
        pool: PgPool,
    }

    impl PgLedgerEntryRepository {
        pub fn new(pool: PgPool) -> Self {
            Self { pool }
        }
    }

    #[async_trait::async_trait]
    impl LedgerEntryRepository for PgLedgerEntryRepository {
        #[instrument(skip(self))]
        async fn fetch_for_account(
            &self,
            account_id: Uuid,
            paging: Pagination,
        ) -> Result<Paginated<LedgerEntryVm>, RepoError> {
            let mut tx = self.pool.begin().await?;

            // Count first (for pagination meta)
            let total_items: (i64,) = sqlx::query_as(
                r#"
                SELECT COUNT(*) as count
                FROM ledger_entries
                WHERE account_id = $1
                "#,
            )
            .bind(account_id)
            .fetch_one(&mut *tx)
            .await?;

            // Main query with pagination
            let rows = sqlx::query(
                r#"
                SELECT id, account_id, posted_at, amount_minor, currency, reference, description
                FROM ledger_entries
                WHERE account_id = $1
                ORDER BY posted_at DESC, id DESC
                OFFSET $2
                LIMIT $3
                "#,
            )
            .bind(account_id)
            .bind(paging.offset() as i64)
            .bind(paging.limit() as i64)
            .map(|row: PgRow| LedgerEntry::try_from(row).expect("infallible due to mapping"))
            .fetch_all(&mut *tx)
            .await?;

            tx.commit().await?;

            // Convert to ViewModel
            let vms: Vec<LedgerEntryVm> = rows.into_iter().map(Into::into).collect();

            // Build paginated envelope
            let paginated = Paginated::build(vms, paging, total_items.0 as u64, 30)?;

            Ok(paginated)
        }
    }
}

// -------------- Tests --------------------------------------------------------------------------
#[cfg(test)]
mod tests {
    use super::pagination::{Pagination, PaginationError};

    #[test]
    fn test_pagination_validation() {
        // Default values
        let p = Pagination::new(None, None).unwrap();
        assert_eq!(p.page, 1);
        assert_eq!(p.per_page, Pagination::DEFAULT_PER_PAGE);

        // Bad page
        assert!(matches!(
            Pagination::new(Some(0), None).unwrap_err(),
            PaginationError::PageIndexOutOfRange
        ));

        // Bad per_page
        assert!(matches!(
            Pagination::new(None, Some(Pagination::MAX_PER_PAGE + 1)).unwrap_err(),
            PaginationError::PerPageOutOfRange(_)
        ));
    }
}
```