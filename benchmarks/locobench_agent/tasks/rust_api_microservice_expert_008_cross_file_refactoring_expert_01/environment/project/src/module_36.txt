```rust
//! src/module_36.rs
//!
//! This module contains *ledger-pagination*, a small but production–grade building
//! block that is reused across the REST and GraphQL façades of **LedgerLink Nexus**.
//!
//! Responsibilities
//! ----------------
//! • Parse and validate incoming pagination query-strings (or GraphQL arguments)  
//! • Provide typed *view-models* that can be reused by CQ-handlers & repositories  
//! • Offer strong, composable cache hints so the gateway can apply smart
//!   response-caching strategies (per-tenant, per-resource, etc.)  
//! • Remain web-framework agnostic – *but* we ship `actix_web::FromRequest` impls
//!   out of the box for convenience.
//!
//! # Example (Actix)
//! ```ignore
//! async fn list_ledgers(
//!     page: Pagination,
//!     svc: web::Data<LedgerEntryQueryService>,
//! ) -> Result<HttpResponse, ApiError> {
//!     let result = svc.list_entries(page).await?;
//!     Ok(HttpResponse::Ok().json(result.with_cache_headers()))
//! }
//! ```

#![allow(clippy::module_name_repetitions)]

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use derive_more::{Display, Error};
use serde::{Deserialize, Serialize};
use std::{
    fmt,
    pin::Pin,
    task::{Context, Poll},
    time::Duration,
};
use validator::{Validate, ValidationError, ValidationErrors};

#[cfg(feature = "actix-web")]
use actix_web::{
    dev::Payload,
    http::header::{CacheControl, CacheDirective},
    web::Query,
    FromRequest, HttpMessage, HttpRequest,
};

/// Default `per_page` when the client does not specify any page size.
pub const DEFAULT_PER_PAGE: u32 = 50;
/// Hard upper-bound to protect the DB from unbounded hits.
pub const MAX_PER_PAGE: u32 = 500;

/// Direction component used for sorting.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum SortOrder {
    Asc,
    Desc,
}

/// Incoming pagination arguments extracted from query-string or
/// GraphQL variables.  
/// This is the *View-Model* part of MVVM for paging concerns.
#[derive(Debug, Clone, Validate, Deserialize)]
pub struct Pagination {
    #[validate(custom = "validate_page")]
    #[serde(default = "default_page")]
    pub page: u32,

    #[validate(custom = "validate_per_page")]
    #[serde(default = "default_per_page")]
    pub per_page: u32,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort: Option<String>,

    #[serde(default)]
    pub order: SortOrder,
}

fn default_page() -> u32 {
    1
}
fn default_per_page() -> u32 {
    DEFAULT_PER_PAGE
}

fn validate_page(p: &u32) -> Result<(), ValidationError> {
    if *p >= 1 {
        Ok(())
    } else {
        Err(ValidationError::new("page_must_be_positive"))
    }
}
fn validate_per_page(p: &u32) -> Result<(), ValidationError> {
    if (1..=MAX_PER_PAGE).contains(p) {
        Ok(())
    } else {
        Err(ValidationError::new("per_page_out_of_range"))
    }
}

/// Meta data returned alongside a collection payload.
#[derive(Debug, Clone, Serialize)]
pub struct PageMeta {
    pub page: u32,
    pub per_page: u32,
    pub total_items: u64,
    pub total_pages: u32,
    pub cached_until: DateTime<Utc>,
}

/// Trait for service-layer functions that return cacheable paginated data.
pub trait CacheHint {
    /// Duration that the resource may live inside the response-cache.
    fn ttl(&self) -> Duration;
}

/// Envelope that wraps list payloads with their page meta data.
#[derive(Debug, Clone, Serialize)]
pub struct PageEnvelope<T> {
    pub data: Vec<T>,
    pub meta: PageMeta,
}

impl<T> PageEnvelope<T> {
    #[must_use]
    pub fn new(
        data: Vec<T>,
        page: &Pagination,
        total_items: u64,
        ttl: Duration,
    ) -> Self {
        let total_pages =
            ((total_items as f64) / (page.per_page as f64)).ceil() as u32;
        Self {
            data,
            meta: PageMeta {
                page: page.page,
                per_page: page.per_page,
                total_items,
                total_pages,
                cached_until: Utc::now() + chrono::Duration::from_std(ttl)
                    .unwrap_or_else(|_| chrono::Duration::seconds(0)),
            },
        }
    }

    /// Helper for REST responses: attach *Cache-Control* header.
    #[cfg(feature = "actix-web")]
    #[must_use]
    pub fn with_cache_headers(
        self,
    ) -> actix_web::HttpResponse {
        use actix_web::HttpResponse;
        HttpResponse::Ok()
            .insert_header((
                actix_web::http::header::CACHE_CONTROL,
                CacheControl(vec![
                    CacheDirective::Public,
                    CacheDirective::MaxAge(
                        (self
                            .meta
                            .cached_until
                            .signed_duration_since(Utc::now())
                            .num_seconds()
                            .max(0)) as u32,
                    ),
                ]),
            ))
            .json(self)
    }
}

/// Errors emitted during pagination parsing / validation.
#[derive(Debug, Display, Error)]
pub enum PaginationError {
    #[display(fmt = "validation failed: {}", _0)]
    Validation(ValidationErrors),

    #[display(fmt = "internal conversion error")]
    Internal,
}

impl From<ValidationErrors> for PaginationError {
    fn from(e: ValidationErrors) -> Self {
        Self::Validation(e)
    }
}

impl fmt::Display for Pagination {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "page={} per_page={} sort={:?} order={:?}",
            self.page, self.per_page, self.sort, self.order
        )
    }
}

#[cfg(feature = "actix-web")]
#[async_trait(?Send)]
impl FromRequest for Pagination {
    type Error = PaginationError;
    type Future = Pin<Box<dyn std::future::Future<Output = Result<Self, Self::Error>>>>;
    type Config = ();

    fn from_request(
        req: &HttpRequest,
        payload: &mut Payload,
    ) -> Self::Future {
        let req = req.clone();
        let mut pl = payload.take();

        Box::pin(async move {
            // Re-use `Query` extractor then run custom validation.
            let query = Query::<Pagination>::from_request(&req, &mut pl)
                .await
                .map_err(|_| PaginationError::Internal)?;
            query
                .validate()
                .map_err(PaginationError::Validation)?;
            Ok(query.into_inner())
        })
    }
}

/// `PagingRepository` is a high-level abstraction used by the Service-Layer.
/// Each implementation hides the persistence strategy (SQL, NoSQL, …).
#[async_trait]
pub trait PagingRepository<R>
where
    R: Send + Sync + 'static,
{
    /// Fetch a slice of records along with the total-count.
    async fn fetch_page(
        &self,
        page: &Pagination,
    ) -> Result<(Vec<R>, u64), RepositoryError>;
}

/// Generic repository error used throughout the Domain layer.
#[derive(Debug, Display, Error)]
pub enum RepositoryError {
    #[display(fmt = "database error: {}", _0)]
    Db(String),

    #[display(fmt = "connection pool exhausted")]
    PoolExhausted,
}

/// A minimal Redis-backed cache implementation used by the
/// API-Gateway for *per-page* caching.  
/// In the real production code of **LedgerLink** this would live in its
/// own `infra` crate – *here we inline a condensed variant*.
#[cfg(feature = "redis")]
pub mod cache {
    use super::*;
    use redis::{AsyncCommands, Client};

    /// Key format: `tenant::<TENANT>::<RESOURCE>::page=<N>::per=<M>::sort=<S>`.
    fn key(tenant: &str, resource: &str, pagination: &Pagination) -> String {
        format!(
            "tenant::{tenant}::{resource}::page={}::per={}::sort={:?}::order={:?}",
            pagination.page, pagination.per_page, pagination.sort, pagination.order
        )
    }

    pub struct PageCache {
        client: Client,
        default_ttl: Duration,
    }

    impl PageCache {
        pub fn new(client: Client, default_ttl: Duration) -> Self {
            Self {
                client,
                default_ttl,
            }
        }

        /// Try to retrieve a cached page.  
        /// Returns `None` on deserialization failure *or* redis error –
        /// we never want to fail the main request because the cache is down.
        pub async fn get<T>(
            &self,
            tenant: &str,
            resource: &str,
            pagination: &Pagination,
        ) -> Option<PageEnvelope<T>>
        where
            for<'de> T: Deserialize<'de>,
        {
            let key = key(tenant, resource, pagination);
            let mut conn = self.client.get_async_connection().await.ok()?;
            let data: Option<Vec<u8>> = conn.get(key).await.ok()?;
            data.and_then(|bytes| postcard::from_bytes(&bytes).ok())
        }

        /// Store page result inside cache.
        pub async fn put<T>(
            &self,
            tenant: &str,
            resource: &str,
            pagination: &Pagination,
            envelope: &PageEnvelope<T>,
        ) where
            T: Serialize,
        {
            if let Ok(buf) = postcard::to_stdvec(envelope) {
                let key = key(tenant, resource, pagination);
                if let Ok(mut conn) = self.client.get_async_connection().await {
                    let _ = conn
                        .set_ex::<_, _, ()>(
                            key,
                            buf,
                            self.default_ttl.as_secs() as usize,
                        )
                        .await;
                }
            }
        }
    }
}

// ---------- Tests -----------------------------------------------------------
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn pagination_validation_works() {
        let p = Pagination {
            page: 0,
            per_page: 600,
            sort: None,
            order: SortOrder::Asc,
        };
        assert!(p.validate().is_err());

        let good = Pagination {
            page: 2,
            per_page: 100,
            sort: Some("created_at".into()),
            order: SortOrder::Desc,
        };
        assert!(good.validate().is_ok());
    }

    #[test]
    fn envelope_meta_calculation() {
        let pg = Pagination {
            page: 1,
            per_page: 40,
            sort: None,
            order: SortOrder::Asc,
        };
        let env: PageEnvelope<i32> =
            PageEnvelope::new(vec![1, 2, 3], &pg, 101, Duration::from_secs(60));
        assert_eq!(env.meta.total_pages, 3);
        assert!(env.meta.total_items >= 101);
    }
}
```