```rust
//! src/module_3.rs
//!
//! LedgerEntry query service (read‐only).
//!
//! This module demonstrates how the project’s “view → view‐model → service layer”
//! pipeline can be implemented for a single domain concept: `LedgerEntry`.
//!
//! Key features demonstrated
//! -------------------------
//! • Pagination helper with strict input validation  
//! • Typed DTO + serde (for both REST & GraphQL payload reuse)  
//! • Repository pattern & async/await friendliness  
//! • Response-caching hints (for gateway & CDN layers)  
//! • Centralised, structured error envelopes (thiserror)  
//! • Integration hooks for authentication & structured logging  
//!
//! The implementation is intentionally self-contained so it can compile in
//! isolation during CI.  External modules (e.g. `db`, `cache`, `auth`) are
//! modeled with minimal trait stubs that the real microservice supplies.

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use log::{debug, error, info, trace};
use serde::{Deserialize, Serialize};
use std::fmt;
use std::sync::Arc;
use thiserror::Error;
use uuid::Uuid;

// -----------------------------------------------------------------------------
// Domain Model (persisted)
// -----------------------------------------------------------------------------
#[derive(Debug, Clone)]
pub struct LedgerEntry {
    pub id: Uuid,
    pub tenant_id: Uuid,
    pub account_id: Uuid,
    pub amount: rust_decimal::Decimal,
    pub currency: String,
    pub narrative: Option<String>,
    pub booked_at: DateTime<Utc>,
    pub created_at: DateTime<Utc>,
}

// -----------------------------------------------------------------------------
// View-Model (DTO) exposed to upper layers / transport serializers
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LedgerEntryDto {
    pub id: Uuid,
    pub account_id: Uuid,
    pub amount: rust_decimal::Decimal,
    pub currency: String,
    pub narrative: Option<String>,
    pub booked_at: DateTime<Utc>,
}

impl From<LedgerEntry> for LedgerEntryDto {
    fn from(entity: LedgerEntry) -> Self {
        Self {
            id: entity.id,
            account_id: entity.account_id,
            amount: entity.amount,
            currency: entity.currency,
            narrative: entity.narrative,
            booked_at: entity.booked_at,
        }
    }
}

// -----------------------------------------------------------------------------
// Pagination helpers
// -----------------------------------------------------------------------------
const MAX_PAGE_SIZE: u32 = 250;

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct PaginationRequest {
    pub page: u32,
    pub per_page: u32,
}

impl PaginationRequest {
    pub fn validate(self) -> Result<Self, LedgerEntryServiceError> {
        if self.per_page == 0 || self.page == 0 {
            return Err(LedgerEntryServiceError::Validation(
                "page and per_page must be > 0".into(),
            ));
        }
        if self.per_page > MAX_PAGE_SIZE {
            return Err(LedgerEntryServiceError::Validation(format!(
                "per_page must not exceed {}",
                MAX_PAGE_SIZE
            )));
        }
        Ok(self)
    }

    pub fn offset_limit(self) -> (u64, u64) {
        let offset = (self.page.saturating_sub(1) * self.per_page) as u64;
        (offset, self.per_page as u64)
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct PaginationMeta {
    pub page: u32,
    pub per_page: u32,
    pub total_items: u64,
    pub total_pages: u32,
}

// -----------------------------------------------------------------------------
// Cache hints (propagated via response headers at gateway level)
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Serialize)]
#[serde(tag = "strategy", content = "value")]
pub enum CacheHint {
    /// Force no-store (e.g. data that depends on auth scope)
    NoCache,
    /// Standard TTL in seconds
    Ttl(u64),
}

// -----------------------------------------------------------------------------
// Error envelope
// -----------------------------------------------------------------------------
#[derive(Debug, Error)]
pub enum LedgerEntryServiceError {
    #[error("validation error: {0}")]
    Validation(String),
    #[error("unauthorised")]
    Unauthorised,
    #[error("not found")]
    NotFound,
    #[error("repository error: {0}")]
    Repository(String),
    #[error("internal: {0}")]
    Internal(String),
}

// -----------------------------------------------------------------------------
// Authentication claims (provided by API gateway / middleware)
// -----------------------------------------------------------------------------
#[derive(Debug, Clone)]
pub struct Claims {
    pub tenant_id: Uuid,
    pub user_id: Uuid,
    pub roles: Vec<String>,
}

impl Claims {
    /// Simple read permission check. Real implementation would be RBAC/ABAC.
    pub fn can_read_ledger(&self) -> bool {
        self.roles.iter().any(|r| r == "finance.read")
    }
}

// -----------------------------------------------------------------------------
// Repository abstraction (domain persistence)
// -----------------------------------------------------------------------------
#[async_trait]
pub trait LedgerEntryRepository: Send + Sync {
    async fn count_entries(
        &self,
        tenant_id: Uuid,
    ) -> Result<u64, anyhow::Error>;

    async fn list_entries(
        &self,
        tenant_id: Uuid,
        offset: u64,
        limit: u64,
    ) -> Result<Vec<LedgerEntry>, anyhow::Error>;
}

// -----------------------------------------------------------------------------
// Cache abstraction (key-value, e.g. Redis)
// -----------------------------------------------------------------------------
#[async_trait]
pub trait CacheBackend: Send + Sync {
    async fn get_bin(&self, key: &str) -> Result<Option<Vec<u8>>, anyhow::Error>;
    async fn set_bin(&self, key: &str, value: &[u8], ttl_seconds: u64)
        -> Result<(), anyhow::Error>;
}

// -----------------------------------------------------------------------------
// Paged result wrapper
// -----------------------------------------------------------------------------
#[derive(Debug, Serialize)]
pub struct PagedResult<T> {
    pub data: Vec<T>,
    pub pagination: PaginationMeta,
    pub cache: CacheHint,
}

// -----------------------------------------------------------------------------
// Query Service
// -----------------------------------------------------------------------------
#[async_trait]
pub trait LedgerEntryQueryService: Send + Sync {
    async fn list_entries(
        &self,
        auth: Claims,
        paging: PaginationRequest,
    ) -> Result<PagedResult<LedgerEntryDto>, LedgerEntryServiceError>;
}

// -----------------------------------------------------------------------------
// Concrete implementation
// -----------------------------------------------------------------------------
pub struct LedgerEntryQueryServiceImpl<R: LedgerEntryRepository, C: CacheBackend> {
    repo: Arc<R>,
    cache: Arc<C>,
}

impl<R: LedgerEntryRepository, C: CacheBackend> LedgerEntryQueryServiceImpl<R, C> {
    pub fn new(repo: Arc<R>, cache: Arc<C>) -> Self {
        Self { repo, cache }
    }

    fn make_cache_key(tenant: Uuid, paging: PaginationRequest) -> String {
        format!(
            "ledger:entries:{}:p{}:s{}",
            tenant, paging.page, paging.per_page
        )
    }
}

#[async_trait]
impl<R, C> LedgerEntryQueryService for LedgerEntryQueryServiceImpl<R, C>
where
    R: LedgerEntryRepository + 'static,
    C: CacheBackend + 'static,
{
    async fn list_entries(
        &self,
        auth: Claims,
        paging: PaginationRequest,
    ) -> Result<PagedResult<LedgerEntryDto>, LedgerEntryServiceError> {
        // ------------------------------------------------------------------
        // AuthN / AuthZ
        // ------------------------------------------------------------------
        if !auth.can_read_ledger() {
            error!("unauthorised access by user {}", auth.user_id);
            return Err(LedgerEntryServiceError::Unauthorised);
        }

        // ------------------------------------------------------------------
        // Validate pagination
        // ------------------------------------------------------------------
        let paging = paging.validate()?;

        let cache_key = Self::make_cache_key(auth.tenant_id, paging);
        let ttl_seconds: u64 = 5; // Hard-coded TTL for demo (would be configurable)

        // ------------------------------------------------------------------
        // Attempt cache hit
        // ------------------------------------------------------------------
        if let Ok(Some(serialised)) = self.cache.get_bin(&cache_key).await {
            trace!("cache hit for {}", cache_key);
            match bincode::deserialize::<PagedResult<LedgerEntryDto>>(&serialised) {
                Ok(result) => return Ok(result),
                Err(e) => {
                    // Corrupt cache entry: log but fall through
                    error!("cache deserialise failed: {}", e);
                }
            }
        }

        // ------------------------------------------------------------------
        // Repository calls (CQRS read side)
        // ------------------------------------------------------------------
        let (offset, limit) = paging.offset_limit();
        let total_items = self
            .repo
            .count_entries(auth.tenant_id)
            .await
            .map_err(|e| LedgerEntryServiceError::Repository(e.to_string()))?;

        let list = self
            .repo
            .list_entries(auth.tenant_id, offset, limit)
            .await
            .map_err(|e| LedgerEntryServiceError::Repository(e.to_string()))?;

        let dto_list: Vec<LedgerEntryDto> = list.into_iter().map(Into::into).collect();

        let total_pages = ((total_items as f64) / (paging.per_page as f64)).ceil() as u32;

        let response = PagedResult {
            data: dto_list,
            pagination: PaginationMeta {
                page: paging.page,
                per_page: paging.per_page,
                total_items,
                total_pages,
            },
            cache: CacheHint::Ttl(ttl_seconds),
        };

        // ------------------------------------------------------------------
        // Store in cache for next caller
        // ------------------------------------------------------------------
        if let Ok(bytes) = bincode::serialize(&response) {
            if let Err(e) = self.cache.set_bin(&cache_key, &bytes, ttl_seconds).await {
                error!("failed to set cache {}: {}", cache_key, e);
            }
        }

        info!(
            "tenant {} fetched ledger entries page {} ({} items)",
            auth.tenant_id, paging.page, response.data.len()
        );

        Ok(response)
    }
}

// -----------------------------------------------------------------------------
// Utility: Pretty debug printing for PaginationRequest
// -----------------------------------------------------------------------------
impl fmt::Display for PaginationRequest {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "page={}, per_page={}", self.page, self.per_page)
    }
}

// -----------------------------------------------------------------------------
// Tests (can be executed with `cargo test`)
// -----------------------------------------------------------------------------
#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use tokio::sync::Mutex;

    struct MockRepo {
        data: Vec<LedgerEntry>,
    }

    #[async_trait]
    impl LedgerEntryRepository for MockRepo {
        async fn count_entries(&self, _tenant_id: Uuid) -> Result<u64, anyhow::Error> {
            Ok(self.data.len() as u64)
        }

        async fn list_entries(
            &self,
            _tenant_id: Uuid,
            offset: u64,
            limit: u64,
        ) -> Result<Vec<LedgerEntry>, anyhow::Error> {
            let slice = self
                .data
                .iter()
                .skip(offset as usize)
                .take(limit as usize)
                .cloned()
                .collect();
            Ok(slice)
        }
    }

    struct InMemCache {
        inner: Mutex<HashMap<String, Vec<u8>>>,
    }

    impl InMemCache {
        fn new() -> Self {
            Self {
                inner: Mutex::new(HashMap::new()),
            }
        }
    }

    #[async_trait]
    impl CacheBackend for InMemCache {
        async fn get_bin(&self, key: &str) -> Result<Option<Vec<u8>>, anyhow::Error> {
            Ok(self.inner.lock().await.get(key).cloned())
        }

        async fn set_bin(
            &self,
            key: &str,
            value: &[u8],
            _ttl_seconds: u64,
        ) -> Result<(), anyhow::Error> {
            self.inner
                .lock()
                .await
                .insert(key.to_string(), value.to_vec());
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_paging_validation() {
        assert!(PaginationRequest { page: 0, per_page: 10 }.validate().is_err());
        assert!(PaginationRequest { page: 1, per_page: 0 }.validate().is_err());
        assert!(PaginationRequest { page: 1, per_page: MAX_PAGE_SIZE + 1 }
            .validate()
            .is_err());
        assert!(PaginationRequest { page: 1, per_page: 10 }.validate().is_ok());
    }

    #[tokio::test]
    async fn test_service_list_entries() {
        let tenant_id = Uuid::new_v4();
        let entries = (0..30)
            .map(|i| LedgerEntry {
                id: Uuid::new_v4(),
                tenant_id,
                account_id: Uuid::new_v4(),
                amount: rust_decimal::Decimal::new(i, 0),
                currency: "USD".to_string(),
                narrative: None,
                booked_at: Utc::now(),
                created_at: Utc::now(),
            })
            .collect::<Vec<_>>();

        let repo = Arc::new(MockRepo { data: entries });
        let cache = Arc::new(InMemCache::new());

        let service = LedgerEntryQueryServiceImpl::new(repo, cache);

        let result = service
            .list_entries(
                Claims {
                    tenant_id,
                    user_id: Uuid::new_v4(),
                    roles: vec!["finance.read".into()],
                },
                PaginationRequest { page: 1, per_page: 25 },
            )
            .await
            .expect("service call");

        assert_eq!(result.pagination.total_items, 30);
        assert_eq!(result.data.len(), 25);
        assert_eq!(result.pagination.total_pages, 2);
    }
}
```