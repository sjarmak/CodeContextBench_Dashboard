```rust
//! src/constants.rs
//! Centralized, compile–time constants & helpers for the LedgerLink Nexus API micro-service.
//!
//! Keeping settings in one place guarantees uniform behavior across crates (API,
//! jobs, CLI, etc.) and makes it trivial to cross-reference configuration in
//! integration tests or operational tooling (e.g. Helm charts).

use std::time::Duration;

use lazy_static::lazy_static;
use regex::Regex;

/// Current public API version (semver *without* pre-release labels).
pub const API_VERSION: &str = "1.3.0";

/// Header used for explicit version negotiation (overrides “Accept”).
pub const HDR_API_VERSION: &str = "x-ledgerlink-api-version";

/// Header that carries the tenant identifier (multi-tenant isolation).
pub const HDR_TENANT_ID: &str = "x-ledgerlink-tenant-id";

/// Default & maximum page sizes for cursor/offset pagination.
pub const DEFAULT_PAGE_SIZE: u32 = 50;
pub const MAX_PAGE_SIZE: u32 = 250;

/// Cache-control durations used by the response_caching middleware.
pub const CACHE_TTL_SHORT: Duration = Duration::from_secs(30);      // e.g. account snapshot
pub const CACHE_TTL_LONG: Duration  = Duration::from_secs(300);     // e.g. static lookup tables

/// Common Redis namespaces – **DO NOT** change without a data-migration plan.
pub const REDIS_NS_CACHE: &str = "llnx:cache:";
pub const REDIS_NS_LOCKS: &str = "llnx:locks:";
pub const REDIS_NS_RATE:  &str = "llnx:ratelimit:";

/// Environment variable names – used by `config` crate.
pub mod env {
    pub const DATABASE_URL: &str      = "LEDGERLINK_DATABASE_URL";
    pub const REDIS_URL: &str         = "LEDGERLINK_REDIS_URL";
    pub const RUST_LOG: &str          = "RUST_LOG";
    pub const SENTRY_DSN: &str        = "LEDGERLINK_SENTRY_DSN";
    pub const ALLOW_CORS_ORIGINS: &str= "LEDGERLINK_ALLOW_CORS";
    pub const ENVIRONMENT: &str       = "LEDGERLINK_ENV"; // dev, staging, prod
}

/// List of numeric error codes mapped to problems used in `error_envelope`.
pub mod err_code {
    pub const VALIDATION: u16        = 1000;
    pub const AUTHENTICATION: u16    = 1001;
    pub const AUTHORIZATION: u16     = 1002;
    pub const NOT_FOUND: u16         = 1003;
    pub const CONFLICT: u16          = 1004;
    pub const RATE_LIMIT: u16        = 1005;
    pub const INTERNAL: u16          = 2000;
}

/// Queue names for background jobs (RabbitMQ/Kafka agnostic naming).
pub mod queues {
    pub const LEDGER_SYNC: &str     = "ledger-sync";
    pub const PAYMENT_WEBHOOK: &str = "payment-webhook";
    pub const AUDIT_EXPORT: &str    = "audit-export";
}

/// RPC/HTTP timeouts for outgoing requests to 3rd-party services.
pub mod timeout {
    use super::*;
    pub const SHORT: Duration  = Duration::from_secs(2);   // idempotent, fast
    pub const MEDIUM: Duration = Duration::from_secs(5);   // majority of calls
    pub const LONG: Duration   = Duration::from_secs(15);  // bulk exports
}

/// A permissive upper-bound for request payload sizes.
///
/// Guarded by `tower_http::limit::RequestBodyLimitLayer`.
pub const MAX_PAYLOAD_BYTES: usize = 1024 * 1024 * 5; // 5 MiB

/// User-facing date/time formatting string (RFC 3339, *without* sub-second precision).
pub const DT_FMT_RFC3339: &str = "%Y-%m-%dT%H:%M:%SZ";

lazy_static! {
    /// Regex for validating tenant IDs (UUID v4, canonical form).
    pub static ref RE_TENANT_ID: Regex = Regex::new(
        r"(?i)^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ).expect("Failed to compile tenant ID regex");
}

/// Convenience helper for building Redis keys with proper namespacing.
///
/// # Examples
/// ```
/// use ledgerlink_nexus::constants::{redis_key, REDIS_NS_CACHE};
///
/// let key = redis_key(REDIS_NS_CACHE, &["tenant_123", "account_snapshots"]);
/// assert_eq!(key, "llnx:cache:tenant_123:account_snapshots");
/// ```
pub fn redis_key(namespace: &str, segments: &[&str]) -> String {
    let mut key = String::with_capacity(
        namespace.len() + segments.iter().map(|s| s.len() + 1).sum::<usize>(),
    );
    key.push_str(namespace);
    for (idx, seg) in segments.iter().enumerate() {
        if idx > 0 || !namespace.ends_with(':') {
            key.push(':');
        }
        key.push_str(seg);
    }
    key
}

/// Normalizes and pre-validates a tenant identifier supplied via HTTP headers.
///
/// Strips surrounding whitespace and ensures the value is a valid UUID v4.
/// Returns `None` if validation fails.
pub fn sanitize_tenant_id(raw: &str) -> Option<String> {
    let trimmed = raw.trim();
    if RE_TENANT_ID.is_match(trimmed) {
        Some(trimmed.to_ascii_lowercase())
    } else {
        None
    }
}
```