```python
"""
crowdpay_connect/infra/k8s/user_service_deployment.yaml   (yes, it's Python code)

This module is responsible for programmatically generating the Kubernetes
manifests required to deploy the `user-service` within the CrowdPay Connect
platform.  Generating YAML via Python offers:

1. Reusable, type-safe configuration objects
2. Environment-aware overrides (e.g. staging vs. production)
3. Guard-rails & validation to catch invalid manifests before `kubectl apply`

Typical usage
-------------
$ export CP_ENV=prod
$ export USER_SVC_IMAGE=ghcr.io/crowdpay/user-service:v2.3.1
$ python -m crowdpay_connect.infra.k8s.user_service_deployment \
        --out ./manifests/user-service.yaml

The resulting YAML can be `kubectl apply -f …`-ed or supplied to an
Automated GitOps pipeline (ArgoCD / Flux).

NOTE:
The filename has a `.yaml` suffix because the repository groups all k8s
configuration under `infra/k8s`; the extension does not affect Python’s
ability to import the module.
"""
from __future__ import annotations

import argparse
import logging
import os
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List

import yaml  # PyYAML (runtime dependency)

_LOG = logging.getLogger(__name__)


# --------------------------------------------------------------------------- #
# Configuration                                                               #
# --------------------------------------------------------------------------- #

@dataclass
class Probe:
    """
    Kubernetes (HTTP) probe configuration.
    """
    path: str
    port: int = 8080
    initial_delay_seconds: int = 5
    period_seconds: int = 10
    timeout_seconds: int = 2
    failure_threshold: int = 3
    success_threshold: int = 1

    def as_dict(self) -> Dict:
        return {
            "httpGet": {
                "path": self.path,
                "port": self.port
            },
            "initialDelaySeconds": self.initial_delay_seconds,
            "periodSeconds": self.period_seconds,
            "timeoutSeconds": self.timeout_seconds,
            "failureThreshold": self.failure_threshold,
            "successThreshold": self.success_threshold,
        }


@dataclass
class ResourceLimits:
    """
    CPU / memory requests & limits.
    """
    request_cpu: str = "100m"
    request_memory: str = "128Mi"
    limit_cpu: str = "500m"
    limit_memory: str = "512Mi"

    def as_dict(self) -> Dict[str, Dict[str, str]]:
        return {
            "requests": {
                "cpu": self.request_cpu,
                "memory": self.request_memory,
            },
            "limits": {
                "cpu": self.limit_cpu,
                "memory": self.limit_memory,
            },
        }


@dataclass
class DeploymentConfig:
    """
    All tunable parameters for the user-service Deployment/Service.
    """
    name: str = "user-service"
    namespace: str = "crowdpay"
    image: str = field(default_factory=lambda: os.getenv("USER_SVC_IMAGE", "ghcr.io/crowdpay/user-service:latest"))
    replicas: int = field(default_factory=lambda: int(os.getenv("USER_SVC_REPLICAS", "3")))
    env: str = field(default_factory=lambda: os.getenv("CP_ENV", "dev"))

    service_port: int = 80
    container_port: int = 8080

    probe: Probe = field(default_factory=lambda: Probe(path="/healthz"))
    resources: ResourceLimits = field(default_factory=ResourceLimits)

    def validate(self) -> None:
        """
        Perform best-effort validation before manifest generation.
        """
        if not self.image or ":" not in self.image:
            raise ValueError("image must include a tag, e.g. 'repo/name:version'")
        if self.replicas < 1:
            raise ValueError("replicas must be >= 1")
        if self.env not in {"dev", "staging", "prod"}:
            raise ValueError("env must be one of dev|staging|prod")


# --------------------------------------------------------------------------- #
# Kubernetes Manifest Builders                                                #
# --------------------------------------------------------------------------- #

class UserServiceManifestBuilder:
    """
    Build K8s Deployment & Service manifests for the user-service.

    Manifests are pure-python dictionaries that can be handed to
    `yaml.safe_dump_all`.
    """

    DEPLOYMENT_API_VERSION = "apps/v1"
    SERVICE_API_VERSION = "v1"

    def __init__(self, cfg: DeploymentConfig) -> None:
        cfg.validate()
        self._cfg = cfg
        _LOG.debug("Initialized builder with %s", cfg)

    # ----------  Public API  ------------------------------------------------ #
    def build(self) -> List[Dict]:
        """
        Create a list of Kubernetes resource dictionaries.
        Order is significant for `kubectl apply -f -`.
        """
        return [
            self._deployment_manifest(),
            self._service_manifest(),
        ]

    # ----------  Private helpers  ------------------------------------------ #
    def _labels(self) -> Dict[str, str]:
        return {
            "app": self._cfg.name,
            "tier": "backend",
            "component": "user",
            "environment": self._cfg.env,
        }

    def _deployment_manifest(self) -> Dict:
        labels = self._labels()
        cfg = self._cfg

        return {
            "apiVersion": self.DEPLOYMENT_API_VERSION,
            "kind": "Deployment",
            "metadata": {
                "name": cfg.name,
                "namespace": cfg.namespace,
                "labels": labels,
            },
            "spec": {
                "replicas": cfg.replicas,
                "selector": {
                    "matchLabels": labels
                },
                "template": {
                    "metadata": {
                        "labels": labels,
                        "annotations": {
                            # Used by Datadog, Prometheus, or similar to scrape metrics
                            "prometheus.io/path": "/metrics",
                            "prometheus.io/port": str(cfg.container_port),
                            "prometheus.io/scrape": "true",
                        },
                    },
                    "spec": {
                        "containers": [
                            {
                                "name": cfg.name,
                                "image": cfg.image,
                                "ports": [{"containerPort": cfg.container_port}],
                                "env": self._environment(),
                                "resources": cfg.resources.as_dict(),
                                "livenessProbe": cfg.probe.as_dict(),
                                "readinessProbe": cfg.probe.as_dict(),
                                "securityContext": {
                                    "runAsNonRoot": True,
                                    "readOnlyRootFilesystem": True,
                                    "capabilities": {
                                        "drop": ["ALL"]
                                    },
                                },
                                "imagePullPolicy": "IfNotPresent",
                            }
                        ],
                        "imagePullSecrets": [
                            {"name": "crowdpay-docker-registry"}
                        ],
                    },
                },
            },
        }

    def _service_manifest(self) -> Dict:
        cfg = self._cfg
        labels = self._labels()

        return {
            "apiVersion": self.SERVICE_API_VERSION,
            "kind": "Service",
            "metadata": {
                "name": cfg.name,
                "namespace": cfg.namespace,
                "labels": labels,
            },
            "spec": {
                "type": "ClusterIP",
                "selector": labels,
                "ports": [
                    {
                        "port": cfg.service_port,
                        "targetPort": cfg.container_port,
                        "protocol": "TCP",
                    }
                ],
            },
        }

    def _environment(self) -> List[Dict[str, str]]:
        """
        Environment variables injected into the container.
        Sensitive secrets are referenced via K8s SecretKeyRef.
        """
        cfg = self._cfg
        env_list: List[Dict[str, str]] = [
            {"name": "CP_ENV", "value": cfg.env},
            {"name": "SERVICE_NAME", "value": cfg.name},
        ]

        # Secret: database credentials (example)
        env_list.extend([
            {
                "name": "DB_USER",
                "valueFrom": {
                    "secretKeyRef": {
                        "name": f"{cfg.name}-db",
                        "key": "username",
                    }
                },
            },
            {
                "name": "DB_PASSWORD",
                "valueFrom": {
                    "secretKeyRef": {
                        "name": f"{cfg.name}-db",
                        "key": "password",
                    }
                },
            },
        ])

        # ConfigMap: non-secret configs
        env_list.append({
            "name": "APP_CONFIG_PATH",
            "value": "/etc/crowdpay/config.yaml",
        })

        return env_list


# --------------------------------------------------------------------------- #
# CLI Entrypoint                                                              #
# --------------------------------------------------------------------------- #

def _parse_args(argv: List[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate Kubernetes YAML for the CrowdPay user-service."
    )
    parser.add_argument(
        "--out",
        required=False,
        default="-",
        help="Output file (default: stdout). Use '-' for stdout.",
    )
    parser.add_argument(
        "--verbose",
        "-v",
        action="count",
        default=0,
        help="Increase log verbosity (repeatable).",
    )
    return parser.parse_args(argv)


def _init_logging(verbosity: int) -> None:
    level = logging.WARNING - (10 * min(verbosity, 2))  # WARN, INFO, DEBUG
    logging.basicConfig(
        level=level,
        format="%(levelname)s: %(message)s",
    )


def main(argv: List[str] | None = None) -> None:
    args = _parse_args(argv or sys.argv[1:])
    _init_logging(args.verbose)

    try:
        cfg = DeploymentConfig()
        builder = UserServiceManifestBuilder(cfg)
        manifests = builder.build()
    except Exception as exc:  # Broad catch to ensure CLI does not traceback
        _LOG.error("Failed to build manifests: %s", exc)
        sys.exit(1)

    yaml_str = yaml.safe_dump_all(manifests, sort_keys=False)

    if args.out == "-":
        print(yaml_str)
    else:
        out_path = Path(args.out).expanduser().resolve()
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(yaml_str)
        _LOG.info("Wrote manifests to %s", out_path)


if __name__ == "__main__":
    main()
```