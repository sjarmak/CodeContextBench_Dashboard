```python
#!/usr/bin/env python3
"""
crowdpod_service_deployment.yaml

Despite the misleading extension, this file is a Python utility that
produces version-pinned, security-hardened Kubernetes manifests for the
CrowdPay Connect “CrowdPod” service.

Usage examples:
---------------
# Print manifests to STDOUT
$ python3 crowdpod_service_deployment.yaml \
      --image ghcr.io/crowdpay/connect/crowdpod:1.4.2

# Write to file
$ python3 crowdpod_service_deployment.yaml \
      --image ghcr.io/crowdpay/connect/crowdpod:1.4.2 \
      --replicas 4 \
      --env LOG_LEVEL=INFO \
      --env FEATURE_FLAG_SAGA=true \
      --output ./crowdpod.yaml
"""
from __future__ import annotations

import argparse
import datetime as _dt
import hashlib as _hashlib
import pathlib as _pl
import sys
from dataclasses import dataclass, field
from typing import Dict, List, Optional

import yaml  # PyYAML


# --------------------------------------------------------------------------- #
# Data-classes that model the minimal subset of Kubernetes objects we need.
# --------------------------------------------------------------------------- #
@dataclass
class ContainerPort:
    """
    Represents a single container port mapping.
    """

    name: str
    container_port: int
    protocol: str = "TCP"

    def to_dict(self) -> Dict[str, str | int]:
        return {
            "name": self.name,
            "containerPort": self.container_port,
            "protocol": self.protocol,
        }


@dataclass
class EnvVar:
    """
    Represents an environment variable to be injected into the container.
    """

    name: str
    value: str

    def to_dict(self) -> Dict[str, str]:
        return {"name": self.name, "value": self.value}


@dataclass
class ResourceRequirements:
    """
    Fine-tuned resource limits/requests following CrowdPay’s “Security by Design”
    and cost-optimised policies.
    """

    limits: Dict[str, str] = field(
        default_factory=lambda: {"cpu": "500m", "memory": "512Mi"}
    )
    requests: Dict[str, str] = field(
        default_factory=lambda: {"cpu": "250m", "memory": "256Mi"}
    )

    def to_dict(self) -> Dict[str, Dict[str, str]]:
        return {"limits": self.limits, "requests": self.requests}


@dataclass
class DeploymentConfig:
    """
    The root configuration used to generate all Kubernetes manifests.
    """

    app_name: str
    docker_image: str
    replicas: int = 2
    ports: List[ContainerPort] = field(
        default_factory=lambda: [ContainerPort(name="http", container_port=8080)]
    )
    env_vars: List[EnvVar] = field(default_factory=list)
    resource_requirements: ResourceRequirements = field(
        default_factory=ResourceRequirements
    )
    enable_network_policy: bool = True
    namespace: str = "crowdpay"

    # --------------------------------------------------------------------- #
    # Manifest builders
    # --------------------------------------------------------------------- #
    def deployment_manifest(self) -> Dict:
        """
        Build a hardened Deployment manifest supporting blue/green rollouts.
        """
        containers = [
            {
                "name": self.app_name,
                "image": self.docker_image,
                "ports": [p.to_dict() for p in self.ports],
                "env": [e.to_dict() for e in self.env_vars],
                "resources": self.resource_requirements.to_dict(),
                "livenessProbe": {
                    "httpGet": {"path": "/healthz", "port": self.ports[0].container_port},
                    "initialDelaySeconds": 10,
                    "timeoutSeconds": 3,
                    "periodSeconds": 10,
                    "failureThreshold": 3,
                },
                "readinessProbe": {
                    "httpGet": {"path": "/readyz", "port": self.ports[0].container_port},
                    "initialDelaySeconds": 5,
                    "timeoutSeconds": 3,
                    "periodSeconds": 5,
                    "failureThreshold": 3,
                },
                "securityContext": {
                    "runAsNonRoot": True,
                    "runAsUser": 1000,
                    "allowPrivilegeEscalation": False,
                    "readOnlyRootFilesystem": True,
                    "capabilities": {"drop": ["ALL"]},
                },
            }
        ]

        return {
            "apiVersion": "apps/v1",
            "kind": "Deployment",
            "metadata": {
                "name": f"{self.app_name}-deployment",
                "namespace": self.namespace,
                "labels": self.common_labels(),
            },
            "spec": {
                "replicas": self.replicas,
                "selector": {"matchLabels": self.common_labels()},
                "template": {
                    "metadata": {
                        "labels": self.common_labels(),
                        "annotations": {"config/hash": self._config_hash()},
                    },
                    "spec": {
                        "serviceAccountName": f"{self.app_name}-sa",
                        "imagePullSecrets": [{"name": "docker-registry-cred"}],
                        "containers": containers,
                    },
                },
                "strategy": {
                    "type": "RollingUpdate",
                    "rollingUpdate": {"maxSurge": 1, "maxUnavailable": 0},
                },
            },
        }

    def service_manifest(self) -> Dict:
        """
        Build a ClusterIP Service to expose internal traffic.
        """
        return {
            "apiVersion": "v1",
            "kind": "Service",
            "metadata": {
                "name": f"{self.app_name}-svc",
                "namespace": self.namespace,
                "labels": self.common_labels(),
            },
            "spec": {
                "selector": self.common_labels(),
                "ports": [
                    {
                        "name": port.name,
                        "port": port.container_port,
                        "targetPort": port.container_port,
                    }
                    for port in self.ports
                ],
                "type": "ClusterIP",
            },
        }

    def network_policy_manifest(self) -> Optional[Dict]:
        """
        A default-deny egress NetworkPolicy that enforces zero-trust
        from day one.
        """
        if not self.enable_network_policy:
            return None
        return {
            "apiVersion": "networking.k8s.io/v1",
            "kind": "NetworkPolicy",
            "metadata": {
                "name": f"{self.app_name}-deny-all-egress",
                "namespace": self.namespace,
            },
            "spec": {
                "podSelector": {"matchLabels": self.common_labels()},
                "policyTypes": ["Egress"],
                "egress": [],  # Explicitly allow nothing; allow-lists live elsewhere.
            },
        }

    def to_yaml(self) -> str:
        """
        Render the aggregated Kubernetes manifests as multi-document YAML.
        """
        manifests = [
            self.deployment_manifest(),
            self.service_manifest(),
            self.network_policy_manifest(),
        ]
        # Filter out Nones
        manifests = [m for m in manifests if m]
        return yaml.safe_dump_all(
            manifests,
            sort_keys=False,
            explicit_start=True,
            default_flow_style=False,
        )

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def common_labels(self) -> Dict[str, str]:
        return {
            "app": self.app_name,
            "component": "crowdpod",
            "managed-by": "crowdpay-connect",
        }

    def _config_hash(self) -> str:
        """
        Deterministic hash used to force rollout on config/environment change.
        """
        composite = "|".join(
            f"{e.name}={e.value}" for e in sorted(self.env_vars, key=lambda ev: ev.name)
        )
        return _hashlib.sha256(composite.encode()).hexdigest()[:16]


# --------------------------------------------------------------------------- #
# CLI Helpers
# --------------------------------------------------------------------------- #
def _parse_args(argv: Optional[List[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate Kubernetes manifests for CrowdPay Connect CrowdPod."
    )
    parser.add_argument(
        "--image",
        required=True,
        help="Container image (e.g. ghcr.io/crowdpay/connect/crowdpod:1.4.2)",
    )
    parser.add_argument(
        "--replicas",
        type=int,
        default=2,
        help="Number of Deployment replicas (default: 2)",
    )
    parser.add_argument(
        "--env",
        action="append",
        default=[],
        metavar="KEY=VALUE",
        help="Environment variables. May be specified multiple times.",
    )
    parser.add_argument(
        "--namespace",
        default="crowdpay",
        help="Target Kubernetes namespace (default: crowdpay)",
    )
    parser.add_argument(
        "--disable-np",
        action="store_true",
        help="Disable default NetworkPolicy generation",
    )
    parser.add_argument(
        "--output", "-o", type=_pl.Path, help="Write output to file instead of STDOUT"
    )
    return parser.parse_args(argv)


def _parse_env_vars(raw_env: List[str]) -> List[EnvVar]:
    env_objects: List[EnvVar] = []
    for raw in raw_env:
        if "=" not in raw:
            raise ValueError(f"Invalid env var '{raw}'; expected KEY=VALUE.")
        key, value = raw.split("=", 1)
        env_objects.append(EnvVar(name=key, value=value))
    return env_objects


# --------------------------------------------------------------------------- #
# Entrypoint
# --------------------------------------------------------------------------- #
def main(argv: Optional[List[str]] = None) -> None:
    args = _parse_args(argv)

    try:
        env_vars = _parse_env_vars(args.env)
    except ValueError as exc:  # pragma: no cover
        print(f"[ERROR] {exc}", file=sys.stderr)
        sys.exit(2)

    config = DeploymentConfig(
        app_name="crowdpod-service",
        docker_image=args.image,
        replicas=args.replicas,
        env_vars=env_vars,
        enable_network_policy=not args.disable_np,
        namespace=args.namespace,
    )

    yaml_output = (
        "# -----------------------------------------------------------------\n"
        "# ⚠️  AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.\n"
        f"#     Generated on: {_dt.datetime.utcnow().isoformat()}Z\n"
        "# -----------------------------------------------------------------\n\n"
        + config.to_yaml()
    )

    if args.output:
        args.output.write_text(yaml_output)
        print(f"[+] Manifest written to {args.output}")
    else:
        print(yaml_output)


if __name__ == "__main__":  # pragma: no cover
    main()
```