```python
#!/usr/bin/env python3
"""
CrowdPay Connect – Kubernetes Namespace Provisioning Utility
------------------------------------------------------------

This script guarantees the presence (idempotently) of the Kubernetes
Namespace required by the CrowdPay Connect platform.  It can:

1.  Apply the namespace (create or patch labels/annotations in-cluster)
2.  Render a compliant YAML manifest for GitOps/preview purposes

Although the file is stored under `infra/k8s/00-namespace.yaml`,
it contains executable Python so that it can be invoked directly
from CI/CD pipelines (e.g., GitHub Actions, Argo Workflows, Jenkins).

Usage
~~~~~
    ./00-namespace.yaml apply                 # Apply to the current cluster
    ./00-namespace.yaml apply --context prod  # Apply to a specific context
    ./00-namespace.yaml render                # Print YAML to stdout

Requirements
~~~~~~~~~~~~
    pip install kubernetes pyyaml

Security & Compliance
~~~~~~~~~~~~~~~~~~~~~
• RBAC: The ServiceAccount/identity executing this script must have:
        - get, create, patch permissions for namespaces.
• Audit-Trail: All operations are logged and kube-API responses captured.
• Policy: Labels/annotations drive network-policies and OPA/Gatekeeper
          constraints across environments.
"""

from __future__ import annotations

import argparse
import logging
import os
import sys
from datetime import datetime
from typing import Any, Dict, Optional

try:
    # Third-party deps
    from kubernetes import client as k8s_client
    from kubernetes.client import V1Namespace, V1NamespaceMetadata
    from kubernetes.config import load_incluster_config, load_kube_config
    import yaml
except ImportError as exc:  # pragma: no cover
    missing = str(exc).split("'")[-2]
    sys.stderr.write(
        f"[ERROR] Missing dependency '{missing}'. "
        "Run `pip install kubernetes pyyaml` and retry.\n"
    )
    sys.exit(1)

###############################################################################
# Configuration
###############################################################################

DEFAULT_NAMESPACE = "crowdpay-connect"
DEFAULT_LABELS: Dict[str, str] = {
    "app.kubernetes.io/managed-by": "crowdpay-connect-infra",
    "app.kubernetes.io/component": "platform",
    "app.kubernetes.io/part-of": "crowdpay-connect",
}
DEFAULT_ANNOTATIONS: Dict[str, str] = {
    "crowdpay/connect.git.sha": os.getenv("GIT_SHA", "unknown"),
    "crowdpay/connect.provisioned-at": datetime.utcnow().isoformat() + "Z",
}

LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
logging.basicConfig(
    level=LOG_LEVEL,
    format="%(asctime)s | %(levelname)-8s | %(message)s",
    datefmt="%Y-%m-%dT%H:%M:%S%z",
)
logger = logging.getLogger("crowdpay.connect.namespace")


###############################################################################
# Kubernetes Helpers
###############################################################################


def _load_kube_credentials(context: Optional[str] = None) -> None:
    """
    Load Kubernetes configuration.

    1. Within the cluster: service-account token & CA.
    2. Otherwise: fall back to local kubeconfig (for CI or developer machines).
    """
    try:
        load_incluster_config()
        logger.debug("Loaded in-cluster Kubernetes configuration")
    except k8s_client.exceptions.ConfigException:
        logger.debug("In-cluster config not found, falling back to ~/.kube/config")
        load_kube_config(context=context or os.getenv("KUBE_CONTEXT"))
        logger.debug("Loaded kubeconfig for context '%s'", context or "current")


def _namespace_exists(api: k8s_client.CoreV1Api, name: str) -> bool:
    try:
        api.read_namespace(name=name)
        return True
    except k8s_client.exceptions.ApiException as exc:
        if exc.status == 404:
            return False
        logger.exception("Unexpected error while checking namespace '%s': %s", name, exc)
        raise


###############################################################################
# Core logic
###############################################################################


def ensure_namespace(
    name: str,
    labels: Dict[str, str],
    annotations: Dict[str, str],
    context: Optional[str] = None,
) -> None:
    """
    Ensure that the specified namespace exists with the desired metadata.
    This operation is idempotent.

    Parameters
    ----------
    name : str
        The namespace to create/update.
    labels : dict
        Labels to apply.
    annotations : dict
        Annotations to apply.
    context : str, optional
        The kube-context to target (ignored when running in-cluster).
    """
    _load_kube_credentials(context)
    api = k8s_client.CoreV1Api()

    if _namespace_exists(api, name):
        logger.info("Namespace '%s' already exists. Patching metadata…", name)
        body = {
            "metadata": {
                "labels": labels,
                "annotations": annotations,
            }
        }
        api.patch_namespace(name=name, body=body)
        logger.info("Namespace '%s' patched successfully", name)
    else:
        logger.info("Creating namespace '%s'…", name)
        ns = V1Namespace(
            metadata=V1NamespaceMetadata(name=name, labels=labels, annotations=annotations)
        )
        api.create_namespace(body=ns)
        logger.info("Namespace '%s' created successfully", name)


###############################################################################
# YAML Manifest Renderer (for GitOps / Preview)
###############################################################################


def render_manifest(
    name: str,
    labels: Dict[str, str],
    annotations: Dict[str, str],
    stream: Any = sys.stdout,
) -> None:
    """
    Render the Namespace as a YAML document.

    Note: The output is compatible with `kubectl apply -f -`.

    Example:
        ./00-namespace.yaml render | kubectl apply -f -
    """
    manifest = {
        "apiVersion": "v1",
        "kind": "Namespace",
        "metadata": {
            "name": name,
            "labels": labels,
            "annotations": annotations,
        },
    }
    yaml.safe_dump(manifest, stream, sort_keys=False)
    stream.write("---\n")  # Separator (useful if concatenating manifests)


###############################################################################
# CLI
###############################################################################


def _parse_args(argv: Optional[list[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Provision or render the CrowdPay Connect Kubernetes Namespace"
    )
    subparsers = parser.add_subparsers(
        dest="command", required=True, help="Action to perform"
    )

    # Apply sub-command
    apply_cmd = subparsers.add_parser("apply", help="Create or patch the namespace")
    apply_cmd.add_argument(
        "--name", default=DEFAULT_NAMESPACE, help="Target namespace name"
    )
    apply_cmd.add_argument(
        "--context",
        default=None,
        help="Kube-context (ignored if running inside cluster)",
    )

    # Render sub-command
    render_cmd = subparsers.add_parser("render", help="Output YAML manifest")
    render_cmd.add_argument(
        "--name", default=DEFAULT_NAMESPACE, help="Namespace name to render"
    )
    render_cmd.add_argument(
        "--output",
        "-o",
        default="-",
        help="Output file path (default: stdout)",
    )

    return parser.parse_args(argv)


def main(argv: Optional[list[str]] = None) -> None:  # entry-point
    args = _parse_args(argv)

    if args.command == "apply":
        ensure_namespace(
            name=args.name,
            labels=DEFAULT_LABELS,
            annotations=DEFAULT_ANNOTATIONS,
            context=args.context,
        )
    elif args.command == "render":
        # Determine destination stream
        if args.output == "-" or args.output.lower() == "stdout":
            stream = sys.stdout
        else:
            stream = open(args.output, "w", encoding="utf-8")  # noqa: PTH123
        try:
            render_manifest(
                name=args.name,
                labels=DEFAULT_LABELS,
                annotations=DEFAULT_ANNOTATIONS,
                stream=stream,
            )
            logger.info("Manifest rendered to %s", args.output)
        finally:
            if stream is not sys.stdout:
                stream.close()


if __name__ == "__main__":  # pragma: no cover
    try:
        main()
    except KeyboardInterrupt:
        logger.warning("Operation interrupted by user")
        sys.exit(130)
    except k8s_client.exceptions.ApiException as exc:
        logger.error("Kubernetes API error: %s", exc)
        sys.exit(exc.status or 1)
    except Exception as exc:  # pylint: disable=broad-except
        logger.exception("Unhandled exception: %s", exc)
        sys.exit(1)
```