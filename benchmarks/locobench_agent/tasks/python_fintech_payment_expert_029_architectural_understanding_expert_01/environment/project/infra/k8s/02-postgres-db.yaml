```python
"""
crowdpay_connect/infra/k8s/02_postgres_db.py
===========================================

Utility script that (a) renders a production-ready Kubernetes manifest for the
CrowdPay Connect PostgreSQL database and (b) optionally applies it to the
cluster.  Keeping the manifest under version control while generating it
programmatically guarantees consistency with environment-specific parameters
(e.g., namespaces, storage classes, passwords) and supports drift detection in
CI/CD pipelines.

Run `python 02_postgres_db.py --help` for usage instructions.

Dependencies
------------
- PyYAML        (`pip install pyyaml`)
- kubernetes    (`pip install kubernetes`)  # optional, only required for --apply
"""

from __future__ import annotations

import argparse
import base64
import logging
import os
import secrets
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List

import yaml

try:
    # Optional dependency, only needed if the user passes --apply
    from kubernetes import client as k8s_client
    from kubernetes import config as k8s_config
    from kubernetes.client.rest import ApiException
except ImportError:  # pragma: no cover
    k8s_client = None  # type: ignore
    k8s_config = None  # type: ignore


###############################################################################
# Logging configuration
###############################################################################

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger("crowdpay.k8s.postgres")


###############################################################################
# Domain models
###############################################################################

@dataclass
class PostgresConfig:
    """
    Declarative configuration for the PostgreSQL statefulset.
    All fields are environment-specific and should be provided by a higher-level
    config manager (e.g., HashiCorp Vault, AWS SSM, or GitHub secrets).
    """

    name: str = "crowdpay-postgres"
    namespace: str = "crowdpay-connect"
    image: str = "postgres:15.3-alpine"
    replicas: int = 1
    storage_size_gi: int = 20
    storage_class_name: str = "standard"  # Adjust to your cluster class
    port: int = 5432

    db_name: str = "crowdpay"
    db_user: str = "crowdpay_app"
    db_password: str | None = None  # None triggers random password
    superuser_password: str | None = None  # None triggers random password

    backup_enabled: bool = True
    backup_bucket: str = "s3://crowdpay-pg-backups"
    backup_cron: str = "0 3 * * *"  # Everyday at 03:00

    extra_env: Dict[str, str] = field(default_factory=dict)

    def __post_init__(self) -> None:
        if self.db_password is None:
            self.db_password = secrets.token_urlsafe(24)
            logger.info("Generated random DB password")

        if self.superuser_password is None:
            self.superuser_password = secrets.token_urlsafe(24)
            logger.info("Generated random superuser password")


###############################################################################
# YAML Helpers
###############################################################################

def _encode_b64(value: str) -> str:
    """Base64-encodes a plaintext string for use in Kubernetes Secrets."""
    return base64.b64encode(value.encode("utf-8")).decode("utf-8")


def _k8s_metadata(name: str, namespace: str, labels: Dict[str, str] | None = None):
    base = {
        "name": name,
        "namespace": namespace,
        "labels": {"app.kubernetes.io/part-of": "crowdpay-connect", **(labels or {})},
    }
    return base


###############################################################################
# Manifest builder
###############################################################################

class PostgresManifestBuilder:
    """
    Convert a PostgresConfig instance into a list of Kubernetes objects that
    can be dumped into a single YAML multi-document file.
    """

    def __init__(self, cfg: PostgresConfig):
        self.cfg = cfg

    # --------------------------------------------------------------------- #
    # High-level builder API
    # --------------------------------------------------------------------- #
    def build(self) -> List[Dict]:
        logger.debug("Building Kubernetes manifest for PostgreSQL")
        objects: List[Dict] = []

        objects.append(self._build_secret())
        objects.append(self._build_stateful_set())
        objects.append(self._build_service())

        if self.cfg.backup_enabled:
            objects.append(self._build_backup_cronjob())

        return objects

    # --------------------------------------------------------------------- #
    # Individual Kubernetes resources
    # --------------------------------------------------------------------- #
    def _build_secret(self) -> Dict:
        cfg = self.cfg
        secret = {
            "apiVersion": "v1",
            "kind": "Secret",
            "metadata": _k8s_metadata(f"{cfg.name}-secret", cfg.namespace),
            "type": "Opaque",
            "data": {
                "POSTGRES_DB": _encode_b64(cfg.db_name),
                "POSTGRES_USER": _encode_b64(cfg.db_user),
                "POSTGRES_PASSWORD": _encode_b64(cfg.db_password),
                "POSTGRES_SUPERUSER_PASSWORD": _encode_b64(cfg.superuser_password),
            },
        }
        logger.debug("Built Secret resource")
        return secret

    def _build_stateful_set(self) -> Dict:
        cfg = self.cfg
        sts = {
            "apiVersion": "apps/v1",
            "kind": "StatefulSet",
            "metadata": _k8s_metadata(cfg.name, cfg.namespace),
            "spec": {
                "serviceName": f"{cfg.name}",  # Headless service is created
                "replicas": cfg.replicas,
                "selector": {"matchLabels": {"app": cfg.name}},
                "template": {
                    "metadata": {
                        "labels": {
                            "app": cfg.name,
                            "role": "database",
                            "tier": "backend",
                        }
                    },
                    "spec": {
                        "containers": [
                            {
                                "name": "postgres",
                                "image": cfg.image,
                                "imagePullPolicy": "IfNotPresent",
                                "ports": [{"containerPort": cfg.port, "name": "postgres"}],
                                "env": [
                                    {
                                        "name": "POSTGRES_DB",
                                        "valueFrom": {
                                            "secretKeyRef": {
                                                "name": f"{cfg.name}-secret",
                                                "key": "POSTGRES_DB",
                                            }
                                        },
                                    },
                                    {
                                        "name": "POSTGRES_USER",
                                        "valueFrom": {
                                            "secretKeyRef": {
                                                "name": f"{cfg.name}-secret",
                                                "key": "POSTGRES_USER",
                                            }
                                        },
                                    },
                                    {
                                        "name": "POSTGRES_PASSWORD",
                                        "valueFrom": {
                                            "secretKeyRef": {
                                                "name": f"{cfg.name}-secret",
                                                "key": "POSTGRES_PASSWORD",
                                            }
                                        },
                                    },
                                    *[
                                        {"name": k, "value": v}
                                        for k, v in cfg.extra_env.items()
                                    ],
                                ],
                                "volumeMounts": [
                                    {
                                        "name": "data",
                                        "mountPath": "/var/lib/postgresql/data",
                                    }
                                ],
                                "livenessProbe": {
                                    "tcpSocket": {"port": cfg.port},
                                    "initialDelaySeconds": 30,
                                    "periodSeconds": 15,
                                },
                                "readinessProbe": {
                                    "tcpSocket": {"port": cfg.port},
                                    "initialDelaySeconds": 5,
                                    "periodSeconds": 10,
                                },
                                "resources": {
                                    "requests": {"cpu": "250m", "memory": "512Mi"},
                                    "limits": {"cpu": "1", "memory": "1Gi"},
                                },
                            }
                        ],
                    },
                },
                "volumeClaimTemplates": [
                    {
                        "metadata": {"name": "data"},
                        "spec": {
                            "accessModes": ["ReadWriteOnce"],
                            "storageClassName": cfg.storage_class_name,
                            "resources": {
                                "requests": {
                                    "storage": f"{cfg.storage_size_gi}Gi"
                                }
                            },
                        },
                    }
                ],
            },
        }
        logger.debug("Built StatefulSet resource")
        return sts

    def _build_service(self) -> Dict:
        cfg = self.cfg
        svc = {
            "apiVersion": "v1",
            "kind": "Service",
            "metadata": _k8s_metadata(cfg.name, cfg.namespace),
            "spec": {
                "type": "ClusterIP",
                "ports": [{"port": cfg.port, "targetPort": cfg.port, "name": "postgres"}],
                "selector": {"app": cfg.name},
            },
        }
        logger.debug("Built Service resource")
        return svc

    def _build_backup_cronjob(self) -> Dict:
        cfg = self.cfg
        cron = {
            "apiVersion": "batch/v1",
            "kind": "CronJob",
            "metadata": _k8s_metadata(f"{cfg.name}-backup", cfg.namespace),
            "spec": {
                "schedule": cfg.backup_cron,
                "concurrencyPolicy": "Forbid",
                "jobTemplate": {
                    "spec": {
                        "template": {
                            "spec": {
                                "restartPolicy": "OnFailure",
                                "containers": [
                                    {
                                        "name": "pg-backup",
                                        "image": "postgres:15.3-alpine",
                                        "imagePullPolicy": "IfNotPresent",
                                        "env": [
                                            {
                                                "name": "PGHOST",
                                                "value": f"{cfg.name}",
                                            },
                                            {
                                                "name": "PGPORT",
                                                "value": str(cfg.port),
                                            },
                                            {
                                                "name": "PGDATABASE",
                                                "valueFrom": {
                                                    "secretKeyRef": {
                                                        "name": f"{cfg.name}-secret",
                                                        "key": "POSTGRES_DB",
                                                    }
                                                },
                                            },
                                            {
                                                "name": "PGUSER",
                                                "valueFrom": {
                                                    "secretKeyRef": {
                                                        "name": f"{cfg.name}-secret",
                                                        "key": "POSTGRES_USER",
                                                    }
                                                },
                                            },
                                            {
                                                "name": "PGPASSWORD",
                                                "valueFrom": {
                                                    "secretKeyRef": {
                                                        "name": f"{cfg.name}-secret",
                                                        "key": "POSTGRES_PASSWORD",
                                                    }
                                                },
                                            },
                                            {"name": "BACKUP_BUCKET", "value": cfg.backup_bucket},
                                        ],
                                        "command": [
                                            "/bin/sh",
                                            "-c",
                                            "pg_dumpall -f /backups/backup.sql && "
                                            "tar -czf /backups/backup.tar.gz /backups/backup.sql && "
                                            "aws s3 cp /backups/backup.tar.gz ${BACKUP_BUCKET}/$(date +%F_%T).tar.gz",
                                        ],
                                        "volumeMounts": [
                                            {"name": "backup", "mountPath": "/backups"}
                                        ],
                                    }
                                ],
                                "volumes": [
                                    {
                                        "name": "backup",
                                        "emptyDir": {},  # ephemeral, only needs to exist during job run
                                    }
                                ],
                            }
                        }
                    }
                },
            },
        }
        logger.debug("Built CronJob resource")
        return cron


###############################################################################
# Orchestrator functions
###############################################################################

def dump_yaml(resource_list: List[Dict]) -> str:
    """
    Serializes a list of Kubernetes resources into a multi-document YAML string.
    """
    return "\n---\n".join(
        yaml.safe_dump(obj, sort_keys=False) for obj in resource_list
    ) + "\n"


def save_yaml_to_file(content: str, file_path: Path) -> None:
    """
    Persists YAML content to disk in an atomic manner to avoid partial writes.
    """
    tmp_path = file_path.with_suffix(".tmp")
    tmp_path.write_text(content, encoding="utf-8")
    tmp_path.replace(file_path)
    logger.info("Wrote manifest to %s", file_path)


def apply_to_cluster(resource_list: List[Dict]) -> None:  # pragma: no cover
    """
    Applies the manifest list to the Kubernetes cluster using the official
    Python client. Similar to `kubectl apply` but without shelling out.
    """
    if k8s_client is None:
        logger.error(
            "kubernetes client library not installed. "
            "Run `pip install kubernetes` or remove --apply."
        )
        sys.exit(1)

    try:
        k8s_config.load_kube_config()  # Search KUBECONFIG or in-cluster config
    except Exception as exc:
        logger.error("Failed to load kube config: %s", exc)
        sys.exit(1)

    api_client = k8s_client.ApiClient()

    for obj in resource_list:
        kind = obj["kind"]
        api_version = obj["apiVersion"]
        namespace = obj["metadata"].get("namespace", "default")

        # Generic dynamic apply using server-side apply (SSA)
        try:
            k8s_client.CustomObjectsApi(api_client).patch_namespaced_custom_object(
                group=api_version.split("/")[0] if "/" in api_version else "",
                version=api_version.split("/")[1] if "/" in api_version else "v1",
                namespace=namespace,
                plural=_kind_to_plural(kind),
                name=obj["metadata"]["name"],
                body=obj,
                field_manager="crowdpay-connect-ssa",
                force=True,
            )
            logger.info("Applied %s/%s (%s)", kind, obj["metadata"]["name"], namespace)
        except ApiException as exc:
            if exc.status == 404:
                _create_object(api_client, obj, namespace)
            else:
                logger.error(
                    "Failed to apply %s/%s: %s", kind, obj["metadata"]["name"], exc
                )
                raise


def _kind_to_plural(kind: str) -> str:  # pragma: no cover
    """
    Very naive pluralization for Kubernetes resources. Handles common kinds.
    For unrecognized kinds, appends 's'.
    """
    mapping = {
        "Secret": "secrets",
        "Service": "services",
        "StatefulSet": "statefulsets",
        "Deployment": "deployments",
        "CronJob": "cronjobs",
        "ConfigMap": "configmaps",
    }
    return mapping.get(kind, kind.lower() + "s")


def _create_object(api_client, obj, namespace) -> None:  # pragma: no cover
    kind = obj["kind"]
    logger.debug("Creating %s/%s because it does not exist", kind, obj["metadata"]["name"])
    if kind == "Secret":
        k8s_client.CoreV1Api(api_client).create_namespaced_secret(namespace, obj)
    elif kind == "Service":
        k8s_client.CoreV1Api(api_client).create_namespaced_service(namespace, obj)
    elif kind == "StatefulSet":
        k8s_client.AppsV1Api(api_client).create_namespaced_stateful_set(namespace, obj)
    elif kind == "CronJob":
        k8s_client.BatchV1Api(api_client).create_namespaced_cron_job(namespace, obj)
    else:
        raise NotImplementedError(f"Create for kind {kind} not implemented")


###############################################################################
# CLI
###############################################################################

def parse_args(argv: List[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate k8s manifest for CrowdPay PostgreSQL DB")
    parser.add_argument(
        "--namespace",
        default=os.getenv("CROWD_NAMESPACE", "crowdpay-connect"),
        help="Kubernetes namespace to deploy into",
    )
    parser.add_argument(
        "--image",
        default=os.getenv("POSTGRES_IMAGE", "postgres:15.3-alpine"),
        help="PostgreSQL container image",
    )
    parser.add_argument(
        "--storage-size",
        type=int,
        default=int(os.getenv("POSTGRES_STORAGE_GI", "20")),
        help="PersistentVolume size in Gi",
    )
    parser.add_argument(
        "--storage-class",
        default=os.getenv("POSTGRES_STORAGE_CLASS", "standard"),
        help="StorageClass to use for the PVC",
    )
    parser.add_argument(
        "--replicas",
        type=int,
        default=int(os.getenv("POSTGRES_REPLICAS", "1")),
        help="Number of PostgreSQL replicas (statefulset pods)",
    )
    parser.add_argument(
        "--out",
        type=Path,
        default=Path.cwd() / "02-postgres-db.yaml",
        help="Path to write the generated manifest",
    )
    parser.add_argument(
        "--apply",
        action="store_true",
        help="Directly apply the manifest to the current Kubernetes context",
    )
    return parser.parse_args(argv)


def main(argv: List[str] | None = None) -> None:  # pragma: no cover
    args = parse_args(argv)

    cfg = PostgresConfig(
        namespace=args.namespace,
        image=args.image,
        storage_size_gi=args.storage_size,
        storage_class_name=args.storage_class,
        replicas=args.replicas,
    )

    builder = PostgresManifestBuilder(cfg)
    manifest_objects = builder.build()
    yaml_content = dump_yaml(manifest_objects)

    save_yaml_to_file(yaml_content, args.out)

    if args.apply:
        apply_to_cluster(manifest_objects)


if __name__ == "__main__":  # pragma: no cover
    try:
        main()
    except KeyboardInterrupt:
        logger.warning("Interrupted by user")
        sys.exit(130)
```