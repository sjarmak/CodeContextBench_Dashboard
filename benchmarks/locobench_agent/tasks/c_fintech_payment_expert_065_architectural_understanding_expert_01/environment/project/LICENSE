/*
 * =====================================================================================
 *  EduPay Ledger Academy - License Verification Sub-system
 *  File:    LICENSE   (yes, we purposefully keep executable code under this name so
 *                     that students learn that a “license” is more than a text block.)
 *
 *  Description:
 *      Provides run-time validation of cryptographically signed product licenses.
 *      The license “blob” is shipped to institutions and loaded during start-up.
 *      It contains:
 *
 *          EDU_PAY_LICENSE
 *          org=University of Example
 *          issued=2024-03-15T12:34:56Z
 *          expires=2025-03-15T00:00:00Z
 *          features=payment_processing,multi_currency,regulatory_compliance
 *          signature=BASE64(RSA-SHA256 signature of all previous lines)
 *
 *      The public key is embedded below; private key is held by EduPay operations.
 *
 *  Build:
 *      gcc -Wall -Wextra -pedantic -std=c11 -lcrypto -o license_test LICENSE
 *
 *  Copyright:
 *      © 2024 EduPay Ledger Academy – All Rights Reserved
 *      SPDX-License-Identifier: BUSL-1.1
 * =====================================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdbool.h>
#include <ctype.h>
#include <pthread.h>
#include <errno.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>

#define LICENSE_BANNER          "EDU_PAY_LICENSE"
#define MAX_FEATURES            32
#define MAX_FEATURE_LEN         64
#define MAX_ERR_LEN             256
#define DATE_FMT_LEN            20      /* yyyy-mm-ddThh:mm:ssZ */
#define SIG_FIELD               "signature="

/* =====================================================================================
 *                           Static / Global State
 * =====================================================================================
 */

typedef struct {
    char  organisation[128];
    time_t issued;
    time_t expires;
    char  features[MAX_FEATURES][MAX_FEATURE_LEN];
    size_t feature_cnt;
    bool  valid;
} lic_ctx_t;

static lic_ctx_t g_ctx;
static char      g_last_error[MAX_ERR_LEN];
static pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;

/* Public RSA-2048 Key (PEM) */
static const char *PUBLIC_KEY_PEM =
        "-----BEGIN PUBLIC KEY-----\n"
        "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwW5p9Gf4bm/FYnGV8eK3\n"
        "uDdGztqKqRR3YKHyCuXapnwXCfJOLwObEWj1vDLteA94ppIqh+apMI2vlA38nSxr\n"
        "idK4USsfx8bVsgcuyo6edSxnl2xe50Tzw9uQWGWpZ6YG1ChcxrFAuo0xO+ogzAm8\n"
        "xHn0pV3hokW2N1GpStO2Qd6hw2yYB9H9n1tFoZT3zh0+BTtPlqvGjufH6G+jD/ad\n"
        "zi10BGi7ipo+nWQBaIj++ImQxGc1dQc5sKXc5teLoI0lp4rWuIwoMvV7lidh+NRO\n"
        "4tW7x1YgnPZXoqBYwygJyI072QtdgQXl3k5iADG7n2AFDzy83H8XTur2qxGn8pYt\n"
        "RQIDAQAB\n"
        "-----END PUBLIC KEY-----\n";

/* =====================================================================================
 *                               Utility Helpers
 * =====================================================================================
 */
static void set_error(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vsnprintf(g_last_error, sizeof g_last_error, fmt, ap);
    va_end(ap);
}

static bool starts_with(const char *str, const char *prefix)
{
    return strncmp(str, prefix, strlen(prefix)) == 0;
}

/* Trim leading/trailing whitespace (in-place) */
static char *trim(char *s)
{
    char *end;
    while (isspace((unsigned char)*s)) s++;
    if (*s == '\0') return s;
    end = s + strlen(s) - 1;
    while (end > s && isspace((unsigned char)*end)) end--;
    end[1] = '\0';
    return s;
}

/* Parse RFC 3339 date to time_t (UTC) */
static bool parse_iso8601(const char *str, time_t *out)
{
    struct tm t = {0};
    if (strlen(str) != 20 || str[10] != 'T' || str[19] != 'Z')
        return false;

    if (sscanf(str, "%4d-%2d-%2dT%2d:%2d:%2dZ",
               &t.tm_year, &t.tm_mon, &t.tm_mday,
               &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)
        return false;

    t.tm_year -= 1900;
    t.tm_mon  -= 1;
    *out = timegm(&t);     /* GNU extension */
    return true;
}

/* Base64 decode using OpenSSL */
static unsigned char *b64_decode(const char *input, size_t *out_len)
{
    BIO *bio, *b64;
    size_t in_len = strlen(input);
    unsigned char *buffer = malloc(in_len);   /* Worst case */
    if (!buffer) return NULL;

    bio = BIO_new_mem_buf((void*)input, (int)in_len);
    b64 = BIO_new(BIO_f_base64());
    if (!bio || !b64) goto err;

    bio = BIO_push(b64, bio);
    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);

    *out_len = BIO_read(bio, buffer, (int)in_len);
    if (*out_len <= 0) goto err;

    BIO_free_all(bio);
    return buffer;
err:
    if (bio) BIO_free_all(bio);
    free(buffer);
    return NULL;
}

/* Verify RSA-SHA256 signature */
static bool verify_signature(const unsigned char *data, size_t data_len,
                             const unsigned char *sig, size_t sig_len)
{
    bool ok = false;
    EVP_PKEY *pkey = NULL;
    EVP_MD_CTX *md_ctx = NULL;
    BIO *bio = BIO_new_mem_buf((void*)PUBLIC_KEY_PEM, -1);

    if (!bio) return false;
    pkey = PEM_read_bio_PUBKEY(bio, NULL, NULL, NULL);
    BIO_free(bio);
    if (!pkey) goto clean;

    md_ctx = EVP_MD_CTX_create();
    if (!md_ctx) goto clean;

    if (EVP_DigestVerifyInit(md_ctx, NULL, EVP_sha256(), NULL, pkey) != 1)
        goto clean;

    if (EVP_DigestVerifyUpdate(md_ctx, data, data_len) != 1)
        goto clean;

    if (EVP_DigestVerifyFinal(md_ctx, sig, sig_len) == 1)
        ok = true;

clean:
    if (md_ctx) EVP_MD_CTX_destroy(md_ctx);
    if (pkey) EVP_PKEY_free(pkey);
    return ok;
}

/* =====================================================================================
 *                         Core License Parsing / Validation
 * =====================================================================================
 */
static bool parse_and_validate(const char *blob, size_t blob_len)
{
    /* Split lines */
    char *buf = strndup(blob, blob_len);
    if (!buf) {
        set_error("Memory allocation failure");
        return false;
    }

    char *signature_b64 = NULL;
    char *saveptr = NULL;
    char *lines[64];
    size_t line_cnt = 0;

    char *line = strtok_r(buf, "\n", &saveptr);
    while (line && line_cnt < 64) {
        lines[line_cnt++] = line;
        line = strtok_r(NULL, "\n", &saveptr);
    }

    /* Must begin with banner */
    if (line_cnt == 0 || strcmp(trim(lines[0]), LICENSE_BANNER) != 0) {
        set_error("License missing header banner");
        free(buf);
        return false;
    }

    /* Buffer holding data for signature verification (all lines before signature) */
    size_t   data_cap = blob_len;
    unsigned char *data_buf = malloc(data_cap);
    size_t   data_len = 0;

    if (!data_buf) {
        set_error("Memory allocation failure");
        free(buf);
        return false;
    }

    for (size_t i = 1; i < line_cnt; ++i) {
        char *kv = trim(lines[i]);

        if (starts_with(kv, SIG_FIELD)) {
            signature_b64 = kv + strlen(SIG_FIELD);
            break;
        }

        /* Accumulate for signature verification (with newline) */
        size_t l = strlen(kv);
        memcpy(data_buf + data_len, kv, l);
        data_len += l;
        data_buf[data_len++] = '\n';

        if (starts_with(kv, "org=")) {
            strncpy(g_ctx.organisation, kv + 4, sizeof g_ctx.organisation - 1);
        } else if (starts_with(kv, "issued=")) {
            if (!parse_iso8601(kv + 7, &g_ctx.issued)) {
                set_error("Invalid issued date");
                goto bad;
            }
        } else if (starts_with(kv, "expires=")) {
            if (!parse_iso8601(kv + 8, &g_ctx.expires)) {
                set_error("Invalid expiry date");
                goto bad;
            }
        } else if (starts_with(kv, "features=")) {
            char *feat_str = kv + 9;
            char *tok, *sp = NULL;
            size_t idx = 0;
            tok = strtok_r(feat_str, ",", &sp);
            while (tok && idx < MAX_FEATURES) {
                strncpy(g_ctx.features[idx++], trim(tok), MAX_FEATURE_LEN - 1);
                tok = strtok_r(NULL, ",", &sp);
            }
            g_ctx.feature_cnt = idx;
        }
    }

    if (!signature_b64) {
        set_error("License missing signature field");
        goto bad;
    }

    /* Decode signature */
    size_t sig_len = 0;
    unsigned char *sig_buf = b64_decode(signature_b64, &sig_len);
    if (!sig_buf || sig_len == 0) {
        set_error("Unable to base64 decode signature");
        goto bad;
    }

    /* Verify signature */
    if (!verify_signature(data_buf, data_len, sig_buf, sig_len)) {
        set_error("Signature verification failed");
        free(sig_buf);
        goto bad;
    }
    free(sig_buf);

    /* Check time validity */
    time_t now = time(NULL);
    if (now < g_ctx.issued) {
        set_error("License not yet valid");
        goto bad;
    }
    if (now > g_ctx.expires) {
        set_error("License expired");
        goto bad;
    }

    g_ctx.valid = true;
    free(data_buf);
    free(buf);
    return true;

bad:
    free(data_buf);
    free(buf);
    g_ctx.valid = false;
    return false;
}

/* =====================================================================================
 *                     Public API – Thread-Safe Wrappers
 * =====================================================================================
 */

/*
 * lic_init
 *      Loads and validates a license file from disk.
 *      Returns 0 on success, negative errno style codes on failure.
 */
int lic_init(const char *license_path)
{
    if (!license_path) return -EINVAL;

    FILE *fp = fopen(license_path, "rb");
    if (!fp) {
        set_error("Cannot open license file: %s", strerror(errno));
        return -errno;
    }

    fseek(fp, 0, SEEK_END);
    long len = ftell(fp);
    rewind(fp);

    if (len <= 0) {
        fclose(fp);
        set_error("License file is empty");
        return -EINVAL;
    }

    char *buffer = malloc((size_t)len + 1);
    if (!buffer) {
        fclose(fp);
        return -ENOMEM;
    }

    if (fread(buffer, 1, (size_t)len, fp) != (size_t)len) {
        fclose(fp);
        free(buffer);
        set_error("Unable to read license file");
        return -EIO;
    }
    buffer[len] = '\0';
    fclose(fp);

    pthread_mutex_lock(&g_mutex);
    bool ok = parse_and_validate(buffer, (size_t)len);
    pthread_mutex_unlock(&g_mutex);

    free(buffer);
    return ok ? 0 : -EPERM;
}

/*
 * lic_is_feature_enabled
 *      Checks whether the given feature is licensed.
 */
bool lic_is_feature_enabled(const char *feature)
{
    if (!feature || !*feature) return false;
    bool enabled = false;

    pthread_mutex_lock(&g_mutex);
    if (g_ctx.valid) {
        for (size_t i = 0; i < g_ctx.feature_cnt; ++i) {
            if (strcmp(g_ctx.features[i], feature) == 0) {
                enabled = true;
                break;
            }
        }
    }
    pthread_mutex_unlock(&g_mutex);
    return enabled;
}

/*
 * lic_is_compliant
 *      Returns true if the license is loaded and valid.
 */
bool lic_is_compliant(void)
{
    bool ok;
    pthread_mutex_lock(&g_mutex);
    ok = g_ctx.valid;
    pthread_mutex_unlock(&g_mutex);
    return ok;
}

/*
 * lic_get_error
 *      Returns the last error message (thread-safe copy).
 */
const char *lic_get_error(char *dst, size_t dst_len)
{
    if (!dst || dst_len == 0) return NULL;
    pthread_mutex_lock(&g_mutex);
    strncpy(dst, g_last_error, dst_len - 1);
    dst[dst_len - 1] = '\0';
    pthread_mutex_unlock(&g_mutex);
    return dst;
}

/* =====================================================================================
 *                              Test Harness (optional)
 * =====================================================================================
 *
 *  Compile with ‑DLICENSE_SELFTEST to generate a simple CLI validator:
 *
 *      $ gcc LICENSE -o lic_test -DLICENSE_SELFTEST -lcrypto
 *      $ ./lic_test /path/to/license.txt
 *
 * =====================================================================================
 */

#ifdef LICENSE_SELFTEST
int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "usage: %s <license_file>\n", argv[0]);
        return EXIT_FAILURE;
    }

    int rc = lic_init(argv[1]);
    if (rc != 0) {
        char err[128];
        lic_get_error(err, sizeof err);
        fprintf(stderr, "License invalid: %s\n", err);
        return EXIT_FAILURE;
    }

    printf("License valid for: %s\n", g_ctx.organisation);
    printf("Features:\n");
    for (size_t i = 0; i < g_ctx.feature_cnt; ++i)
        printf("  • %s\n", g_ctx.features[i]);

    const char *demo_feature = "fraud_detection";
    printf("Feature '%s' is %s\n",
           demo_feature,
           lic_is_feature_enabled(demo_feature) ? "ENABLED" : "DISABLED");

    return EXIT_SUCCESS;
}
#endif  /* LICENSE_SELFTEST */

/* =====================================================================================
 *  End of file
 * =====================================================================================
 */
