/*
 * sample_event_stream.jsonl
 *
 * This C source file is intentionally stored under the data/events directory
 * because its sole purpose is to generate a realistic JSON-Lines test fixture
 * used by multiple integration- and course-level scenarios.
 *
 * Build:
 *      cc -std=c11 -Wall -Wextra -pedantic -o sample_event_stream \
 *         sample_event_stream.jsonl
 *
 * Usage:
 *      ./sample_event_stream               # writes to STDOUT
 *      ./sample_event_stream /tmp/events   # writes to /tmp/events
 *
 * Each line emitted by the program is a valid JSON document representing an
 * immutable domain event in the EduPay Ledger Academy platform.  The events
 * align with the platform’s Event-Sourcing strategy and cover typical payment
 * lifecycles (initiation → authorization → settlement → refund) along with
 * fraud-detection signals.
 */

#include <errno.h>
#include <inttypes.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* ---------------------------------------------------------------------------
 * Domain: Event Metadata
 * -------------------------------------------------------------------------*/

#define ISO8601_BUF_LEN 32 /* yyyy-MM-ddTHH:mm:ss.SSSZ\0 */
#define ID_BUF_LEN      48 /* EVT-<epoch>-<counter>\0   */
#define MAX_PAYLOAD_LEN 256

typedef enum
{
    EVT_PAYMENT_INITIATED,
    EVT_PAYMENT_AUTHORIZED,
    EVT_PAYMENT_SETTLED,
    EVT_PAYMENT_FAILED,
    EVT_FRAUD_FLAGGED,
    EVT_REFUND_INITIATED,
    EVT_REFUND_COMPLETED,
    EVT_TYPE_COUNT
} event_type_t;

/* Human-readable label for each enum value */
static const char *EVENT_TYPE_STRINGS[EVT_TYPE_COUNT] = {
    [EVT_PAYMENT_INITIATED] = "PaymentInitiated",
    [EVT_PAYMENT_AUTHORIZED] = "PaymentAuthorized",
    [EVT_PAYMENT_SETTLED]    = "PaymentSettled",
    [EVT_PAYMENT_FAILED]     = "PaymentFailed",
    [EVT_FRAUD_FLAGGED]      = "FraudFlagged",
    [EVT_REFUND_INITIATED]   = "RefundInitiated",
    [EVT_REFUND_COMPLETED]   = "RefundCompleted"};

typedef struct
{
    char         id[ID_BUF_LEN];
    char         occurred_at[ISO8601_BUF_LEN];
    const char  *correlation_id;
    event_type_t type;
    char         payload[MAX_PAYLOAD_LEN];
} event_t;

/* ---------------------------------------------------------------------------
 * Utility helpers
 * -------------------------------------------------------------------------*/

/* Return current UTC time in milliseconds since Unix epoch */
static uint64_t
utc_epoch_millis(void)
{
    struct timespec ts;
    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
    {
        perror("clock_gettime");
        exit(EXIT_FAILURE);
    }
    return (uint64_t)ts.tv_sec * 1000ULL + (uint64_t)(ts.tv_nsec / 1000000ULL);
}

/* Build ISO-8601 string with millisecond precision in UTC */
static void
iso8601_from_epoch(uint64_t epoch_ms, char *out, size_t len)
{
    time_t      sec  = (time_t)(epoch_ms / 1000ULL);
    uint16_t    msec = (uint16_t)(epoch_ms % 1000ULL);
    struct tm   tm;
    if (gmtime_r(&sec, &tm) == NULL)
    {
        perror("gmtime_r");
        exit(EXIT_FAILURE);
    }
    /* yyyy-MM-ddTHH:mm:ss.SSSZ */
    if (snprintf(out, len, "%04d-%02d-%02dT%02d:%02d:%02d.%03uZ",
                 tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour,
                 tm.tm_min, tm.tm_sec, msec) >= (int)len)
    {
        fprintf(stderr, "iso8601 buffer too small\n");
        exit(EXIT_FAILURE);
    }
}

/* Generate a deterministic but unique event id */
static void
generate_event_id(char *out, size_t len, uint64_t epoch_ms, uint32_t counter)
{
    if (snprintf(out, len, "EVT-%" PRIu64 "-%06" PRIu32, epoch_ms, counter) >=
        (int)len)
    {
        fprintf(stderr, "id buffer too small\n");
        exit(EXIT_FAILURE);
    }
}

/* Write event as a single JSON document followed by '\n' */
static void
write_event(FILE *out, const event_t *evt)
{
    if (fprintf(
            out,
            "{"
            "\"event_id\":\"%s\","
            "\"event_type\":\"%s\","
            "\"occurred_at\":\"%s\","
            "\"correlation_id\":\"%s\","
            "\"payload\":%s"
            "}\n",
            evt->id, EVENT_TYPE_STRINGS[evt->type], evt->occurred_at,
            evt->correlation_id, evt->payload) < 0)
    {
        perror("fprintf");
        exit(EXIT_FAILURE);
    }
}

/* ---------------------------------------------------------------------------
 * Scenario: Construct a canonical payment lifecycle
 * -------------------------------------------------------------------------*/

static void
emit_sample_stream(FILE *out)
{
    static uint32_t counter = 0;
    const char     *payment_id = "PAY-987654321";
    const char     *refund_id  = "REF-123456";
    const char     *tenant     = "Campus-A";

    /* Anchor the entire stream around a single point in time */
    uint64_t t0_ms = utc_epoch_millis();

    /* Helper macro to push events with incremental timestamps */
#define PUSH_EVENT(_evt, _delta_ms, _type, _payload_fmt, ...)                   \
    do                                                                          \
    {                                                                           \
        event_t _evt;                                                           \
        uint64_t _ts = t0_ms + (_delta_ms);                                     \
        generate_event_id(_evt.id, sizeof(_evt.id), _ts, ++counter);            \
        iso8601_from_epoch(_ts, _evt.occurred_at, sizeof(_evt.occurred_at));    \
        _evt.correlation_id = payment_id;                                       \
        _evt.type           = (_type);                                          \
        snprintf(_evt.payload, sizeof(_evt.payload), _payload_fmt,              \
                 __VA_ARGS__);                                                  \
        write_event(out, &_evt);                                                \
    } while (0)

    /* 1. PaymentInitiated -------------------------------------------------- */
    PUSH_EVENT(evt0, 0, EVT_PAYMENT_INITIATED,
               "{"
               "\"tenant\":\"%s\","
               "\"payment_id\":\"%s\","
               "\"amount\":1250.00,"
               "\"currency\":\"USD\","
               "\"method\":\"credit_card\""
               "}",
               tenant, payment_id);

    /* 2. FraudFlagged (soft risk score) ----------------------------------- */
    PUSH_EVENT(evt1, 300, EVT_FRAUD_FLAGGED,
               "{"
               "\"payment_id\":\"%s\","
               "\"risk_score\":0.67,"
               "\"rule\":\"velocity_check\""
               "}",
               payment_id);

    /* 3. PaymentAuthorized ------------------------------------------------- */
    PUSH_EVENT(evt2, 800, EVT_PAYMENT_AUTHORIZED,
               "{"
               "\"payment_id\":\"%s\","
               "\"auth_code\":\"AUTH-564738\","
               "\"processor\":\"VISA\","
               "\"authorized_amount\":1250.00"
               "}",
               payment_id);

    /* 4. PaymentSettled ---------------------------------------------------- */
    PUSH_EVENT(evt3, 7200, EVT_PAYMENT_SETTLED,
               "{"
               "\"payment_id\":\"%s\","
               "\"settled_amount\":1250.00,"
               "\"exchange_rate\":1.00,"
               "\"settlement_batch\":\"2023-10-05-US-USD\""
               "}",
               payment_id);

    /* 5. RefundInitiated --------------------------------------------------- */
    PUSH_EVENT(evt4, 86400000, EVT_REFUND_INITIATED,
               "{"
               "\"payment_id\":\"%s\","
               "\"refund_id\":\"%s\","
               "\"amount\":1250.00,"
               "\"reason\":\"student_dropped_course\""
               "}",
               payment_id, refund_id);

    /* 6. RefundCompleted --------------------------------------------------- */
    PUSH_EVENT(evt5, 86400000 + 120000, EVT_REFUND_COMPLETED,
               "{"
               "\"payment_id\":\"%s\","
               "\"refund_id\":\"%s\","
               "\"settled_amount\":1250.00,"
               "\"processor\":\"VISA\""
               "}",
               payment_id, refund_id);

#undef PUSH_EVENT
}

/* ---------------------------------------------------------------------------
 * Program entry
 * -------------------------------------------------------------------------*/

static void
usage(const char *exe)
{
    fprintf(stderr,
            "Usage: %s [output_path]\n"
            "If no output_path is provided, events are written to STDOUT.\n",
            exe);
}

int
main(int argc, char *argv[])
{
    FILE *out = stdout;

    if (argc > 2)
    {
        usage(argv[0]);
        return EXIT_FAILURE;
    }

    if (argc == 2)
    {
        out = fopen(argv[1], "w");
        if (!out)
        {
            fprintf(stderr, "Failed to open '%s': %s\n", argv[1],
                    strerror(errno));
            return EXIT_FAILURE;
        }
    }

    emit_sample_stream(out);

    if (out != stdout)
    {
        if (fclose(out) != 0)
        {
            perror("fclose");
            return EXIT_FAILURE;
        }
    }
    return EXIT_SUCCESS;
}
