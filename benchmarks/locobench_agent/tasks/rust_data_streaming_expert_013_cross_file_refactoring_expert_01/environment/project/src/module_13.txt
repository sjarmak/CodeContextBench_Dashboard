```rust
//! ChirpPulse ‚Äì Module 13
//! -------------------------------------------------------------
//! Enrichment pipeline core + runtime-swappable strategy registry.
//!
//! This module owns:
//!   1. `SocialEvent` ‚Äì the canonical in-memory representation of a
//!      unit of social chatter we ingest from Kafka.
//!   2. `EnrichmentStage` ‚Äì the Strategy trait executed by the
//!      enrichment pipeline.  Implementations can be registered and
//!      replaced at runtime without downtime.
//!   3. `EnrichmentPipeline` ‚Äì a small, lock‚Äìfree executor that
//!      applies all currently-active stages to each event.
//!   4. A globally accessible `STAGE_REGISTRY` (DashMap) that keeps
//!      factories for strategies and allows hot-swap.
//!
//! The concrete strategies below (`LanguageDetector`,
//! `ToxicityScorer`) are deliberately simple so the example compiles
//! standalone; in production they would delegate to heavy ML models
//! (ONNX, TensorRT, etc.) via async FFI calls.
//!
//! Build: `cargo test -p chirp_pulse`
//! Runtime (illustration):
//! ```bash
//! STAGE_REGISTRY.insert("toxicity", Box::new(|| Box::new(ToxicityScorer::default())))
//! ```
//! -------------------------------------------------------------

use std::sync::Arc;
use std::time::{Duration, SystemTime};

use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use dashmap::DashMap;
use rand::Rng;
use serde::{Deserialize, Serialize};
use tokio::time;

//
// Canonical event ------------------------------------------------------------------------------

/// A social post, comment, or reaction ingested from a remote stream.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SocialEvent {
    /// Primary key from upstream.
    pub event_id: String,
    /// Raw text or caption.
    pub body: String,
    /// UTC wall-clock time the event was emitted by the producer.
    #[serde(default = "utc_now")]
    pub created_at: SystemTime,
    /// Mutating metadata created by enrichment stages.
    #[serde(default)]
    pub meta: EventMetadata,
}

fn utc_now() -> SystemTime {
    SystemTime::now()
}

/// Enrichment metadata.  Extend this struct whenever a new enrichment
/// stage is added.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct EventMetadata {
    pub lang: Option<String>,
    pub toxicity_score: Option<f32>,
}

//
// Strategy Pattern ------------------------------------------------------------------------------

/// Processing strategies operate on a single mutable event.
#[async_trait]
pub trait EnrichmentStage: Send + Sync + 'static {
    /// Human-friendly name used for metric dimensions.
    fn name(&self) -> &'static str;

    /// Apply the transformation. Implementations should be fast and
    /// non-blocking; long-running work should be awaited.
    async fn process(&self, event: &mut SocialEvent) -> Result<()>;
}

/// A factory that can build a stage at runtime.
///
/// The indirection allows us to register **blueprints** in the global
/// registry and create fresh instances without carrying state between
/// events (unless desired).
pub type StageFactory =
    dyn Fn() -> Box<dyn EnrichmentStage + Send + Sync> + Send + Sync + 'static;

//
// Example strategies ---------------------------------------------------------------------------

/// Language detector (placeholder).
#[derive(Debug, Default)]
pub struct LanguageDetector;

#[async_trait]
impl EnrichmentStage for LanguageDetector {
    fn name(&self) -> &'static str {
        "lang_detect"
    }

    async fn process(&self, event: &mut SocialEvent) -> Result<()> {
        // üõà  An actual implementation would tokenize and run an ML
        //     model.  We fake it by looking for a few Unicode ranges.
        let lang = if event.body.is_ascii() { "en" } else { "unknown" };
        event.meta.lang = Some(lang.to_string());
        Ok(())
    }
}

/// Toxicity scorer (placeholder).
#[derive(Debug, Default)]
pub struct ToxicityScorer;

#[async_trait]
impl EnrichmentStage for ToxicityScorer {
    fn name(&self) -> &'static str {
        "toxicity"
    }

    async fn process(&self, event: &mut SocialEvent) -> Result<()> {
        // ‚ö†Ô∏è  In production this would call out to Perspective, Detoxify,
        //     or an internal BERT model.  We generate a pseudo-random
        //     score strictly for demonstration purposes.
        let mut rng = rand::thread_rng();
        event.meta.toxicity_score = Some(rng.gen_range(0.0..1.0));
        Ok(())
    }
}

//
// Stage registry (hot-swap) ---------------------------------------------------------------------

lazy_static::lazy_static! {
    /// A thread-safe map from stage name ‚Üí factory. A vector of stage
    /// names defines the execution plan.  By inserting a new factory
    /// under an existing key we can hot-swap code the next time a
    /// pipeline is rebuilt.
    static ref STAGE_REGISTRY: DashMap<String, Arc<Box<StageFactory>>> = {
        let m = DashMap::new();
        // Register default strategies.
        m.insert(
            "lang_detect".into(),
            Arc::new(Box::new(|| Box::new(LanguageDetector::default())))
        );
        m.insert(
            "toxicity".into(),
            Arc::new(Box::new(|| Box::new(ToxicityScorer::default())))
        );
        m
    };
}

pub fn register_stage<S: EnrichmentStage + Default>() {
    STAGE_REGISTRY.insert(
        S::default().name().into(),
        Arc::new(Box::new(|| Box::new(S::default()))),
    );
}

pub fn unregister_stage(name: &str) -> Option<Arc<Box<StageFactory>>> {
    STAGE_REGISTRY.remove(name).map(|(_, v)| v)
}

//
// Pipeline executor ------------------------------------------------------------------------------

/// Configurable pipeline definition.  This is usually produced by
/// deserializing a TOML / JSON config stored in ZooKeeper or pushed
/// via a control plane.
#[derive(Debug, Clone)]
pub struct PipelineSpec {
    /// Ordered names of stages from `STAGE_REGISTRY` to be applied.
    pub stages: Vec<String>,
    /// If `true`, fail the entire event when any single stage errors.
    pub fail_fast: bool,
}

impl Default for PipelineSpec {
    fn default() -> Self {
        Self {
            stages: vec!["lang_detect".into(), "toxicity".into()],
            fail_fast: false,
        }
    }
}

/// An executable pipeline instance.
pub struct EnrichmentPipeline {
    spec: PipelineSpec,
    compiled: Vec<Box<dyn EnrichmentStage + Send + Sync>>,
}

impl EnrichmentPipeline {
    /// Compile a pipeline spec into concrete stage instances.
    pub fn new(spec: PipelineSpec) -> Result<Self> {
        let mut compiled = Vec::with_capacity(spec.stages.len());

        for name in &spec.stages {
            let factory = STAGE_REGISTRY
                .get(name)
                .ok_or_else(|| anyhow!("stage `{name}` not found in registry"))?;
            compiled.push((factory)());
        }

        Ok(Self { spec, compiled })
    }

    /// Pass `event` through all enrichment stages.
    ///
    /// Errors:
    ///  * Returns the first stage error when `fail_fast == true`.
    ///  * Otherwise, logs the error and continues with subsequent
    ///    stages.
    pub async fn execute(&self, mut event: SocialEvent) -> Result<SocialEvent> {
        for stage in &self.compiled {
            let name = stage.name();
            let start = SystemTime::now();

            match stage.process(&mut event).await {
                Ok(_) => {
                    let elapsed = start.elapsed().unwrap_or_default();
                    metrics::histogram!("pipeline.stage.ok_ms", elapsed.as_millis() as f64, "stage" => name);
                }
                Err(e) => {
                    metrics::increment_counter!("pipeline.stage.err", "stage" => name);
                    if self.spec.fail_fast {
                        return Err(e).with_context(|| format!("stage `{name}` failed"));
                    } else {
                        tracing::warn!(error = %e, stage = name, "stage failed (continuing)");
                    }
                }
            }
        }

        Ok(event)
    }
}

//
// Minimal demo/test ------------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn pipeline_smoke_test() -> Result<()> {
        // Build an example event.
        let mut event = SocialEvent {
            event_id: "abc123".into(),
            body: "Hello, world!".into(),
            created_at: utc_now(),
            meta: Default::default(),
        };

        // Compile a pipeline with default spec.
        let pipeline = EnrichmentPipeline::new(PipelineSpec::default())?;

        // Execute.
        event = pipeline.execute(event).await?;

        // Expectations.
        assert_eq!(event.meta.lang.as_deref(), Some("en"));
        assert!(event.meta.toxicity_score.is_some());

        Ok(())
    }

    #[tokio::test]
    async fn pipeline_fail_fast() -> Result<()> {
        // Dynamically register a bad stage to trigger failure.
        #[derive(Default)]
        struct BrokenStage;
        #[async_trait]
        impl EnrichmentStage for BrokenStage {
            fn name(&self) -> &'static str { "broken" }
            async fn process(&self, _: &mut SocialEvent) -> Result<()> {
                Err(anyhow!("intentional failure"))
            }
        }
        register_stage::<BrokenStage>();

        let spec = PipelineSpec {
            stages: vec!["broken".into(), "lang_detect".into()],
            fail_fast: true,
        };
        let pipeline = EnrichmentPipeline::new(spec)?;

        let event = SocialEvent {
            event_id: "fail".into(),
            body: "oops".into(),
            created_at: utc_now(),
            meta: Default::default(),
        };

        // The pipeline should bail out with an error.
        assert!(pipeline.execute(event).await.is_err());

        // Cleanup.
        unregister_stage("broken");
        Ok(())
    }
}

//
// Background worker (illustrative) --------------------------------------------------------------
// This is **NOT** compiled in tests and is only a blueprint for how
// you could feed events from a Kafka consumer into the pipeline.

#[allow(dead_code)]
pub async fn run_event_loop() -> Result<()> {
    // 1. Build pipeline (ideally refreshed on config topic changes).
    let pipeline = EnrichmentPipeline::new(PipelineSpec::default())?;

    // 2. In production we'd stream from rdkafka::consumer::StreamConsumer.
    //    For demo, generate a fake event every second.
    let mut ticker = time::interval(Duration::from_secs(1));

    loop {
        ticker.tick().await;

        let raw_event = SocialEvent {
            event_id: uuid::Uuid::new_v4().to_string(),
            body: "Realtime generated event üöÄ".into(),
            created_at: utc_now(),
            meta: Default::default(),
        };

        match pipeline.execute(raw_event).await {
            Ok(enriched) => {
                tracing::info!(?enriched, "event enriched");
                // ‚ûú produce to Kafka / Iceberg writer here
            }
            Err(e) => tracing::error!(error = %e, "failed to enrich event"),
        }
    }
}
```