```rust
//! src/module_36.rs
//!
//! Sentiment engine with hot-swappable algorithms.
//!
//! This module consumes raw social events from Kafka, enriches them with a
//! sentiment score (algorithm chosen at runtime), and then republishes the
//! enriched record downstream.
//!
//! The engine demonstrates a production-grade implementation of the Strategy
//! pattern with zero-downtime algorithm swaps through `arc-swap`.

// ================ Crate Dependencies =================
//
// tokio               = { version = "1",   features = ["rt-multi-thread", "macros"] }
// rdkafka             = { version = "0.36", features = ["cmake-build"] }
// arc-swap            = "1.7"
// async-trait         = "0.1"
// serde               = { version = "1.0", features = ["derive"] }
// serde_json          = "1.0"
// dashmap             = "5.5"
// tracing             = "0.1"
// thiserror           = "1.0"
//
// =====================================================

use std::sync::Arc;
use std::time::Duration;

use arc_swap::ArcSwap;
use async_trait::async_trait;
use dashmap::DashMap;
use rdkafka::{
    consumer::{Consumer, StreamConsumer},
    message::OwnedMessage,
    producer::{FutureProducer, FutureRecord},
    util::Timeout,
    ClientConfig, Message,
};
use serde::{Deserialize, Serialize};
use tokio::{select, signal, task, time};
use tokio_stream::StreamExt;
use tracing::{debug, error, info, instrument, warn};

/// Type alias for dynamic strategy.
type DynAlgo = Arc<dyn SentimentAlgorithm + Send + Sync>;

/// In-memory registry keyed by algorithm identifier.
static ALGO_REGISTRY: once_cell::sync::Lazy<DashMap<String, DynAlgo>> =
    once_cell::sync::Lazy::new(DashMap::new);

/// JSON emitted downstream.
#[derive(Serialize, Deserialize, Debug)]
pub struct SentimentEnvelope {
    pub event_id: String,
    pub timestamp: u64,
    pub text: String,
    pub lang: Option<String>,
    pub polarity: f32,
    pub algorithm: String,
}

/// Raw event consumed from upstream.
#[derive(Serialize, Deserialize, Debug)]
pub struct SocialEvent {
    pub id: String,
    pub timestamp: u64,
    pub text: String,
    pub lang: Option<String>,
}

/// Trait defining sentiment algorithm interface.
#[async_trait]
pub trait SentimentAlgorithm {
    /// Human-readable name (used for metrics & registry).
    fn name(&self) -> &str;

    /// One-time initialization hook (e.g., load model, dictionaries …).
    async fn init(&self) -> SentimentResult<()>;

    /// Score a text, returning polarity in range [-1, 1].
    async fn score(&self, text: &str) -> SentimentResult<f32>;
}

/// Error type for engine & strategies.
#[derive(thiserror::Error, Debug)]
pub enum SentimentError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Kafka error: {0}")]
    Kafka(#[from] rdkafka::error::KafkaError),

    #[error("Serde error: {0}")]
    Serde(#[from] serde_json::Error),

    #[error("Unknown algorithm {0}")]
    UnknownAlgorithm(String),

    #[error("Internal: {0}")]
    Internal(String),
}

pub type SentimentResult<T> = Result<T, SentimentError>;

/// Rule-based sentiment (toy example).
pub struct RuleBasedAlgo;

#[async_trait]
impl SentimentAlgorithm for RuleBasedAlgo {
    fn name(&self) -> &str {
        "rule_based_v1"
    }

    async fn init(&self) -> SentimentResult<()> {
        info!("RuleBasedAlgo initialized");
        Ok(())
    }

    async fn score(&self, text: &str) -> SentimentResult<f32> {
        // Very naive: positive if contains ":)" negative if ":(" else neutral.
        let score = if text.contains(":)") {
            0.8
        } else if text.contains(":(") {
            -0.8
        } else {
            0.0
        };
        Ok(score)
    }
}

/// Dummy deep-learning algorithm placeholder.
pub struct BertAlgo {
    /// Imagine expensive model inside Arc.
    _model: (),
}

impl BertAlgo {
    pub fn new() -> Self {
        Self { _model: () }
    }
}

#[async_trait]
impl SentimentAlgorithm for BertAlgo {
    fn name(&self) -> &str {
        "bert_sentiment_v2"
    }

    async fn init(&self) -> SentimentResult<()> {
        info!("Loading BERT weights…");
        // Simulate heavy load time.
        time::sleep(Duration::from_secs(2)).await;
        Ok(())
    }

    async fn score(&self, text: &str) -> SentimentResult<f32> {
        // Placeholder pseudo-logic
        let polarity = (text.len() % 10) as f32 / 10.0 - 0.5;
        Ok(polarity)
    }
}

/// Engine orchestrating consumption, scoring & production.
pub struct SentimentEngine {
    consumer: StreamConsumer,
    producer: FutureProducer,
    topic_in: String,
    topic_out: String,
    algorithm: ArcSwap<DynAlgo>,
}

impl SentimentEngine {
    /// Construct a new engine instance.
    pub async fn new(
        brokers: &str,
        group_id: &str,
        topic_in: &str,
        topic_out: &str,
        algo: DynAlgo,
    ) -> SentimentResult<Self> {
        let consumer: StreamConsumer = ClientConfig::new()
            .set("bootstrap.servers", brokers)
            .set("group.id", group_id)
            .set("enable.partition.eof", "false")
            .set("auto.offset.reset", "earliest")
            .create()?;

        consumer.subscribe(&[topic_in])?;

        let producer: FutureProducer = ClientConfig::new()
            .set("bootstrap.servers", brokers)
            .set("message.timeout.ms", "5000")
            .create()?;

        Ok(Self {
            consumer,
            producer,
            topic_in: topic_in.into(),
            topic_out: topic_out.into(),
            algorithm: ArcSwap::from(algo),
        })
    }

    /// Atomically swap algorithm by id (must exist in registry).
    pub fn swap_algorithm(&self, id: &str) -> SentimentResult<()> {
        let entry = ALGO_REGISTRY
            .get(id)
            .ok_or_else(|| SentimentError::UnknownAlgorithm(id.into()))?;
        info!(new_algo = id, "Hot-swapping algorithm");
        self.algorithm.store(entry.value().clone());
        Ok(())
    }

    /// Spawn async loop to monitor Kafka + process events.
    #[instrument(skip(self))]
    pub async fn run(self: Arc<Self>) -> SentimentResult<()> {
        let (swap_tx, mut swap_rx) = tokio::sync::mpsc::unbounded_channel::<String>();

        // -- Spawn control plane (simulated config changes) --------------
        task::spawn({
            let swap_tx = swap_tx.clone();
            async move {
                // Every 60 seconds pretend we received new config.
                let mut interval = time::interval(Duration::from_secs(60));
                loop {
                    interval.tick().await;
                    let algo_id = if rand::random::<bool>() {
                        "rule_based_v1"
                    } else {
                        "bert_sentiment_v2"
                    };
                    if let Err(e) = swap_tx.send(algo_id.into()) {
                        warn!(?e, "Failed to send swap command");
                    }
                }
            }
        });

        // -- Data plane --------------------------------------------------
        let mut stream = self.consumer.stream();
        loop {
            select! {
                biased;

                Some(algo_id) = swap_rx.recv() => {
                    if let Err(e) = self.swap_algorithm(&algo_id) {
                        error!(?e, "Failed to swap algorithm");
                    }
                }

                _ = signal::ctrl_c() => {
                    info!("Shutdown signal received");
                    break;
                }

                maybe_msg = stream.next() => {
                    match maybe_msg {
                        Some(Ok(m)) => {
                            if let Err(e) = self.handle_message(m).await {
                                error!(?e, "Failed to process message");
                            }
                        }
                        Some(Err(e)) => {
                            error!(?e, "Kafka error in stream");
                        }
                        None => {
                            warn!("Kafka stream terminated");
                            break;
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// De-serialize, enrich, and publish.
    #[instrument(skip(self, msg))]
    async fn handle_message(&self, msg: OwnedMessage) -> SentimentResult<()> {
        let payload = msg.payload().ok_or_else(|| {
            SentimentError::Internal("Kafka message without payload".into())
        })?;
        let event: SocialEvent = serde_json::from_slice(payload)?;

        let algo = self.algorithm.load();
        let polarity = algo.score(&event.text).await?;

        let envelope = SentimentEnvelope {
            event_id: event.id,
            timestamp: event.timestamp,
            text: event.text,
            lang: event.lang,
            polarity,
            algorithm: algo.name().into(),
        };

        let serialized = serde_json::to_vec(&envelope)?;

        self.producer
            .send(
                FutureRecord::to(&self.topic_out)
                    .payload(&serialized)
                    .key(&envelope.event_id),
                Timeout::After(Duration::from_millis(500)),
            )
            .await
            .map_err(|(e, _)| SentimentError::Kafka(e))?;

        debug!("Published sentiment result");
        Ok(())
    }
}

// ============== Registry bootstrap ===================================

/// Register bundled algorithms.  Call once at startup.
pub async fn bootstrap_algorithms() -> SentimentResult<()> {
    let rule_based = Arc::new(RuleBasedAlgo) as DynAlgo;
    rule_based.init().await?;
    ALGO_REGISTRY.insert(rule_based.name().into(), rule_based.clone());

    let bert = Arc::new(BertAlgo::new()) as DynAlgo;
    bert.init().await?;
    ALGO_REGISTRY.insert(bert.name().into(), bert.clone());

    info!("Registered {} algorithms", ALGO_REGISTRY.len());
    Ok(())
}

// ==================== Main entry point (binary) =====================
// Note: In a workspace, this would live in src/bin/…  Here for brevity.

#[tokio::main]
async fn main() -> SentimentResult<()> {
    tracing_subscriber::fmt::init();

    bootstrap_algorithms().await?;

    let initial_algo = ALGO_REGISTRY
        .get("rule_based_v1")
        .expect("algorithm exists")
        .clone();

    let engine = Arc::new(
        SentimentEngine::new(
            "localhost:9092",
            "sentiment-engine",
            "social_raw",
            "social_sentiment",
            initial_algo.value().clone(),
        )
        .await?,
    );

    info!("Sentiment engine online");
    engine.run().await
}
```