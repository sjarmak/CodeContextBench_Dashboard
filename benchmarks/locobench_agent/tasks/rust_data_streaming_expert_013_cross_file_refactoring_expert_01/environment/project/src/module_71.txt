```rust
//! module_71.rs
//!
//! This module implements a pluggable “strategy-pattern” sentiment engine that can be
//! hot-swapped at runtime without taking the data-stream offline.  Each `SentimentAnalyzer`
//! implementation lives behind a trait-object and can therefore be exchanged dynamically.
//!
//! The engine is designed to be embedded in a `tokio` task that listens for control
//! messages (e.g. Kafka or NATS) instructing it to swap out the algorithm.
//!
//!     +------------------+            Control Plane             +------------------+
//!     |  Stream Worker   |  <--- hot-swap message (JSON)  --->  |  Strategy Registry|
//!     +------------------+                                      +------------------+
//!
//! # Example
//! ```no_run
//! use module_71::{SentimentEngine, StrategyKind};
//!
//! #[tokio::main]
//! async fn main() -> anyhow::Result<()> {
//!     let engine = SentimentEngine::new_default().await?;
//!
//!     // Run some text through the default algorithm.
//!     let score = engine.analyze("Rust is fantastic!")?;
//!     println!("score={score:?}");
//!
//!     // Hot-swap to a different strategy.
//!     engine.replace_strategy(StrategyKind::BagOfWords)?;
//!
//!     let score = engine.analyze("I hate runtime panics...")?;
//!     println!("score={score:?}");
//!     Ok(())
//! }
//! ```
//!
//! NOTE: All strategies contained herein are illustrative and *not* production-grade
//! sentiment models.  They are placeholders that demonstrate the plug-in architecture
//! around which more sophisticated algorithms (e.g. onnx-runtime, hugging-face, etc.)
//! can be integrated.

use std::{
    collections::{HashMap, HashSet},
    sync::Arc,
};

use parking_lot::RwLock;
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::sync::broadcast;

type DynAnalyzer = dyn SentimentAnalyzer + Send + Sync + 'static;

/// Numeric sentiment returned to callers.
///
/// `value` is normalized to the range `[-1.0, 1.0]` where
/// `-1.0` means very negative and `1.0` means very positive.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct SentimentScore {
    /// normalized sentiment value
    pub value: f32,
}

impl SentimentScore {
    #[inline]
    pub fn neutral() -> Self {
        Self { value: 0.0 }
    }
}

/// Trait implemented by all run-time pluggable analyzers.
pub trait SentimentAnalyzer: Send + Sync {
    /// Human-readable identifier (used for metrics & logs).
    fn name(&self) -> &'static str;

    /// Perform sentiment analysis on a single text snippet.
    ///
    /// Implementations should be pure and side-effect free.
    fn analyze(&self, text: &str) -> Result<SentimentScore, AnalyzerError>;
}

/// Public error type for this module.
#[derive(Error, Debug)]
pub enum AnalyzerError {
    #[error("strategy not found: {0}")]
    StrategyNotFound(String),
    #[error("invalid configuration: {0}")]
    InvalidConfig(String),
    #[error("runtime error: {0}")]
    Runtime(String),
}

/// Variants for built-in strategies.
///
/// New variants can be added in minor versions without
/// breaking semver as they do not change existing behavior.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum StrategyKind {
    /// Extremely naive word list sentiment.
    BagOfWords,
    /// Slightly less naive rule based.
    RuleBased,
}

/// Registry that maps a `StrategyKind` to a constructor fn.
pub struct StrategyRegistry {
    factories: HashMap<StrategyKind, fn() -> Box<DynAnalyzer>>,
}

impl StrategyRegistry {
    /// Create a registry and register built-ins.
    pub fn new_builtin() -> Self {
        let mut factories: HashMap<StrategyKind, fn() -> Box<DynAnalyzer>> = HashMap::new();
        factories.insert(StrategyKind::BagOfWords, || Box::new(BagOfWords::default()));
        factories.insert(StrategyKind::RuleBased, || Box::new(RuleBased::default()));
        Self { factories }
    }

    /// Instantiate a strategy or return error if not present.
    pub fn make(
        &self,
        kind: StrategyKind,
    ) -> Result<Box<DynAnalyzer>, AnalyzerError> {
        self.factories
            .get(&kind)
            .copied()
            .map(|ctor| ctor())
            .ok_or_else(|| AnalyzerError::StrategyNotFound(format!("{kind:?}")))
    }

    /// Return a list of all registered strategies.
    pub fn available(&self) -> HashSet<StrategyKind> {
        self.factories.keys().cloned().collect()
    }
}

/// Thread-safe, hot-swappable sentiment engine.
///
/// Internally stores a `RwLock<Box<dyn SentimentAnalyzer>>` protected behind
/// an `Arc` so instances can be cloned cheaply and sent across threads/tasks.
#[derive(Clone)]
pub struct SentimentEngine {
    analyzer: Arc<RwLock<Box<DynAnalyzer>>>,
    /// Emits events when strategy is swapped. Useful for metrics dashboards.
    notifier: broadcast::Sender<StrategyKind>,
    registry: StrategyRegistry,
}

impl SentimentEngine {
    /// Construct the engine with the default strategy (`RuleBased`).
    pub async fn new_default() -> Result<Self, AnalyzerError> {
        Self::new_with_strategy(StrategyKind::RuleBased)
    }

    /// Construct with an explicit strategy.
    pub fn new_with_strategy(strategy: StrategyKind) -> Result<Self, AnalyzerError> {
        let registry = StrategyRegistry::new_builtin();
        let analyzer = registry.make(strategy)?;
        let (tx, _rx) = broadcast::channel(16);

        Ok(Self {
            analyzer: Arc::new(RwLock::new(analyzer)),
            notifier: tx,
            registry,
        })
    }

    /// Replace current strategy with new one.  If the desired strategy is
    /// unavailable this call does nothing and returns an error.
    pub fn replace_strategy(&self, strategy: StrategyKind) -> Result<(), AnalyzerError> {
        let new_analyzer = self.registry.make(strategy)?;
        {
            let mut guard = self.analyzer.write();
            *guard = new_analyzer;
        }
        // broadcast the change; ignore lagged receivers
        let _ = self.notifier.send(strategy);
        Ok(())
    }

    /// Subscribe to strategy-changed events. The returned `Receiver` implements `Stream`.
    pub fn subscribe(&self) -> broadcast::Receiver<StrategyKind> {
        self.notifier.subscribe()
    }

    /// Analyze a single piece of text with the currently-active strategy.
    pub fn analyze<T: AsRef<str>>(
        &self,
        text: T,
    ) -> Result<SentimentScore, AnalyzerError> {
        let guard = self.analyzer.read();
        guard.analyze(text.as_ref())
    }
}

/* ------------------------------------------------------------------------- *
 *  Strategy Implementations
 * ------------------------------------------------------------------------- */

/// Simple bag-of-words strategy using hard-coded word lists.
///
/// NOT production-quality; for demo purposes only.
#[derive(Default)]
struct BagOfWords {
    positive: HashSet<&'static str>,
    negative: HashSet<&'static str>,
}

impl BagOfWords {
    fn build_word_sets() -> (HashSet<&'static str>, HashSet<&'static str>) {
        let positive = HashSet::from([
            "good", "great", "happy", "love", "excellent", "best", "fantastic",
        ]);
        let negative = HashSet::from(["bad", "terrible", "sad", "hate", "worst", "awful"]);
        (positive, negative)
    }
}

impl Default for BagOfWords {
    fn default() -> Self {
        let (positive, negative) = Self::build_word_sets();
        Self { positive, negative }
    }
}

impl SentimentAnalyzer for BagOfWords {
    fn name(&self) -> &'static str {
        "bag_of_words"
    }

    fn analyze(&self, text: &str) -> Result<SentimentScore, AnalyzerError> {
        let mut score: i32 = 0;
        for token in text.split_whitespace() {
            let lower = token.to_ascii_lowercase();
            if self.positive.contains(lower.as_str()) {
                score += 1;
            } else if self.negative.contains(lower.as_str()) {
                score -= 1;
            }
        }
        // Normalise to [-1, 1]
        let norm = match score {
            0 => 0.0,
            x if x > 0 => (x as f32).min(5.0) / 5.0,
            x => (x as f32).max(-5.0) / 5.0,
        };
        Ok(SentimentScore { value: norm })
    }
}

/// Slightly more advanced rule-based analyzer that looks at punctuation and
/// negation words. Again, demo only.
#[derive(Default)]
struct RuleBased;

impl SentimentAnalyzer for RuleBased {
    fn name(&self) -> &'static str {
        "rule_based"
    }

    fn analyze(&self, text: &str) -> Result<SentimentScore, AnalyzerError> {
        let mut score: f32 = 0.0;
        let mut last_was_negation = false;

        for token in text.split_whitespace() {
            let token_lc = token.trim_matches(|c: char| !c.is_alphanumeric()).to_ascii_lowercase();
            match token_lc.as_str() {
                "not" | "never" | "no" => {
                    last_was_negation = true;
                    continue;
                }
                "!" => score += 0.1,
                _ => {}
            }

            let delta = match token_lc.as_str() {
                "love" | "great" | "awesome" => 0.5,
                "like" | "good" | "happy" => 0.3,
                "bad" | "worse" | "terrible" => -0.3,
                "hate" | "awful" | "horrible" => -0.5,
                _ => 0.0,
            };

            score += if last_was_negation { -delta } else { delta };
            last_was_negation = false;
        }

        // Clamp to [-1, 1]
        score = score.clamp(-1.0, 1.0);
        Ok(SentimentScore { value: score })
    }
}

/* ------------------------------------------------------------------------- *
 *  Asynchronous Hot-Swap Example (can be removed in embedded environments)
 * ------------------------------------------------------------------------- */

/// Spawn a control-plane task that listens for JSON strings on a channel and
/// swaps strategies at runtime.
///
/// The expected payload is a JSON object: `{ "strategy": "bag_of_words" }`
pub fn spawn_control_plane(
    engine: SentimentEngine,
    mut rx: tokio::sync::mpsc::Receiver<String>,
) -> tokio::task::JoinHandle<()> {
    task::spawn(async move {
        while let Some(msg) = rx.recv().await {
            match serde_json::from_str::<ControlMsg>(&msg) {
                Ok(control) => {
                    if let Err(err) = engine.replace_strategy(control.strategy) {
                        tracing::warn!(?err, "failed to replace strategy");
                    } else {
                        tracing::info!(
                            strategy = ?control.strategy,
                            "strategy updated via control plane"
                        );
                    }
                }
                Err(e) => tracing::warn!(%msg, %e, "invalid control message"),
            }
        }
    })
}

#[derive(Debug, Deserialize)]
struct ControlMsg {
    strategy: StrategyKind,
}

/* ------------------------------------------------------------------------- *
 *  Tests
 * ------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn bag_of_words_basic() -> Result<(), AnalyzerError> {
        let analyzer = BagOfWords::default();
        assert!(analyzer.analyze("I love rust")?.value > 0.0);
        assert!(analyzer.analyze("This is the worst")?.value < 0.0);
        Ok(())
    }

    #[test]
    fn rule_based_negation() -> Result<(), AnalyzerError> {
        let analyzer = RuleBased::default();
        let positive = analyzer.analyze("I am not sad")?.value;
        let negative = analyzer.analyze("I am sad")?.value;
        assert!(positive > negative);
        Ok(())
    }

    #[test]
    fn engine_swap() -> Result<(), AnalyzerError> {
        let engine = SentimentEngine::new_default()?;
        let s1 = engine.analyze("I love Rust")?.value;
        engine.replace_strategy(StrategyKind::BagOfWords)?;
        let s2 = engine.analyze("I love Rust")?.value;
        // Values should differ because algorithms differ
        assert_ne!(s1, s2);
        Ok(())
    }
}
```