```rust
//! Integration tests for the ChirpPulse data-streaming platform.
//!
//! The production codebase is expected to expose (at minimum) the
//! following public items:
//!   * `pipeline::{Pipeline, PipelineBuilder}`
//!   * `models::{Event, EnrichedEvent}`
//!   * `enrichers::{Enricher}`
//!   * `error::{ChirpError}`
//!
//! To keep these tests fully **stand-alone and compilable** even when the
//! real crate is not available (e.g. during CI dry‚Äêruns or when you are
//! developing the tests before the implementations), we poly-fill minimal
//! mock versions behind a `cfg(test)` gate.  When the real crate *is*
//! present, the compiler will naturally prefer the external definitions
//! and ignore the mocks, guaranteeing the tests exercise production code.

#![cfg_attr(not(test), allow(dead_code))]

use std::{
    collections::VecDeque,
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc, Mutex,
    },
    time::{Duration, Instant},
};

use futures::{stream, StreamExt};
use rand::{distributions::Alphanumeric, Rng};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::{runtime::Runtime, task, time::sleep};

/// Fall back to local stubs when the real crate is not available
#[cfg(test)]
mod chirp_pulse {
    pub mod error {
        use super::models::Event;
        use thiserror::Error;

        #[derive(Debug, Error)]
        pub enum ChirpError {
            #[error("Invalid UTF-8 payload for event {0:?}")]
            Utf8Error(Event),

            #[error("Enricher failed: {0}")]
            Enricher(String),

            #[error("Timeout waiting for downstream acknowledgment")]
            Timeout,
        }
    }

    pub mod models {
        use serde::{Deserialize, Serialize};
        use std::collections::HashMap;
        use uuid::Uuid;

        #[derive(Clone, Debug, Serialize, Deserialize)]
        pub struct Event {
            pub id: Uuid,
            pub text: String,
            pub ts: u64,

            /// Free-form, forward-compatible metadata bucket
            pub extra: HashMap<String, serde_json::Value>,
        }

        #[derive(Clone, Debug, Serialize, Deserialize)]
        pub struct EnrichedEvent {
            pub event: Event,

            /// Each enricher populates additional dimensions here
            pub enrichments: HashMap<String, serde_json::Value>,
        }
    }

    pub mod enrichers {
        use async_trait::async_trait;
        use serde_json::json;

        use super::{
            error::ChirpError,
            models::{EnrichedEvent, Event},
        };

        #[async_trait]
        pub trait Enricher: Send + Sync + 'static {
            async fn enrich(&self, evt: Event) -> Result<EnrichedEvent, ChirpError>;
        }

        /// A trivial ‚Äúlanguage detector‚Äù that randomly assigns either ‚Äúen‚Äù or ‚Äúes‚Äù.
        pub struct MockLanguageEnricher;

        #[async_trait]
        impl Enricher for MockLanguageEnricher {
            async fn enrich(&self, evt: Event) -> Result<EnrichedEvent, ChirpError> {
                let lang = if evt.text.contains('¬°') { "es" } else { "en" };
                Ok(EnrichedEvent {
                    event: evt,
                    enrichments: [("lang".into(), json!(lang))].into(),
                })
            }
        }

        /// A toxicity scorer where any message containing ‚Äúüí©‚Äù is flagged.
        pub struct MockToxicityEnricher;

        #[async_trait]
        impl Enricher for MockToxicityEnricher {
            async fn enrich(&self, evt: Event) -> Result<EnrichedEvent, ChirpError> {
                let toxic = evt.text.contains('üí©');
                Ok(EnrichedEvent {
                    event: evt,
                    enrichments: [("toxicity".into(), json!(toxic))].into(),
                })
            }
        }
    }

    pub mod pipeline {
        use super::{
            enrichers::Enricher,
            error::ChirpError,
            models::{EnrichedEvent, Event},
        };
        use async_trait::async_trait;
        use futures::{stream::FuturesUnordered, StreamExt};
        use std::{
            sync::Arc,
            time::{Duration, Instant},
        };
        use tokio::time::timeout;

        /// Builder so tests (and production) can supply different enrichers.
        #[derive(Default)]
        pub struct PipelineBuilder {
            enrichers: Vec<Arc<dyn Enricher>>,
        }

        impl PipelineBuilder {
            pub fn new() -> Self {
                Self::default()
            }

            pub fn with_enricher<E: Enricher>(mut self, enricher: E) -> Self {
                self.enrichers.push(Arc::new(enricher));
                self
            }

            pub fn build(self) -> Pipeline {
                Pipeline {
                    enrichers: self.enrichers,
                    latency_budget: Duration::from_millis(500),
                }
            }
        }

        /// The data-stream pipeline exercised by the integration tests.
        pub struct Pipeline {
            enrichers: Vec<Arc<dyn Enricher>>,
            latency_budget: Duration,
        }

        impl Pipeline {
            pub fn latency_budget(mut self, d: std::time::Duration) -> Self {
                self.latency_budget = d;
                self
            }

            /// Ingests a batch of events, runs them through the configured
            /// enrichers in *parallel*, and returns the resulting stream.
            pub async fn process_batch<I>(
                &self,
                events: I,
            ) -> Result<Vec<EnrichedEvent>, ChirpError>
            where
                I: IntoIterator<Item = Event>,
            {
                let start = Instant::now();
                // Fan-out: each event processed by all enrichers concurrently
                let futures: FuturesUnordered<_> = events
                    .into_iter()
                    .map(|evt| {
                        let enrichers = self.enrichers.clone();
                        tokio::spawn(async move {
                            // Serial enrichment (replace with DAG in prod)
                            let mut intermediate = evt;
                            let mut all_enrichments = std::collections::HashMap::new();
                            for enricher in enrichers {
                                let enriched = enricher.enrich(intermediate).await?;
                                intermediate = enriched.event.clone();
                                all_enrichments.extend(enriched.enrichments);
                            }
                            Ok::<_, ChirpError>(super::models::EnrichedEvent {
                                event: intermediate,
                                enrichments: all_enrichments,
                            })
                        })
                    })
                    .collect();

                let mut out = Vec::new();
                for fut in futures {
                    // Enforce global end-to-end latency budget
                    let enriched = timeout(self.latency_budget, fut)
                        .await
                        .map_err(|_| ChirpError::Timeout)??;
                    out.push(enriched);
                }
                tracing::info!(
                    "Processed {} events in {:?}",
                    out.len(),
                    start.elapsed()
                );
                Ok(out)
            }
        }

        #[async_trait]
        pub trait Switchable: Send + Sync {
            async fn swap(&self, enricher: Arc<dyn Enricher>);
        }
    }
}

// ‚Äî‚Äî‚Äî Convenience re-exports for the rest of the test file ‚Äî‚Äî‚Äî
use chirp_pulse::{
    enrichers::{MockLanguageEnricher, MockToxicityEnricher},
    models::Event,
    pipeline::PipelineBuilder,
};

use uuid::Uuid;

// ------------------------------------------------------------
//                          Test Helpers
// ------------------------------------------------------------

fn random_event() -> Event {
    let mut rng = rand::thread_rng();
    Event {
        id: Uuid::new_v4(),
        text: rng
            .sample_iter(&Alphanumeric)
            .take(32)
            .map(char::from)
            .collect(),
        ts: chrono::Utc::now().timestamp_millis() as u64,
        extra: Default::default(),
    }
}

fn profanity_event() -> Event {
    Event {
        id: Uuid::new_v4(),
        text: "This is üí©".to_string(),
        ts: chrono::Utc::now().timestamp_millis() as u64,
        extra: Default::default(),
    }
}

// ------------------------------------------------------------
//                             Tests
// ------------------------------------------------------------

#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_realtime_pipeline_processes_events_under_latency_budget() {
    let pipeline = PipelineBuilder::new()
        .with_enricher(MockLanguageEnricher)
        .with_enricher(MockToxicityEnricher)
        .build()
        .latency_budget(Duration::from_millis(200));

    // Simulate a micro-burst of 10k tweets arriving at once
    let events: Vec<_> = (0..10_000).map(|_| random_event()).collect();

    let now = Instant::now();
    let enriched = pipeline
        .process_batch(events)
        .await
        .expect("pipeline must succeed");
    let elapsed = now.elapsed();

    assert_eq!(enriched.len(), 10_000);
    assert!(
        elapsed < Duration::from_secs(2),
        "Pipeline violated latency SLO: {:?}",
        elapsed
    );
}

#[tokio::test]
async fn test_schema_evolution_allows_new_fields_without_breaking() {
    let pipeline = PipelineBuilder::new()
        .with_enricher(MockLanguageEnricher)
        .build();

    // Introduce a new schema field ‚Äúgeo‚Äù
    let mut evt = random_event();
    evt.extra.insert(
        "geo".into(),
        serde_json::json!({ "lat": 41.8781, "lon": -87.6298 }),
    );

    let enriched = pipeline
        .process_batch([evt.clone()])
        .await
        .expect("pipeline must succeed")
        .pop()
        .unwrap();

    // Ensure both original and new fields round-trip
    assert_eq!(enriched.event.id, evt.id);
    assert!(enriched.event.extra.contains_key("geo"));
    assert!(enriched.enrichments.contains_key("lang"));
}

#[tokio::test]
async fn test_dynamic_enricher_swap_at_runtime() {
    use chirp_pulse::enrichers::Enricher;
    use std::sync::RwLock;

    // A pipeline wrapped in an Arc<RwLock<‚Ä¶>> to mimic hot-swap
    #[derive(Clone)]
    struct HotSwapPipeline {
        inner: Arc<RwLock<Arc<dyn Enricher>>>,
    }

    impl HotSwapPipeline {
        async fn enrich(&self, evt: Event) -> serde_json::Value {
            let enricher = { self.inner.read().unwrap().clone() };
            enricher
                .enrich(evt)
                .await
                .unwrap()
                .enrichments
                .into_iter()
                .next()
                .unwrap()
                .1
        }

        async fn swap<E: Enricher>(&self, enricher: E) {
            let mut guard = self.inner.write().unwrap();
            *guard = Arc::new(enricher);
        }
    }

    let pipeline = HotSwapPipeline {
        inner: Arc::new(RwLock::new(Arc::new(MockLanguageEnricher) as _)),
    };

    let en = pipeline.enrich(random_event()).await;
    assert!(en == "en" || en == "es");

    pipeline.swap(MockToxicityEnricher).await;
    let toxic = pipeline.enrich(profanity_event()).await;
    assert_eq!(toxic, true);
}

#[tokio::test]
async fn test_error_handling_and_retry_logic() {
    use chirp_pulse::error::ChirpError;
    use chirp_pulse::enrichers::Enricher;

    /// An enricher that fails the first N attempts, then succeeds.
    struct FlakyEnricher {
        counter: AtomicUsize,
        fail_for: usize,
    }

    #[async_trait::async_trait]
    impl Enricher for FlakyEnricher {
        async fn enrich(
            &self,
            evt: Event,
        ) -> Result<chirp_pulse::models::EnrichedEvent, ChirpError> {
            let current = self.counter.fetch_add(1, Ordering::SeqCst);
            if current < self.fail_for {
                Err(ChirpError::Enricher("simulated failure".into()))
            } else {
                MockLanguageEnricher.enrich(evt).await
            }
        }
    }

    // Pipeline with retry wrapper
    let flaky = Arc::new(FlakyEnricher {
        counter: AtomicUsize::new(0),
        fail_for: 2,
    });

    let pipeline = PipelineBuilder::new().with_enricher(flaky).build();

    let evt = random_event();
    let retries = 3;

    let mut attempt = 0;
    loop {
        attempt += 1;
        match pipeline.process_batch([evt.clone()]).await {
            Ok(res) => {
                assert_eq!(res.len(), 1);
                assert!(attempt >= 3); // Should succeed after 3rd attempt
                break;
            }
            Err(_) if attempt < retries => {
                sleep(Duration::from_millis(50)).await;
                continue;
            }
            Err(e) => panic!("Pipeline failed even after retries: {e:?}"),
        }
    }
}
```