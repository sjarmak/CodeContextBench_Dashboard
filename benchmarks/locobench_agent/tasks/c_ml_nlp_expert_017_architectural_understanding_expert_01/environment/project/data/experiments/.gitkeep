```c
/*
 *  LexiLearn Orchestrator – Experiment Logging Utility
 *  ---------------------------------------------------
 *  File:    data/experiments/.gitkeep     (yes, unusual name; kept for legacy)
 *  Author:  LexiLearn Engineering Team
 *
 *  Synopsis:
 *      Lightweight, thread-safe experiment logger for the LexiLearn MVC
 *      Orchestrator.  Designed as a pure-C replacement for higher-level
 *      experiment-tracking frameworks (e.g., MLflow) when running in
 *      constrained or embedded environments.
 *
 *  Features:
 *      • Automatic directory creation and file rotation
 *      • JSON-line output compatible with downstream analytics
 *      • Thread-safe writes via a POSIX mutex
 *      • Environment-variable override for experiment root directory
 *
 *  Build:
 *      gcc -std=c11 -Wall -Wextra -pedantic -pthread -o experiment_logger \
 *          experiment_logger.c
 *
 *  NOTE:
 *      This code lives in a “.gitkeep” file so that empty directories remain
 *      version-controlled.  The unusual extension is harmless to the compiler.
 */

#include <errno.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

/* ---------------------------------------------------------------------------
 *  Constants
 * -------------------------------------------------------------------------*/
#define EXP_DIR_ENV         "LEXILEARN_EXPERIMENT_DIR"
#define DEFAULT_EXP_DIR     "data/experiments"
#define ISO_TIMESTAMP_LEN   32
#define EXP_ID_LEN          64
#define JSON_BUF_LEN        4096

/* ---------------------------------------------------------------------------
 *  Helpers
 * -------------------------------------------------------------------------*/

/* Obtain current UTC time in ISO-8601 format. */
static void
utc_iso8601(char *dst, size_t len)
{
    time_t     now = time(NULL);
    struct tm  tm_now;

    gmtime_r(&now, &tm_now);
    strftime(dst, len, "%Y-%m-%dT%H:%M:%SZ", &tm_now);
}

/* Simple ID generator: UTC timestamp + PID + random suffix (base36). */
static void
generate_id(char *dst, size_t len)
{
    char ts[ISO_TIMESTAMP_LEN];
    utc_iso8601(ts, sizeof ts);

    /* Convert random number to base36 string. */
    char rand_suffix[16];
    unsigned int r = (unsigned int)random();
    const char *digits = "0123456789abcdefghijklmnopqrstuvwxyz";
    int idx = 0;
    do {
        rand_suffix[idx++] = digits[r % 36];
        r /= 36;
    } while (r && idx < (int)sizeof(rand_suffix) - 1);
    rand_suffix[idx] = '\0';

    snprintf(dst, len, "%s-%d-%s", ts, (int)getpid(), rand_suffix);
}

/* Recursively create directories (mkdir -p).  Returns 0 on success. */
static int
mkdir_p(const char *path, mode_t mode)
{
    char *tmp = strdup(path);
    if (!tmp) return -1;

    char *p = tmp;

    /* Skip leading '/' */
    if (p[0] == '/')
        ++p;

    for (; *p; ++p)
    {
        if (*p == '/')
        {
            *p = '\0';
            if (mkdir(tmp, mode) && errno != EEXIST)
            {
                perror("mkdir");
                free(tmp);
                return -1;
            }
            *p = '/';
        }
    }

    if (mkdir(tmp, mode) && errno != EEXIST)
    {
        perror("mkdir");
        free(tmp);
        return -1;
    }

    free(tmp);
    return 0;
}

/* Minimal string-replace helper for JSON escaping of quotes and backslashes. */
static void
json_escape(const char *src, char *dst, size_t len)
{
    size_t pos = 0;
    for (const char *s = src; *s && pos + 2 < len; ++s)
    {
        if (*s == '"' || *s == '\\')
            dst[pos++] = '\\';
        dst[pos++] = *s;
    }
    dst[pos] = '\0';
}

/* ---------------------------------------------------------------------------
 *  Experiment API
 * -------------------------------------------------------------------------*/

typedef struct
{
    FILE          *fp;
    char           id[EXP_ID_LEN];
    char           created[ISO_TIMESTAMP_LEN];
    pthread_mutex_t mtx;
    int            closed;     /* Prevent double-closings */
} experiment_t;

/**
 *  exp_open  –  Create and initialize an experiment logfile.
 *
 *  run_name   Optional human-friendly name; may be NULL.
 *
 *  Returns 0 on success, −1 on failure.
 */
int
exp_open(experiment_t *exp, const char *run_name)
{
    memset(exp, 0, sizeof *exp);
    pthread_mutex_init(&exp->mtx, NULL);

    /* Determine root directory */
    const char *root = getenv(EXP_DIR_ENV);
    if (!root || !*root)
        root = DEFAULT_EXP_DIR;

    if (mkdir_p(root, 0755))
        return -1;

    /* Generate file path */
    generate_id(exp->id, sizeof exp->id);
    utc_iso8601(exp->created, sizeof exp->created);

    char path[PATH_MAX];
    snprintf(path, sizeof path, "%s/%s.jsonl", root, exp->id);

    exp->fp = fopen(path, "w");
    if (!exp->fp)
    {
        perror("fopen");
        return -1;
    }

    /* Emit metadata header */
    char safe_name[256] = "";
    if (run_name)
        json_escape(run_name, safe_name, sizeof safe_name);

    fprintf(exp->fp,
            "{ \"event\": \"__start__\", \"id\": \"%s\", \"created\": \"%s\", "
            "\"run_name\": \"%s\" }\n",
            exp->id, exp->created, safe_name);
    fflush(exp->fp);

    return 0;
}

/**
 *  exp_log_param  – Emit a key/value hyper-parameter.
 */
int
exp_log_param(experiment_t *exp, const char *key, const char *value)
{
    if (!exp || !exp->fp) return -1;

    pthread_mutex_lock(&exp->mtx);

    char safe_key[256];
    char safe_val[256];
    json_escape(key,   safe_key, sizeof safe_key);
    json_escape(value, safe_val, sizeof safe_val);

    int rc = fprintf(exp->fp,
                     "{ \"event\": \"param\", \"key\": \"%s\", \"value\": \"%s\" }\n",
                     safe_key, safe_val);
    fflush(exp->fp);

    pthread_mutex_unlock(&exp->mtx);
    return rc < 0 ? -1 : 0;
}

/**
 *  exp_log_metric  – Emit a floating-point metric (e.g., accuracy).
 */
int
exp_log_metric(experiment_t *exp, const char *key, double value, uint64_t step)
{
    if (!exp || !exp->fp) return -1;

    pthread_mutex_lock(&exp->mtx);

    char safe_key[256];
    json_escape(key, safe_key, sizeof safe_key);

    int rc = fprintf(exp->fp,
                     "{ \"event\": \"metric\", \"key\": \"%s\", \"value\": %.10g, "
                     "\"step\": %" PRIu64 " }\n",
                     safe_key, value, step);
    fflush(exp->fp);

    pthread_mutex_unlock(&exp->mtx);
    return rc < 0 ? -1 : 0;
}

/**
 *  exp_log_artifact  – Register an artifact path (e.g., model checkpoint).
 */
int
exp_log_artifact(experiment_t *exp, const char *abs_path)
{
    if (!exp || !exp->fp) return -1;

    pthread_mutex_lock(&exp->mtx);

    char safe[512];
    json_escape(abs_path, safe, sizeof safe);

    int rc = fprintf(exp->fp,
                     "{ \"event\": \"artifact\", \"path\": \"%s\" }\n",
                     safe);
    fflush(exp->fp);

    pthread_mutex_unlock(&exp->mtx);
    return rc < 0 ? -1 : 0;
}

/**
 *  exp_close  – Close experiment; safe to call multiple times.
 */
int
exp_close(experiment_t *exp)
{
    if (!exp || !exp->fp || exp->closed)
        return 0;

    pthread_mutex_lock(&exp->mtx);

    /* Emit footer */
    char finished[ISO_TIMESTAMP_LEN];
    utc_iso8601(finished, sizeof finished);

    fprintf(exp->fp,
            "{ \"event\": \"__end__\", \"id\": \"%s\", \"finished\": \"%s\" }\n",
            exp->id, finished);

    fclose(exp->fp);
    exp->fp = NULL;
    exp->closed = 1;

    pthread_mutex_unlock(&exp->mtx);
    pthread_mutex_destroy(&exp->mtx);
    return 0;
}

/* ---------------------------------------------------------------------------
 *  Example usage (unit-test style).  Compile with -DUNIT_TEST to execute.
 * -------------------------------------------------------------------------*/
#ifdef UNIT_TEST
#include <inttypes.h>

int main(void)
{
    /* Seed PRNG for ID generation */
    srandom((unsigned)time(NULL) ^ (unsigned)getpid());

    experiment_t exp;
    if (exp_open(&exp, "demo-run") != 0)
        exit(EXIT_FAILURE);

    exp_log_param(&exp, "learning_rate", "0.01");
    exp_log_param(&exp, "optimizer", "adam");

    for (uint64_t step = 0; step < 5; ++step)
        exp_log_metric(&exp, "accuracy", 0.5 + 0.1 * step, step);

    exp_log_artifact(&exp, "/tmp/model.bin");
    exp_close(&exp);

    return 0;
}
#endif
```