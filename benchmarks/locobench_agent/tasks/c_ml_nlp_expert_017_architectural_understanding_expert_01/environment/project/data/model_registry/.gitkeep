/*
 * LexiLearn MVC Orchestrator
 * ------------------------------------------------------------
 * File: model_registry.c
 *
 * A lightweight, lock-aware, on-disk Model Registry for the
 * C-based LexiLearn platform.  Responsible for tracking model
 * versions, hyper-parameters, evaluation metrics, and timestamps
 * in a strictly-structured directory hierarchy:
 *
 *    $REGISTRY_ROOT/<model_name>/<semantic_version>/metadata.json
 *
 * Typical usage:
 *
 *    ModelMetadata meta = {
 *        .name     = "essay_quality_classifier",
 *        .version  = "v1.2.0",
 *        .metrics  = "{\"f1\":0.912,\"accuracy\":0.935}",
 *        .params   = "{\"lr\":1e-4,\"epochs\":25}"
 *    };
 *    if (registry_register(&meta) != 0) {
 *        fprintf(stderr, "Failed to register model\n");
 *    }
 *
 * The implementation purposely avoids third-party dependencies
 * and performs only rudimentary JSON writing, relying on
 * predictable, sanitized input provided by higher-level layers.
 *
 * ------------------------------------------------------------
 */

#define _POSIX_C_SOURCE 200809L  /* for strdup, getline       */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>
#include <fcntl.h>

/* ------------------------------------------------------------------
 * Configuration
 * ------------------------------------------------------------------*/
#ifndef REGISTRY_ENV_VAR
#define REGISTRY_ENV_VAR  "LL_MODEL_REGISTRY"
#endif

#ifndef REGISTRY_DEFAULT_PATH
#define REGISTRY_DEFAULT_PATH  "./data/model_registry"
#endif

#define MAX_PATH_LEN     1024
#define MAX_JSON_LEN     2048
#define LOCK_FILE_NAME   ".registry.lock"
#define ISO8601_LEN      32

/* ------------------------------------------------------------------
 * Data structures
 * ------------------------------------------------------------------*/
typedef struct ModelMetadata {
    char  name[128];                 /* human-readable model ID        */
    char  version[32];               /* semantic version               */
    char  metrics[256];              /* JSON string of eval metrics    */
    char  params[256];               /* JSON string of hyper-params    */
    char  created_at[ISO8601_LEN];   /* ISO-8601 timestamp (filled in) */
} ModelMetadata;

/* ------------------------------------------------------------------
 * Internal helpers
 * ------------------------------------------------------------------*/
static void
log_errno(const char *msg)
{
    fprintf(stderr, "ModelRegistry: %s - %s\n", msg, strerror(errno));
}

static char *
registry_root(void)
{
    const char *env = getenv(REGISTRY_ENV_VAR);
    if (env && *env != '\0')
        return strdup(env);

    return strdup(REGISTRY_DEFAULT_PATH);
}

/* Recursively mkdir()s the supplied path (POSIX) */
static int
mkdir_p(const char *dir, mode_t mode)
{
    char tmp[MAX_PATH_LEN];
    char *p = NULL;
    size_t len;

    if (!dir)
        return -1;

    len = strnlen(dir, sizeof(tmp));
    if (len == 0 || len >= sizeof(tmp) - 1)
        return -1;

    strncpy(tmp, dir, len);
    tmp[len] = '\0';

    /* Skip leading / */
    for (p = tmp + 1; *p; ++p) {
        if (*p == '/') {
            *p = '\0';
            if (mkdir(tmp, mode) != 0 && errno != EEXIST) {
                log_errno("mkdir_p failed");
                return -1;
            }
            *p = '/';
        }
    }

    if (mkdir(tmp, mode) != 0 && errno != EEXIST) {
        log_errno("mkdir_p failed");
        return -1;
    }
    return 0;
}

/* Return ISO-8601 timestamp */
static void
iso8601_now(char *buf, size_t len)
{
    time_t     t   = time(NULL);
    struct tm  tm  = {0};

    gmtime_r(&t, &tm);
    strftime(buf, len, "%Y-%m-%dT%H:%M:%SZ", &tm);
}

/* ------------------------------------------------------------------
 * Advisory locking (POSIX fcntl)
 * ------------------------------------------------------------------*/
static int
lock_registry(const char *root)
{
    char  lock_path[MAX_PATH_LEN];
    int   fd;
    struct flock fl = {0};

    snprintf(lock_path, sizeof(lock_path), "%s/%s", root, LOCK_FILE_NAME);
    fd = open(lock_path, O_CREAT | O_RDWR, 0666);
    if (fd == -1) {
        log_errno("Unable to open lock file");
        return -1;
    }

    fl.l_type   = F_WRLCK;
    fl.l_whence = SEEK_SET;
    if (fcntl(fd, F_SETLKW, &fl) == -1) {
        log_errno("Unable to obtain file lock");
        close(fd);
        return -1;
    }
    return fd;   /* caller must close() to release lock */
}

static void
unlock_registry(int lock_fd)
{
    if (lock_fd >= 0)
        close(lock_fd);  /* releasing lock via closing descriptor */
}

/* ------------------------------------------------------------------
 * Core functions
 * ------------------------------------------------------------------*/

/*
 * Write metadata.json in canonical order. Caller must ensure
 * that all string fields are already JSON-escaped where needed.
 */
static int
write_metadata_json(const char *file_path, const ModelMetadata *m)
{
    FILE *fp = fopen(file_path, "w");
    if (!fp) {
        log_errno("Unable to open metadata.json for writing");
        return -1;
    }

    fprintf(fp,
            "{\n"
            "  \"model_name\"   : \"%s\",\n"
            "  \"version\"      : \"%s\",\n"
            "  \"created_at\"   : \"%s\",\n"
            "  \"metrics\"      : %s,\n"
            "  \"hyper_params\" : %s\n"
            "}\n",
            m->name,
            m->version,
            m->created_at,
            (strlen(m->metrics) > 0) ? m->metrics : "{}",
            (strlen(m->params)  > 0) ? m->params  : "{}"
    );

    fclose(fp);
    return 0;
}

/*
 * Public API: register (write) a new model version.
 * Return 0 on success, negative on failure.
 */
int
registry_register(ModelMetadata *model)
{
    if (!model || strlen(model->name) == 0 || strlen(model->version) == 0) {
        fprintf(stderr, "ModelRegistry: invalid metadata supplied\n");
        return -1;
    }

    char *root = registry_root();
    if (!root)
        return -1;

    int lock_fd = lock_registry(root);
    if (lock_fd < 0) {
        free(root);
        return -1;
    }

    /* Build destination path: <root>/<name>/<version> */
    char dst_dir[MAX_PATH_LEN];
    snprintf(dst_dir, sizeof(dst_dir), "%s/%s/%s", root,
             model->name, model->version);

    if (mkdir_p(dst_dir, 0755) != 0) {
        unlock_registry(lock_fd);
        free(root);
        return -1;
    }

    /* Auto-populate timestamp if missing */
    if (model->created_at[0] == '\0')
        iso8601_now(model->created_at, sizeof(model->created_at));

    char meta_path[MAX_PATH_LEN];
    snprintf(meta_path, sizeof(meta_path), "%s/metadata.json", dst_dir);

    if (write_metadata_json(meta_path, model) != 0) {
        unlock_registry(lock_fd);
        free(root);
        return -1;
    }

    unlock_registry(lock_fd);
    free(root);
    return 0;
}

/*
 * Load metadata from an existing model version.
 * Returns dynamically allocated ModelMetadata* on success,
 * NULL on failure.  Caller owns the pointer.
 */
ModelMetadata *
registry_load(const char *model_name, const char *version)
{
    if (!model_name || !version)
        return NULL;

    char *root = registry_root();
    if (!root)
        return NULL;

    char meta_path[MAX_PATH_LEN];
    snprintf(meta_path, sizeof(meta_path),
             "%s/%s/%s/metadata.json", root, model_name, version);

    FILE *fp = fopen(meta_path, "r");
    if (!fp) {
        free(root);
        return NULL;
    }

    /* Simple line-by-line read; not a full JSON parser */
    ModelMetadata *m = calloc(1, sizeof(*m));
    if (!m) {
        fclose(fp);
        free(root);
        return NULL;
    }

    strncpy(m->name,    model_name, sizeof(m->name)    - 1);
    strncpy(m->version, version,    sizeof(m->version) - 1);

    char *line = NULL;
    size_t n   = 0;
    while (getline(&line, &n, fp) != -1) {
        char buf[256];
        if (sscanf(line, " \"created_at\"%*[^:] : \"%31[^\"]\"", buf) == 1)
            strncpy(m->created_at, buf, sizeof(m->created_at) - 1);
        else if (sscanf(line, " \"metrics\"%*[^:] : %255[^,\n]", buf) == 1)
            strncpy(m->metrics, buf, sizeof(m->metrics) - 1);
        else if (sscanf(line, " \"hyper_params\"%*[^:] : %255[^,\n]", buf) == 1)
            strncpy(m->params, buf, sizeof(m->params) - 1);
    }
    free(line);
    fclose(fp);
    free(root);
    return m;
}

/*
 * Iterate all models in registry.  For each metadata.json discovered
 * invoke callback(meta, userdata).  Traversal stops if callback
 * returns non-zero.  Returns first non-zero callback code or 0.
 */
int
registry_foreach(int (*cb)(const ModelMetadata *, void *), void *userdata)
{
    int rc          = 0;
    char *root      = registry_root();
    DIR  *root_dir  = NULL;
    DIR  *ver_dir   = NULL;

    if (!root)
        return -1;

    root_dir = opendir(root);
    if (!root_dir) {
        log_errno("Unable to open registry root");
        free(root);
        return -1;
    }

    struct dirent *entry_model = NULL;
    while ((entry_model = readdir(root_dir)) != NULL && rc == 0) {
        if (entry_model->d_type != DT_DIR)
            continue;
        if (strcmp(entry_model->d_name, ".") == 0 ||
            strcmp(entry_model->d_name, "..") == 0)
            continue;

        char model_path[MAX_PATH_LEN];
        snprintf(model_path, sizeof(model_path), "%s/%s",
                 root, entry_model->d_name);

        ver_dir = opendir(model_path);
        if (!ver_dir)
            continue;

        struct dirent *entry_ver = NULL;
        while ((entry_ver = readdir(ver_dir)) != NULL && rc == 0) {
            if (entry_ver->d_type != DT_DIR)
                continue;
            if (strcmp(entry_ver->d_name, ".") == 0 ||
                strcmp(entry_ver->d_name, "..") == 0)
                continue;

            ModelMetadata *meta = registry_load(entry_model->d_name,
                                                entry_ver->d_name);
            if (!meta)
                continue;

            rc = cb(meta, userdata);
            free(meta);
        }
        closedir(ver_dir);
    }

    closedir(root_dir);
    free(root);
    return rc;
}

/* ------------------------------------------------------------------
 * Example CLI utility (may be removed in production deployments)
 * ------------------------------------------------------------------*/
#ifdef REGISTRY_STANDALONE
static int
print_meta_cb(const ModelMetadata *m, void *ud)
{
    (void)ud;
    printf("%s @ %s  (%s)\n", m->name, m->version, m->created_at);
    return 0;
}

static void
usage(const char *prog)
{
    fprintf(stderr,
            "Usage: %s [register <name> <version> <metrics_json> <params_json>]\n"
            "       %s [list]\n", prog, prog);
}

int
main(int argc, char **argv)
{
    if (argc < 2) {
        usage(argv[0]);
        return EXIT_FAILURE;
    }

    if (strcmp(argv[1], "register") == 0) {
        if (argc != 6) {
            usage(argv[0]);
            return EXIT_FAILURE;
        }

        ModelMetadata m   = {0};
        strncpy(m.name,    argv[2], sizeof(m.name)    - 1);
        strncpy(m.version, argv[3], sizeof(m.version) - 1);
        strncpy(m.metrics, argv[4], sizeof(m.metrics) - 1);
        strncpy(m.params,  argv[5], sizeof(m.params)  - 1);

        if (registry_register(&m) == 0)
            printf("Model registered successfully.\n");
        else
            return EXIT_FAILURE;

    } else if (strcmp(argv[1], "list") == 0) {
        registry_foreach(print_meta_cb, NULL);
    } else {
        usage(argv[0]);
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}
#endif /* REGISTRY_STANDALONE */

/* ------------------------------------------------------------------
 * End of file
 * ------------------------------------------------------------------*/
