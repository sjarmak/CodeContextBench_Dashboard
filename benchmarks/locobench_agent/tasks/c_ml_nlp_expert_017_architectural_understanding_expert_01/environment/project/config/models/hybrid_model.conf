/*
 * File: hybrid_model.conf
 * Location: lexilearn_orchestrator/config/models/
 * Language: C (compile-time + run-time configuration helper)
 *
 * This “*.conf” source file is intentionally written in C so that
 *  1.  Build-time constants are available to the compiler/linker.
 *  2.  Run-time helpers (INI-style parser & pretty-printer) are kept
 *      physically close to the constants they manipulate.
 *
 * The file can be compiled directly into any component that requires
 * fast, type-safe access to Hybrid-Model settings while still allowing
 * operators to override values at deployment time through an external
 * text-based configuration file.
 *
 * Typical usage
 * -------------
 *      #include "config/models/hybrid_model.conf"
 *
 *      ll_hybrid_model_conf_t cfg;
 *      if (ll_load_hybrid_conf("/etc/lexilearn/hybrid_model.conf", &cfg) < 0)
 *          cfg = HYBRID_MODEL_DEFAULT_CONF;        // 100 % fallback
 *
 *      train_hybrid_model(&cfg);
 */

#ifndef LEXILEARN_HYBRID_MODEL_CONF_H
#define LEXILEARN_HYBRID_MODEL_CONF_H

/* ────────────────────────────────────────────────────────────────────────────
 *  Standard Library
 * ────────────────────────────────────────────────────────────────────────── */
#include <ctype.h>
#include <errno.h>
#include <inttypes.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* GCC/Clang diagnostic-only header guards */
#if defined(_MSC_VER)
#    define strcasecmp _stricmp
#endif

/* ────────────────────────────────────────────────────────────────────────────
 *  Public Data Structures
 * ────────────────────────────────────────────────────────────────────────── */

/*
 * Struct: ll_hybrid_model_conf_t
 * ------------------------------
 * Represents all configurable aspects of the Hybrid Model.  This struct is
 * purposely POD-only so that it can be `memcpy`’d across processes or
 * written/read in binary form if required by low-level IPC.
 */
typedef struct
{
    /* ------------- Pre-processing flags ------------- */
    _Bool   enable_text_normalization;    /* Unicode NFKC + lower-casing      */
    _Bool   enable_stopword_removal;      /* Language-aware stop words         */
    _Bool   enable_lemmatization;         /* SpaCy-style lemmatizer            */

    /* ------------- TF-IDF parameters  --------------- */
    float   tfidf_min_df;                 /* Minimum document frequency [0–1]  */
    float   tfidf_max_df;                 /* Maximum document frequency [0–1]  */

    /* ------------- Transformer head ----------------- */
    uint16_t transformer_hidden_size;     /* e.g. 512/768                      */
    uint16_t transformer_num_heads;       /* e.g. 8/12                         */
    uint16_t transformer_num_layers;      /* encoder layers                    */
    float    transformer_dropout;         /* (0…1]                             */

    /* ------------- Classical SVM head --------------- */
    uint16_t ngram_min;                   /* lower bound for character n-grams */
    uint16_t ngram_max;                   /* upper bound for character n-grams */
    float    svm_c;                       /* C-parameter (soft margin)         */
    float    svm_gamma;                   /* RBF kernel gamma                  */

    /* ------------- Training loop -------------------- */
    uint16_t batch_size;                  /* mini-batch size                   */
    uint32_t max_epochs;                  /* early-stop after N epochs         */
    float    learning_rate;               /* AdamW initial LR                  */
    float    weight_decay;                /* L2 regularisation                 */

    /* ------------- Monitoring & Ops ----------------- */
    float    drift_threshold;             /* Population-stability threshold    */
    uint32_t evaluation_interval_minutes; /* Frequency of eval + metrics push  */

    /* ------------- Metadata (Model Registry) -------- */
    char     model_name[64];              /* slug-style identifier             */
    char     model_version[16];           /* SemVer                            */
    char     created_by[64];              /* author or automated pipeline      */
} ll_hybrid_model_conf_t;

/* ────────────────────────────────────────────────────────────────────────────
 *  Compile-time Defaults
 * ────────────────────────────────────────────────────────────────────────── */

static const ll_hybrid_model_conf_t HYBRID_MODEL_DEFAULT_CONF = {
    /* Pre-processing */
    .enable_text_normalization   = 1,
    .enable_stopword_removal     = 1,
    .enable_lemmatization        = 1,

    /* TF-IDF */
    .tfidf_min_df                = 0.01f,
    .tfidf_max_df                = 0.85f,

    /* Transformer */
    .transformer_hidden_size     = 512,
    .transformer_num_heads       = 8,
    .transformer_num_layers      = 6,
    .transformer_dropout         = 0.10f,

    /* Classical SVM */
    .ngram_min                   = 1,
    .ngram_max                   = 3,
    .svm_c                       = 1.0f,
    .svm_gamma                   = 0.1f,

    /* Training */
    .batch_size                  = 32,
    .max_epochs                  = 10,
    .learning_rate               = 2e-5f,
    .weight_decay                = 0.01f,

    /* Monitoring */
    .drift_threshold             = 0.05f,
    .evaluation_interval_minutes = 60,

    /* Metadata */
    .model_name                  = "hybrid_ngram_transformer",
    .model_version               = "1.0.0",
    .created_by                  = "MLEngineeringTeam"
};

/* ────────────────────────────────────────────────────────────────────────────
 *  Utility helpers (internal linkage)
 * ────────────────────────────────────────────────────────────────────────── */

static void _trim(char *s)
{
    if (!s) return;

    /* Left trim */
    char *start = s;
    while (*start && isspace((unsigned char)*start))
        ++start;
    if (start != s)
        memmove(s, start, strlen(start) + 1);

    /* Right trim */
    char *end = s + strlen(s);
    while (end > s && isspace((unsigned char)*(end - 1)))
        --end;
    *end = '\0';
}

static int _parse_bool(const char *value, _Bool *out)
{
    if (!value || !out) return -EINVAL;
    if (strcasecmp(value, "true") == 0 || strcmp(value, "1") == 0)
        *out = 1;
    else if (strcasecmp(value, "false") == 0 || strcmp(value, "0") == 0)
        *out = 0;
    else
        return -EINVAL;
    return 0;
}

static int _parse_float(const char *value, float *out)
{
    if (!value || !out) return -EINVAL;
    char *endptr = NULL;
    errno        = 0;
    float v      = strtof(value, &endptr);
    if (errno || !endptr || *endptr != '\0')
        return -EINVAL;
    *out = v;
    return 0;
}

static int _parse_uint16(const char *value, uint16_t *out)
{
    if (!value || !out) return -EINVAL;
    char   *endptr = NULL;
    errno         = 0;
    unsigned long v = strtoul(value, &endptr, 10);
    if (errno || !endptr || *endptr != '\0' || v > UINT16_MAX)
        return -EINVAL;
    *out = (uint16_t)v;
    return 0;
}

static int _parse_uint32(const char *value, uint32_t *out)
{
    if (!value || !out) return -EINVAL;
    char   *endptr = NULL;
    errno         = 0;
    unsigned long v = strtoul(value, &endptr, 10);
    if (errno || !endptr || *endptr != '\0' || v > UINT32_MAX)
        return -EINVAL;
    *out = (uint32_t)v;
    return 0;
}

/* ────────────────────────────────────────────────────────────────────────────
 *  Public API
 * ────────────────────────────────────────────────────────────────────────── */

/*
 * Function: ll_load_hybrid_conf
 * -----------------------------
 * Populates ‘out_conf’ by overlaying values found in the text file at
 * ‘filepath’ onto HYBRID_MODEL_DEFAULT_CONF.
 *
 * The file format is a simple “key = value” syntax with ‘#’ comments.  For
 * production deployments the file is usually rendered by the orchestration
 * layer (e.g., Ansible, Kubernetes ConfigMap).
 *
 * Returns: 0 on success
 *         -ENOENT when the file cannot be opened
 *         -EINVAL on syntax/semantic errors
 *         -errno  pass-through for other stdio failures
 */
static int ll_load_hybrid_conf(const char *filepath,
                               ll_hybrid_model_conf_t *out_conf)
{
    if (!out_conf) return -EINVAL;

    /* Start from the baked-in defaults */
    *out_conf = HYBRID_MODEL_DEFAULT_CONF;

    /* NULL path → caller only wants defaults */
    if (!filepath) return 0;

    FILE *fp = fopen(filepath, "r");
    if (!fp) return -errno;

    char   line[256];
    size_t lineno = 0;

    while (fgets(line, sizeof line, fp))
    {
        ++lineno;
        _trim(line);

        if (line[0] == '\0' || line[0] == '#')
            continue;                       /* blank / comment */

        char *eq = strchr(line, '=');
        if (!eq)
        {
            fprintf(stderr,
                    "hybrid_model.conf:%zu: missing '='\n", lineno);
            fclose(fp);
            return -EINVAL;
        }

        *eq = '\0';
        char *key   = line;
        char *value = eq + 1;
        _trim(key);
        _trim(value);

        int rc = 0;
        if (strcmp(key, "enable_text_normalization") == 0)
            rc = _parse_bool(value, &out_conf->enable_text_normalization);
        else if (strcmp(key, "enable_stopword_removal") == 0)
            rc = _parse_bool(value, &out_conf->enable_stopword_removal);
        else if (strcmp(key, "enable_lemmatization") == 0)
            rc = _parse_bool(value, &out_conf->enable_lemmatization);
        else if (strcmp(key, "tfidf_min_df") == 0)
            rc = _parse_float(value, &out_conf->tfidf_min_df);
        else if (strcmp(key, "tfidf_max_df") == 0)
            rc = _parse_float(value, &out_conf->tfidf_max_df);
        else if (strcmp(key, "transformer_hidden_size") == 0)
            rc = _parse_uint16(value, &out_conf->transformer_hidden_size);
        else if (strcmp(key, "transformer_num_heads") == 0)
            rc = _parse_uint16(value, &out_conf->transformer_num_heads);
        else if (strcmp(key, "transformer_num_layers") == 0)
            rc = _parse_uint16(value, &out_conf->transformer_num_layers);
        else if (strcmp(key, "transformer_dropout") == 0)
            rc = _parse_float(value, &out_conf->transformer_dropout);
        else if (strcmp(key, "ngram_min") == 0)
            rc = _parse_uint16(value, &out_conf->ngram_min);
        else if (strcmp(key, "ngram_max") == 0)
            rc = _parse_uint16(value, &out_conf->ngram_max);
        else if (strcmp(key, "svm_c") == 0)
            rc = _parse_float(value, &out_conf->svm_c);
        else if (strcmp(key, "svm_gamma") == 0)
            rc = _parse_float(value, &out_conf->svm_gamma);
        else if (strcmp(key, "batch_size") == 0)
            rc = _parse_uint16(value, &out_conf->batch_size);
        else if (strcmp(key, "max_epochs") == 0)
            rc = _parse_uint32(value, &out_conf->max_epochs);
        else if (strcmp(key, "learning_rate") == 0)
            rc = _parse_float(value, &out_conf->learning_rate);
        else if (strcmp(key, "weight_decay") == 0)
            rc = _parse_float(value, &out_conf->weight_decay);
        else if (strcmp(key, "drift_threshold") == 0)
            rc = _parse_float(value, &out_conf->drift_threshold);
        else if (strcmp(key, "evaluation_interval_minutes") == 0)
            rc = _parse_uint32(value,
                               &out_conf->evaluation_interval_minutes);
        else if (strcmp(key, "model_name") == 0)
            strncpy(out_conf->model_name, value,
                    sizeof out_conf->model_name - 1);
        else if (strcmp(key, "model_version") == 0)
            strncpy(out_conf->model_version, value,
                    sizeof out_conf->model_version - 1);
        else if (strcmp(key, "created_by") == 0)
            strncpy(out_conf->created_by, value,
                    sizeof out_conf->created_by - 1);
        else
            fprintf(stderr,
                    "hybrid_model.conf:%zu: unknown key '%s' (ignored)\n",
                    lineno, key);

        if (rc < 0)
        {
            fprintf(stderr,
                    "hybrid_model.conf:%zu: invalid value '%s' for key '%s'\n",
                    lineno, value, key);
            fclose(fp);
            return rc;
        }
    } /* while fgets */

    fclose(fp);
    return 0;
}

/*
 * Function: ll_print_hybrid_conf
 * ------------------------------
 * Dumps the configuration as a valid key=value file to ‘stream’.  Passing
 * NULL for ‘stream’ defaults to stdout.
 */
static void ll_print_hybrid_conf(const ll_hybrid_model_conf_t *conf,
                                 FILE *stream)
{
    if (!conf) return;
    if (!stream) stream = stdout;

    fprintf(stream,
        "# ------------------------------------------------------------------\n"
        "#  LexiLearn Hybrid Model Configuration (auto-generated)\n"
        "# ------------------------------------------------------------------\n"
        "enable_text_normalization=%d\n"
        "enable_stopword_removal=%d\n"
        "enable_lemmatization=%d\n"
        "tfidf_min_df=%f\n"
        "tfidf_max_df=%f\n"
        "transformer_hidden_size=%u\n"
        "transformer_num_heads=%u\n"
        "transformer_num_layers=%u\n"
        "transformer_dropout=%f\n"
        "ngram_min=%u\n"
        "ngram_max=%u\n"
        "svm_c=%f\n"
        "svm_gamma=%f\n"
        "batch_size=%u\n"
        "max_epochs=%u\n"
        "learning_rate=%f\n"
        "weight_decay=%f\n"
        "drift_threshold=%f\n"
        "evaluation_interval_minutes=%u\n"
        "model_name=%s\n"
        "model_version=%s\n"
        "created_by=%s\n",
        conf->enable_text_normalization,
        conf->enable_stopword_removal,
        conf->enable_lemmatization,
        conf->tfidf_min_df,
        conf->tfidf_max_df,
        conf->transformer_hidden_size,
        conf->transformer_num_heads,
        conf->transformer_num_layers,
        conf->transformer_dropout,
        conf->ngram_min,
        conf->ngram_max,
        conf->svm_c,
        conf->svm_gamma,
        conf->batch_size,
        conf->max_epochs,
        conf->learning_rate,
        conf->weight_decay,
        conf->drift_threshold,
        conf->evaluation_interval_minutes,
        conf->model_name,
        conf->model_version,
        conf->created_by);
}

#endif /* LEXILEARN_HYBRID_MODEL_CONF_H */