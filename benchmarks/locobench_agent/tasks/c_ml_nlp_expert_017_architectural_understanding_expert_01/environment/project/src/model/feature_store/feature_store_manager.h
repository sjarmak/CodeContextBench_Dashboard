#ifndef LEXILEARN_ORCHESTRATOR_MODEL_FEATURE_STORE_MANAGER_H
#define LEXILEARN_ORCHESTRATOR_MODEL_FEATURE_STORE_MANAGER_H
/*
 *  LexiLearn MVC Orchestrator – Feature Store Manager
 *  --------------------------------------------------
 *  Copyright (c) 2024
 *
 *  Responsible for lifecycle management of feature vectors persisted in the
 *  shared, version-aware feature store.  Down-stream Model strategies depend on
 *  this component for immutable, reproducible access to engineered features
 *  generated by the Data-Preprocessing pipeline.
 *
 *  This header purposefully contains a mix of declarations and small static
 *  inlines so that downstream consumers can compile even if the dynamic
 *  library has not yet been linked (e.g., unit-testing with mocks).  Heavy
 *  implementations live in feature_store_manager.c.
 */

#include <stddef.h>     /* size_t                             */
#include <stdint.h>     /* uint64_t, uint32_t                */
#include <stdbool.h>    /* bool                              */
#include <time.h>       /* time_t                            */
#include <pthread.h>    /* pthread_rwlock_t                  */

#ifdef __cplusplus
extern "C" {
#endif

/* =========================================================================
 *  Compile-time configuration
 * ========================================================================= */
#ifndef LEXILEARN_FS_MAX_NAMESPACE
#   define LEXILEARN_FS_MAX_NAMESPACE      128U
#endif

#ifndef LEXILEARN_FS_MAX_KEY
#   define LEXILEARN_FS_MAX_KEY            256U
#endif

#ifndef LEXILEARN_FS_DEFAULT_ROOT
#   define LEXILEARN_FS_DEFAULT_ROOT       "/var/lib/lexilearn/feature_store"
#endif

/* =========================================================================
 *  Error Handling
 * ========================================================================= */
/* Enumerated error codes returned by Feature Store operations. */
typedef enum {
    FS_OK = 0,                 /* Success                                         */
    FS_ERR_UNKNOWN,            /* Unknown/unmapped error                           */
    FS_ERR_NOT_INITIALIZED,    /* Manager not initialized                          */
    FS_ERR_ALREADY_INITIALIZED,/* Re-initialization attempt                        */
    FS_ERR_INVALID_ARGUMENT,   /* Generic bad input                                */
    FS_ERR_KEY_NOT_FOUND,      /* Feature key does not exist                       */
    FS_ERR_NAMESPACE_NOT_FOUND,/* Feature namespace does not exist                 */
    FS_ERR_IO,                 /* Low-level disk I/O error                         */
    FS_ERR_SERIALIZATION,      /* Failed to (de)serialize payload                  */
    FS_ERR_LOCKING,            /* RW-lock acquisition failure                      */
    FS_ERR_VERSION_CONFLICT,   /* Optimistic concurrency control failure           */
    FS_ERR_OUT_OF_MEMORY       /* malloc/calloc failure                            */
} fs_status_t;

/* Human-readable error message.  Thread-safe (returns const string literal). */
static inline const char *
fs_status_str(fs_status_t status)
{
    switch (status) {
        case FS_OK:                     return "OK";
        case FS_ERR_UNKNOWN:            return "Unknown error";
        case FS_ERR_NOT_INITIALIZED:    return "Manager not initialized";
        case FS_ERR_ALREADY_INITIALIZED:return "Manager already initialized";
        case FS_ERR_INVALID_ARGUMENT:   return "Invalid argument";
        case FS_ERR_KEY_NOT_FOUND:      return "Feature key not found";
        case FS_ERR_NAMESPACE_NOT_FOUND:return "Namespace not found";
        case FS_ERR_IO:                 return "I/O error";
        case FS_ERR_SERIALIZATION:      return "Serialization failure";
        case FS_ERR_LOCKING:            return "Locking error";
        case FS_ERR_VERSION_CONFLICT:   return "Version conflict";
        case FS_ERR_OUT_OF_MEMORY:      return "Out of memory";
        default:                        return "Unmapped error code";
    }
}

/* =========================================================================
 *  Feature Vector Definition
 * ========================================================================= */

/* Supported primitive value types.  Extend as needed. */
typedef enum {
    FS_FT_FLOAT32 = 1,
    FS_FT_FLOAT64,
    FS_FT_INT32,
    FS_FT_INT64,
    FS_FT_BINARY_BLOB
} fs_feature_type_t;

/* Metadata for a single feature vector. */
typedef struct {
    char     namespace_id[LEXILEARN_FS_MAX_NAMESPACE]; /* logical grouping */
    char     key[LEXILEARN_FS_MAX_KEY];                /* unique feature key */
    uint64_t version;                                  /* monotonically increasing */
    time_t   timestamp;                                /* unix epoch, seconds */
    fs_feature_type_t dtype;                           /* data type          */
    size_t   element_count;                            /* # of primitives    */
    size_t   byte_size;                                /* total payload size */
} fs_feature_meta_t;

/* Opaque payload container.  The content is serialized/deserialized by
 * the caller according to dtype (e.g., float32 array). */
typedef struct {
    fs_feature_meta_t meta;
    void             *data; /* heap-allocated, meta.byte_size bytes */
} fs_feature_vector_t;

/* =========================================================================
 *  Feature Store Manager
 * ========================================================================= */

/* Forward declaration of internal storage engine context. */
typedef struct _fs_storage_engine fs_storage_engine_t;

/* Public manager object. */
typedef struct {
    bool                   initialized;
    char                   root_dir[PATH_MAX];
    fs_storage_engine_t   *engine;  /* pluggable backend (e.g., Parquet, LMDB) */
    pthread_rwlock_t       rwlock;  /* global shared mutex                     */
} fs_manager_t;

/* =========================================================================
 *  API – Lifecycle
 * ========================================================================= */

/*
 * fs_manager_init
 * --------------------------------------------------------------------------
 * Initialize a Feature Store Manager instance.  The root on-disk directory is
 * created on-the-fly if it does not exist.  Thread-safe.
 *
 * mgr       – pointer to zero-initialized fs_manager_t
 * root_dir  – optional; pass NULL to use LEXILEARN_FS_DEFAULT_ROOT
 *
 * Returns   – FS_OK on success or appropriate error code on failure.
 */
fs_status_t
fs_manager_init(fs_manager_t *mgr, const char *root_dir);

/*
 * fs_manager_shutdown
 * --------------------------------------------------------------------------
 * Flush and free all internal resources bound to the manager instance.
 * No other API calls are permitted on mgr after this completes.
 *
 * mgr       – pointer to an initialized fs_manager_t
 *
 * Returns   – FS_OK or error.
 */
fs_status_t
fs_manager_shutdown(fs_manager_t *mgr);

/* =========================================================================
 *  API – CRUD Operations
 * ========================================================================= */

/*
 * fs_manager_put
 * --------------------------------------------------------------------------
 * Persist the provided feature vector.  If an older version exists, the new
 * vector’s version number must be >= existing_version + 1; else
 * FS_ERR_VERSION_CONFLICT is returned.
 *
 * mgr       – initialized manager
 * vec       – caller-owned feature vector; data is deep-copied
 * overwrite – if true, bypass optimistic concurrency check
 *
 * Returns   – FS_OK on success
 */
fs_status_t
fs_manager_put(fs_manager_t *mgr,
               const fs_feature_vector_t *vec,
               bool overwrite);

/*
 * fs_manager_get
 * --------------------------------------------------------------------------
 * Retrieve the latest (or a specific) version of a feature vector.
 * Caller is responsible for freeing the returned vector via
 * fs_manager_free_vector().
 *
 * mgr       – initialized manager
 * namespace – feature namespace
 * key       – feature key
 * version   – 0 for latest, else specific version number
 * out_vec   – out-parameter populated on success
 *
 * Returns   – FS_OK or relevant error.
 */
fs_status_t
fs_manager_get(fs_manager_t          *mgr,
               const char            *namespace,
               const char            *key,
               uint64_t               version,
               fs_feature_vector_t  **out_vec);

/*
 * fs_manager_delete
 * --------------------------------------------------------------------------
 * Delete a specific (or all) versions of a feature key.
 *
 * mgr       – initialized manager
 * namespace – feature namespace
 * key       – feature key
 * version   – 0 to delete ALL versions, else specific version
 *
 * Returns   – FS_OK or error.
 */
fs_status_t
fs_manager_delete(fs_manager_t *mgr,
                  const char   *namespace,
                  const char   *key,
                  uint64_t      version);

/* =========================================================================
 *  API – Utility Helpers
 * ========================================================================= */

/*
 * fs_manager_free_vector
 * --------------------------------------------------------------------------
 * Free a feature vector previously obtained via fs_manager_get().
 */
static inline void
fs_manager_free_vector(fs_feature_vector_t *vec)
{
    if (!vec) return;
    free(vec->data);
    free(vec);
}

/*
 * fs_manager_checkpoint
 * --------------------------------------------------------------------------
 * Force persistent checkpoint on the underlying storage engine.
 * Useful when called from controller’s Observer hook before shutdown.
 */
fs_status_t
fs_manager_checkpoint(fs_manager_t *mgr);

/*
 * fs_manager_log_state
 * --------------------------------------------------------------------------
 * Print internal diagnostics to the supplied file handle (stdout if NULL).
 * This function never fails and is safe to call in signal handlers.
 */
void
fs_manager_log_state(const fs_manager_t *mgr, FILE *stream);

/* =========================================================================
 *  Observer Integration Hooks
 * ========================================================================= */

/*
 * fs_manager_subscribe_drift_detector
 * --------------------------------------------------------------------------
 * Attaches an observer callback which gets invoked each time a new feature
 * vector is committed.  Drift detection module can register here to receive
 * streaming updates without polling.
 */
typedef void (*fs_drift_cb)(const fs_feature_meta_t *meta, void *user_ctx);

fs_status_t
fs_manager_subscribe_drift_detector(fs_manager_t *mgr,
                                    fs_drift_cb   callback,
                                    void         *user_ctx);

/* =========================================================================
 *  Experimental: Bulk Iteration (zero-copy)
 * ========================================================================= */

typedef bool (*fs_iter_cb)(const fs_feature_vector_t *vec,
                           void                      *user_ctx);

/*
 * fs_manager_iterate_namespace
 * --------------------------------------------------------------------------
 * Stream all feature vectors belonging to a namespace.  The iterator runs under
 * a read lock to guarantee consistency.  If the callback returns false, the
 * iteration halts early.
 *
 * namespace – feature namespace
 * version   – 0 for latest version per key, else specific version
 */
fs_status_t
fs_manager_iterate_namespace(fs_manager_t *mgr,
                             const char   *namespace,
                             uint64_t      version,
                             fs_iter_cb    callback,
                             void         *user_ctx);

/* =========================================================================
 *  Internal convenience macros
 * ========================================================================= */

#define FS_SAFE_CALL(expr)                                      \
    do {                                                        \
        fs_status_t __rc = (expr);                              \
        if (__rc != FS_OK) {                                    \
            fprintf(stderr,                                     \
                    "[FeatureStoreManager] %s failed: %s (%d)\n",\
                    #expr, fs_status_str(__rc), __rc);          \
        }                                                       \
    } while (0)

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* LEXILEARN_ORCHESTRATOR_MODEL_FEATURE_STORE_MANAGER_H */
